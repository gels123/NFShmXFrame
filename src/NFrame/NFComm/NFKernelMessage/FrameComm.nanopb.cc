/* Automatically generated nanopb constant definitions */
/* Generated by nanopb-0.3.9 */

#include <sstream>
#include "NFComm/NFObjCommon/NFShmMgr.h"
#include "FrameComm.nanopb.h"

/* @@protoc_insertion_point(includes) */
#if PB_PROTO_HEADER_VERSION != 30
#error Regenerate this file with the current version of nanopb generator.
#endif

tbServerMgr::tbServerMgr()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

tbServerMgr::~tbServerMgr()
{
}

tbServerMgr::tbServerMgr(const tbServerMgr& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

tbServerMgr& tbServerMgr::operator=(const tbServerMgr& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void tbServerMgr::CopyData(const tbServerMgr& stArgsData)
{
    id = stArgsData.id;
    contract = stArgsData.contract;
    machine_addr = stArgsData.machine_addr;
    ip = stArgsData.ip;
    bus_name = stArgsData.bus_name;
    server_desc = stArgsData.server_desc;
    cur_count = stArgsData.cur_count;
    last_login_time = stArgsData.last_login_time;
    last_logout_time = stArgsData.last_logout_time;
    create_time = stArgsData.create_time;
}

int tbServerMgr::CreateInit()
{
    id = 0;
    cur_count = 0;
    last_login_time = 0;
    last_logout_time = 0;
    create_time = 0;
	return 0;
}

int tbServerMgr::ResumeInit()
{
	return 0;
}

void tbServerMgr::Init()
{
    id = 0;
    cur_count = 0;
    last_login_time = 0;
    last_logout_time = 0;
    create_time = 0;
}

bool tbServerMgr::FromPb(const NFrame::tbServerMgr& cc)
{
    id = cc.id();
    contract = cc.contract();
    machine_addr = cc.machine_addr();
    ip = cc.ip();
    bus_name = cc.bus_name();
    server_desc = cc.server_desc();
    cur_count = cc.cur_count();
    last_login_time = cc.last_login_time();
    last_logout_time = cc.last_logout_time();
    create_time = cc.create_time();
    return true;
}

void tbServerMgr::ToPb(NFrame::tbServerMgr* cc) const
{
    cc->set_id(id);
    cc->set_contract(contract);
    cc->set_machine_addr(machine_addr);
    cc->set_ip(ip);
    cc->set_bus_name(bus_name);
    cc->set_server_desc(server_desc);
    cc->set_cur_count(cur_count);
    cc->set_last_login_time(last_login_time);
    cc->set_last_logout_time(last_logout_time);
    cc->set_create_time(create_time);
    return;
}

NFrame::tbServerMgr tbServerMgr::ToPb() const
{
    NFrame::tbServerMgr cc;
    ToPb(&cc);
    return cc;
}

std::string tbServerMgr::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "id:" << id << ", ";
    ss << "contract:" << "\"" << contract << "\"" << ", ";
    ss << "machine_addr:" << "\"" << machine_addr << "\"" << ", ";
    ss << "ip:" << "\"" << ip << "\"" << ", ";
    ss << "bus_name:" << "\"" << bus_name << "\"" << ", ";
    ss << "server_desc:" << "\"" << server_desc << "\"" << ", ";
    ss << "cur_count:" << cur_count << ", ";
    ss << "last_login_time:" << last_login_time << ", ";
    ss << "last_logout_time:" << last_logout_time << ", ";
    ss << "create_time:" << create_time;
    ss << "}";
    return ss.str();
}

pbMysqlConfig::pbMysqlConfig()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

pbMysqlConfig::~pbMysqlConfig()
{
}

pbMysqlConfig::pbMysqlConfig(const pbMysqlConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

pbMysqlConfig& pbMysqlConfig::operator=(const pbMysqlConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void pbMysqlConfig::CopyData(const pbMysqlConfig& stArgsData)
{
    MysqlIp = stArgsData.MysqlIp;
    MysqlPort = stArgsData.MysqlPort;
    MysqlDbName = stArgsData.MysqlDbName;
    MysqlUser = stArgsData.MysqlUser;
    MysqlPassword = stArgsData.MysqlPassword;
    TBConfList.clear();
    TBConfList = stArgsData.TBConfList;
}

int pbMysqlConfig::CreateInit()
{
    MysqlPort = 0;
	return 0;
}

int pbMysqlConfig::ResumeInit()
{
	return 0;
}

void pbMysqlConfig::Init()
{
    MysqlPort = 0;
}

bool pbMysqlConfig::FromPb(const NFrame::pbMysqlConfig& cc)
{
    MysqlIp = cc.mysqlip();
    MysqlPort = cc.mysqlport();
    MysqlDbName = cc.mysqldbname();
    MysqlUser = cc.mysqluser();
    MysqlPassword = cc.mysqlpassword();
    TBConfList.clear();
    for (int i = 0; i < cc.tbconflist_size(); ++i)
    {
        pbTableConfig temp;
        if (!temp.FromPb(cc.tbconflist(i)))
        {
            if (NULL != g_nanopb_frompb_log_handle)
                g_nanopb_frompb_log_handle("FromPb Failed, struct:pbMysqlConfig, field:TBConfList, cur count:%d", cc.tbconflist_size());
            return false;
        }
        TBConfList.push_back(temp);
    }
    return true;
}

void pbMysqlConfig::ToPb(NFrame::pbMysqlConfig* cc) const
{
    cc->set_mysqlip(MysqlIp);
    cc->set_mysqlport(MysqlPort);
    cc->set_mysqldbname(MysqlDbName);
    cc->set_mysqluser(MysqlUser);
    cc->set_mysqlpassword(MysqlPassword);
    cc->clear_tbconflist();
    for (auto iter = TBConfList.begin(); iter != TBConfList.end(); ++iter)
    {
        iter->ToPb(cc->add_tbconflist());
    }
    return;
}

NFrame::pbMysqlConfig pbMysqlConfig::ToPb() const
{
    NFrame::pbMysqlConfig cc;
    ToPb(&cc);
    return cc;
}

std::string pbMysqlConfig::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "MysqlIp:" << "\"" << MysqlIp << "\"" << ", ";
    ss << "MysqlPort:" << MysqlPort << ", ";
    ss << "MysqlDbName:" << "\"" << MysqlDbName << "\"" << ", ";
    ss << "MysqlUser:" << "\"" << MysqlUser << "\"" << ", ";
    ss << "MysqlPassword:" << "\"" << MysqlPassword << "\"" << ", ";
    ss << "TBConfList(" << TBConfList.size()<< "):[";
    for (auto iter = TBConfList.begin(); iter != TBConfList.end(); ++iter)
    {
        ss << iter->ShortDebugString();
    }
;
    ss << "}";
    return ss.str();
}

pbRedisConfig::pbRedisConfig()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

pbRedisConfig::~pbRedisConfig()
{
}

pbRedisConfig::pbRedisConfig(const pbRedisConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

pbRedisConfig& pbRedisConfig::operator=(const pbRedisConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void pbRedisConfig::CopyData(const pbRedisConfig& stArgsData)
{
    RedisIp = stArgsData.RedisIp;
    RedisPort = stArgsData.RedisPort;
    RedisPass = stArgsData.RedisPass;
}

int pbRedisConfig::CreateInit()
{
    RedisPort = 0;
	return 0;
}

int pbRedisConfig::ResumeInit()
{
	return 0;
}

void pbRedisConfig::Init()
{
    RedisPort = 0;
}

bool pbRedisConfig::FromPb(const NFrame::pbRedisConfig& cc)
{
    RedisIp = cc.redisip();
    RedisPort = cc.redisport();
    RedisPass = cc.redispass();
    return true;
}

void pbRedisConfig::ToPb(NFrame::pbRedisConfig* cc) const
{
    cc->set_redisip(RedisIp);
    cc->set_redisport(RedisPort);
    cc->set_redispass(RedisPass);
    return;
}

NFrame::pbRedisConfig pbRedisConfig::ToPb() const
{
    NFrame::pbRedisConfig cc;
    ToPb(&cc);
    return cc;
}

std::string pbRedisConfig::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "RedisIp:" << "\"" << RedisIp << "\"" << ", ";
    ss << "RedisPort:" << RedisPort << ", ";
    ss << "RedisPass:" << "\"" << RedisPass << "\"";
    ss << "}";
    return ss.str();
}

pbRouteConfig::pbRouteConfig()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

pbRouteConfig::~pbRouteConfig()
{
}

pbRouteConfig::pbRouteConfig(const pbRouteConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

pbRouteConfig& pbRouteConfig::operator=(const pbRouteConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void pbRouteConfig::CopyData(const pbRouteConfig& stArgsData)
{
    MasterIp = stArgsData.MasterIp;
    MasterPort = stArgsData.MasterPort;
    NamingHost = stArgsData.NamingHost;
    NamingPath = stArgsData.NamingPath;
    RouteAgent = stArgsData.RouteAgent;
}

int pbRouteConfig::CreateInit()
{
    MasterPort = 0;
	return 0;
}

int pbRouteConfig::ResumeInit()
{
	return 0;
}

void pbRouteConfig::Init()
{
    MasterPort = 0;
}

bool pbRouteConfig::FromPb(const NFrame::pbRouteConfig& cc)
{
    MasterIp = cc.masterip();
    MasterPort = cc.masterport();
    NamingHost = cc.naminghost();
    NamingPath = cc.namingpath();
    RouteAgent = cc.routeagent();
    return true;
}

void pbRouteConfig::ToPb(NFrame::pbRouteConfig* cc) const
{
    cc->set_masterip(MasterIp);
    cc->set_masterport(MasterPort);
    cc->set_naminghost(NamingHost);
    cc->set_namingpath(NamingPath);
    cc->set_routeagent(RouteAgent);
    return;
}

NFrame::pbRouteConfig pbRouteConfig::ToPb() const
{
    NFrame::pbRouteConfig cc;
    ToPb(&cc);
    return cc;
}

std::string pbRouteConfig::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "MasterIp:" << "\"" << MasterIp << "\"" << ", ";
    ss << "MasterPort:" << MasterPort << ", ";
    ss << "NamingHost:" << "\"" << NamingHost << "\"" << ", ";
    ss << "NamingPath:" << "\"" << NamingPath << "\"" << ", ";
    ss << "RouteAgent:" << "\"" << RouteAgent << "\"";
    ss << "}";
    return ss.str();
}

pbPluginConfig::pbPluginConfig()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

pbPluginConfig::~pbPluginConfig()
{
}

pbPluginConfig::pbPluginConfig(const pbPluginConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

pbPluginConfig& pbPluginConfig::operator=(const pbPluginConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void pbPluginConfig::CopyData(const pbPluginConfig& stArgsData)
{
    ServerType = stArgsData.ServerType;
    FramePlugins.clear();
    FramePlugins = stArgsData.FramePlugins;
    ServerPlugins.clear();
    ServerPlugins = stArgsData.ServerPlugins;
    WorkPlugins.clear();
    WorkPlugins = stArgsData.WorkPlugins;
    ServerList.clear();
    ServerList = stArgsData.ServerList;
}

int pbPluginConfig::CreateInit()
{
    ServerType = 0;
	return 0;
}

int pbPluginConfig::ResumeInit()
{
	return 0;
}

void pbPluginConfig::Init()
{
    ServerType = 0;
}

bool pbPluginConfig::FromPb(const NFrame::pbPluginConfig& cc)
{
    ServerType = cc.servertype();
    FramePlugins.clear();
    for (int i = 0; i < cc.frameplugins_size(); ++i)
    {
        FramePlugins.push_back(cc.frameplugins(i));
    }
    ServerPlugins.clear();
    for (int i = 0; i < cc.serverplugins_size(); ++i)
    {
        ServerPlugins.push_back(cc.serverplugins(i));
    }
    WorkPlugins.clear();
    for (int i = 0; i < cc.workplugins_size(); ++i)
    {
        WorkPlugins.push_back(cc.workplugins(i));
    }
    ServerList.clear();
    for (int i = 0; i < cc.serverlist_size(); ++i)
    {
        pbAllServerConfig temp;
        if (!temp.FromPb(cc.serverlist(i)))
        {
            if (NULL != g_nanopb_frompb_log_handle)
                g_nanopb_frompb_log_handle("FromPb Failed, struct:pbPluginConfig, field:ServerList, cur count:%d", cc.serverlist_size());
            return false;
        }
        ServerList.push_back(temp);
    }
    return true;
}

void pbPluginConfig::ToPb(NFrame::pbPluginConfig* cc) const
{
    cc->set_servertype(ServerType);
    cc->clear_frameplugins();
    for (auto iter = FramePlugins.begin(); iter != FramePlugins.end(); ++iter)
    {
        cc->add_frameplugins(*iter);
    }
    cc->clear_serverplugins();
    for (auto iter = ServerPlugins.begin(); iter != ServerPlugins.end(); ++iter)
    {
        cc->add_serverplugins(*iter);
    }
    cc->clear_workplugins();
    for (auto iter = WorkPlugins.begin(); iter != WorkPlugins.end(); ++iter)
    {
        cc->add_workplugins(*iter);
    }
    cc->clear_serverlist();
    for (auto iter = ServerList.begin(); iter != ServerList.end(); ++iter)
    {
        iter->ToPb(cc->add_serverlist());
    }
    return;
}

NFrame::pbPluginConfig pbPluginConfig::ToPb() const
{
    NFrame::pbPluginConfig cc;
    ToPb(&cc);
    return cc;
}

std::string pbPluginConfig::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "ServerType:" << ServerType << ", ";
    ss << "FramePlugins(" << FramePlugins.size()<< "):[";
    for (auto iter = FramePlugins.begin(); iter != FramePlugins.end(); ++iter)
    {
        ss << "\"" << *iter << "\"";
    }
;
    ss << "ServerPlugins(" << ServerPlugins.size()<< "):[";
    for (auto iter = ServerPlugins.begin(); iter != ServerPlugins.end(); ++iter)
    {
        ss << "\"" << *iter << "\"";
    }
;
    ss << "WorkPlugins(" << WorkPlugins.size()<< "):[";
    for (auto iter = WorkPlugins.begin(); iter != WorkPlugins.end(); ++iter)
    {
        ss << "\"" << *iter << "\"";
    }
;
    ss << "ServerList(" << ServerList.size()<< "):[";
    for (auto iter = ServerList.begin(); iter != ServerList.end(); ++iter)
    {
        ss << iter->ShortDebugString();
    }
;
    ss << "}";
    return ss.str();
}

pbAllServerConfig::pbAllServerConfig()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

pbAllServerConfig::~pbAllServerConfig()
{
}

pbAllServerConfig::pbAllServerConfig(const pbAllServerConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

pbAllServerConfig& pbAllServerConfig::operator=(const pbAllServerConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void pbAllServerConfig::CopyData(const pbAllServerConfig& stArgsData)
{
    Server = stArgsData.Server;
    ID = stArgsData.ID;
    ServerType = stArgsData.ServerType;
}

int pbAllServerConfig::CreateInit()
{
    ServerType = 0;
	return 0;
}

int pbAllServerConfig::ResumeInit()
{
	return 0;
}

void pbAllServerConfig::Init()
{
    ServerType = 0;
}

bool pbAllServerConfig::FromPb(const NFrame::pbAllServerConfig& cc)
{
    Server = cc.server();
    ID = cc.id();
    ServerType = cc.servertype();
    return true;
}

void pbAllServerConfig::ToPb(NFrame::pbAllServerConfig* cc) const
{
    cc->set_server(Server);
    cc->set_id(ID);
    cc->set_servertype(ServerType);
    return;
}

NFrame::pbAllServerConfig pbAllServerConfig::ToPb() const
{
    NFrame::pbAllServerConfig cc;
    ToPb(&cc);
    return cc;
}

std::string pbAllServerConfig::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "Server:" << "\"" << Server << "\"" << ", ";
    ss << "ID:" << "\"" << ID << "\"" << ", ";
    ss << "ServerType:" << ServerType;
    ss << "}";
    return ss.str();
}

pbTableConfig::pbTableConfig()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

pbTableConfig::~pbTableConfig()
{
}

pbTableConfig::pbTableConfig(const pbTableConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

pbTableConfig& pbTableConfig::operator=(const pbTableConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void pbTableConfig::CopyData(const pbTableConfig& stArgsData)
{
    TableName = stArgsData.TableName;
    TableCount = stArgsData.TableCount;
    Cache = stArgsData.Cache;
}

int pbTableConfig::CreateInit()
{
    TableCount = 0;
    Cache = 0;
	return 0;
}

int pbTableConfig::ResumeInit()
{
	return 0;
}

void pbTableConfig::Init()
{
    TableCount = 0;
    Cache = 0;
}

bool pbTableConfig::FromPb(const NFrame::pbTableConfig& cc)
{
    TableName = cc.tablename();
    TableCount = cc.tablecount();
    Cache = cc.cache();
    return true;
}

void pbTableConfig::ToPb(NFrame::pbTableConfig* cc) const
{
    cc->set_tablename(TableName);
    cc->set_tablecount(TableCount);
    cc->set_cache(Cache);
    return;
}

NFrame::pbTableConfig pbTableConfig::ToPb() const
{
    NFrame::pbTableConfig cc;
    ToPb(&cc);
    return cc;
}

std::string pbTableConfig::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "TableName:" << "\"" << TableName << "\"" << ", ";
    ss << "TableCount:" << TableCount << ", ";
    ss << "Cache:" << Cache;
    ss << "}";
    return ss.str();
}

pbEncryptConfig::pbEncryptConfig()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

pbEncryptConfig::~pbEncryptConfig()
{
}

pbEncryptConfig::pbEncryptConfig(const pbEncryptConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

pbEncryptConfig& pbEncryptConfig::operator=(const pbEncryptConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void pbEncryptConfig::CopyData(const pbEncryptConfig& stArgsData)
{
    PublicAuthEncryptkey = stArgsData.PublicAuthEncryptkey;
    EncryptPolicy = stArgsData.EncryptPolicy;
    CompressPolicy = stArgsData.CompressPolicy;
    EncrypyKey = stArgsData.EncrypyKey;
}

int pbEncryptConfig::CreateInit()
{
    EncryptPolicy = 0;
    CompressPolicy = 0;
	return 0;
}

int pbEncryptConfig::ResumeInit()
{
	return 0;
}

void pbEncryptConfig::Init()
{
    EncryptPolicy = 0;
    CompressPolicy = 0;
}

bool pbEncryptConfig::FromPb(const NFrame::pbEncryptConfig& cc)
{
    PublicAuthEncryptkey = cc.publicauthencryptkey();
    EncryptPolicy = cc.encryptpolicy();
    CompressPolicy = cc.compresspolicy();
    EncrypyKey = cc.encrypykey();
    return true;
}

void pbEncryptConfig::ToPb(NFrame::pbEncryptConfig* cc) const
{
    cc->set_publicauthencryptkey(PublicAuthEncryptkey);
    cc->set_encryptpolicy(EncryptPolicy);
    cc->set_compresspolicy(CompressPolicy);
    cc->set_encrypykey(EncrypyKey);
    return;
}

NFrame::pbEncryptConfig pbEncryptConfig::ToPb() const
{
    NFrame::pbEncryptConfig cc;
    ToPb(&cc);
    return cc;
}

std::string pbEncryptConfig::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "PublicAuthEncryptkey:" << "\"" << PublicAuthEncryptkey << "\"" << ", ";
    ss << "EncryptPolicy:" << EncryptPolicy << ", ";
    ss << "CompressPolicy:" << CompressPolicy << ", ";
    ss << "EncrypyKey:" << "\"" << EncrypyKey << "\"";
    ss << "}";
    return ss.str();
}

pbNFServerConfig::pbNFServerConfig()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

pbNFServerConfig::~pbNFServerConfig()
{
}

pbNFServerConfig::pbNFServerConfig(const pbNFServerConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

pbNFServerConfig& pbNFServerConfig::operator=(const pbNFServerConfig& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void pbNFServerConfig::CopyData(const pbNFServerConfig& stArgsData)
{
    ServerId = stArgsData.ServerId;
    ServerType = stArgsData.ServerType;
    ServerName = stArgsData.ServerName;
    BusId = stArgsData.BusId;
    BusLength = stArgsData.BusLength;
    LinkMode = stArgsData.LinkMode;
    Url = stArgsData.Url;
    IdleSleepUS = stArgsData.IdleSleepUS;
    HandleMsgNumPerFrame = stArgsData.HandleMsgNumPerFrame;
    ServerOpenTime = stArgsData.ServerOpenTime;
    LoadProtoDs = stArgsData.LoadProtoDs;
    CrossServer = stArgsData.CrossServer;
    ServerIp = stArgsData.ServerIp;
    ServerPort = stArgsData.ServerPort;
    ExternalServerIp = stArgsData.ExternalServerIp;
    ExternalServerPort = stArgsData.ExternalServerPort;
    HttpPort = stArgsData.HttpPort;
    MaxConnectNum = stArgsData.MaxConnectNum;
    WorkThreadNum = stArgsData.WorkThreadNum;
    NetThreadNum = stArgsData.NetThreadNum;
    Security = stArgsData.Security;
    WebSocket = stArgsData.WebSocket;
    ParseType = stArgsData.ParseType;
    RouteConfig = stArgsData.RouteConfig;
    MysqlConfig = stArgsData.MysqlConfig;
    DefaultDBName = stArgsData.DefaultDBName;
    CrossDBName = stArgsData.CrossDBName;
    RedisConfig = stArgsData.RedisConfig;
    sendEmail = stArgsData.sendEmail;
    sendEmailPass = stArgsData.sendEmailPass;
    sendEmailUrl = stArgsData.sendEmailUrl;
    sendEmailPort = stArgsData.sendEmailPort;
    recvEmail = stArgsData.recvEmail;
    wxWorkdRobot = stArgsData.wxWorkdRobot;
    MaxOnlinePlayerNum = stArgsData.MaxOnlinePlayerNum;
    HeartBeatTimeout = stArgsData.HeartBeatTimeout;
    ClientKeepAliveTimeout = stArgsData.ClientKeepAliveTimeout;
    ClientVersion = stArgsData.ClientVersion;
    IsNoToken = stArgsData.IsNoToken;
    EncryptConfig = stArgsData.EncryptConfig;
}

int pbNFServerConfig::CreateInit()
{
    ServerType = 0;
    BusId = 0;
    BusLength = 0;
    IdleSleepUS = 0;
    HandleMsgNumPerFrame = 0;
    ServerOpenTime = 0;
    CrossServer = 0;
    ServerPort = 0;
    ExternalServerPort = 0;
    HttpPort = 0;
    MaxConnectNum = 0;
    WorkThreadNum = 0;
    NetThreadNum = 0;
    Security = 0;
    WebSocket = 0;
    ParseType = 0;
    MaxOnlinePlayerNum = 0;
    HeartBeatTimeout = 0;
    ClientKeepAliveTimeout = 0;
    ClientVersion = 0;
    IsNoToken = 0;
	return 0;
}

int pbNFServerConfig::ResumeInit()
{
	return 0;
}

void pbNFServerConfig::Init()
{
    ServerType = 0;
    BusId = 0;
    BusLength = 0;
    IdleSleepUS = 0;
    HandleMsgNumPerFrame = 0;
    ServerOpenTime = 0;
    CrossServer = 0;
    ServerPort = 0;
    ExternalServerPort = 0;
    HttpPort = 0;
    MaxConnectNum = 0;
    WorkThreadNum = 0;
    NetThreadNum = 0;
    Security = 0;
    WebSocket = 0;
    ParseType = 0;
    RouteConfig.Init();
    MysqlConfig.Init();
    RedisConfig.Init();
    MaxOnlinePlayerNum = 0;
    HeartBeatTimeout = 0;
    ClientKeepAliveTimeout = 0;
    ClientVersion = 0;
    IsNoToken = 0;
    EncryptConfig.Init();
}

bool pbNFServerConfig::FromPb(const NFrame::pbNFServerConfig& cc)
{
    ServerId = cc.serverid();
    ServerType = cc.servertype();
    ServerName = cc.servername();
    BusId = cc.busid();
    BusLength = cc.buslength();
    LinkMode = cc.linkmode();
    Url = cc.url();
    IdleSleepUS = cc.idlesleepus();
    HandleMsgNumPerFrame = cc.handlemsgnumperframe();
    ServerOpenTime = cc.serveropentime();
    LoadProtoDs = cc.loadprotods();
    CrossServer = cc.crossserver();
    ServerIp = cc.serverip();
    ServerPort = cc.serverport();
    ExternalServerIp = cc.externalserverip();
    ExternalServerPort = cc.externalserverport();
    HttpPort = cc.httpport();
    MaxConnectNum = cc.maxconnectnum();
    WorkThreadNum = cc.workthreadnum();
    NetThreadNum = cc.netthreadnum();
    Security = cc.security();
    WebSocket = cc.websocket();
    ParseType = cc.parsetype();
    if (!RouteConfig.FromPb(cc.routeconfig())) return false;
    if (!MysqlConfig.FromPb(cc.mysqlconfig())) return false;
    DefaultDBName = cc.defaultdbname();
    CrossDBName = cc.crossdbname();
    if (!RedisConfig.FromPb(cc.redisconfig())) return false;
    sendEmail = cc.sendemail();
    sendEmailPass = cc.sendemailpass();
    sendEmailUrl = cc.sendemailurl();
    sendEmailPort = cc.sendemailport();
    recvEmail = cc.recvemail();
    wxWorkdRobot = cc.wxworkdrobot();
    MaxOnlinePlayerNum = cc.maxonlineplayernum();
    HeartBeatTimeout = cc.heartbeattimeout();
    ClientKeepAliveTimeout = cc.clientkeepalivetimeout();
    ClientVersion = cc.clientversion();
    IsNoToken = cc.isnotoken();
    if (!EncryptConfig.FromPb(cc.encryptconfig())) return false;
    return true;
}

void pbNFServerConfig::ToPb(NFrame::pbNFServerConfig* cc) const
{
    cc->set_serverid(ServerId);
    cc->set_servertype(ServerType);
    cc->set_servername(ServerName);
    cc->set_busid(BusId);
    cc->set_buslength(BusLength);
    cc->set_linkmode(LinkMode);
    cc->set_url(Url);
    cc->set_idlesleepus(IdleSleepUS);
    cc->set_handlemsgnumperframe(HandleMsgNumPerFrame);
    cc->set_serveropentime(ServerOpenTime);
    cc->set_loadprotods(LoadProtoDs);
    cc->set_crossserver(CrossServer);
    cc->set_serverip(ServerIp);
    cc->set_serverport(ServerPort);
    cc->set_externalserverip(ExternalServerIp);
    cc->set_externalserverport(ExternalServerPort);
    cc->set_httpport(HttpPort);
    cc->set_maxconnectnum(MaxConnectNum);
    cc->set_workthreadnum(WorkThreadNum);
    cc->set_netthreadnum(NetThreadNum);
    cc->set_security(Security);
    cc->set_websocket(WebSocket);
    cc->set_parsetype(ParseType);
    RouteConfig.ToPb(cc->mutable_routeconfig());
    MysqlConfig.ToPb(cc->mutable_mysqlconfig());
    cc->set_defaultdbname(DefaultDBName);
    cc->set_crossdbname(CrossDBName);
    RedisConfig.ToPb(cc->mutable_redisconfig());
    cc->set_sendemail(sendEmail);
    cc->set_sendemailpass(sendEmailPass);
    cc->set_sendemailurl(sendEmailUrl);
    cc->set_sendemailport(sendEmailPort);
    cc->set_recvemail(recvEmail);
    cc->set_wxworkdrobot(wxWorkdRobot);
    cc->set_maxonlineplayernum(MaxOnlinePlayerNum);
    cc->set_heartbeattimeout(HeartBeatTimeout);
    cc->set_clientkeepalivetimeout(ClientKeepAliveTimeout);
    cc->set_clientversion(ClientVersion);
    cc->set_isnotoken(IsNoToken);
    EncryptConfig.ToPb(cc->mutable_encryptconfig());
    return;
}

NFrame::pbNFServerConfig pbNFServerConfig::ToPb() const
{
    NFrame::pbNFServerConfig cc;
    ToPb(&cc);
    return cc;
}

std::string pbNFServerConfig::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "ServerId:" << "\"" << ServerId << "\"" << ", ";
    ss << "ServerType:" << ServerType << ", ";
    ss << "ServerName:" << "\"" << ServerName << "\"" << ", ";
    ss << "BusId:" << BusId << ", ";
    ss << "BusLength:" << BusLength << ", ";
    ss << "LinkMode:" << "\"" << LinkMode << "\"" << ", ";
    ss << "Url:" << "\"" << Url << "\"" << ", ";
    ss << "IdleSleepUS:" << IdleSleepUS << ", ";
    ss << "HandleMsgNumPerFrame:" << HandleMsgNumPerFrame << ", ";
    ss << "ServerOpenTime:" << ServerOpenTime << ", ";
    ss << "LoadProtoDs:" << "\"" << LoadProtoDs << "\"" << ", ";
    ss << "CrossServer:" << CrossServer << ", ";
    ss << "ServerIp:" << "\"" << ServerIp << "\"" << ", ";
    ss << "ServerPort:" << ServerPort << ", ";
    ss << "ExternalServerIp:" << "\"" << ExternalServerIp << "\"" << ", ";
    ss << "ExternalServerPort:" << ExternalServerPort << ", ";
    ss << "HttpPort:" << HttpPort << ", ";
    ss << "MaxConnectNum:" << MaxConnectNum << ", ";
    ss << "WorkThreadNum:" << WorkThreadNum << ", ";
    ss << "NetThreadNum:" << NetThreadNum << ", ";
    ss << "Security:" << Security << ", ";
    ss << "WebSocket:" << WebSocket << ", ";
    ss << "ParseType:" << ParseType << ", ";
    ss << "RouteConfig:" << RouteConfig.ShortDebugString() << ", ";
    ss << "MysqlConfig:" << MysqlConfig.ShortDebugString() << ", ";
    ss << "DefaultDBName:" << "\"" << DefaultDBName << "\"" << ", ";
    ss << "CrossDBName:" << "\"" << CrossDBName << "\"" << ", ";
    ss << "RedisConfig:" << RedisConfig.ShortDebugString() << ", ";
    ss << "sendEmail:" << "\"" << sendEmail << "\"" << ", ";
    ss << "sendEmailPass:" << "\"" << sendEmailPass << "\"" << ", ";
    ss << "sendEmailUrl:" << "\"" << sendEmailUrl << "\"" << ", ";
    ss << "sendEmailPort:" << "\"" << sendEmailPort << "\"" << ", ";
    ss << "recvEmail:" << "\"" << recvEmail << "\"" << ", ";
    ss << "wxWorkdRobot:" << "\"" << wxWorkdRobot << "\"" << ", ";
    ss << "MaxOnlinePlayerNum:" << MaxOnlinePlayerNum << ", ";
    ss << "HeartBeatTimeout:" << HeartBeatTimeout << ", ";
    ss << "ClientKeepAliveTimeout:" << ClientKeepAliveTimeout << ", ";
    ss << "ClientVersion:" << ClientVersion << ", ";
    ss << "IsNoToken:" << IsNoToken << ", ";
    ss << "EncryptConfig:" << EncryptConfig.ShortDebugString();
    ss << "}";
    return ss.str();
}

wxWorkRobotText::wxWorkRobotText()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

wxWorkRobotText::~wxWorkRobotText()
{
}

wxWorkRobotText::wxWorkRobotText(const wxWorkRobotText& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

wxWorkRobotText& wxWorkRobotText::operator=(const wxWorkRobotText& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void wxWorkRobotText::CopyData(const wxWorkRobotText& stArgsData)
{
    content = stArgsData.content;
    mentioned_list.clear();
    mentioned_list = stArgsData.mentioned_list;
    mentioned_mobile_list.clear();
    mentioned_mobile_list = stArgsData.mentioned_mobile_list;
}

int wxWorkRobotText::CreateInit()
{
	return 0;
}

int wxWorkRobotText::ResumeInit()
{
	return 0;
}

void wxWorkRobotText::Init()
{
}

bool wxWorkRobotText::FromPb(const NFrame::wxWorkRobotText& cc)
{
    content = cc.content();
    mentioned_list.clear();
    for (int i = 0; i < cc.mentioned_list_size(); ++i)
    {
        mentioned_list.push_back(cc.mentioned_list(i));
    }
    mentioned_mobile_list.clear();
    for (int i = 0; i < cc.mentioned_mobile_list_size(); ++i)
    {
        mentioned_mobile_list.push_back(cc.mentioned_mobile_list(i));
    }
    return true;
}

void wxWorkRobotText::ToPb(NFrame::wxWorkRobotText* cc) const
{
    cc->set_content(content);
    cc->clear_mentioned_list();
    for (auto iter = mentioned_list.begin(); iter != mentioned_list.end(); ++iter)
    {
        cc->add_mentioned_list(*iter);
    }
    cc->clear_mentioned_mobile_list();
    for (auto iter = mentioned_mobile_list.begin(); iter != mentioned_mobile_list.end(); ++iter)
    {
        cc->add_mentioned_mobile_list(*iter);
    }
    return;
}

NFrame::wxWorkRobotText wxWorkRobotText::ToPb() const
{
    NFrame::wxWorkRobotText cc;
    ToPb(&cc);
    return cc;
}

std::string wxWorkRobotText::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "content:" << "\"" << content << "\"" << ", ";
    ss << "mentioned_list(" << mentioned_list.size()<< "):[";
    for (auto iter = mentioned_list.begin(); iter != mentioned_list.end(); ++iter)
    {
        ss << "\"" << *iter << "\"";
    }
;
    ss << "mentioned_mobile_list(" << mentioned_mobile_list.size()<< "):[";
    for (auto iter = mentioned_mobile_list.begin(); iter != mentioned_mobile_list.end(); ++iter)
    {
        ss << "\"" << *iter << "\"";
    }
;
    ss << "}";
    return ss.str();
}

wxWorkRobotHttpPost::wxWorkRobotHttpPost()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

wxWorkRobotHttpPost::~wxWorkRobotHttpPost()
{
}

wxWorkRobotHttpPost::wxWorkRobotHttpPost(const wxWorkRobotHttpPost& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

wxWorkRobotHttpPost& wxWorkRobotHttpPost::operator=(const wxWorkRobotHttpPost& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void wxWorkRobotHttpPost::CopyData(const wxWorkRobotHttpPost& stArgsData)
{
    msgtype = stArgsData.msgtype;
    text = stArgsData.text;
}

int wxWorkRobotHttpPost::CreateInit()
{
	return 0;
}

int wxWorkRobotHttpPost::ResumeInit()
{
	return 0;
}

void wxWorkRobotHttpPost::Init()
{
    text.Init();
}

bool wxWorkRobotHttpPost::FromPb(const NFrame::wxWorkRobotHttpPost& cc)
{
    msgtype = cc.msgtype();
    if (!text.FromPb(cc.text())) return false;
    return true;
}

void wxWorkRobotHttpPost::ToPb(NFrame::wxWorkRobotHttpPost* cc) const
{
    cc->set_msgtype(msgtype);
    text.ToPb(cc->mutable_text());
    return;
}

NFrame::wxWorkRobotHttpPost wxWorkRobotHttpPost::ToPb() const
{
    NFrame::wxWorkRobotHttpPost cc;
    ToPb(&cc);
    return cc;
}

std::string wxWorkRobotHttpPost::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "msgtype:" << "\"" << msgtype << "\"" << ", ";
    ss << "text:" << text.ShortDebugString();
    ss << "}";
    return ss.str();
}

ExcelSheetInfo::ExcelSheetInfo()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

ExcelSheetInfo::~ExcelSheetInfo()
{
}

ExcelSheetInfo::ExcelSheetInfo(const ExcelSheetInfo& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

ExcelSheetInfo& ExcelSheetInfo::operator=(const ExcelSheetInfo& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void ExcelSheetInfo::CopyData(const ExcelSheetInfo& stArgsData)
{
    name = stArgsData.name;
    unique_index = stArgsData.unique_index;
    multi_index = stArgsData.multi_index;
    relation = stArgsData.relation;
    createSql = stArgsData.createSql;
    field_enum = stArgsData.field_enum;
    import_proto = stArgsData.import_proto;
    colMessageType = stArgsData.colMessageType;
    add_field = stArgsData.add_field;
    otherName = stArgsData.otherName;
    sheetMsgName = stArgsData.sheetMsgName;
    protoMsgName = stArgsData.protoMsgName;
}

int ExcelSheetInfo::CreateInit()
{
    createSql = 0;
	return 0;
}

int ExcelSheetInfo::ResumeInit()
{
	return 0;
}

void ExcelSheetInfo::Init()
{
    createSql = 0;
}

bool ExcelSheetInfo::FromPb(const NFrame::ExcelSheetInfo& cc)
{
    name = cc.name();
    unique_index = cc.unique_index();
    multi_index = cc.multi_index();
    relation = cc.relation();
    createSql = cc.createsql();
    field_enum = cc.field_enum();
    import_proto = cc.import_proto();
    colMessageType = cc.colmessagetype();
    add_field = cc.add_field();
    otherName = cc.othername();
    sheetMsgName = cc.sheetmsgname();
    protoMsgName = cc.protomsgname();
    return true;
}

void ExcelSheetInfo::ToPb(NFrame::ExcelSheetInfo* cc) const
{
    cc->set_name(name);
    cc->set_unique_index(unique_index);
    cc->set_multi_index(multi_index);
    cc->set_relation(relation);
    cc->set_createsql(createSql);
    cc->set_field_enum(field_enum);
    cc->set_import_proto(import_proto);
    cc->set_colmessagetype(colMessageType);
    cc->set_add_field(add_field);
    cc->set_othername(otherName);
    cc->set_sheetmsgname(sheetMsgName);
    cc->set_protomsgname(protoMsgName);
    return;
}

NFrame::ExcelSheetInfo ExcelSheetInfo::ToPb() const
{
    NFrame::ExcelSheetInfo cc;
    ToPb(&cc);
    return cc;
}

std::string ExcelSheetInfo::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "name:" << "\"" << name << "\"" << ", ";
    ss << "unique_index:" << "\"" << unique_index << "\"" << ", ";
    ss << "multi_index:" << "\"" << multi_index << "\"" << ", ";
    ss << "relation:" << "\"" << relation << "\"" << ", ";
    ss << "createSql:" << createSql << ", ";
    ss << "field_enum:" << "\"" << field_enum << "\"" << ", ";
    ss << "import_proto:" << "\"" << import_proto << "\"" << ", ";
    ss << "colMessageType:" << "\"" << colMessageType << "\"" << ", ";
    ss << "add_field:" << "\"" << add_field << "\"" << ", ";
    ss << "otherName:" << "\"" << otherName << "\"" << ", ";
    ss << "sheetMsgName:" << "\"" << sheetMsgName << "\"" << ", ";
    ss << "protoMsgName:" << "\"" << protoMsgName << "\"";
    ss << "}";
    return ss.str();
}

ExcelPbInfo::ExcelPbInfo()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

ExcelPbInfo::~ExcelPbInfo()
{
}

ExcelPbInfo::ExcelPbInfo(const ExcelPbInfo& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

ExcelPbInfo& ExcelPbInfo::operator=(const ExcelPbInfo& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void ExcelPbInfo::CopyData(const ExcelPbInfo& stArgsData)
{
    name = stArgsData.name;
    sheet.clear();
    sheet = stArgsData.sheet;
}

int ExcelPbInfo::CreateInit()
{
	return 0;
}

int ExcelPbInfo::ResumeInit()
{
	return 0;
}

void ExcelPbInfo::Init()
{
}

bool ExcelPbInfo::FromPb(const NFrame::ExcelPbInfo& cc)
{
    name = cc.name();
    sheet.clear();
    for (int i = 0; i < cc.sheet_size(); ++i)
    {
        ExcelSheetInfo temp;
        if (!temp.FromPb(cc.sheet(i)))
        {
            if (NULL != g_nanopb_frompb_log_handle)
                g_nanopb_frompb_log_handle("FromPb Failed, struct:ExcelPbInfo, field:sheet, cur count:%d", cc.sheet_size());
            return false;
        }
        sheet.emplace(cc.sheet(i).name(), temp);
    }
    return true;
}

void ExcelPbInfo::ToPb(NFrame::ExcelPbInfo* cc) const
{
    cc->set_name(name);
    cc->clear_sheet();
    for (auto iter = sheet.begin(); iter != sheet.end(); ++iter)
    {
        iter->second.ToPb(cc->add_sheet());
    }
    return;
}

NFrame::ExcelPbInfo ExcelPbInfo::ToPb() const
{
    NFrame::ExcelPbInfo cc;
    ToPb(&cc);
    return cc;
}

std::string ExcelPbInfo::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "name:" << "\"" << name << "\"" << ", ";
    ss << "sheet(" << sheet.size()<< "):[";
    for (auto iter = sheet.begin(); iter != sheet.end(); ++iter)
    {
        ss << iter->second.ShortDebugString();
    }
;
    ss << "}";
    return ss.str();
}

ExcelParseInfo::ExcelParseInfo()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

ExcelParseInfo::~ExcelParseInfo()
{
}

ExcelParseInfo::ExcelParseInfo(const ExcelParseInfo& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

ExcelParseInfo& ExcelParseInfo::operator=(const ExcelParseInfo& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void ExcelParseInfo::CopyData(const ExcelParseInfo& stArgsData)
{
    excel.clear();
    excel = stArgsData.excel;
}

int ExcelParseInfo::CreateInit()
{
	return 0;
}

int ExcelParseInfo::ResumeInit()
{
	return 0;
}

void ExcelParseInfo::Init()
{
}

bool ExcelParseInfo::FromPb(const NFrame::ExcelParseInfo& cc)
{
    excel.clear();
    for (int i = 0; i < cc.excel_size(); ++i)
    {
        ExcelPbInfo temp;
        if (!temp.FromPb(cc.excel(i)))
        {
            if (NULL != g_nanopb_frompb_log_handle)
                g_nanopb_frompb_log_handle("FromPb Failed, struct:ExcelParseInfo, field:excel, cur count:%d", cc.excel_size());
            return false;
        }
        excel.emplace(cc.excel(i).name(), temp);
    }
    return true;
}

void ExcelParseInfo::ToPb(NFrame::ExcelParseInfo* cc) const
{
    cc->clear_excel();
    for (auto iter = excel.begin(); iter != excel.end(); ++iter)
    {
        iter->second.ToPb(cc->add_excel());
    }
    return;
}

NFrame::ExcelParseInfo ExcelParseInfo::ToPb() const
{
    NFrame::ExcelParseInfo cc;
    ToPb(&cc);
    return cc;
}

std::string ExcelParseInfo::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "excel(" << excel.size()<< "):[";
    for (auto iter = excel.begin(); iter != excel.end(); ++iter)
    {
        ss << iter->second.ShortDebugString();
    }
;
    ss << "}";
    return ss.str();
}




/* Check that field information fits in pb_field_t */
#if !defined(PB_FIELD_32BIT)
/* If you get an error here, it means that you need to define PB_FIELD_32BIT
 * compile-time option. You can do that in pb.h or on compiler command line.
 * 
 * The reason you need to do this is that some of your messages contain tag
 * numbers or field sizes that are larger than what can fit in 8 or 16 bit
 * field descriptors.
 */
PB_STATIC_ASSERT((pb_membersize(pbMysqlConfig, TBConfList[0]) < 65536 && pb_membersize(pbPluginConfig, ServerList[0]) < 65536 && pb_membersize(pbNFServerConfig, RouteConfig) < 65536 && pb_membersize(pbNFServerConfig, MysqlConfig) < 65536 && pb_membersize(pbNFServerConfig, RedisConfig) < 65536 && pb_membersize(pbNFServerConfig, EncryptConfig) < 65536 && pb_membersize(wxWorkRobotHttpPost, text) < 65536 && pb_membersize(ExcelPbInfo, sheet[0]) < 65536 && pb_membersize(ExcelParseInfo, excel[0]) < 65536), YOU_MUST_DEFINE_PB_FIELD_32BIT_FOR_MESSAGES_tbServerMgr_pbMysqlConfig_pbRedisConfig_pbRouteConfig_pbPluginConfig_pbAllServerConfig_pbTableConfig_pbEncryptConfig_pbNFServerConfig_wxWorkRobotText_wxWorkRobotHttpPost_ExcelSheetInfo_ExcelPbInfo_ExcelParseInfo)
#endif

#if !defined(PB_FIELD_16BIT) && !defined(PB_FIELD_32BIT)
/* If you get an error here, it means that you need to define PB_FIELD_16BIT
 * compile-time option. You can do that in pb.h or on compiler command line.
 * 
 * The reason you need to do this is that some of your messages contain tag
 * numbers or field sizes that are larger than what can fit in the default
 * 8 bit descriptors.
 */
PB_STATIC_ASSERT((pb_membersize(pbMysqlConfig, TBConfList[0]) < 256 && pb_membersize(pbPluginConfig, ServerList[0]) < 256 && pb_membersize(pbNFServerConfig, RouteConfig) < 256 && pb_membersize(pbNFServerConfig, MysqlConfig) < 256 && pb_membersize(pbNFServerConfig, RedisConfig) < 256 && pb_membersize(pbNFServerConfig, EncryptConfig) < 256 && pb_membersize(wxWorkRobotHttpPost, text) < 256 && pb_membersize(ExcelPbInfo, sheet[0]) < 256 && pb_membersize(ExcelParseInfo, excel[0]) < 256), YOU_MUST_DEFINE_PB_FIELD_16BIT_FOR_MESSAGES_tbServerMgr_pbMysqlConfig_pbRedisConfig_pbRouteConfig_pbPluginConfig_pbAllServerConfig_pbTableConfig_pbEncryptConfig_pbNFServerConfig_wxWorkRobotText_wxWorkRobotHttpPost_ExcelSheetInfo_ExcelPbInfo_ExcelParseInfo)
#endif


/* @@protoc_insertion_point(eof) */
