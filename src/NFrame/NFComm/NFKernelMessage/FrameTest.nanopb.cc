/* Automatically generated nanopb constant definitions */
/* Generated by nanopb-0.3.9 */

#include <sstream>
#include "NFComm/NFObjCommon/NFShmMgr.h"
#include "FrameTest.nanopb.h"

/* @@protoc_insertion_point(includes) */
#if PB_PROTO_HEADER_VERSION != 30
#error Regenerate this file with the current version of nanopb generator.
#endif

wxWorkRobotTextMore::wxWorkRobotTextMore()
{
	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode()) {
		CreateInit();
	} else {
		ResumeInit();
	}
}

wxWorkRobotTextMore::~wxWorkRobotTextMore()
{
}

wxWorkRobotTextMore::wxWorkRobotTextMore(const wxWorkRobotTextMore& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
}

wxWorkRobotTextMore& wxWorkRobotTextMore::operator=(const wxWorkRobotTextMore& stArgsData)
{
	if (this != &stArgsData) {
		CopyData(stArgsData);
	}
	return *this;
}

void wxWorkRobotTextMore::CopyData(const wxWorkRobotTextMore& stArgsData)
{
    test_map = stArgsData.test_map;
    test_set = stArgsData.test_set;
}

int wxWorkRobotTextMore::CreateInit()
{
	return 0;
}

int wxWorkRobotTextMore::ResumeInit()
{
	return 0;
}

void wxWorkRobotTextMore::Init()
{
    test_map.Init();
    test_set.Init();
}

bool wxWorkRobotTextMore::FromPb(const NFrame::wxWorkRobotTextMore& cc)
{
    test_map.clear();
    if (cc.test_map_size() > FRAME_ENUM_DEFAULT_REPEATED)
    {
        if (NULL != g_nanopb_frompb_log_handle)
            g_nanopb_frompb_log_handle("struct:wxWorkRobotTextMore, field:test_map, cur count:%d, max count:%d", cc.test_map_size(), FRAME_ENUM_DEFAULT_REPEATED);
        return false;
    }
    for (int i = 0; i < cc.test_map_size(); ++i)
    {
        if (test_map.size() >= test_map.max_size())
        {
            if (NULL != g_nanopb_frompb_log_handle)
                g_nanopb_frompb_log_handle("struct:wxWorkRobotTextMore, field:test_map, cur count:%d, max count:%d", cc.test_map_size(), FRAME_ENUM_DEFAULT_REPEATED);
            return false;
        }
        wxWorkRobotTextTest temp;
        if (!temp.FromPb(cc.test_map(i)))
        {
            if (NULL != g_nanopb_frompb_log_handle)
                g_nanopb_frompb_log_handle("struct:wxWorkRobotTextMore, field:test_map, cur count:%d, max count:%d", cc.test_map_size(), FRAME_ENUM_DEFAULT_REPEATED);
            return false;
        }
        test_map.emplace(cc.test_map(i).id(), temp);
    }
    test_set.clear();
    if (cc.test_set_size() > FRAME_ENUM_DEFAULT_REPEATED)
    {
        if (NULL != g_nanopb_frompb_log_handle)
            g_nanopb_frompb_log_handle("struct:wxWorkRobotTextMore, field:test_set, cur count:%d, max count:%d", cc.test_set_size(), FRAME_ENUM_DEFAULT_REPEATED);
        return false;
    }
    for (int i = 0; i < cc.test_set_size(); ++i)
    {
        if (test_set.size() >= test_set.max_size())
        {
            if (NULL != g_nanopb_frompb_log_handle)
                g_nanopb_frompb_log_handle("struct:wxWorkRobotTextMore, field:test_set, cur count:%d, max count:%d", cc.test_set_size(), FRAME_ENUM_DEFAULT_REPEATED);
            return false;
        }
        wxWorkRobotTextTest temp;
        if (!temp.FromPb(cc.test_set(i)))
        {
            if (NULL != g_nanopb_frompb_log_handle)
                g_nanopb_frompb_log_handle("struct:wxWorkRobotTextMore, field:test_set, cur count:%d, max count:%d", cc.test_set_size(), FRAME_ENUM_DEFAULT_REPEATED);
            return false;
        }
        test_set.insert(temp);
    }
    return true;
}

void wxWorkRobotTextMore::ToPb(NFrame::wxWorkRobotTextMore* cc) const
{
    cc->clear_test_map();
    for (auto iter = test_map.begin(); iter != test_map.end(); ++iter)
    {
        iter->second.ToPb(cc->add_test_map());
    }
    cc->clear_test_set();
    for (auto iter = test_set.begin(); iter != test_set.end(); ++iter)
    {
        iter->ToPb(cc->add_test_set());
    }
    return;
}

NFrame::wxWorkRobotTextMore wxWorkRobotTextMore::ToPb() const
{
    NFrame::wxWorkRobotTextMore cc;
    ToPb(&cc);
    return cc;
}

std::string wxWorkRobotTextMore::ShortDebugString() const
{
    std::stringstream ss;
    ss << "{";
    ss << "test_map(" << test_map.size()<< "):[";
    for (auto iter = test_map.begin(); iter != test_map.end(); ++iter)
    {
        ss << iter->second.ShortDebugString();
        ss << ", ";
    }
    ss << "]";
    ss << "test_set(" << test_set.size()<< "):[";
    for (auto iter = test_set.begin(); iter != test_set.end(); ++iter)
    {
        ss << iter->ShortDebugString();
        ss << ", ";
    }
    ss << "]";
    ss << "}";
    return ss.str();
}




/* Check that field information fits in pb_field_t */
#if !defined(PB_FIELD_32BIT)
/* If you get an error here, it means that you need to define PB_FIELD_32BIT
 * compile-time option. You can do that in pb.h or on compiler command line.
 * 
 * The reason you need to do this is that some of your messages contain tag
 * numbers or field sizes that are larger than what can fit in 8 or 16 bit
 * field descriptors.
 */
PB_STATIC_ASSERT((pb_membersize(wxWorkRobotTextMore, test_map[0]) < 65536 && pb_membersize(wxWorkRobotTextMore, test_set[0]) < 65536), YOU_MUST_DEFINE_PB_FIELD_32BIT_FOR_MESSAGES_wxWorkRobotTextMore)
#endif

#if !defined(PB_FIELD_16BIT) && !defined(PB_FIELD_32BIT)
/* If you get an error here, it means that you need to define PB_FIELD_16BIT
 * compile-time option. You can do that in pb.h or on compiler command line.
 * 
 * The reason you need to do this is that some of your messages contain tag
 * numbers or field sizes that are larger than what can fit in the default
 * 8 bit descriptors.
 */
PB_STATIC_ASSERT((pb_membersize(wxWorkRobotTextMore, test_map[0]) < 256 && pb_membersize(wxWorkRobotTextMore, test_set[0]) < 256), YOU_MUST_DEFINE_PB_FIELD_16BIT_FOR_MESSAGES_wxWorkRobotTextMore)
#endif


/* @@protoc_insertion_point(eof) */
