// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto_common.proto

#ifndef PROTOBUF_proto_5fcommon_2eproto__INCLUDED
#define PROTOBUF_proto_5fcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "yd_fieldoptions.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_5fcommon_2eproto();
void protobuf_AssignDesc_proto_5fcommon_2eproto();
void protobuf_ShutdownFile_proto_5fcommon_2eproto();

class tbServerMgr;
class pbMysqlConfig;
class pbRedisConfig;
class pbRouteConfig;
class pbAllServerConfig;
class pbPluginConfig;
class pbTableConfig;
class pbNFServerConfig;
class wxWorkRobotText;
class wxWorkRobotHttpPost;

enum NF_SERVER_TYPE {
  NF_ST_NONE = 0,
  NF_ST_MASTER_SERVER = 1,
  NF_ST_ROUTE_SERVER = 2,
  NF_ST_ROUTE_AGENT_SERVER = 3,
  NF_ST_PROXY_SERVER = 4,
  NF_ST_PROXY_AGENT_SERVER = 5,
  NF_ST_STORE_SERVER = 6,
  NF_ST_LOGIN_SERVER = 7,
  NF_ST_WORLD_SERVER = 8,
  NF_ST_LOGIC_SERVER = 9,
  NF_ST_GAME_SERVER = 10,
  NF_ST_SNS_SERVER = 11,
  NF_ST_WEB_SERVER = 12,
  NF_ST_MONITOR_SERVER = 13,
  NF_ST_CENTER_SERVER = 14,
  NF_ST_MAX = 20
};
bool NF_SERVER_TYPE_IsValid(int value);
const NF_SERVER_TYPE NF_SERVER_TYPE_MIN = NF_ST_NONE;
const NF_SERVER_TYPE NF_SERVER_TYPE_MAX = NF_ST_MAX;
const int NF_SERVER_TYPE_ARRAYSIZE = NF_SERVER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* NF_SERVER_TYPE_descriptor();
inline const ::std::string& NF_SERVER_TYPE_Name(NF_SERVER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    NF_SERVER_TYPE_descriptor(), value);
}
inline bool NF_SERVER_TYPE_Parse(
    const ::std::string& name, NF_SERVER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NF_SERVER_TYPE>(
    NF_SERVER_TYPE_descriptor(), name, value);
}
// ===================================================================

class tbServerMgr : public ::google::protobuf::Message {
 public:
  tbServerMgr();
  virtual ~tbServerMgr();

  tbServerMgr(const tbServerMgr& from);

  inline tbServerMgr& operator=(const tbServerMgr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tbServerMgr& default_instance();

  void Swap(tbServerMgr* other);

  // implements Message ----------------------------------------------

  tbServerMgr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tbServerMgr& from);
  void MergeFrom(const tbServerMgr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string contract = 2;
  inline bool has_contract() const;
  inline void clear_contract();
  static const int kContractFieldNumber = 2;
  inline const ::std::string& contract() const;
  inline void set_contract(const ::std::string& value);
  inline void set_contract(const char* value);
  inline void set_contract(const char* value, size_t size);
  inline ::std::string* mutable_contract();
  inline ::std::string* release_contract();
  inline void set_allocated_contract(::std::string* contract);

  // optional string machine_addr = 3;
  inline bool has_machine_addr() const;
  inline void clear_machine_addr();
  static const int kMachineAddrFieldNumber = 3;
  inline const ::std::string& machine_addr() const;
  inline void set_machine_addr(const ::std::string& value);
  inline void set_machine_addr(const char* value);
  inline void set_machine_addr(const char* value, size_t size);
  inline ::std::string* mutable_machine_addr();
  inline ::std::string* release_machine_addr();
  inline void set_allocated_machine_addr(::std::string* machine_addr);

  // optional string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string bus_name = 5;
  inline bool has_bus_name() const;
  inline void clear_bus_name();
  static const int kBusNameFieldNumber = 5;
  inline const ::std::string& bus_name() const;
  inline void set_bus_name(const ::std::string& value);
  inline void set_bus_name(const char* value);
  inline void set_bus_name(const char* value, size_t size);
  inline ::std::string* mutable_bus_name();
  inline ::std::string* release_bus_name();
  inline void set_allocated_bus_name(::std::string* bus_name);

  // optional string server_desc = 6;
  inline bool has_server_desc() const;
  inline void clear_server_desc();
  static const int kServerDescFieldNumber = 6;
  inline const ::std::string& server_desc() const;
  inline void set_server_desc(const ::std::string& value);
  inline void set_server_desc(const char* value);
  inline void set_server_desc(const char* value, size_t size);
  inline ::std::string* mutable_server_desc();
  inline ::std::string* release_server_desc();
  inline void set_allocated_server_desc(::std::string* server_desc);

  // optional uint32 cur_count = 7;
  inline bool has_cur_count() const;
  inline void clear_cur_count();
  static const int kCurCountFieldNumber = 7;
  inline ::google::protobuf::uint32 cur_count() const;
  inline void set_cur_count(::google::protobuf::uint32 value);

  // optional uint64 last_login_time = 8;
  inline bool has_last_login_time() const;
  inline void clear_last_login_time();
  static const int kLastLoginTimeFieldNumber = 8;
  inline ::google::protobuf::uint64 last_login_time() const;
  inline void set_last_login_time(::google::protobuf::uint64 value);

  // optional uint64 last_logout_time = 9;
  inline bool has_last_logout_time() const;
  inline void clear_last_logout_time();
  static const int kLastLogoutTimeFieldNumber = 9;
  inline ::google::protobuf::uint64 last_logout_time() const;
  inline void set_last_logout_time(::google::protobuf::uint64 value);

  // optional uint64 create_time = 10;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 10;
  inline ::google::protobuf::uint64 create_time() const;
  inline void set_create_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.tbServerMgr)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_contract();
  inline void clear_has_contract();
  inline void set_has_machine_addr();
  inline void clear_has_machine_addr();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_bus_name();
  inline void clear_has_bus_name();
  inline void set_has_server_desc();
  inline void clear_has_server_desc();
  inline void set_has_cur_count();
  inline void clear_has_cur_count();
  inline void set_has_last_login_time();
  inline void clear_has_last_login_time();
  inline void set_has_last_logout_time();
  inline void clear_has_last_logout_time();
  inline void set_has_create_time();
  inline void clear_has_create_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* contract_;
  ::std::string* machine_addr_;
  ::std::string* ip_;
  ::std::string* bus_name_;
  ::std::string* server_desc_;
  ::google::protobuf::uint64 last_login_time_;
  ::google::protobuf::uint64 last_logout_time_;
  ::google::protobuf::uint64 create_time_;
  ::google::protobuf::uint32 cur_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static tbServerMgr* default_instance_;
};
// -------------------------------------------------------------------

class pbMysqlConfig : public ::google::protobuf::Message {
 public:
  pbMysqlConfig();
  virtual ~pbMysqlConfig();

  pbMysqlConfig(const pbMysqlConfig& from);

  inline pbMysqlConfig& operator=(const pbMysqlConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbMysqlConfig& default_instance();

  void Swap(pbMysqlConfig* other);

  // implements Message ----------------------------------------------

  pbMysqlConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbMysqlConfig& from);
  void MergeFrom(const pbMysqlConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string MysqlIp = 1;
  inline bool has_mysqlip() const;
  inline void clear_mysqlip();
  static const int kMysqlIpFieldNumber = 1;
  inline const ::std::string& mysqlip() const;
  inline void set_mysqlip(const ::std::string& value);
  inline void set_mysqlip(const char* value);
  inline void set_mysqlip(const char* value, size_t size);
  inline ::std::string* mutable_mysqlip();
  inline ::std::string* release_mysqlip();
  inline void set_allocated_mysqlip(::std::string* mysqlip);

  // optional uint32 MysqlPort = 2;
  inline bool has_mysqlport() const;
  inline void clear_mysqlport();
  static const int kMysqlPortFieldNumber = 2;
  inline ::google::protobuf::uint32 mysqlport() const;
  inline void set_mysqlport(::google::protobuf::uint32 value);

  // optional string MysqlDbName = 3;
  inline bool has_mysqldbname() const;
  inline void clear_mysqldbname();
  static const int kMysqlDbNameFieldNumber = 3;
  inline const ::std::string& mysqldbname() const;
  inline void set_mysqldbname(const ::std::string& value);
  inline void set_mysqldbname(const char* value);
  inline void set_mysqldbname(const char* value, size_t size);
  inline ::std::string* mutable_mysqldbname();
  inline ::std::string* release_mysqldbname();
  inline void set_allocated_mysqldbname(::std::string* mysqldbname);

  // optional string MysqlUser = 4;
  inline bool has_mysqluser() const;
  inline void clear_mysqluser();
  static const int kMysqlUserFieldNumber = 4;
  inline const ::std::string& mysqluser() const;
  inline void set_mysqluser(const ::std::string& value);
  inline void set_mysqluser(const char* value);
  inline void set_mysqluser(const char* value, size_t size);
  inline ::std::string* mutable_mysqluser();
  inline ::std::string* release_mysqluser();
  inline void set_allocated_mysqluser(::std::string* mysqluser);

  // optional string MysqlPassword = 5;
  inline bool has_mysqlpassword() const;
  inline void clear_mysqlpassword();
  static const int kMysqlPasswordFieldNumber = 5;
  inline const ::std::string& mysqlpassword() const;
  inline void set_mysqlpassword(const ::std::string& value);
  inline void set_mysqlpassword(const char* value);
  inline void set_mysqlpassword(const char* value, size_t size);
  inline ::std::string* mutable_mysqlpassword();
  inline ::std::string* release_mysqlpassword();
  inline void set_allocated_mysqlpassword(::std::string* mysqlpassword);

  // repeated .proto_ff.pbTableConfig TBConfList = 6;
  inline int tbconflist_size() const;
  inline void clear_tbconflist();
  static const int kTBConfListFieldNumber = 6;
  inline const ::proto_ff::pbTableConfig& tbconflist(int index) const;
  inline ::proto_ff::pbTableConfig* mutable_tbconflist(int index);
  inline ::proto_ff::pbTableConfig* add_tbconflist();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig >&
      tbconflist() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig >*
      mutable_tbconflist();

  // @@protoc_insertion_point(class_scope:proto_ff.pbMysqlConfig)
 private:
  inline void set_has_mysqlip();
  inline void clear_has_mysqlip();
  inline void set_has_mysqlport();
  inline void clear_has_mysqlport();
  inline void set_has_mysqldbname();
  inline void clear_has_mysqldbname();
  inline void set_has_mysqluser();
  inline void clear_has_mysqluser();
  inline void set_has_mysqlpassword();
  inline void clear_has_mysqlpassword();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mysqlip_;
  ::std::string* mysqldbname_;
  ::std::string* mysqluser_;
  ::std::string* mysqlpassword_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig > tbconflist_;
  ::google::protobuf::uint32 mysqlport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbMysqlConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbRedisConfig : public ::google::protobuf::Message {
 public:
  pbRedisConfig();
  virtual ~pbRedisConfig();

  pbRedisConfig(const pbRedisConfig& from);

  inline pbRedisConfig& operator=(const pbRedisConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbRedisConfig& default_instance();

  void Swap(pbRedisConfig* other);

  // implements Message ----------------------------------------------

  pbRedisConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbRedisConfig& from);
  void MergeFrom(const pbRedisConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RedisIp = 1;
  inline bool has_redisip() const;
  inline void clear_redisip();
  static const int kRedisIpFieldNumber = 1;
  inline const ::std::string& redisip() const;
  inline void set_redisip(const ::std::string& value);
  inline void set_redisip(const char* value);
  inline void set_redisip(const char* value, size_t size);
  inline ::std::string* mutable_redisip();
  inline ::std::string* release_redisip();
  inline void set_allocated_redisip(::std::string* redisip);

  // optional uint32 RedisPort = 2;
  inline bool has_redisport() const;
  inline void clear_redisport();
  static const int kRedisPortFieldNumber = 2;
  inline ::google::protobuf::uint32 redisport() const;
  inline void set_redisport(::google::protobuf::uint32 value);

  // optional string RedisPass = 3;
  inline bool has_redispass() const;
  inline void clear_redispass();
  static const int kRedisPassFieldNumber = 3;
  inline const ::std::string& redispass() const;
  inline void set_redispass(const ::std::string& value);
  inline void set_redispass(const char* value);
  inline void set_redispass(const char* value, size_t size);
  inline ::std::string* mutable_redispass();
  inline ::std::string* release_redispass();
  inline void set_allocated_redispass(::std::string* redispass);

  // @@protoc_insertion_point(class_scope:proto_ff.pbRedisConfig)
 private:
  inline void set_has_redisip();
  inline void clear_has_redisip();
  inline void set_has_redisport();
  inline void clear_has_redisport();
  inline void set_has_redispass();
  inline void clear_has_redispass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* redisip_;
  ::std::string* redispass_;
  ::google::protobuf::uint32 redisport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbRedisConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbRouteConfig : public ::google::protobuf::Message {
 public:
  pbRouteConfig();
  virtual ~pbRouteConfig();

  pbRouteConfig(const pbRouteConfig& from);

  inline pbRouteConfig& operator=(const pbRouteConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbRouteConfig& default_instance();

  void Swap(pbRouteConfig* other);

  // implements Message ----------------------------------------------

  pbRouteConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbRouteConfig& from);
  void MergeFrom(const pbRouteConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string MasterIp = 1;
  inline bool has_masterip() const;
  inline void clear_masterip();
  static const int kMasterIpFieldNumber = 1;
  inline const ::std::string& masterip() const;
  inline void set_masterip(const ::std::string& value);
  inline void set_masterip(const char* value);
  inline void set_masterip(const char* value, size_t size);
  inline ::std::string* mutable_masterip();
  inline ::std::string* release_masterip();
  inline void set_allocated_masterip(::std::string* masterip);

  // optional uint32 MasterPort = 2;
  inline bool has_masterport() const;
  inline void clear_masterport();
  static const int kMasterPortFieldNumber = 2;
  inline ::google::protobuf::uint32 masterport() const;
  inline void set_masterport(::google::protobuf::uint32 value);

  // optional string NamingHost = 3;
  inline bool has_naminghost() const;
  inline void clear_naminghost();
  static const int kNamingHostFieldNumber = 3;
  inline const ::std::string& naminghost() const;
  inline void set_naminghost(const ::std::string& value);
  inline void set_naminghost(const char* value);
  inline void set_naminghost(const char* value, size_t size);
  inline ::std::string* mutable_naminghost();
  inline ::std::string* release_naminghost();
  inline void set_allocated_naminghost(::std::string* naminghost);

  // optional string NamingPath = 4;
  inline bool has_namingpath() const;
  inline void clear_namingpath();
  static const int kNamingPathFieldNumber = 4;
  inline const ::std::string& namingpath() const;
  inline void set_namingpath(const ::std::string& value);
  inline void set_namingpath(const char* value);
  inline void set_namingpath(const char* value, size_t size);
  inline ::std::string* mutable_namingpath();
  inline ::std::string* release_namingpath();
  inline void set_allocated_namingpath(::std::string* namingpath);

  // optional string RouteAgent = 5;
  inline bool has_routeagent() const;
  inline void clear_routeagent();
  static const int kRouteAgentFieldNumber = 5;
  inline const ::std::string& routeagent() const;
  inline void set_routeagent(const ::std::string& value);
  inline void set_routeagent(const char* value);
  inline void set_routeagent(const char* value, size_t size);
  inline ::std::string* mutable_routeagent();
  inline ::std::string* release_routeagent();
  inline void set_allocated_routeagent(::std::string* routeagent);

  // @@protoc_insertion_point(class_scope:proto_ff.pbRouteConfig)
 private:
  inline void set_has_masterip();
  inline void clear_has_masterip();
  inline void set_has_masterport();
  inline void clear_has_masterport();
  inline void set_has_naminghost();
  inline void clear_has_naminghost();
  inline void set_has_namingpath();
  inline void clear_has_namingpath();
  inline void set_has_routeagent();
  inline void clear_has_routeagent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* masterip_;
  ::std::string* naminghost_;
  ::std::string* namingpath_;
  ::std::string* routeagent_;
  ::google::protobuf::uint32 masterport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbRouteConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbAllServerConfig : public ::google::protobuf::Message {
 public:
  pbAllServerConfig();
  virtual ~pbAllServerConfig();

  pbAllServerConfig(const pbAllServerConfig& from);

  inline pbAllServerConfig& operator=(const pbAllServerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbAllServerConfig& default_instance();

  void Swap(pbAllServerConfig* other);

  // implements Message ----------------------------------------------

  pbAllServerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbAllServerConfig& from);
  void MergeFrom(const pbAllServerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Server = 1;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 1;
  inline const ::std::string& server() const;
  inline void set_server(const ::std::string& value);
  inline void set_server(const char* value);
  inline void set_server(const char* value, size_t size);
  inline ::std::string* mutable_server();
  inline ::std::string* release_server();
  inline void set_allocated_server(::std::string* server);

  // optional string ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional uint32 ServerType = 3;
  inline bool has_servertype() const;
  inline void clear_servertype();
  static const int kServerTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 servertype() const;
  inline void set_servertype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.pbAllServerConfig)
 private:
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_servertype();
  inline void clear_has_servertype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* server_;
  ::std::string* id_;
  ::google::protobuf::uint32 servertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbAllServerConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbPluginConfig : public ::google::protobuf::Message {
 public:
  pbPluginConfig();
  virtual ~pbPluginConfig();

  pbPluginConfig(const pbPluginConfig& from);

  inline pbPluginConfig& operator=(const pbPluginConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbPluginConfig& default_instance();

  void Swap(pbPluginConfig* other);

  // implements Message ----------------------------------------------

  pbPluginConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbPluginConfig& from);
  void MergeFrom(const pbPluginConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ServerType = 1;
  inline bool has_servertype() const;
  inline void clear_servertype();
  static const int kServerTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 servertype() const;
  inline void set_servertype(::google::protobuf::uint32 value);

  // repeated string FramePlugins = 2;
  inline int frameplugins_size() const;
  inline void clear_frameplugins();
  static const int kFramePluginsFieldNumber = 2;
  inline const ::std::string& frameplugins(int index) const;
  inline ::std::string* mutable_frameplugins(int index);
  inline void set_frameplugins(int index, const ::std::string& value);
  inline void set_frameplugins(int index, const char* value);
  inline void set_frameplugins(int index, const char* value, size_t size);
  inline ::std::string* add_frameplugins();
  inline void add_frameplugins(const ::std::string& value);
  inline void add_frameplugins(const char* value);
  inline void add_frameplugins(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& frameplugins() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_frameplugins();

  // repeated string ServerPlugins = 3;
  inline int serverplugins_size() const;
  inline void clear_serverplugins();
  static const int kServerPluginsFieldNumber = 3;
  inline const ::std::string& serverplugins(int index) const;
  inline ::std::string* mutable_serverplugins(int index);
  inline void set_serverplugins(int index, const ::std::string& value);
  inline void set_serverplugins(int index, const char* value);
  inline void set_serverplugins(int index, const char* value, size_t size);
  inline ::std::string* add_serverplugins();
  inline void add_serverplugins(const ::std::string& value);
  inline void add_serverplugins(const char* value);
  inline void add_serverplugins(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& serverplugins() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_serverplugins();

  // repeated string WorkPlugins = 4;
  inline int workplugins_size() const;
  inline void clear_workplugins();
  static const int kWorkPluginsFieldNumber = 4;
  inline const ::std::string& workplugins(int index) const;
  inline ::std::string* mutable_workplugins(int index);
  inline void set_workplugins(int index, const ::std::string& value);
  inline void set_workplugins(int index, const char* value);
  inline void set_workplugins(int index, const char* value, size_t size);
  inline ::std::string* add_workplugins();
  inline void add_workplugins(const ::std::string& value);
  inline void add_workplugins(const char* value);
  inline void add_workplugins(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& workplugins() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_workplugins();

  // repeated .proto_ff.pbAllServerConfig ServerList = 5;
  inline int serverlist_size() const;
  inline void clear_serverlist();
  static const int kServerListFieldNumber = 5;
  inline const ::proto_ff::pbAllServerConfig& serverlist(int index) const;
  inline ::proto_ff::pbAllServerConfig* mutable_serverlist(int index);
  inline ::proto_ff::pbAllServerConfig* add_serverlist();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::pbAllServerConfig >&
      serverlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::pbAllServerConfig >*
      mutable_serverlist();

  // @@protoc_insertion_point(class_scope:proto_ff.pbPluginConfig)
 private:
  inline void set_has_servertype();
  inline void clear_has_servertype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> frameplugins_;
  ::google::protobuf::RepeatedPtrField< ::std::string> serverplugins_;
  ::google::protobuf::RepeatedPtrField< ::std::string> workplugins_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::pbAllServerConfig > serverlist_;
  ::google::protobuf::uint32 servertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbPluginConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbTableConfig : public ::google::protobuf::Message {
 public:
  pbTableConfig();
  virtual ~pbTableConfig();

  pbTableConfig(const pbTableConfig& from);

  inline pbTableConfig& operator=(const pbTableConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbTableConfig& default_instance();

  void Swap(pbTableConfig* other);

  // implements Message ----------------------------------------------

  pbTableConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbTableConfig& from);
  void MergeFrom(const pbTableConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TableName = 1;
  inline bool has_tablename() const;
  inline void clear_tablename();
  static const int kTableNameFieldNumber = 1;
  inline const ::std::string& tablename() const;
  inline void set_tablename(const ::std::string& value);
  inline void set_tablename(const char* value);
  inline void set_tablename(const char* value, size_t size);
  inline ::std::string* mutable_tablename();
  inline ::std::string* release_tablename();
  inline void set_allocated_tablename(::std::string* tablename);

  // optional uint32 TableCount = 2;
  inline bool has_tablecount() const;
  inline void clear_tablecount();
  static const int kTableCountFieldNumber = 2;
  inline ::google::protobuf::uint32 tablecount() const;
  inline void set_tablecount(::google::protobuf::uint32 value);

  // optional bool Cache = 3;
  inline bool has_cache() const;
  inline void clear_cache();
  static const int kCacheFieldNumber = 3;
  inline bool cache() const;
  inline void set_cache(bool value);

  // @@protoc_insertion_point(class_scope:proto_ff.pbTableConfig)
 private:
  inline void set_has_tablename();
  inline void clear_has_tablename();
  inline void set_has_tablecount();
  inline void clear_has_tablecount();
  inline void set_has_cache();
  inline void clear_has_cache();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tablename_;
  ::google::protobuf::uint32 tablecount_;
  bool cache_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbTableConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbNFServerConfig : public ::google::protobuf::Message {
 public:
  pbNFServerConfig();
  virtual ~pbNFServerConfig();

  pbNFServerConfig(const pbNFServerConfig& from);

  inline pbNFServerConfig& operator=(const pbNFServerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbNFServerConfig& default_instance();

  void Swap(pbNFServerConfig* other);

  // implements Message ----------------------------------------------

  pbNFServerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbNFServerConfig& from);
  void MergeFrom(const pbNFServerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ServerId = 1;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIdFieldNumber = 1;
  inline const ::std::string& serverid() const;
  inline void set_serverid(const ::std::string& value);
  inline void set_serverid(const char* value);
  inline void set_serverid(const char* value, size_t size);
  inline ::std::string* mutable_serverid();
  inline ::std::string* release_serverid();
  inline void set_allocated_serverid(::std::string* serverid);

  // optional uint32 ServerType = 2;
  inline bool has_servertype() const;
  inline void clear_servertype();
  static const int kServerTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 servertype() const;
  inline void set_servertype(::google::protobuf::uint32 value);

  // optional string ServerName = 3;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServerNameFieldNumber = 3;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // optional uint32 BusId = 4;
  inline bool has_busid() const;
  inline void clear_busid();
  static const int kBusIdFieldNumber = 4;
  inline ::google::protobuf::uint32 busid() const;
  inline void set_busid(::google::protobuf::uint32 value);

  // optional uint32 BusLength = 5;
  inline bool has_buslength() const;
  inline void clear_buslength();
  static const int kBusLengthFieldNumber = 5;
  inline ::google::protobuf::uint32 buslength() const;
  inline void set_buslength(::google::protobuf::uint32 value);

  // optional string LinkMode = 7;
  inline bool has_linkmode() const;
  inline void clear_linkmode();
  static const int kLinkModeFieldNumber = 7;
  inline const ::std::string& linkmode() const;
  inline void set_linkmode(const ::std::string& value);
  inline void set_linkmode(const char* value);
  inline void set_linkmode(const char* value, size_t size);
  inline ::std::string* mutable_linkmode();
  inline ::std::string* release_linkmode();
  inline void set_allocated_linkmode(::std::string* linkmode);

  // optional string Url = 8;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 8;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional uint32 IdleSleepUS = 9;
  inline bool has_idlesleepus() const;
  inline void clear_idlesleepus();
  static const int kIdleSleepUSFieldNumber = 9;
  inline ::google::protobuf::uint32 idlesleepus() const;
  inline void set_idlesleepus(::google::protobuf::uint32 value);

  // optional uint32 HandleMsgNumPerFrame = 10;
  inline bool has_handlemsgnumperframe() const;
  inline void clear_handlemsgnumperframe();
  static const int kHandleMsgNumPerFrameFieldNumber = 10;
  inline ::google::protobuf::uint32 handlemsgnumperframe() const;
  inline void set_handlemsgnumperframe(::google::protobuf::uint32 value);

  // optional uint64 ServerOpenTime = 11;
  inline bool has_serveropentime() const;
  inline void clear_serveropentime();
  static const int kServerOpenTimeFieldNumber = 11;
  inline ::google::protobuf::uint64 serveropentime() const;
  inline void set_serveropentime(::google::protobuf::uint64 value);

  // optional string LoadProtoDs = 12;
  inline bool has_loadprotods() const;
  inline void clear_loadprotods();
  static const int kLoadProtoDsFieldNumber = 12;
  inline const ::std::string& loadprotods() const;
  inline void set_loadprotods(const ::std::string& value);
  inline void set_loadprotods(const char* value);
  inline void set_loadprotods(const char* value, size_t size);
  inline ::std::string* mutable_loadprotods();
  inline ::std::string* release_loadprotods();
  inline void set_allocated_loadprotods(::std::string* loadprotods);

  // optional bool CrossServer = 13;
  inline bool has_crossserver() const;
  inline void clear_crossserver();
  static const int kCrossServerFieldNumber = 13;
  inline bool crossserver() const;
  inline void set_crossserver(bool value);

  // optional string ServerIp = 20;
  inline bool has_serverip() const;
  inline void clear_serverip();
  static const int kServerIpFieldNumber = 20;
  inline const ::std::string& serverip() const;
  inline void set_serverip(const ::std::string& value);
  inline void set_serverip(const char* value);
  inline void set_serverip(const char* value, size_t size);
  inline ::std::string* mutable_serverip();
  inline ::std::string* release_serverip();
  inline void set_allocated_serverip(::std::string* serverip);

  // optional uint32 ServerPort = 21;
  inline bool has_serverport() const;
  inline void clear_serverport();
  static const int kServerPortFieldNumber = 21;
  inline ::google::protobuf::uint32 serverport() const;
  inline void set_serverport(::google::protobuf::uint32 value);

  // optional string ExternalServerIp = 22;
  inline bool has_externalserverip() const;
  inline void clear_externalserverip();
  static const int kExternalServerIpFieldNumber = 22;
  inline const ::std::string& externalserverip() const;
  inline void set_externalserverip(const ::std::string& value);
  inline void set_externalserverip(const char* value);
  inline void set_externalserverip(const char* value, size_t size);
  inline ::std::string* mutable_externalserverip();
  inline ::std::string* release_externalserverip();
  inline void set_allocated_externalserverip(::std::string* externalserverip);

  // optional uint32 ExternalServerPort = 23;
  inline bool has_externalserverport() const;
  inline void clear_externalserverport();
  static const int kExternalServerPortFieldNumber = 23;
  inline ::google::protobuf::uint32 externalserverport() const;
  inline void set_externalserverport(::google::protobuf::uint32 value);

  // optional uint32 HttpPort = 24;
  inline bool has_httpport() const;
  inline void clear_httpport();
  static const int kHttpPortFieldNumber = 24;
  inline ::google::protobuf::uint32 httpport() const;
  inline void set_httpport(::google::protobuf::uint32 value);

  // optional uint32 MaxConnectNum = 25;
  inline bool has_maxconnectnum() const;
  inline void clear_maxconnectnum();
  static const int kMaxConnectNumFieldNumber = 25;
  inline ::google::protobuf::uint32 maxconnectnum() const;
  inline void set_maxconnectnum(::google::protobuf::uint32 value);

  // optional uint32 WorkThreadNum = 26;
  inline bool has_workthreadnum() const;
  inline void clear_workthreadnum();
  static const int kWorkThreadNumFieldNumber = 26;
  inline ::google::protobuf::uint32 workthreadnum() const;
  inline void set_workthreadnum(::google::protobuf::uint32 value);

  // optional uint32 NetThreadNum = 27;
  inline bool has_netthreadnum() const;
  inline void clear_netthreadnum();
  static const int kNetThreadNumFieldNumber = 27;
  inline ::google::protobuf::uint32 netthreadnum() const;
  inline void set_netthreadnum(::google::protobuf::uint32 value);

  // optional bool Security = 28;
  inline bool has_security() const;
  inline void clear_security();
  static const int kSecurityFieldNumber = 28;
  inline bool security() const;
  inline void set_security(bool value);

  // optional bool WebSocket = 29;
  inline bool has_websocket() const;
  inline void clear_websocket();
  static const int kWebSocketFieldNumber = 29;
  inline bool websocket() const;
  inline void set_websocket(bool value);

  // optional uint32 ParseType = 30;
  inline bool has_parsetype() const;
  inline void clear_parsetype();
  static const int kParseTypeFieldNumber = 30;
  inline ::google::protobuf::uint32 parsetype() const;
  inline void set_parsetype(::google::protobuf::uint32 value);

  // optional .proto_ff.pbRouteConfig RouteConfig = 50;
  inline bool has_routeconfig() const;
  inline void clear_routeconfig();
  static const int kRouteConfigFieldNumber = 50;
  inline const ::proto_ff::pbRouteConfig& routeconfig() const;
  inline ::proto_ff::pbRouteConfig* mutable_routeconfig();
  inline ::proto_ff::pbRouteConfig* release_routeconfig();
  inline void set_allocated_routeconfig(::proto_ff::pbRouteConfig* routeconfig);

  // optional .proto_ff.pbMysqlConfig MysqlConfig = 70;
  inline bool has_mysqlconfig() const;
  inline void clear_mysqlconfig();
  static const int kMysqlConfigFieldNumber = 70;
  inline const ::proto_ff::pbMysqlConfig& mysqlconfig() const;
  inline ::proto_ff::pbMysqlConfig* mutable_mysqlconfig();
  inline ::proto_ff::pbMysqlConfig* release_mysqlconfig();
  inline void set_allocated_mysqlconfig(::proto_ff::pbMysqlConfig* mysqlconfig);

  // optional string DefaultDBName = 75;
  inline bool has_defaultdbname() const;
  inline void clear_defaultdbname();
  static const int kDefaultDBNameFieldNumber = 75;
  inline const ::std::string& defaultdbname() const;
  inline void set_defaultdbname(const ::std::string& value);
  inline void set_defaultdbname(const char* value);
  inline void set_defaultdbname(const char* value, size_t size);
  inline ::std::string* mutable_defaultdbname();
  inline ::std::string* release_defaultdbname();
  inline void set_allocated_defaultdbname(::std::string* defaultdbname);

  // optional string CrossDBName = 76;
  inline bool has_crossdbname() const;
  inline void clear_crossdbname();
  static const int kCrossDBNameFieldNumber = 76;
  inline const ::std::string& crossdbname() const;
  inline void set_crossdbname(const ::std::string& value);
  inline void set_crossdbname(const char* value);
  inline void set_crossdbname(const char* value, size_t size);
  inline ::std::string* mutable_crossdbname();
  inline ::std::string* release_crossdbname();
  inline void set_allocated_crossdbname(::std::string* crossdbname);

  // optional .proto_ff.pbRedisConfig RedisConfig = 80;
  inline bool has_redisconfig() const;
  inline void clear_redisconfig();
  static const int kRedisConfigFieldNumber = 80;
  inline const ::proto_ff::pbRedisConfig& redisconfig() const;
  inline ::proto_ff::pbRedisConfig* mutable_redisconfig();
  inline ::proto_ff::pbRedisConfig* release_redisconfig();
  inline void set_allocated_redisconfig(::proto_ff::pbRedisConfig* redisconfig);

  // optional string sendEmail = 91;
  inline bool has_sendemail() const;
  inline void clear_sendemail();
  static const int kSendEmailFieldNumber = 91;
  inline const ::std::string& sendemail() const;
  inline void set_sendemail(const ::std::string& value);
  inline void set_sendemail(const char* value);
  inline void set_sendemail(const char* value, size_t size);
  inline ::std::string* mutable_sendemail();
  inline ::std::string* release_sendemail();
  inline void set_allocated_sendemail(::std::string* sendemail);

  // optional string sendEmailPass = 92;
  inline bool has_sendemailpass() const;
  inline void clear_sendemailpass();
  static const int kSendEmailPassFieldNumber = 92;
  inline const ::std::string& sendemailpass() const;
  inline void set_sendemailpass(const ::std::string& value);
  inline void set_sendemailpass(const char* value);
  inline void set_sendemailpass(const char* value, size_t size);
  inline ::std::string* mutable_sendemailpass();
  inline ::std::string* release_sendemailpass();
  inline void set_allocated_sendemailpass(::std::string* sendemailpass);

  // optional string sendEmailUrl = 93;
  inline bool has_sendemailurl() const;
  inline void clear_sendemailurl();
  static const int kSendEmailUrlFieldNumber = 93;
  inline const ::std::string& sendemailurl() const;
  inline void set_sendemailurl(const ::std::string& value);
  inline void set_sendemailurl(const char* value);
  inline void set_sendemailurl(const char* value, size_t size);
  inline ::std::string* mutable_sendemailurl();
  inline ::std::string* release_sendemailurl();
  inline void set_allocated_sendemailurl(::std::string* sendemailurl);

  // optional string sendEmailPort = 94;
  inline bool has_sendemailport() const;
  inline void clear_sendemailport();
  static const int kSendEmailPortFieldNumber = 94;
  inline const ::std::string& sendemailport() const;
  inline void set_sendemailport(const ::std::string& value);
  inline void set_sendemailport(const char* value);
  inline void set_sendemailport(const char* value, size_t size);
  inline ::std::string* mutable_sendemailport();
  inline ::std::string* release_sendemailport();
  inline void set_allocated_sendemailport(::std::string* sendemailport);

  // optional string recvEmail = 95;
  inline bool has_recvemail() const;
  inline void clear_recvemail();
  static const int kRecvEmailFieldNumber = 95;
  inline const ::std::string& recvemail() const;
  inline void set_recvemail(const ::std::string& value);
  inline void set_recvemail(const char* value);
  inline void set_recvemail(const char* value, size_t size);
  inline ::std::string* mutable_recvemail();
  inline ::std::string* release_recvemail();
  inline void set_allocated_recvemail(::std::string* recvemail);

  // optional string wxWorkdRobot = 96;
  inline bool has_wxworkdrobot() const;
  inline void clear_wxworkdrobot();
  static const int kWxWorkdRobotFieldNumber = 96;
  inline const ::std::string& wxworkdrobot() const;
  inline void set_wxworkdrobot(const ::std::string& value);
  inline void set_wxworkdrobot(const char* value);
  inline void set_wxworkdrobot(const char* value, size_t size);
  inline ::std::string* mutable_wxworkdrobot();
  inline ::std::string* release_wxworkdrobot();
  inline void set_allocated_wxworkdrobot(::std::string* wxworkdrobot);

  // optional uint32 MaxOnlinePlayerNum = 100;
  inline bool has_maxonlineplayernum() const;
  inline void clear_maxonlineplayernum();
  static const int kMaxOnlinePlayerNumFieldNumber = 100;
  inline ::google::protobuf::uint32 maxonlineplayernum() const;
  inline void set_maxonlineplayernum(::google::protobuf::uint32 value);

  // optional uint32 HeartBeatTimeout = 101;
  inline bool has_heartbeattimeout() const;
  inline void clear_heartbeattimeout();
  static const int kHeartBeatTimeoutFieldNumber = 101;
  inline ::google::protobuf::uint32 heartbeattimeout() const;
  inline void set_heartbeattimeout(::google::protobuf::uint32 value);

  // optional uint32 ClientKeepAliveTimeout = 102;
  inline bool has_clientkeepalivetimeout() const;
  inline void clear_clientkeepalivetimeout();
  static const int kClientKeepAliveTimeoutFieldNumber = 102;
  inline ::google::protobuf::uint32 clientkeepalivetimeout() const;
  inline void set_clientkeepalivetimeout(::google::protobuf::uint32 value);

  // optional uint32 ClientVersion = 103;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 103;
  inline ::google::protobuf::uint32 clientversion() const;
  inline void set_clientversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.pbNFServerConfig)
 private:
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_servertype();
  inline void clear_has_servertype();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_busid();
  inline void clear_has_busid();
  inline void set_has_buslength();
  inline void clear_has_buslength();
  inline void set_has_linkmode();
  inline void clear_has_linkmode();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_idlesleepus();
  inline void clear_has_idlesleepus();
  inline void set_has_handlemsgnumperframe();
  inline void clear_has_handlemsgnumperframe();
  inline void set_has_serveropentime();
  inline void clear_has_serveropentime();
  inline void set_has_loadprotods();
  inline void clear_has_loadprotods();
  inline void set_has_crossserver();
  inline void clear_has_crossserver();
  inline void set_has_serverip();
  inline void clear_has_serverip();
  inline void set_has_serverport();
  inline void clear_has_serverport();
  inline void set_has_externalserverip();
  inline void clear_has_externalserverip();
  inline void set_has_externalserverport();
  inline void clear_has_externalserverport();
  inline void set_has_httpport();
  inline void clear_has_httpport();
  inline void set_has_maxconnectnum();
  inline void clear_has_maxconnectnum();
  inline void set_has_workthreadnum();
  inline void clear_has_workthreadnum();
  inline void set_has_netthreadnum();
  inline void clear_has_netthreadnum();
  inline void set_has_security();
  inline void clear_has_security();
  inline void set_has_websocket();
  inline void clear_has_websocket();
  inline void set_has_parsetype();
  inline void clear_has_parsetype();
  inline void set_has_routeconfig();
  inline void clear_has_routeconfig();
  inline void set_has_mysqlconfig();
  inline void clear_has_mysqlconfig();
  inline void set_has_defaultdbname();
  inline void clear_has_defaultdbname();
  inline void set_has_crossdbname();
  inline void clear_has_crossdbname();
  inline void set_has_redisconfig();
  inline void clear_has_redisconfig();
  inline void set_has_sendemail();
  inline void clear_has_sendemail();
  inline void set_has_sendemailpass();
  inline void clear_has_sendemailpass();
  inline void set_has_sendemailurl();
  inline void clear_has_sendemailurl();
  inline void set_has_sendemailport();
  inline void clear_has_sendemailport();
  inline void set_has_recvemail();
  inline void clear_has_recvemail();
  inline void set_has_wxworkdrobot();
  inline void clear_has_wxworkdrobot();
  inline void set_has_maxonlineplayernum();
  inline void clear_has_maxonlineplayernum();
  inline void set_has_heartbeattimeout();
  inline void clear_has_heartbeattimeout();
  inline void set_has_clientkeepalivetimeout();
  inline void clear_has_clientkeepalivetimeout();
  inline void set_has_clientversion();
  inline void clear_has_clientversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* serverid_;
  ::std::string* servername_;
  ::google::protobuf::uint32 servertype_;
  ::google::protobuf::uint32 busid_;
  ::std::string* linkmode_;
  ::google::protobuf::uint32 buslength_;
  ::google::protobuf::uint32 idlesleepus_;
  ::std::string* url_;
  ::google::protobuf::uint64 serveropentime_;
  ::std::string* loadprotods_;
  ::google::protobuf::uint32 handlemsgnumperframe_;
  ::google::protobuf::uint32 serverport_;
  ::std::string* serverip_;
  ::std::string* externalserverip_;
  ::google::protobuf::uint32 externalserverport_;
  ::google::protobuf::uint32 httpport_;
  ::google::protobuf::uint32 maxconnectnum_;
  bool crossserver_;
  bool security_;
  bool websocket_;
  ::google::protobuf::uint32 workthreadnum_;
  ::google::protobuf::uint32 netthreadnum_;
  ::proto_ff::pbRouteConfig* routeconfig_;
  ::proto_ff::pbMysqlConfig* mysqlconfig_;
  ::std::string* defaultdbname_;
  ::std::string* crossdbname_;
  ::proto_ff::pbRedisConfig* redisconfig_;
  ::std::string* sendemail_;
  ::google::protobuf::uint32 parsetype_;
  ::google::protobuf::uint32 maxonlineplayernum_;
  ::std::string* sendemailpass_;
  ::std::string* sendemailurl_;
  ::std::string* sendemailport_;
  ::std::string* recvemail_;
  ::std::string* wxworkdrobot_;
  ::google::protobuf::uint32 heartbeattimeout_;
  ::google::protobuf::uint32 clientkeepalivetimeout_;
  ::google::protobuf::uint32 clientversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(38 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbNFServerConfig* default_instance_;
};
// -------------------------------------------------------------------

class wxWorkRobotText : public ::google::protobuf::Message {
 public:
  wxWorkRobotText();
  virtual ~wxWorkRobotText();

  wxWorkRobotText(const wxWorkRobotText& from);

  inline wxWorkRobotText& operator=(const wxWorkRobotText& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const wxWorkRobotText& default_instance();

  void Swap(wxWorkRobotText* other);

  // implements Message ----------------------------------------------

  wxWorkRobotText* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const wxWorkRobotText& from);
  void MergeFrom(const wxWorkRobotText& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // repeated string mentioned_list = 2;
  inline int mentioned_list_size() const;
  inline void clear_mentioned_list();
  static const int kMentionedListFieldNumber = 2;
  inline const ::std::string& mentioned_list(int index) const;
  inline ::std::string* mutable_mentioned_list(int index);
  inline void set_mentioned_list(int index, const ::std::string& value);
  inline void set_mentioned_list(int index, const char* value);
  inline void set_mentioned_list(int index, const char* value, size_t size);
  inline ::std::string* add_mentioned_list();
  inline void add_mentioned_list(const ::std::string& value);
  inline void add_mentioned_list(const char* value);
  inline void add_mentioned_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mentioned_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mentioned_list();

  // repeated string mentioned_mobile_list = 3;
  inline int mentioned_mobile_list_size() const;
  inline void clear_mentioned_mobile_list();
  static const int kMentionedMobileListFieldNumber = 3;
  inline const ::std::string& mentioned_mobile_list(int index) const;
  inline ::std::string* mutable_mentioned_mobile_list(int index);
  inline void set_mentioned_mobile_list(int index, const ::std::string& value);
  inline void set_mentioned_mobile_list(int index, const char* value);
  inline void set_mentioned_mobile_list(int index, const char* value, size_t size);
  inline ::std::string* add_mentioned_mobile_list();
  inline void add_mentioned_mobile_list(const ::std::string& value);
  inline void add_mentioned_mobile_list(const char* value);
  inline void add_mentioned_mobile_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mentioned_mobile_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mentioned_mobile_list();

  // @@protoc_insertion_point(class_scope:proto_ff.wxWorkRobotText)
 private:
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mentioned_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mentioned_mobile_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static wxWorkRobotText* default_instance_;
};
// -------------------------------------------------------------------

class wxWorkRobotHttpPost : public ::google::protobuf::Message {
 public:
  wxWorkRobotHttpPost();
  virtual ~wxWorkRobotHttpPost();

  wxWorkRobotHttpPost(const wxWorkRobotHttpPost& from);

  inline wxWorkRobotHttpPost& operator=(const wxWorkRobotHttpPost& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const wxWorkRobotHttpPost& default_instance();

  void Swap(wxWorkRobotHttpPost* other);

  // implements Message ----------------------------------------------

  wxWorkRobotHttpPost* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const wxWorkRobotHttpPost& from);
  void MergeFrom(const wxWorkRobotHttpPost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgtype = 1;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 1;
  inline const ::std::string& msgtype() const;
  inline void set_msgtype(const ::std::string& value);
  inline void set_msgtype(const char* value);
  inline void set_msgtype(const char* value, size_t size);
  inline ::std::string* mutable_msgtype();
  inline ::std::string* release_msgtype();
  inline void set_allocated_msgtype(::std::string* msgtype);

  // optional .proto_ff.wxWorkRobotText text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::proto_ff::wxWorkRobotText& text() const;
  inline ::proto_ff::wxWorkRobotText* mutable_text();
  inline ::proto_ff::wxWorkRobotText* release_text();
  inline void set_allocated_text(::proto_ff::wxWorkRobotText* text);

  // @@protoc_insertion_point(class_scope:proto_ff.wxWorkRobotHttpPost)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgtype_;
  ::proto_ff::wxWorkRobotText* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static wxWorkRobotHttpPost* default_instance_;
};
// ===================================================================


// ===================================================================

// tbServerMgr

// optional uint64 id = 1;
inline bool tbServerMgr::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tbServerMgr::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tbServerMgr::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tbServerMgr::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 tbServerMgr::id() const {
  return id_;
}
inline void tbServerMgr::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string contract = 2;
inline bool tbServerMgr::has_contract() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tbServerMgr::set_has_contract() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tbServerMgr::clear_has_contract() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tbServerMgr::clear_contract() {
  if (contract_ != &::google::protobuf::internal::kEmptyString) {
    contract_->clear();
  }
  clear_has_contract();
}
inline const ::std::string& tbServerMgr::contract() const {
  return *contract_;
}
inline void tbServerMgr::set_contract(const ::std::string& value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::kEmptyString) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
}
inline void tbServerMgr::set_contract(const char* value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::kEmptyString) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
}
inline void tbServerMgr::set_contract(const char* value, size_t size) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::kEmptyString) {
    contract_ = new ::std::string;
  }
  contract_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tbServerMgr::mutable_contract() {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::kEmptyString) {
    contract_ = new ::std::string;
  }
  return contract_;
}
inline ::std::string* tbServerMgr::release_contract() {
  clear_has_contract();
  if (contract_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contract_;
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tbServerMgr::set_allocated_contract(::std::string* contract) {
  if (contract_ != &::google::protobuf::internal::kEmptyString) {
    delete contract_;
  }
  if (contract) {
    set_has_contract();
    contract_ = contract;
  } else {
    clear_has_contract();
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string machine_addr = 3;
inline bool tbServerMgr::has_machine_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tbServerMgr::set_has_machine_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tbServerMgr::clear_has_machine_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tbServerMgr::clear_machine_addr() {
  if (machine_addr_ != &::google::protobuf::internal::kEmptyString) {
    machine_addr_->clear();
  }
  clear_has_machine_addr();
}
inline const ::std::string& tbServerMgr::machine_addr() const {
  return *machine_addr_;
}
inline void tbServerMgr::set_machine_addr(const ::std::string& value) {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  machine_addr_->assign(value);
}
inline void tbServerMgr::set_machine_addr(const char* value) {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  machine_addr_->assign(value);
}
inline void tbServerMgr::set_machine_addr(const char* value, size_t size) {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  machine_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tbServerMgr::mutable_machine_addr() {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  return machine_addr_;
}
inline ::std::string* tbServerMgr::release_machine_addr() {
  clear_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_addr_;
    machine_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tbServerMgr::set_allocated_machine_addr(::std::string* machine_addr) {
  if (machine_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_addr_;
  }
  if (machine_addr) {
    set_has_machine_addr();
    machine_addr_ = machine_addr;
  } else {
    clear_has_machine_addr();
    machine_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 4;
inline bool tbServerMgr::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void tbServerMgr::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void tbServerMgr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void tbServerMgr::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& tbServerMgr::ip() const {
  return *ip_;
}
inline void tbServerMgr::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void tbServerMgr::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void tbServerMgr::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tbServerMgr::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* tbServerMgr::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tbServerMgr::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bus_name = 5;
inline bool tbServerMgr::has_bus_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void tbServerMgr::set_has_bus_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void tbServerMgr::clear_has_bus_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void tbServerMgr::clear_bus_name() {
  if (bus_name_ != &::google::protobuf::internal::kEmptyString) {
    bus_name_->clear();
  }
  clear_has_bus_name();
}
inline const ::std::string& tbServerMgr::bus_name() const {
  return *bus_name_;
}
inline void tbServerMgr::set_bus_name(const ::std::string& value) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(value);
}
inline void tbServerMgr::set_bus_name(const char* value) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(value);
}
inline void tbServerMgr::set_bus_name(const char* value, size_t size) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tbServerMgr::mutable_bus_name() {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  return bus_name_;
}
inline ::std::string* tbServerMgr::release_bus_name() {
  clear_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bus_name_;
    bus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tbServerMgr::set_allocated_bus_name(::std::string* bus_name) {
  if (bus_name_ != &::google::protobuf::internal::kEmptyString) {
    delete bus_name_;
  }
  if (bus_name) {
    set_has_bus_name();
    bus_name_ = bus_name;
  } else {
    clear_has_bus_name();
    bus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string server_desc = 6;
inline bool tbServerMgr::has_server_desc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void tbServerMgr::set_has_server_desc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void tbServerMgr::clear_has_server_desc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void tbServerMgr::clear_server_desc() {
  if (server_desc_ != &::google::protobuf::internal::kEmptyString) {
    server_desc_->clear();
  }
  clear_has_server_desc();
}
inline const ::std::string& tbServerMgr::server_desc() const {
  return *server_desc_;
}
inline void tbServerMgr::set_server_desc(const ::std::string& value) {
  set_has_server_desc();
  if (server_desc_ == &::google::protobuf::internal::kEmptyString) {
    server_desc_ = new ::std::string;
  }
  server_desc_->assign(value);
}
inline void tbServerMgr::set_server_desc(const char* value) {
  set_has_server_desc();
  if (server_desc_ == &::google::protobuf::internal::kEmptyString) {
    server_desc_ = new ::std::string;
  }
  server_desc_->assign(value);
}
inline void tbServerMgr::set_server_desc(const char* value, size_t size) {
  set_has_server_desc();
  if (server_desc_ == &::google::protobuf::internal::kEmptyString) {
    server_desc_ = new ::std::string;
  }
  server_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tbServerMgr::mutable_server_desc() {
  set_has_server_desc();
  if (server_desc_ == &::google::protobuf::internal::kEmptyString) {
    server_desc_ = new ::std::string;
  }
  return server_desc_;
}
inline ::std::string* tbServerMgr::release_server_desc() {
  clear_has_server_desc();
  if (server_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_desc_;
    server_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tbServerMgr::set_allocated_server_desc(::std::string* server_desc) {
  if (server_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete server_desc_;
  }
  if (server_desc) {
    set_has_server_desc();
    server_desc_ = server_desc;
  } else {
    clear_has_server_desc();
    server_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 cur_count = 7;
inline bool tbServerMgr::has_cur_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void tbServerMgr::set_has_cur_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void tbServerMgr::clear_has_cur_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void tbServerMgr::clear_cur_count() {
  cur_count_ = 0u;
  clear_has_cur_count();
}
inline ::google::protobuf::uint32 tbServerMgr::cur_count() const {
  return cur_count_;
}
inline void tbServerMgr::set_cur_count(::google::protobuf::uint32 value) {
  set_has_cur_count();
  cur_count_ = value;
}

// optional uint64 last_login_time = 8;
inline bool tbServerMgr::has_last_login_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void tbServerMgr::set_has_last_login_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void tbServerMgr::clear_has_last_login_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void tbServerMgr::clear_last_login_time() {
  last_login_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_login_time();
}
inline ::google::protobuf::uint64 tbServerMgr::last_login_time() const {
  return last_login_time_;
}
inline void tbServerMgr::set_last_login_time(::google::protobuf::uint64 value) {
  set_has_last_login_time();
  last_login_time_ = value;
}

// optional uint64 last_logout_time = 9;
inline bool tbServerMgr::has_last_logout_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void tbServerMgr::set_has_last_logout_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void tbServerMgr::clear_has_last_logout_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void tbServerMgr::clear_last_logout_time() {
  last_logout_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_logout_time();
}
inline ::google::protobuf::uint64 tbServerMgr::last_logout_time() const {
  return last_logout_time_;
}
inline void tbServerMgr::set_last_logout_time(::google::protobuf::uint64 value) {
  set_has_last_logout_time();
  last_logout_time_ = value;
}

// optional uint64 create_time = 10;
inline bool tbServerMgr::has_create_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void tbServerMgr::set_has_create_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void tbServerMgr::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void tbServerMgr::clear_create_time() {
  create_time_ = GOOGLE_ULONGLONG(0);
  clear_has_create_time();
}
inline ::google::protobuf::uint64 tbServerMgr::create_time() const {
  return create_time_;
}
inline void tbServerMgr::set_create_time(::google::protobuf::uint64 value) {
  set_has_create_time();
  create_time_ = value;
}

// -------------------------------------------------------------------

// pbMysqlConfig

// optional string MysqlIp = 1;
inline bool pbMysqlConfig::has_mysqlip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbMysqlConfig::set_has_mysqlip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbMysqlConfig::clear_has_mysqlip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbMysqlConfig::clear_mysqlip() {
  if (mysqlip_ != &::google::protobuf::internal::kEmptyString) {
    mysqlip_->clear();
  }
  clear_has_mysqlip();
}
inline const ::std::string& pbMysqlConfig::mysqlip() const {
  return *mysqlip_;
}
inline void pbMysqlConfig::set_mysqlip(const ::std::string& value) {
  set_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    mysqlip_ = new ::std::string;
  }
  mysqlip_->assign(value);
}
inline void pbMysqlConfig::set_mysqlip(const char* value) {
  set_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    mysqlip_ = new ::std::string;
  }
  mysqlip_->assign(value);
}
inline void pbMysqlConfig::set_mysqlip(const char* value, size_t size) {
  set_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    mysqlip_ = new ::std::string;
  }
  mysqlip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbMysqlConfig::mutable_mysqlip() {
  set_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    mysqlip_ = new ::std::string;
  }
  return mysqlip_;
}
inline ::std::string* pbMysqlConfig::release_mysqlip() {
  clear_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqlip_;
    mysqlip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbMysqlConfig::set_allocated_mysqlip(::std::string* mysqlip) {
  if (mysqlip_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqlip_;
  }
  if (mysqlip) {
    set_has_mysqlip();
    mysqlip_ = mysqlip;
  } else {
    clear_has_mysqlip();
    mysqlip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 MysqlPort = 2;
inline bool pbMysqlConfig::has_mysqlport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbMysqlConfig::set_has_mysqlport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbMysqlConfig::clear_has_mysqlport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbMysqlConfig::clear_mysqlport() {
  mysqlport_ = 0u;
  clear_has_mysqlport();
}
inline ::google::protobuf::uint32 pbMysqlConfig::mysqlport() const {
  return mysqlport_;
}
inline void pbMysqlConfig::set_mysqlport(::google::protobuf::uint32 value) {
  set_has_mysqlport();
  mysqlport_ = value;
}

// optional string MysqlDbName = 3;
inline bool pbMysqlConfig::has_mysqldbname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbMysqlConfig::set_has_mysqldbname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbMysqlConfig::clear_has_mysqldbname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbMysqlConfig::clear_mysqldbname() {
  if (mysqldbname_ != &::google::protobuf::internal::kEmptyString) {
    mysqldbname_->clear();
  }
  clear_has_mysqldbname();
}
inline const ::std::string& pbMysqlConfig::mysqldbname() const {
  return *mysqldbname_;
}
inline void pbMysqlConfig::set_mysqldbname(const ::std::string& value) {
  set_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    mysqldbname_ = new ::std::string;
  }
  mysqldbname_->assign(value);
}
inline void pbMysqlConfig::set_mysqldbname(const char* value) {
  set_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    mysqldbname_ = new ::std::string;
  }
  mysqldbname_->assign(value);
}
inline void pbMysqlConfig::set_mysqldbname(const char* value, size_t size) {
  set_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    mysqldbname_ = new ::std::string;
  }
  mysqldbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbMysqlConfig::mutable_mysqldbname() {
  set_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    mysqldbname_ = new ::std::string;
  }
  return mysqldbname_;
}
inline ::std::string* pbMysqlConfig::release_mysqldbname() {
  clear_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqldbname_;
    mysqldbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbMysqlConfig::set_allocated_mysqldbname(::std::string* mysqldbname) {
  if (mysqldbname_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqldbname_;
  }
  if (mysqldbname) {
    set_has_mysqldbname();
    mysqldbname_ = mysqldbname;
  } else {
    clear_has_mysqldbname();
    mysqldbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MysqlUser = 4;
inline bool pbMysqlConfig::has_mysqluser() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbMysqlConfig::set_has_mysqluser() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbMysqlConfig::clear_has_mysqluser() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbMysqlConfig::clear_mysqluser() {
  if (mysqluser_ != &::google::protobuf::internal::kEmptyString) {
    mysqluser_->clear();
  }
  clear_has_mysqluser();
}
inline const ::std::string& pbMysqlConfig::mysqluser() const {
  return *mysqluser_;
}
inline void pbMysqlConfig::set_mysqluser(const ::std::string& value) {
  set_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    mysqluser_ = new ::std::string;
  }
  mysqluser_->assign(value);
}
inline void pbMysqlConfig::set_mysqluser(const char* value) {
  set_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    mysqluser_ = new ::std::string;
  }
  mysqluser_->assign(value);
}
inline void pbMysqlConfig::set_mysqluser(const char* value, size_t size) {
  set_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    mysqluser_ = new ::std::string;
  }
  mysqluser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbMysqlConfig::mutable_mysqluser() {
  set_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    mysqluser_ = new ::std::string;
  }
  return mysqluser_;
}
inline ::std::string* pbMysqlConfig::release_mysqluser() {
  clear_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqluser_;
    mysqluser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbMysqlConfig::set_allocated_mysqluser(::std::string* mysqluser) {
  if (mysqluser_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqluser_;
  }
  if (mysqluser) {
    set_has_mysqluser();
    mysqluser_ = mysqluser;
  } else {
    clear_has_mysqluser();
    mysqluser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MysqlPassword = 5;
inline bool pbMysqlConfig::has_mysqlpassword() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbMysqlConfig::set_has_mysqlpassword() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbMysqlConfig::clear_has_mysqlpassword() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbMysqlConfig::clear_mysqlpassword() {
  if (mysqlpassword_ != &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_->clear();
  }
  clear_has_mysqlpassword();
}
inline const ::std::string& pbMysqlConfig::mysqlpassword() const {
  return *mysqlpassword_;
}
inline void pbMysqlConfig::set_mysqlpassword(const ::std::string& value) {
  set_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_ = new ::std::string;
  }
  mysqlpassword_->assign(value);
}
inline void pbMysqlConfig::set_mysqlpassword(const char* value) {
  set_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_ = new ::std::string;
  }
  mysqlpassword_->assign(value);
}
inline void pbMysqlConfig::set_mysqlpassword(const char* value, size_t size) {
  set_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_ = new ::std::string;
  }
  mysqlpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbMysqlConfig::mutable_mysqlpassword() {
  set_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_ = new ::std::string;
  }
  return mysqlpassword_;
}
inline ::std::string* pbMysqlConfig::release_mysqlpassword() {
  clear_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqlpassword_;
    mysqlpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbMysqlConfig::set_allocated_mysqlpassword(::std::string* mysqlpassword) {
  if (mysqlpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqlpassword_;
  }
  if (mysqlpassword) {
    set_has_mysqlpassword();
    mysqlpassword_ = mysqlpassword;
  } else {
    clear_has_mysqlpassword();
    mysqlpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto_ff.pbTableConfig TBConfList = 6;
inline int pbMysqlConfig::tbconflist_size() const {
  return tbconflist_.size();
}
inline void pbMysqlConfig::clear_tbconflist() {
  tbconflist_.Clear();
}
inline const ::proto_ff::pbTableConfig& pbMysqlConfig::tbconflist(int index) const {
  return tbconflist_.Get(index);
}
inline ::proto_ff::pbTableConfig* pbMysqlConfig::mutable_tbconflist(int index) {
  return tbconflist_.Mutable(index);
}
inline ::proto_ff::pbTableConfig* pbMysqlConfig::add_tbconflist() {
  return tbconflist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig >&
pbMysqlConfig::tbconflist() const {
  return tbconflist_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig >*
pbMysqlConfig::mutable_tbconflist() {
  return &tbconflist_;
}

// -------------------------------------------------------------------

// pbRedisConfig

// optional string RedisIp = 1;
inline bool pbRedisConfig::has_redisip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbRedisConfig::set_has_redisip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbRedisConfig::clear_has_redisip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbRedisConfig::clear_redisip() {
  if (redisip_ != &::google::protobuf::internal::kEmptyString) {
    redisip_->clear();
  }
  clear_has_redisip();
}
inline const ::std::string& pbRedisConfig::redisip() const {
  return *redisip_;
}
inline void pbRedisConfig::set_redisip(const ::std::string& value) {
  set_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    redisip_ = new ::std::string;
  }
  redisip_->assign(value);
}
inline void pbRedisConfig::set_redisip(const char* value) {
  set_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    redisip_ = new ::std::string;
  }
  redisip_->assign(value);
}
inline void pbRedisConfig::set_redisip(const char* value, size_t size) {
  set_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    redisip_ = new ::std::string;
  }
  redisip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbRedisConfig::mutable_redisip() {
  set_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    redisip_ = new ::std::string;
  }
  return redisip_;
}
inline ::std::string* pbRedisConfig::release_redisip() {
  clear_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = redisip_;
    redisip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbRedisConfig::set_allocated_redisip(::std::string* redisip) {
  if (redisip_ != &::google::protobuf::internal::kEmptyString) {
    delete redisip_;
  }
  if (redisip) {
    set_has_redisip();
    redisip_ = redisip;
  } else {
    clear_has_redisip();
    redisip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 RedisPort = 2;
inline bool pbRedisConfig::has_redisport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbRedisConfig::set_has_redisport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbRedisConfig::clear_has_redisport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbRedisConfig::clear_redisport() {
  redisport_ = 0u;
  clear_has_redisport();
}
inline ::google::protobuf::uint32 pbRedisConfig::redisport() const {
  return redisport_;
}
inline void pbRedisConfig::set_redisport(::google::protobuf::uint32 value) {
  set_has_redisport();
  redisport_ = value;
}

// optional string RedisPass = 3;
inline bool pbRedisConfig::has_redispass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbRedisConfig::set_has_redispass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbRedisConfig::clear_has_redispass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbRedisConfig::clear_redispass() {
  if (redispass_ != &::google::protobuf::internal::kEmptyString) {
    redispass_->clear();
  }
  clear_has_redispass();
}
inline const ::std::string& pbRedisConfig::redispass() const {
  return *redispass_;
}
inline void pbRedisConfig::set_redispass(const ::std::string& value) {
  set_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    redispass_ = new ::std::string;
  }
  redispass_->assign(value);
}
inline void pbRedisConfig::set_redispass(const char* value) {
  set_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    redispass_ = new ::std::string;
  }
  redispass_->assign(value);
}
inline void pbRedisConfig::set_redispass(const char* value, size_t size) {
  set_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    redispass_ = new ::std::string;
  }
  redispass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbRedisConfig::mutable_redispass() {
  set_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    redispass_ = new ::std::string;
  }
  return redispass_;
}
inline ::std::string* pbRedisConfig::release_redispass() {
  clear_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = redispass_;
    redispass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbRedisConfig::set_allocated_redispass(::std::string* redispass) {
  if (redispass_ != &::google::protobuf::internal::kEmptyString) {
    delete redispass_;
  }
  if (redispass) {
    set_has_redispass();
    redispass_ = redispass;
  } else {
    clear_has_redispass();
    redispass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// pbRouteConfig

// optional string MasterIp = 1;
inline bool pbRouteConfig::has_masterip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbRouteConfig::set_has_masterip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbRouteConfig::clear_has_masterip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbRouteConfig::clear_masterip() {
  if (masterip_ != &::google::protobuf::internal::kEmptyString) {
    masterip_->clear();
  }
  clear_has_masterip();
}
inline const ::std::string& pbRouteConfig::masterip() const {
  return *masterip_;
}
inline void pbRouteConfig::set_masterip(const ::std::string& value) {
  set_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    masterip_ = new ::std::string;
  }
  masterip_->assign(value);
}
inline void pbRouteConfig::set_masterip(const char* value) {
  set_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    masterip_ = new ::std::string;
  }
  masterip_->assign(value);
}
inline void pbRouteConfig::set_masterip(const char* value, size_t size) {
  set_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    masterip_ = new ::std::string;
  }
  masterip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbRouteConfig::mutable_masterip() {
  set_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    masterip_ = new ::std::string;
  }
  return masterip_;
}
inline ::std::string* pbRouteConfig::release_masterip() {
  clear_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = masterip_;
    masterip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbRouteConfig::set_allocated_masterip(::std::string* masterip) {
  if (masterip_ != &::google::protobuf::internal::kEmptyString) {
    delete masterip_;
  }
  if (masterip) {
    set_has_masterip();
    masterip_ = masterip;
  } else {
    clear_has_masterip();
    masterip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 MasterPort = 2;
inline bool pbRouteConfig::has_masterport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbRouteConfig::set_has_masterport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbRouteConfig::clear_has_masterport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbRouteConfig::clear_masterport() {
  masterport_ = 0u;
  clear_has_masterport();
}
inline ::google::protobuf::uint32 pbRouteConfig::masterport() const {
  return masterport_;
}
inline void pbRouteConfig::set_masterport(::google::protobuf::uint32 value) {
  set_has_masterport();
  masterport_ = value;
}

// optional string NamingHost = 3;
inline bool pbRouteConfig::has_naminghost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbRouteConfig::set_has_naminghost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbRouteConfig::clear_has_naminghost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbRouteConfig::clear_naminghost() {
  if (naminghost_ != &::google::protobuf::internal::kEmptyString) {
    naminghost_->clear();
  }
  clear_has_naminghost();
}
inline const ::std::string& pbRouteConfig::naminghost() const {
  return *naminghost_;
}
inline void pbRouteConfig::set_naminghost(const ::std::string& value) {
  set_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    naminghost_ = new ::std::string;
  }
  naminghost_->assign(value);
}
inline void pbRouteConfig::set_naminghost(const char* value) {
  set_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    naminghost_ = new ::std::string;
  }
  naminghost_->assign(value);
}
inline void pbRouteConfig::set_naminghost(const char* value, size_t size) {
  set_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    naminghost_ = new ::std::string;
  }
  naminghost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbRouteConfig::mutable_naminghost() {
  set_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    naminghost_ = new ::std::string;
  }
  return naminghost_;
}
inline ::std::string* pbRouteConfig::release_naminghost() {
  clear_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = naminghost_;
    naminghost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbRouteConfig::set_allocated_naminghost(::std::string* naminghost) {
  if (naminghost_ != &::google::protobuf::internal::kEmptyString) {
    delete naminghost_;
  }
  if (naminghost) {
    set_has_naminghost();
    naminghost_ = naminghost;
  } else {
    clear_has_naminghost();
    naminghost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string NamingPath = 4;
inline bool pbRouteConfig::has_namingpath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbRouteConfig::set_has_namingpath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbRouteConfig::clear_has_namingpath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbRouteConfig::clear_namingpath() {
  if (namingpath_ != &::google::protobuf::internal::kEmptyString) {
    namingpath_->clear();
  }
  clear_has_namingpath();
}
inline const ::std::string& pbRouteConfig::namingpath() const {
  return *namingpath_;
}
inline void pbRouteConfig::set_namingpath(const ::std::string& value) {
  set_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    namingpath_ = new ::std::string;
  }
  namingpath_->assign(value);
}
inline void pbRouteConfig::set_namingpath(const char* value) {
  set_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    namingpath_ = new ::std::string;
  }
  namingpath_->assign(value);
}
inline void pbRouteConfig::set_namingpath(const char* value, size_t size) {
  set_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    namingpath_ = new ::std::string;
  }
  namingpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbRouteConfig::mutable_namingpath() {
  set_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    namingpath_ = new ::std::string;
  }
  return namingpath_;
}
inline ::std::string* pbRouteConfig::release_namingpath() {
  clear_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = namingpath_;
    namingpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbRouteConfig::set_allocated_namingpath(::std::string* namingpath) {
  if (namingpath_ != &::google::protobuf::internal::kEmptyString) {
    delete namingpath_;
  }
  if (namingpath) {
    set_has_namingpath();
    namingpath_ = namingpath;
  } else {
    clear_has_namingpath();
    namingpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string RouteAgent = 5;
inline bool pbRouteConfig::has_routeagent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbRouteConfig::set_has_routeagent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbRouteConfig::clear_has_routeagent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbRouteConfig::clear_routeagent() {
  if (routeagent_ != &::google::protobuf::internal::kEmptyString) {
    routeagent_->clear();
  }
  clear_has_routeagent();
}
inline const ::std::string& pbRouteConfig::routeagent() const {
  return *routeagent_;
}
inline void pbRouteConfig::set_routeagent(const ::std::string& value) {
  set_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    routeagent_ = new ::std::string;
  }
  routeagent_->assign(value);
}
inline void pbRouteConfig::set_routeagent(const char* value) {
  set_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    routeagent_ = new ::std::string;
  }
  routeagent_->assign(value);
}
inline void pbRouteConfig::set_routeagent(const char* value, size_t size) {
  set_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    routeagent_ = new ::std::string;
  }
  routeagent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbRouteConfig::mutable_routeagent() {
  set_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    routeagent_ = new ::std::string;
  }
  return routeagent_;
}
inline ::std::string* pbRouteConfig::release_routeagent() {
  clear_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = routeagent_;
    routeagent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbRouteConfig::set_allocated_routeagent(::std::string* routeagent) {
  if (routeagent_ != &::google::protobuf::internal::kEmptyString) {
    delete routeagent_;
  }
  if (routeagent) {
    set_has_routeagent();
    routeagent_ = routeagent;
  } else {
    clear_has_routeagent();
    routeagent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// pbAllServerConfig

// optional string Server = 1;
inline bool pbAllServerConfig::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbAllServerConfig::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbAllServerConfig::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbAllServerConfig::clear_server() {
  if (server_ != &::google::protobuf::internal::kEmptyString) {
    server_->clear();
  }
  clear_has_server();
}
inline const ::std::string& pbAllServerConfig::server() const {
  return *server_;
}
inline void pbAllServerConfig::set_server(const ::std::string& value) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void pbAllServerConfig::set_server(const char* value) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void pbAllServerConfig::set_server(const char* value, size_t size) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbAllServerConfig::mutable_server() {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  return server_;
}
inline ::std::string* pbAllServerConfig::release_server() {
  clear_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_;
    server_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbAllServerConfig::set_allocated_server(::std::string* server) {
  if (server_ != &::google::protobuf::internal::kEmptyString) {
    delete server_;
  }
  if (server) {
    set_has_server();
    server_ = server;
  } else {
    clear_has_server();
    server_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ID = 2;
inline bool pbAllServerConfig::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbAllServerConfig::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbAllServerConfig::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbAllServerConfig::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& pbAllServerConfig::id() const {
  return *id_;
}
inline void pbAllServerConfig::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void pbAllServerConfig::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void pbAllServerConfig::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbAllServerConfig::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* pbAllServerConfig::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbAllServerConfig::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ServerType = 3;
inline bool pbAllServerConfig::has_servertype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbAllServerConfig::set_has_servertype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbAllServerConfig::clear_has_servertype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbAllServerConfig::clear_servertype() {
  servertype_ = 0u;
  clear_has_servertype();
}
inline ::google::protobuf::uint32 pbAllServerConfig::servertype() const {
  return servertype_;
}
inline void pbAllServerConfig::set_servertype(::google::protobuf::uint32 value) {
  set_has_servertype();
  servertype_ = value;
}

// -------------------------------------------------------------------

// pbPluginConfig

// optional uint32 ServerType = 1;
inline bool pbPluginConfig::has_servertype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbPluginConfig::set_has_servertype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbPluginConfig::clear_has_servertype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbPluginConfig::clear_servertype() {
  servertype_ = 0u;
  clear_has_servertype();
}
inline ::google::protobuf::uint32 pbPluginConfig::servertype() const {
  return servertype_;
}
inline void pbPluginConfig::set_servertype(::google::protobuf::uint32 value) {
  set_has_servertype();
  servertype_ = value;
}

// repeated string FramePlugins = 2;
inline int pbPluginConfig::frameplugins_size() const {
  return frameplugins_.size();
}
inline void pbPluginConfig::clear_frameplugins() {
  frameplugins_.Clear();
}
inline const ::std::string& pbPluginConfig::frameplugins(int index) const {
  return frameplugins_.Get(index);
}
inline ::std::string* pbPluginConfig::mutable_frameplugins(int index) {
  return frameplugins_.Mutable(index);
}
inline void pbPluginConfig::set_frameplugins(int index, const ::std::string& value) {
  frameplugins_.Mutable(index)->assign(value);
}
inline void pbPluginConfig::set_frameplugins(int index, const char* value) {
  frameplugins_.Mutable(index)->assign(value);
}
inline void pbPluginConfig::set_frameplugins(int index, const char* value, size_t size) {
  frameplugins_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbPluginConfig::add_frameplugins() {
  return frameplugins_.Add();
}
inline void pbPluginConfig::add_frameplugins(const ::std::string& value) {
  frameplugins_.Add()->assign(value);
}
inline void pbPluginConfig::add_frameplugins(const char* value) {
  frameplugins_.Add()->assign(value);
}
inline void pbPluginConfig::add_frameplugins(const char* value, size_t size) {
  frameplugins_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
pbPluginConfig::frameplugins() const {
  return frameplugins_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
pbPluginConfig::mutable_frameplugins() {
  return &frameplugins_;
}

// repeated string ServerPlugins = 3;
inline int pbPluginConfig::serverplugins_size() const {
  return serverplugins_.size();
}
inline void pbPluginConfig::clear_serverplugins() {
  serverplugins_.Clear();
}
inline const ::std::string& pbPluginConfig::serverplugins(int index) const {
  return serverplugins_.Get(index);
}
inline ::std::string* pbPluginConfig::mutable_serverplugins(int index) {
  return serverplugins_.Mutable(index);
}
inline void pbPluginConfig::set_serverplugins(int index, const ::std::string& value) {
  serverplugins_.Mutable(index)->assign(value);
}
inline void pbPluginConfig::set_serverplugins(int index, const char* value) {
  serverplugins_.Mutable(index)->assign(value);
}
inline void pbPluginConfig::set_serverplugins(int index, const char* value, size_t size) {
  serverplugins_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbPluginConfig::add_serverplugins() {
  return serverplugins_.Add();
}
inline void pbPluginConfig::add_serverplugins(const ::std::string& value) {
  serverplugins_.Add()->assign(value);
}
inline void pbPluginConfig::add_serverplugins(const char* value) {
  serverplugins_.Add()->assign(value);
}
inline void pbPluginConfig::add_serverplugins(const char* value, size_t size) {
  serverplugins_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
pbPluginConfig::serverplugins() const {
  return serverplugins_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
pbPluginConfig::mutable_serverplugins() {
  return &serverplugins_;
}

// repeated string WorkPlugins = 4;
inline int pbPluginConfig::workplugins_size() const {
  return workplugins_.size();
}
inline void pbPluginConfig::clear_workplugins() {
  workplugins_.Clear();
}
inline const ::std::string& pbPluginConfig::workplugins(int index) const {
  return workplugins_.Get(index);
}
inline ::std::string* pbPluginConfig::mutable_workplugins(int index) {
  return workplugins_.Mutable(index);
}
inline void pbPluginConfig::set_workplugins(int index, const ::std::string& value) {
  workplugins_.Mutable(index)->assign(value);
}
inline void pbPluginConfig::set_workplugins(int index, const char* value) {
  workplugins_.Mutable(index)->assign(value);
}
inline void pbPluginConfig::set_workplugins(int index, const char* value, size_t size) {
  workplugins_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbPluginConfig::add_workplugins() {
  return workplugins_.Add();
}
inline void pbPluginConfig::add_workplugins(const ::std::string& value) {
  workplugins_.Add()->assign(value);
}
inline void pbPluginConfig::add_workplugins(const char* value) {
  workplugins_.Add()->assign(value);
}
inline void pbPluginConfig::add_workplugins(const char* value, size_t size) {
  workplugins_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
pbPluginConfig::workplugins() const {
  return workplugins_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
pbPluginConfig::mutable_workplugins() {
  return &workplugins_;
}

// repeated .proto_ff.pbAllServerConfig ServerList = 5;
inline int pbPluginConfig::serverlist_size() const {
  return serverlist_.size();
}
inline void pbPluginConfig::clear_serverlist() {
  serverlist_.Clear();
}
inline const ::proto_ff::pbAllServerConfig& pbPluginConfig::serverlist(int index) const {
  return serverlist_.Get(index);
}
inline ::proto_ff::pbAllServerConfig* pbPluginConfig::mutable_serverlist(int index) {
  return serverlist_.Mutable(index);
}
inline ::proto_ff::pbAllServerConfig* pbPluginConfig::add_serverlist() {
  return serverlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::pbAllServerConfig >&
pbPluginConfig::serverlist() const {
  return serverlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::pbAllServerConfig >*
pbPluginConfig::mutable_serverlist() {
  return &serverlist_;
}

// -------------------------------------------------------------------

// pbTableConfig

// optional string TableName = 1;
inline bool pbTableConfig::has_tablename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbTableConfig::set_has_tablename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbTableConfig::clear_has_tablename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbTableConfig::clear_tablename() {
  if (tablename_ != &::google::protobuf::internal::kEmptyString) {
    tablename_->clear();
  }
  clear_has_tablename();
}
inline const ::std::string& pbTableConfig::tablename() const {
  return *tablename_;
}
inline void pbTableConfig::set_tablename(const ::std::string& value) {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(value);
}
inline void pbTableConfig::set_tablename(const char* value) {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(value);
}
inline void pbTableConfig::set_tablename(const char* value, size_t size) {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbTableConfig::mutable_tablename() {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  return tablename_;
}
inline ::std::string* pbTableConfig::release_tablename() {
  clear_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tablename_;
    tablename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbTableConfig::set_allocated_tablename(::std::string* tablename) {
  if (tablename_ != &::google::protobuf::internal::kEmptyString) {
    delete tablename_;
  }
  if (tablename) {
    set_has_tablename();
    tablename_ = tablename;
  } else {
    clear_has_tablename();
    tablename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 TableCount = 2;
inline bool pbTableConfig::has_tablecount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbTableConfig::set_has_tablecount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbTableConfig::clear_has_tablecount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbTableConfig::clear_tablecount() {
  tablecount_ = 0u;
  clear_has_tablecount();
}
inline ::google::protobuf::uint32 pbTableConfig::tablecount() const {
  return tablecount_;
}
inline void pbTableConfig::set_tablecount(::google::protobuf::uint32 value) {
  set_has_tablecount();
  tablecount_ = value;
}

// optional bool Cache = 3;
inline bool pbTableConfig::has_cache() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbTableConfig::set_has_cache() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbTableConfig::clear_has_cache() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbTableConfig::clear_cache() {
  cache_ = false;
  clear_has_cache();
}
inline bool pbTableConfig::cache() const {
  return cache_;
}
inline void pbTableConfig::set_cache(bool value) {
  set_has_cache();
  cache_ = value;
}

// -------------------------------------------------------------------

// pbNFServerConfig

// optional string ServerId = 1;
inline bool pbNFServerConfig::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbNFServerConfig::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbNFServerConfig::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbNFServerConfig::clear_serverid() {
  if (serverid_ != &::google::protobuf::internal::kEmptyString) {
    serverid_->clear();
  }
  clear_has_serverid();
}
inline const ::std::string& pbNFServerConfig::serverid() const {
  return *serverid_;
}
inline void pbNFServerConfig::set_serverid(const ::std::string& value) {
  set_has_serverid();
  if (serverid_ == &::google::protobuf::internal::kEmptyString) {
    serverid_ = new ::std::string;
  }
  serverid_->assign(value);
}
inline void pbNFServerConfig::set_serverid(const char* value) {
  set_has_serverid();
  if (serverid_ == &::google::protobuf::internal::kEmptyString) {
    serverid_ = new ::std::string;
  }
  serverid_->assign(value);
}
inline void pbNFServerConfig::set_serverid(const char* value, size_t size) {
  set_has_serverid();
  if (serverid_ == &::google::protobuf::internal::kEmptyString) {
    serverid_ = new ::std::string;
  }
  serverid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_serverid() {
  set_has_serverid();
  if (serverid_ == &::google::protobuf::internal::kEmptyString) {
    serverid_ = new ::std::string;
  }
  return serverid_;
}
inline ::std::string* pbNFServerConfig::release_serverid() {
  clear_has_serverid();
  if (serverid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverid_;
    serverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_serverid(::std::string* serverid) {
  if (serverid_ != &::google::protobuf::internal::kEmptyString) {
    delete serverid_;
  }
  if (serverid) {
    set_has_serverid();
    serverid_ = serverid;
  } else {
    clear_has_serverid();
    serverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ServerType = 2;
inline bool pbNFServerConfig::has_servertype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbNFServerConfig::set_has_servertype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbNFServerConfig::clear_has_servertype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbNFServerConfig::clear_servertype() {
  servertype_ = 0u;
  clear_has_servertype();
}
inline ::google::protobuf::uint32 pbNFServerConfig::servertype() const {
  return servertype_;
}
inline void pbNFServerConfig::set_servertype(::google::protobuf::uint32 value) {
  set_has_servertype();
  servertype_ = value;
}

// optional string ServerName = 3;
inline bool pbNFServerConfig::has_servername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbNFServerConfig::set_has_servername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbNFServerConfig::clear_has_servername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbNFServerConfig::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& pbNFServerConfig::servername() const {
  return *servername_;
}
inline void pbNFServerConfig::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void pbNFServerConfig::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void pbNFServerConfig::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* pbNFServerConfig::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BusId = 4;
inline bool pbNFServerConfig::has_busid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbNFServerConfig::set_has_busid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbNFServerConfig::clear_has_busid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbNFServerConfig::clear_busid() {
  busid_ = 0u;
  clear_has_busid();
}
inline ::google::protobuf::uint32 pbNFServerConfig::busid() const {
  return busid_;
}
inline void pbNFServerConfig::set_busid(::google::protobuf::uint32 value) {
  set_has_busid();
  busid_ = value;
}

// optional uint32 BusLength = 5;
inline bool pbNFServerConfig::has_buslength() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbNFServerConfig::set_has_buslength() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbNFServerConfig::clear_has_buslength() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbNFServerConfig::clear_buslength() {
  buslength_ = 0u;
  clear_has_buslength();
}
inline ::google::protobuf::uint32 pbNFServerConfig::buslength() const {
  return buslength_;
}
inline void pbNFServerConfig::set_buslength(::google::protobuf::uint32 value) {
  set_has_buslength();
  buslength_ = value;
}

// optional string LinkMode = 7;
inline bool pbNFServerConfig::has_linkmode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbNFServerConfig::set_has_linkmode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbNFServerConfig::clear_has_linkmode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbNFServerConfig::clear_linkmode() {
  if (linkmode_ != &::google::protobuf::internal::kEmptyString) {
    linkmode_->clear();
  }
  clear_has_linkmode();
}
inline const ::std::string& pbNFServerConfig::linkmode() const {
  return *linkmode_;
}
inline void pbNFServerConfig::set_linkmode(const ::std::string& value) {
  set_has_linkmode();
  if (linkmode_ == &::google::protobuf::internal::kEmptyString) {
    linkmode_ = new ::std::string;
  }
  linkmode_->assign(value);
}
inline void pbNFServerConfig::set_linkmode(const char* value) {
  set_has_linkmode();
  if (linkmode_ == &::google::protobuf::internal::kEmptyString) {
    linkmode_ = new ::std::string;
  }
  linkmode_->assign(value);
}
inline void pbNFServerConfig::set_linkmode(const char* value, size_t size) {
  set_has_linkmode();
  if (linkmode_ == &::google::protobuf::internal::kEmptyString) {
    linkmode_ = new ::std::string;
  }
  linkmode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_linkmode() {
  set_has_linkmode();
  if (linkmode_ == &::google::protobuf::internal::kEmptyString) {
    linkmode_ = new ::std::string;
  }
  return linkmode_;
}
inline ::std::string* pbNFServerConfig::release_linkmode() {
  clear_has_linkmode();
  if (linkmode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = linkmode_;
    linkmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_linkmode(::std::string* linkmode) {
  if (linkmode_ != &::google::protobuf::internal::kEmptyString) {
    delete linkmode_;
  }
  if (linkmode) {
    set_has_linkmode();
    linkmode_ = linkmode;
  } else {
    clear_has_linkmode();
    linkmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Url = 8;
inline bool pbNFServerConfig::has_url() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbNFServerConfig::set_has_url() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbNFServerConfig::clear_has_url() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbNFServerConfig::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& pbNFServerConfig::url() const {
  return *url_;
}
inline void pbNFServerConfig::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void pbNFServerConfig::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void pbNFServerConfig::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* pbNFServerConfig::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 IdleSleepUS = 9;
inline bool pbNFServerConfig::has_idlesleepus() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbNFServerConfig::set_has_idlesleepus() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbNFServerConfig::clear_has_idlesleepus() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbNFServerConfig::clear_idlesleepus() {
  idlesleepus_ = 0u;
  clear_has_idlesleepus();
}
inline ::google::protobuf::uint32 pbNFServerConfig::idlesleepus() const {
  return idlesleepus_;
}
inline void pbNFServerConfig::set_idlesleepus(::google::protobuf::uint32 value) {
  set_has_idlesleepus();
  idlesleepus_ = value;
}

// optional uint32 HandleMsgNumPerFrame = 10;
inline bool pbNFServerConfig::has_handlemsgnumperframe() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbNFServerConfig::set_has_handlemsgnumperframe() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbNFServerConfig::clear_has_handlemsgnumperframe() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbNFServerConfig::clear_handlemsgnumperframe() {
  handlemsgnumperframe_ = 0u;
  clear_has_handlemsgnumperframe();
}
inline ::google::protobuf::uint32 pbNFServerConfig::handlemsgnumperframe() const {
  return handlemsgnumperframe_;
}
inline void pbNFServerConfig::set_handlemsgnumperframe(::google::protobuf::uint32 value) {
  set_has_handlemsgnumperframe();
  handlemsgnumperframe_ = value;
}

// optional uint64 ServerOpenTime = 11;
inline bool pbNFServerConfig::has_serveropentime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pbNFServerConfig::set_has_serveropentime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pbNFServerConfig::clear_has_serveropentime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pbNFServerConfig::clear_serveropentime() {
  serveropentime_ = GOOGLE_ULONGLONG(0);
  clear_has_serveropentime();
}
inline ::google::protobuf::uint64 pbNFServerConfig::serveropentime() const {
  return serveropentime_;
}
inline void pbNFServerConfig::set_serveropentime(::google::protobuf::uint64 value) {
  set_has_serveropentime();
  serveropentime_ = value;
}

// optional string LoadProtoDs = 12;
inline bool pbNFServerConfig::has_loadprotods() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void pbNFServerConfig::set_has_loadprotods() {
  _has_bits_[0] |= 0x00000400u;
}
inline void pbNFServerConfig::clear_has_loadprotods() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void pbNFServerConfig::clear_loadprotods() {
  if (loadprotods_ != &::google::protobuf::internal::kEmptyString) {
    loadprotods_->clear();
  }
  clear_has_loadprotods();
}
inline const ::std::string& pbNFServerConfig::loadprotods() const {
  return *loadprotods_;
}
inline void pbNFServerConfig::set_loadprotods(const ::std::string& value) {
  set_has_loadprotods();
  if (loadprotods_ == &::google::protobuf::internal::kEmptyString) {
    loadprotods_ = new ::std::string;
  }
  loadprotods_->assign(value);
}
inline void pbNFServerConfig::set_loadprotods(const char* value) {
  set_has_loadprotods();
  if (loadprotods_ == &::google::protobuf::internal::kEmptyString) {
    loadprotods_ = new ::std::string;
  }
  loadprotods_->assign(value);
}
inline void pbNFServerConfig::set_loadprotods(const char* value, size_t size) {
  set_has_loadprotods();
  if (loadprotods_ == &::google::protobuf::internal::kEmptyString) {
    loadprotods_ = new ::std::string;
  }
  loadprotods_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_loadprotods() {
  set_has_loadprotods();
  if (loadprotods_ == &::google::protobuf::internal::kEmptyString) {
    loadprotods_ = new ::std::string;
  }
  return loadprotods_;
}
inline ::std::string* pbNFServerConfig::release_loadprotods() {
  clear_has_loadprotods();
  if (loadprotods_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loadprotods_;
    loadprotods_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_loadprotods(::std::string* loadprotods) {
  if (loadprotods_ != &::google::protobuf::internal::kEmptyString) {
    delete loadprotods_;
  }
  if (loadprotods) {
    set_has_loadprotods();
    loadprotods_ = loadprotods;
  } else {
    clear_has_loadprotods();
    loadprotods_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool CrossServer = 13;
inline bool pbNFServerConfig::has_crossserver() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void pbNFServerConfig::set_has_crossserver() {
  _has_bits_[0] |= 0x00000800u;
}
inline void pbNFServerConfig::clear_has_crossserver() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void pbNFServerConfig::clear_crossserver() {
  crossserver_ = false;
  clear_has_crossserver();
}
inline bool pbNFServerConfig::crossserver() const {
  return crossserver_;
}
inline void pbNFServerConfig::set_crossserver(bool value) {
  set_has_crossserver();
  crossserver_ = value;
}

// optional string ServerIp = 20;
inline bool pbNFServerConfig::has_serverip() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void pbNFServerConfig::set_has_serverip() {
  _has_bits_[0] |= 0x00001000u;
}
inline void pbNFServerConfig::clear_has_serverip() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void pbNFServerConfig::clear_serverip() {
  if (serverip_ != &::google::protobuf::internal::kEmptyString) {
    serverip_->clear();
  }
  clear_has_serverip();
}
inline const ::std::string& pbNFServerConfig::serverip() const {
  return *serverip_;
}
inline void pbNFServerConfig::set_serverip(const ::std::string& value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
}
inline void pbNFServerConfig::set_serverip(const char* value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
}
inline void pbNFServerConfig::set_serverip(const char* value, size_t size) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_serverip() {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    serverip_ = new ::std::string;
  }
  return serverip_;
}
inline ::std::string* pbNFServerConfig::release_serverip() {
  clear_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverip_;
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_serverip(::std::string* serverip) {
  if (serverip_ != &::google::protobuf::internal::kEmptyString) {
    delete serverip_;
  }
  if (serverip) {
    set_has_serverip();
    serverip_ = serverip;
  } else {
    clear_has_serverip();
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ServerPort = 21;
inline bool pbNFServerConfig::has_serverport() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void pbNFServerConfig::set_has_serverport() {
  _has_bits_[0] |= 0x00002000u;
}
inline void pbNFServerConfig::clear_has_serverport() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void pbNFServerConfig::clear_serverport() {
  serverport_ = 0u;
  clear_has_serverport();
}
inline ::google::protobuf::uint32 pbNFServerConfig::serverport() const {
  return serverport_;
}
inline void pbNFServerConfig::set_serverport(::google::protobuf::uint32 value) {
  set_has_serverport();
  serverport_ = value;
}

// optional string ExternalServerIp = 22;
inline bool pbNFServerConfig::has_externalserverip() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void pbNFServerConfig::set_has_externalserverip() {
  _has_bits_[0] |= 0x00004000u;
}
inline void pbNFServerConfig::clear_has_externalserverip() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void pbNFServerConfig::clear_externalserverip() {
  if (externalserverip_ != &::google::protobuf::internal::kEmptyString) {
    externalserverip_->clear();
  }
  clear_has_externalserverip();
}
inline const ::std::string& pbNFServerConfig::externalserverip() const {
  return *externalserverip_;
}
inline void pbNFServerConfig::set_externalserverip(const ::std::string& value) {
  set_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    externalserverip_ = new ::std::string;
  }
  externalserverip_->assign(value);
}
inline void pbNFServerConfig::set_externalserverip(const char* value) {
  set_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    externalserverip_ = new ::std::string;
  }
  externalserverip_->assign(value);
}
inline void pbNFServerConfig::set_externalserverip(const char* value, size_t size) {
  set_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    externalserverip_ = new ::std::string;
  }
  externalserverip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_externalserverip() {
  set_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    externalserverip_ = new ::std::string;
  }
  return externalserverip_;
}
inline ::std::string* pbNFServerConfig::release_externalserverip() {
  clear_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = externalserverip_;
    externalserverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_externalserverip(::std::string* externalserverip) {
  if (externalserverip_ != &::google::protobuf::internal::kEmptyString) {
    delete externalserverip_;
  }
  if (externalserverip) {
    set_has_externalserverip();
    externalserverip_ = externalserverip;
  } else {
    clear_has_externalserverip();
    externalserverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ExternalServerPort = 23;
inline bool pbNFServerConfig::has_externalserverport() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void pbNFServerConfig::set_has_externalserverport() {
  _has_bits_[0] |= 0x00008000u;
}
inline void pbNFServerConfig::clear_has_externalserverport() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void pbNFServerConfig::clear_externalserverport() {
  externalserverport_ = 0u;
  clear_has_externalserverport();
}
inline ::google::protobuf::uint32 pbNFServerConfig::externalserverport() const {
  return externalserverport_;
}
inline void pbNFServerConfig::set_externalserverport(::google::protobuf::uint32 value) {
  set_has_externalserverport();
  externalserverport_ = value;
}

// optional uint32 HttpPort = 24;
inline bool pbNFServerConfig::has_httpport() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void pbNFServerConfig::set_has_httpport() {
  _has_bits_[0] |= 0x00010000u;
}
inline void pbNFServerConfig::clear_has_httpport() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void pbNFServerConfig::clear_httpport() {
  httpport_ = 0u;
  clear_has_httpport();
}
inline ::google::protobuf::uint32 pbNFServerConfig::httpport() const {
  return httpport_;
}
inline void pbNFServerConfig::set_httpport(::google::protobuf::uint32 value) {
  set_has_httpport();
  httpport_ = value;
}

// optional uint32 MaxConnectNum = 25;
inline bool pbNFServerConfig::has_maxconnectnum() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void pbNFServerConfig::set_has_maxconnectnum() {
  _has_bits_[0] |= 0x00020000u;
}
inline void pbNFServerConfig::clear_has_maxconnectnum() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void pbNFServerConfig::clear_maxconnectnum() {
  maxconnectnum_ = 0u;
  clear_has_maxconnectnum();
}
inline ::google::protobuf::uint32 pbNFServerConfig::maxconnectnum() const {
  return maxconnectnum_;
}
inline void pbNFServerConfig::set_maxconnectnum(::google::protobuf::uint32 value) {
  set_has_maxconnectnum();
  maxconnectnum_ = value;
}

// optional uint32 WorkThreadNum = 26;
inline bool pbNFServerConfig::has_workthreadnum() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void pbNFServerConfig::set_has_workthreadnum() {
  _has_bits_[0] |= 0x00040000u;
}
inline void pbNFServerConfig::clear_has_workthreadnum() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void pbNFServerConfig::clear_workthreadnum() {
  workthreadnum_ = 0u;
  clear_has_workthreadnum();
}
inline ::google::protobuf::uint32 pbNFServerConfig::workthreadnum() const {
  return workthreadnum_;
}
inline void pbNFServerConfig::set_workthreadnum(::google::protobuf::uint32 value) {
  set_has_workthreadnum();
  workthreadnum_ = value;
}

// optional uint32 NetThreadNum = 27;
inline bool pbNFServerConfig::has_netthreadnum() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void pbNFServerConfig::set_has_netthreadnum() {
  _has_bits_[0] |= 0x00080000u;
}
inline void pbNFServerConfig::clear_has_netthreadnum() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void pbNFServerConfig::clear_netthreadnum() {
  netthreadnum_ = 0u;
  clear_has_netthreadnum();
}
inline ::google::protobuf::uint32 pbNFServerConfig::netthreadnum() const {
  return netthreadnum_;
}
inline void pbNFServerConfig::set_netthreadnum(::google::protobuf::uint32 value) {
  set_has_netthreadnum();
  netthreadnum_ = value;
}

// optional bool Security = 28;
inline bool pbNFServerConfig::has_security() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void pbNFServerConfig::set_has_security() {
  _has_bits_[0] |= 0x00100000u;
}
inline void pbNFServerConfig::clear_has_security() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void pbNFServerConfig::clear_security() {
  security_ = false;
  clear_has_security();
}
inline bool pbNFServerConfig::security() const {
  return security_;
}
inline void pbNFServerConfig::set_security(bool value) {
  set_has_security();
  security_ = value;
}

// optional bool WebSocket = 29;
inline bool pbNFServerConfig::has_websocket() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void pbNFServerConfig::set_has_websocket() {
  _has_bits_[0] |= 0x00200000u;
}
inline void pbNFServerConfig::clear_has_websocket() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void pbNFServerConfig::clear_websocket() {
  websocket_ = false;
  clear_has_websocket();
}
inline bool pbNFServerConfig::websocket() const {
  return websocket_;
}
inline void pbNFServerConfig::set_websocket(bool value) {
  set_has_websocket();
  websocket_ = value;
}

// optional uint32 ParseType = 30;
inline bool pbNFServerConfig::has_parsetype() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void pbNFServerConfig::set_has_parsetype() {
  _has_bits_[0] |= 0x00400000u;
}
inline void pbNFServerConfig::clear_has_parsetype() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void pbNFServerConfig::clear_parsetype() {
  parsetype_ = 0u;
  clear_has_parsetype();
}
inline ::google::protobuf::uint32 pbNFServerConfig::parsetype() const {
  return parsetype_;
}
inline void pbNFServerConfig::set_parsetype(::google::protobuf::uint32 value) {
  set_has_parsetype();
  parsetype_ = value;
}

// optional .proto_ff.pbRouteConfig RouteConfig = 50;
inline bool pbNFServerConfig::has_routeconfig() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void pbNFServerConfig::set_has_routeconfig() {
  _has_bits_[0] |= 0x00800000u;
}
inline void pbNFServerConfig::clear_has_routeconfig() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void pbNFServerConfig::clear_routeconfig() {
  if (routeconfig_ != NULL) routeconfig_->::proto_ff::pbRouteConfig::Clear();
  clear_has_routeconfig();
}
inline const ::proto_ff::pbRouteConfig& pbNFServerConfig::routeconfig() const {
  return routeconfig_ != NULL ? *routeconfig_ : *default_instance_->routeconfig_;
}
inline ::proto_ff::pbRouteConfig* pbNFServerConfig::mutable_routeconfig() {
  set_has_routeconfig();
  if (routeconfig_ == NULL) routeconfig_ = new ::proto_ff::pbRouteConfig;
  return routeconfig_;
}
inline ::proto_ff::pbRouteConfig* pbNFServerConfig::release_routeconfig() {
  clear_has_routeconfig();
  ::proto_ff::pbRouteConfig* temp = routeconfig_;
  routeconfig_ = NULL;
  return temp;
}
inline void pbNFServerConfig::set_allocated_routeconfig(::proto_ff::pbRouteConfig* routeconfig) {
  delete routeconfig_;
  routeconfig_ = routeconfig;
  if (routeconfig) {
    set_has_routeconfig();
  } else {
    clear_has_routeconfig();
  }
}

// optional .proto_ff.pbMysqlConfig MysqlConfig = 70;
inline bool pbNFServerConfig::has_mysqlconfig() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void pbNFServerConfig::set_has_mysqlconfig() {
  _has_bits_[0] |= 0x01000000u;
}
inline void pbNFServerConfig::clear_has_mysqlconfig() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void pbNFServerConfig::clear_mysqlconfig() {
  if (mysqlconfig_ != NULL) mysqlconfig_->::proto_ff::pbMysqlConfig::Clear();
  clear_has_mysqlconfig();
}
inline const ::proto_ff::pbMysqlConfig& pbNFServerConfig::mysqlconfig() const {
  return mysqlconfig_ != NULL ? *mysqlconfig_ : *default_instance_->mysqlconfig_;
}
inline ::proto_ff::pbMysqlConfig* pbNFServerConfig::mutable_mysqlconfig() {
  set_has_mysqlconfig();
  if (mysqlconfig_ == NULL) mysqlconfig_ = new ::proto_ff::pbMysqlConfig;
  return mysqlconfig_;
}
inline ::proto_ff::pbMysqlConfig* pbNFServerConfig::release_mysqlconfig() {
  clear_has_mysqlconfig();
  ::proto_ff::pbMysqlConfig* temp = mysqlconfig_;
  mysqlconfig_ = NULL;
  return temp;
}
inline void pbNFServerConfig::set_allocated_mysqlconfig(::proto_ff::pbMysqlConfig* mysqlconfig) {
  delete mysqlconfig_;
  mysqlconfig_ = mysqlconfig;
  if (mysqlconfig) {
    set_has_mysqlconfig();
  } else {
    clear_has_mysqlconfig();
  }
}

// optional string DefaultDBName = 75;
inline bool pbNFServerConfig::has_defaultdbname() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void pbNFServerConfig::set_has_defaultdbname() {
  _has_bits_[0] |= 0x02000000u;
}
inline void pbNFServerConfig::clear_has_defaultdbname() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void pbNFServerConfig::clear_defaultdbname() {
  if (defaultdbname_ != &::google::protobuf::internal::kEmptyString) {
    defaultdbname_->clear();
  }
  clear_has_defaultdbname();
}
inline const ::std::string& pbNFServerConfig::defaultdbname() const {
  return *defaultdbname_;
}
inline void pbNFServerConfig::set_defaultdbname(const ::std::string& value) {
  set_has_defaultdbname();
  if (defaultdbname_ == &::google::protobuf::internal::kEmptyString) {
    defaultdbname_ = new ::std::string;
  }
  defaultdbname_->assign(value);
}
inline void pbNFServerConfig::set_defaultdbname(const char* value) {
  set_has_defaultdbname();
  if (defaultdbname_ == &::google::protobuf::internal::kEmptyString) {
    defaultdbname_ = new ::std::string;
  }
  defaultdbname_->assign(value);
}
inline void pbNFServerConfig::set_defaultdbname(const char* value, size_t size) {
  set_has_defaultdbname();
  if (defaultdbname_ == &::google::protobuf::internal::kEmptyString) {
    defaultdbname_ = new ::std::string;
  }
  defaultdbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_defaultdbname() {
  set_has_defaultdbname();
  if (defaultdbname_ == &::google::protobuf::internal::kEmptyString) {
    defaultdbname_ = new ::std::string;
  }
  return defaultdbname_;
}
inline ::std::string* pbNFServerConfig::release_defaultdbname() {
  clear_has_defaultdbname();
  if (defaultdbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defaultdbname_;
    defaultdbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_defaultdbname(::std::string* defaultdbname) {
  if (defaultdbname_ != &::google::protobuf::internal::kEmptyString) {
    delete defaultdbname_;
  }
  if (defaultdbname) {
    set_has_defaultdbname();
    defaultdbname_ = defaultdbname;
  } else {
    clear_has_defaultdbname();
    defaultdbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CrossDBName = 76;
inline bool pbNFServerConfig::has_crossdbname() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void pbNFServerConfig::set_has_crossdbname() {
  _has_bits_[0] |= 0x04000000u;
}
inline void pbNFServerConfig::clear_has_crossdbname() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void pbNFServerConfig::clear_crossdbname() {
  if (crossdbname_ != &::google::protobuf::internal::kEmptyString) {
    crossdbname_->clear();
  }
  clear_has_crossdbname();
}
inline const ::std::string& pbNFServerConfig::crossdbname() const {
  return *crossdbname_;
}
inline void pbNFServerConfig::set_crossdbname(const ::std::string& value) {
  set_has_crossdbname();
  if (crossdbname_ == &::google::protobuf::internal::kEmptyString) {
    crossdbname_ = new ::std::string;
  }
  crossdbname_->assign(value);
}
inline void pbNFServerConfig::set_crossdbname(const char* value) {
  set_has_crossdbname();
  if (crossdbname_ == &::google::protobuf::internal::kEmptyString) {
    crossdbname_ = new ::std::string;
  }
  crossdbname_->assign(value);
}
inline void pbNFServerConfig::set_crossdbname(const char* value, size_t size) {
  set_has_crossdbname();
  if (crossdbname_ == &::google::protobuf::internal::kEmptyString) {
    crossdbname_ = new ::std::string;
  }
  crossdbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_crossdbname() {
  set_has_crossdbname();
  if (crossdbname_ == &::google::protobuf::internal::kEmptyString) {
    crossdbname_ = new ::std::string;
  }
  return crossdbname_;
}
inline ::std::string* pbNFServerConfig::release_crossdbname() {
  clear_has_crossdbname();
  if (crossdbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crossdbname_;
    crossdbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_crossdbname(::std::string* crossdbname) {
  if (crossdbname_ != &::google::protobuf::internal::kEmptyString) {
    delete crossdbname_;
  }
  if (crossdbname) {
    set_has_crossdbname();
    crossdbname_ = crossdbname;
  } else {
    clear_has_crossdbname();
    crossdbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto_ff.pbRedisConfig RedisConfig = 80;
inline bool pbNFServerConfig::has_redisconfig() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void pbNFServerConfig::set_has_redisconfig() {
  _has_bits_[0] |= 0x08000000u;
}
inline void pbNFServerConfig::clear_has_redisconfig() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void pbNFServerConfig::clear_redisconfig() {
  if (redisconfig_ != NULL) redisconfig_->::proto_ff::pbRedisConfig::Clear();
  clear_has_redisconfig();
}
inline const ::proto_ff::pbRedisConfig& pbNFServerConfig::redisconfig() const {
  return redisconfig_ != NULL ? *redisconfig_ : *default_instance_->redisconfig_;
}
inline ::proto_ff::pbRedisConfig* pbNFServerConfig::mutable_redisconfig() {
  set_has_redisconfig();
  if (redisconfig_ == NULL) redisconfig_ = new ::proto_ff::pbRedisConfig;
  return redisconfig_;
}
inline ::proto_ff::pbRedisConfig* pbNFServerConfig::release_redisconfig() {
  clear_has_redisconfig();
  ::proto_ff::pbRedisConfig* temp = redisconfig_;
  redisconfig_ = NULL;
  return temp;
}
inline void pbNFServerConfig::set_allocated_redisconfig(::proto_ff::pbRedisConfig* redisconfig) {
  delete redisconfig_;
  redisconfig_ = redisconfig;
  if (redisconfig) {
    set_has_redisconfig();
  } else {
    clear_has_redisconfig();
  }
}

// optional string sendEmail = 91;
inline bool pbNFServerConfig::has_sendemail() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void pbNFServerConfig::set_has_sendemail() {
  _has_bits_[0] |= 0x10000000u;
}
inline void pbNFServerConfig::clear_has_sendemail() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void pbNFServerConfig::clear_sendemail() {
  if (sendemail_ != &::google::protobuf::internal::kEmptyString) {
    sendemail_->clear();
  }
  clear_has_sendemail();
}
inline const ::std::string& pbNFServerConfig::sendemail() const {
  return *sendemail_;
}
inline void pbNFServerConfig::set_sendemail(const ::std::string& value) {
  set_has_sendemail();
  if (sendemail_ == &::google::protobuf::internal::kEmptyString) {
    sendemail_ = new ::std::string;
  }
  sendemail_->assign(value);
}
inline void pbNFServerConfig::set_sendemail(const char* value) {
  set_has_sendemail();
  if (sendemail_ == &::google::protobuf::internal::kEmptyString) {
    sendemail_ = new ::std::string;
  }
  sendemail_->assign(value);
}
inline void pbNFServerConfig::set_sendemail(const char* value, size_t size) {
  set_has_sendemail();
  if (sendemail_ == &::google::protobuf::internal::kEmptyString) {
    sendemail_ = new ::std::string;
  }
  sendemail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_sendemail() {
  set_has_sendemail();
  if (sendemail_ == &::google::protobuf::internal::kEmptyString) {
    sendemail_ = new ::std::string;
  }
  return sendemail_;
}
inline ::std::string* pbNFServerConfig::release_sendemail() {
  clear_has_sendemail();
  if (sendemail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendemail_;
    sendemail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_sendemail(::std::string* sendemail) {
  if (sendemail_ != &::google::protobuf::internal::kEmptyString) {
    delete sendemail_;
  }
  if (sendemail) {
    set_has_sendemail();
    sendemail_ = sendemail;
  } else {
    clear_has_sendemail();
    sendemail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sendEmailPass = 92;
inline bool pbNFServerConfig::has_sendemailpass() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void pbNFServerConfig::set_has_sendemailpass() {
  _has_bits_[0] |= 0x20000000u;
}
inline void pbNFServerConfig::clear_has_sendemailpass() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void pbNFServerConfig::clear_sendemailpass() {
  if (sendemailpass_ != &::google::protobuf::internal::kEmptyString) {
    sendemailpass_->clear();
  }
  clear_has_sendemailpass();
}
inline const ::std::string& pbNFServerConfig::sendemailpass() const {
  return *sendemailpass_;
}
inline void pbNFServerConfig::set_sendemailpass(const ::std::string& value) {
  set_has_sendemailpass();
  if (sendemailpass_ == &::google::protobuf::internal::kEmptyString) {
    sendemailpass_ = new ::std::string;
  }
  sendemailpass_->assign(value);
}
inline void pbNFServerConfig::set_sendemailpass(const char* value) {
  set_has_sendemailpass();
  if (sendemailpass_ == &::google::protobuf::internal::kEmptyString) {
    sendemailpass_ = new ::std::string;
  }
  sendemailpass_->assign(value);
}
inline void pbNFServerConfig::set_sendemailpass(const char* value, size_t size) {
  set_has_sendemailpass();
  if (sendemailpass_ == &::google::protobuf::internal::kEmptyString) {
    sendemailpass_ = new ::std::string;
  }
  sendemailpass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_sendemailpass() {
  set_has_sendemailpass();
  if (sendemailpass_ == &::google::protobuf::internal::kEmptyString) {
    sendemailpass_ = new ::std::string;
  }
  return sendemailpass_;
}
inline ::std::string* pbNFServerConfig::release_sendemailpass() {
  clear_has_sendemailpass();
  if (sendemailpass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendemailpass_;
    sendemailpass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_sendemailpass(::std::string* sendemailpass) {
  if (sendemailpass_ != &::google::protobuf::internal::kEmptyString) {
    delete sendemailpass_;
  }
  if (sendemailpass) {
    set_has_sendemailpass();
    sendemailpass_ = sendemailpass;
  } else {
    clear_has_sendemailpass();
    sendemailpass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sendEmailUrl = 93;
inline bool pbNFServerConfig::has_sendemailurl() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void pbNFServerConfig::set_has_sendemailurl() {
  _has_bits_[0] |= 0x40000000u;
}
inline void pbNFServerConfig::clear_has_sendemailurl() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void pbNFServerConfig::clear_sendemailurl() {
  if (sendemailurl_ != &::google::protobuf::internal::kEmptyString) {
    sendemailurl_->clear();
  }
  clear_has_sendemailurl();
}
inline const ::std::string& pbNFServerConfig::sendemailurl() const {
  return *sendemailurl_;
}
inline void pbNFServerConfig::set_sendemailurl(const ::std::string& value) {
  set_has_sendemailurl();
  if (sendemailurl_ == &::google::protobuf::internal::kEmptyString) {
    sendemailurl_ = new ::std::string;
  }
  sendemailurl_->assign(value);
}
inline void pbNFServerConfig::set_sendemailurl(const char* value) {
  set_has_sendemailurl();
  if (sendemailurl_ == &::google::protobuf::internal::kEmptyString) {
    sendemailurl_ = new ::std::string;
  }
  sendemailurl_->assign(value);
}
inline void pbNFServerConfig::set_sendemailurl(const char* value, size_t size) {
  set_has_sendemailurl();
  if (sendemailurl_ == &::google::protobuf::internal::kEmptyString) {
    sendemailurl_ = new ::std::string;
  }
  sendemailurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_sendemailurl() {
  set_has_sendemailurl();
  if (sendemailurl_ == &::google::protobuf::internal::kEmptyString) {
    sendemailurl_ = new ::std::string;
  }
  return sendemailurl_;
}
inline ::std::string* pbNFServerConfig::release_sendemailurl() {
  clear_has_sendemailurl();
  if (sendemailurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendemailurl_;
    sendemailurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_sendemailurl(::std::string* sendemailurl) {
  if (sendemailurl_ != &::google::protobuf::internal::kEmptyString) {
    delete sendemailurl_;
  }
  if (sendemailurl) {
    set_has_sendemailurl();
    sendemailurl_ = sendemailurl;
  } else {
    clear_has_sendemailurl();
    sendemailurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sendEmailPort = 94;
inline bool pbNFServerConfig::has_sendemailport() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void pbNFServerConfig::set_has_sendemailport() {
  _has_bits_[0] |= 0x80000000u;
}
inline void pbNFServerConfig::clear_has_sendemailport() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void pbNFServerConfig::clear_sendemailport() {
  if (sendemailport_ != &::google::protobuf::internal::kEmptyString) {
    sendemailport_->clear();
  }
  clear_has_sendemailport();
}
inline const ::std::string& pbNFServerConfig::sendemailport() const {
  return *sendemailport_;
}
inline void pbNFServerConfig::set_sendemailport(const ::std::string& value) {
  set_has_sendemailport();
  if (sendemailport_ == &::google::protobuf::internal::kEmptyString) {
    sendemailport_ = new ::std::string;
  }
  sendemailport_->assign(value);
}
inline void pbNFServerConfig::set_sendemailport(const char* value) {
  set_has_sendemailport();
  if (sendemailport_ == &::google::protobuf::internal::kEmptyString) {
    sendemailport_ = new ::std::string;
  }
  sendemailport_->assign(value);
}
inline void pbNFServerConfig::set_sendemailport(const char* value, size_t size) {
  set_has_sendemailport();
  if (sendemailport_ == &::google::protobuf::internal::kEmptyString) {
    sendemailport_ = new ::std::string;
  }
  sendemailport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_sendemailport() {
  set_has_sendemailport();
  if (sendemailport_ == &::google::protobuf::internal::kEmptyString) {
    sendemailport_ = new ::std::string;
  }
  return sendemailport_;
}
inline ::std::string* pbNFServerConfig::release_sendemailport() {
  clear_has_sendemailport();
  if (sendemailport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendemailport_;
    sendemailport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_sendemailport(::std::string* sendemailport) {
  if (sendemailport_ != &::google::protobuf::internal::kEmptyString) {
    delete sendemailport_;
  }
  if (sendemailport) {
    set_has_sendemailport();
    sendemailport_ = sendemailport;
  } else {
    clear_has_sendemailport();
    sendemailport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string recvEmail = 95;
inline bool pbNFServerConfig::has_recvemail() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void pbNFServerConfig::set_has_recvemail() {
  _has_bits_[1] |= 0x00000001u;
}
inline void pbNFServerConfig::clear_has_recvemail() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void pbNFServerConfig::clear_recvemail() {
  if (recvemail_ != &::google::protobuf::internal::kEmptyString) {
    recvemail_->clear();
  }
  clear_has_recvemail();
}
inline const ::std::string& pbNFServerConfig::recvemail() const {
  return *recvemail_;
}
inline void pbNFServerConfig::set_recvemail(const ::std::string& value) {
  set_has_recvemail();
  if (recvemail_ == &::google::protobuf::internal::kEmptyString) {
    recvemail_ = new ::std::string;
  }
  recvemail_->assign(value);
}
inline void pbNFServerConfig::set_recvemail(const char* value) {
  set_has_recvemail();
  if (recvemail_ == &::google::protobuf::internal::kEmptyString) {
    recvemail_ = new ::std::string;
  }
  recvemail_->assign(value);
}
inline void pbNFServerConfig::set_recvemail(const char* value, size_t size) {
  set_has_recvemail();
  if (recvemail_ == &::google::protobuf::internal::kEmptyString) {
    recvemail_ = new ::std::string;
  }
  recvemail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_recvemail() {
  set_has_recvemail();
  if (recvemail_ == &::google::protobuf::internal::kEmptyString) {
    recvemail_ = new ::std::string;
  }
  return recvemail_;
}
inline ::std::string* pbNFServerConfig::release_recvemail() {
  clear_has_recvemail();
  if (recvemail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recvemail_;
    recvemail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_recvemail(::std::string* recvemail) {
  if (recvemail_ != &::google::protobuf::internal::kEmptyString) {
    delete recvemail_;
  }
  if (recvemail) {
    set_has_recvemail();
    recvemail_ = recvemail;
  } else {
    clear_has_recvemail();
    recvemail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string wxWorkdRobot = 96;
inline bool pbNFServerConfig::has_wxworkdrobot() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void pbNFServerConfig::set_has_wxworkdrobot() {
  _has_bits_[1] |= 0x00000002u;
}
inline void pbNFServerConfig::clear_has_wxworkdrobot() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void pbNFServerConfig::clear_wxworkdrobot() {
  if (wxworkdrobot_ != &::google::protobuf::internal::kEmptyString) {
    wxworkdrobot_->clear();
  }
  clear_has_wxworkdrobot();
}
inline const ::std::string& pbNFServerConfig::wxworkdrobot() const {
  return *wxworkdrobot_;
}
inline void pbNFServerConfig::set_wxworkdrobot(const ::std::string& value) {
  set_has_wxworkdrobot();
  if (wxworkdrobot_ == &::google::protobuf::internal::kEmptyString) {
    wxworkdrobot_ = new ::std::string;
  }
  wxworkdrobot_->assign(value);
}
inline void pbNFServerConfig::set_wxworkdrobot(const char* value) {
  set_has_wxworkdrobot();
  if (wxworkdrobot_ == &::google::protobuf::internal::kEmptyString) {
    wxworkdrobot_ = new ::std::string;
  }
  wxworkdrobot_->assign(value);
}
inline void pbNFServerConfig::set_wxworkdrobot(const char* value, size_t size) {
  set_has_wxworkdrobot();
  if (wxworkdrobot_ == &::google::protobuf::internal::kEmptyString) {
    wxworkdrobot_ = new ::std::string;
  }
  wxworkdrobot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_wxworkdrobot() {
  set_has_wxworkdrobot();
  if (wxworkdrobot_ == &::google::protobuf::internal::kEmptyString) {
    wxworkdrobot_ = new ::std::string;
  }
  return wxworkdrobot_;
}
inline ::std::string* pbNFServerConfig::release_wxworkdrobot() {
  clear_has_wxworkdrobot();
  if (wxworkdrobot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wxworkdrobot_;
    wxworkdrobot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_wxworkdrobot(::std::string* wxworkdrobot) {
  if (wxworkdrobot_ != &::google::protobuf::internal::kEmptyString) {
    delete wxworkdrobot_;
  }
  if (wxworkdrobot) {
    set_has_wxworkdrobot();
    wxworkdrobot_ = wxworkdrobot;
  } else {
    clear_has_wxworkdrobot();
    wxworkdrobot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 MaxOnlinePlayerNum = 100;
inline bool pbNFServerConfig::has_maxonlineplayernum() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void pbNFServerConfig::set_has_maxonlineplayernum() {
  _has_bits_[1] |= 0x00000004u;
}
inline void pbNFServerConfig::clear_has_maxonlineplayernum() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void pbNFServerConfig::clear_maxonlineplayernum() {
  maxonlineplayernum_ = 0u;
  clear_has_maxonlineplayernum();
}
inline ::google::protobuf::uint32 pbNFServerConfig::maxonlineplayernum() const {
  return maxonlineplayernum_;
}
inline void pbNFServerConfig::set_maxonlineplayernum(::google::protobuf::uint32 value) {
  set_has_maxonlineplayernum();
  maxonlineplayernum_ = value;
}

// optional uint32 HeartBeatTimeout = 101;
inline bool pbNFServerConfig::has_heartbeattimeout() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void pbNFServerConfig::set_has_heartbeattimeout() {
  _has_bits_[1] |= 0x00000008u;
}
inline void pbNFServerConfig::clear_has_heartbeattimeout() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void pbNFServerConfig::clear_heartbeattimeout() {
  heartbeattimeout_ = 0u;
  clear_has_heartbeattimeout();
}
inline ::google::protobuf::uint32 pbNFServerConfig::heartbeattimeout() const {
  return heartbeattimeout_;
}
inline void pbNFServerConfig::set_heartbeattimeout(::google::protobuf::uint32 value) {
  set_has_heartbeattimeout();
  heartbeattimeout_ = value;
}

// optional uint32 ClientKeepAliveTimeout = 102;
inline bool pbNFServerConfig::has_clientkeepalivetimeout() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void pbNFServerConfig::set_has_clientkeepalivetimeout() {
  _has_bits_[1] |= 0x00000010u;
}
inline void pbNFServerConfig::clear_has_clientkeepalivetimeout() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void pbNFServerConfig::clear_clientkeepalivetimeout() {
  clientkeepalivetimeout_ = 0u;
  clear_has_clientkeepalivetimeout();
}
inline ::google::protobuf::uint32 pbNFServerConfig::clientkeepalivetimeout() const {
  return clientkeepalivetimeout_;
}
inline void pbNFServerConfig::set_clientkeepalivetimeout(::google::protobuf::uint32 value) {
  set_has_clientkeepalivetimeout();
  clientkeepalivetimeout_ = value;
}

// optional uint32 ClientVersion = 103;
inline bool pbNFServerConfig::has_clientversion() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void pbNFServerConfig::set_has_clientversion() {
  _has_bits_[1] |= 0x00000020u;
}
inline void pbNFServerConfig::clear_has_clientversion() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void pbNFServerConfig::clear_clientversion() {
  clientversion_ = 0u;
  clear_has_clientversion();
}
inline ::google::protobuf::uint32 pbNFServerConfig::clientversion() const {
  return clientversion_;
}
inline void pbNFServerConfig::set_clientversion(::google::protobuf::uint32 value) {
  set_has_clientversion();
  clientversion_ = value;
}

// -------------------------------------------------------------------

// wxWorkRobotText

// optional string content = 1;
inline bool wxWorkRobotText::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void wxWorkRobotText::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void wxWorkRobotText::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void wxWorkRobotText::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& wxWorkRobotText::content() const {
  return *content_;
}
inline void wxWorkRobotText::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void wxWorkRobotText::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void wxWorkRobotText::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* wxWorkRobotText::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* wxWorkRobotText::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void wxWorkRobotText::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string mentioned_list = 2;
inline int wxWorkRobotText::mentioned_list_size() const {
  return mentioned_list_.size();
}
inline void wxWorkRobotText::clear_mentioned_list() {
  mentioned_list_.Clear();
}
inline const ::std::string& wxWorkRobotText::mentioned_list(int index) const {
  return mentioned_list_.Get(index);
}
inline ::std::string* wxWorkRobotText::mutable_mentioned_list(int index) {
  return mentioned_list_.Mutable(index);
}
inline void wxWorkRobotText::set_mentioned_list(int index, const ::std::string& value) {
  mentioned_list_.Mutable(index)->assign(value);
}
inline void wxWorkRobotText::set_mentioned_list(int index, const char* value) {
  mentioned_list_.Mutable(index)->assign(value);
}
inline void wxWorkRobotText::set_mentioned_list(int index, const char* value, size_t size) {
  mentioned_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* wxWorkRobotText::add_mentioned_list() {
  return mentioned_list_.Add();
}
inline void wxWorkRobotText::add_mentioned_list(const ::std::string& value) {
  mentioned_list_.Add()->assign(value);
}
inline void wxWorkRobotText::add_mentioned_list(const char* value) {
  mentioned_list_.Add()->assign(value);
}
inline void wxWorkRobotText::add_mentioned_list(const char* value, size_t size) {
  mentioned_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
wxWorkRobotText::mentioned_list() const {
  return mentioned_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
wxWorkRobotText::mutable_mentioned_list() {
  return &mentioned_list_;
}

// repeated string mentioned_mobile_list = 3;
inline int wxWorkRobotText::mentioned_mobile_list_size() const {
  return mentioned_mobile_list_.size();
}
inline void wxWorkRobotText::clear_mentioned_mobile_list() {
  mentioned_mobile_list_.Clear();
}
inline const ::std::string& wxWorkRobotText::mentioned_mobile_list(int index) const {
  return mentioned_mobile_list_.Get(index);
}
inline ::std::string* wxWorkRobotText::mutable_mentioned_mobile_list(int index) {
  return mentioned_mobile_list_.Mutable(index);
}
inline void wxWorkRobotText::set_mentioned_mobile_list(int index, const ::std::string& value) {
  mentioned_mobile_list_.Mutable(index)->assign(value);
}
inline void wxWorkRobotText::set_mentioned_mobile_list(int index, const char* value) {
  mentioned_mobile_list_.Mutable(index)->assign(value);
}
inline void wxWorkRobotText::set_mentioned_mobile_list(int index, const char* value, size_t size) {
  mentioned_mobile_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* wxWorkRobotText::add_mentioned_mobile_list() {
  return mentioned_mobile_list_.Add();
}
inline void wxWorkRobotText::add_mentioned_mobile_list(const ::std::string& value) {
  mentioned_mobile_list_.Add()->assign(value);
}
inline void wxWorkRobotText::add_mentioned_mobile_list(const char* value) {
  mentioned_mobile_list_.Add()->assign(value);
}
inline void wxWorkRobotText::add_mentioned_mobile_list(const char* value, size_t size) {
  mentioned_mobile_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
wxWorkRobotText::mentioned_mobile_list() const {
  return mentioned_mobile_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
wxWorkRobotText::mutable_mentioned_mobile_list() {
  return &mentioned_mobile_list_;
}

// -------------------------------------------------------------------

// wxWorkRobotHttpPost

// optional string msgtype = 1;
inline bool wxWorkRobotHttpPost::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void wxWorkRobotHttpPost::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void wxWorkRobotHttpPost::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void wxWorkRobotHttpPost::clear_msgtype() {
  if (msgtype_ != &::google::protobuf::internal::kEmptyString) {
    msgtype_->clear();
  }
  clear_has_msgtype();
}
inline const ::std::string& wxWorkRobotHttpPost::msgtype() const {
  return *msgtype_;
}
inline void wxWorkRobotHttpPost::set_msgtype(const ::std::string& value) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::kEmptyString) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(value);
}
inline void wxWorkRobotHttpPost::set_msgtype(const char* value) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::kEmptyString) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(value);
}
inline void wxWorkRobotHttpPost::set_msgtype(const char* value, size_t size) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::kEmptyString) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* wxWorkRobotHttpPost::mutable_msgtype() {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::kEmptyString) {
    msgtype_ = new ::std::string;
  }
  return msgtype_;
}
inline ::std::string* wxWorkRobotHttpPost::release_msgtype() {
  clear_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgtype_;
    msgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void wxWorkRobotHttpPost::set_allocated_msgtype(::std::string* msgtype) {
  if (msgtype_ != &::google::protobuf::internal::kEmptyString) {
    delete msgtype_;
  }
  if (msgtype) {
    set_has_msgtype();
    msgtype_ = msgtype;
  } else {
    clear_has_msgtype();
    msgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto_ff.wxWorkRobotText text = 2;
inline bool wxWorkRobotHttpPost::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void wxWorkRobotHttpPost::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void wxWorkRobotHttpPost::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void wxWorkRobotHttpPost::clear_text() {
  if (text_ != NULL) text_->::proto_ff::wxWorkRobotText::Clear();
  clear_has_text();
}
inline const ::proto_ff::wxWorkRobotText& wxWorkRobotHttpPost::text() const {
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::proto_ff::wxWorkRobotText* wxWorkRobotHttpPost::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::proto_ff::wxWorkRobotText;
  return text_;
}
inline ::proto_ff::wxWorkRobotText* wxWorkRobotHttpPost::release_text() {
  clear_has_text();
  ::proto_ff::wxWorkRobotText* temp = text_;
  text_ = NULL;
  return temp;
}
inline void wxWorkRobotHttpPost::set_allocated_text(::proto_ff::wxWorkRobotText* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::NF_SERVER_TYPE>() {
  return ::proto_ff::NF_SERVER_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_5fcommon_2eproto__INCLUDED
