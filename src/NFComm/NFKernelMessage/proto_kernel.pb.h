// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto_kernel.proto

#ifndef PROTOBUF_proto_5fkernel_2eproto__INCLUDED
#define PROTOBUF_proto_5fkernel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "yd_fieldoptions.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_5fkernel_2eproto();
void protobuf_AssignDesc_proto_5fkernel_2eproto();
void protobuf_ShutdownFile_proto_5fkernel_2eproto();

class Proto_DispInfo;
class Proto_StoreInfo_CB;
class Proto_StoreInfo;
class Proto_EventInfo;
class Proto_ScriptRpcResult;
class Proto_RpcInfo;
class Proto_RedirectInfo;
class Proto_SvrPkg;
class ServerInfoReport;
class ServerInfoReportList;
class ServerInfoReportListRespne;
class ZkServerInfo;
class DynLibFileInfo;
class DynLibFileInfoArray;
class Proto_KillAllServerNtf;
class Proto_KillAllServerRsp;
class Proto_STSBroadPlayerMsgNotify;
class Proto_STWebMsgRspNotify;
class BehaviorLogHeader;
class NFEventNoneData;
class NFEventScriptData;
class Proto_ServerDumpInfoNtf;

enum Proto_Kernel_CMD {
  NF_SERVER_TO_SERVER_HEART_BEAT = 5001,
  NF_SERVER_TO_SERVER_HEART_BEAT_RSP = 5002,
  NF_SERVER_TO_SERVER_BUS_CONNECT_REQ = 5003,
  NF_SERVER_TO_SERVER_BUS_CONNECT_RSP = 5004,
  NF_GTM_KILL_ALL_SERVER_NTF = 5050,
  NF_STS_KILL_ALL_SERVER_NTF = 5051,
  NF_STS_SEND_DUMP_INFO_NTF = 5052,
  NF_MasterTMonitor_RELOAD_CMD_REQ = 5080,
  NF_MasterTMonitor_RESTART_CMD_REQ = 5081,
  NF_MasterTMonitor_START_CMD_REQ = 5082,
  NF_MasterTMonitor_STOP_CMD_REQ = 5083,
  NF_MasterTMonitor_STOP_ALL_CMD_REQ = 5084,
  NF_MasterTMonitor_RELOAD_ALL_CMD_REQ = 5085,
  NF_MasterTMonitor_RESTART_ALL_CMD_REQ = 5086,
  NF_MasterTMonitor_START_ALL_CMD_REQ = 5087,
  NF_MonitorTMaster_RELOAD_CMD_RSP = 5090,
  NF_MonitorTMaster_RESTART_CMD_RSP = 5091,
  NF_MonitorTMaster_START_CMD_RSP = 5092,
  NF_MonitorTMaster_STOP_CMD_RSP = 5093,
  NF_MonitorTMaster_STOP_ALL_CMD_RSP = 5094,
  NF_MonitorTMaster_RELOAD_ALL_CMD_RSP = 5095,
  NF_MonitorTMaster_RESTART_ALL_CMD_RSP = 5096,
  NF_MonitorTMaster_START_ALL_CMD_RSP = 5097,
  NF_SERVER_TO_SERVER_REGISTER = 5100,
  NF_SERVER_TO_SERVER_REGISTER_RSP = 5101,
  NF_MASTER_SERVER_SEND_OTHERS_TO_SERVER = 5102,
  NF_SERVER_TO_MASTER_SERVER_REPORT = 5103,
  NF_ROUTER_CMD_INTERNAL_C2R_REGISTER = 5104,
  NF_ROUTER_CMD_INTERNAL_R2C_REGISTER = 5105,
  NF_ROUTER_CMD_INTERNAL_C2R_HEARTBEAT = 5106,
  NF_ROUTER_CMD_INTERNAL_R2C_HEARTBEAT = 5107,
  NF_ROUTER_CMD_DISPATCH_MOD = 5108,
  NF_ROUTER_CMD_DISPATCH_ROUNDROBIN = 5109,
  NF_ROUTER_CMD_DISPATCH_BROADCAST = 5110,
  NF_ROUTER_CMD_DISPATCH_BROADCAST_AND_MASTER = 5111,
  NF_ROUTER_CMD_DISPATCH_BORADCAST_MASTER = 5112,
  NF_ROUTER_CMD_DISPATCH_BORADCAST_SLAVE = 5113,
  NF_ROUTER_CMD_DISPATCH_DIRECT = 5114,
  NF_ROUTER_CMD_INTERNAL_R2C_DISPATCHFAILED = 5115,
  NF_ROUTER_CMD_INTERNAL_C2R_REG_RAASSOCAPPSVS = 5116,
  NF_SERVER_TO_SERVER_RPC_CMD = 5119,
  NF_SERVER_TO_SERVER_TRANS_CMD = 5120,
  NF_SERVER_TO_STORE_SERVER_DB_CMD = 5121,
  NF_STORE_SERVER_TO_SERVER_DB_CMD = 5122,
  NF_WORLD_ROUTER_CMD_TO_SUIT_LOGIC = 5123,
  NF_SNS_ROUTER_CMD_TO_SUIT_LOGIC = 5124,
  NF_STS_BROAD_PLAYER_MSG_NOTIFY = 5125,
  NF_SEVER_TO_WEB_SERVER_RSP_NOTIFY = 5126,
  NF_SERVER_BROAD_EVENT_TO_SERVER_CMD = 5127,
  NF_SERVER_REDIRECT_MSG_TO_PROXY_SERVER_CMD = 5128,
  NF_SERVER_TO_SERVER_REGISTER_ROOM_INFO_RPC = 5129,
  NF_STORESVR_C2S_SELECT = 5200,
  NF_STORESVR_S2C_SELECT = 5201,
  NF_STORESVR_C2S_SELECTOBJ = 5202,
  NF_STORESVR_S2C_SELECTOBJ = 5203,
  NF_STORESVR_C2S_INSERT = 5204,
  NF_STORESVR_S2C_INSERT = 5205,
  NF_STORESVR_C2S_INSERTOBJ = 5206,
  NF_STORESVR_S2C_INSERTOBJ = 5207,
  NF_STORESVR_C2S_DELETE = 5208,
  NF_STORESVR_S2C_DELETE = 5209,
  NF_STORESVR_C2S_DELETEOBJ = 5210,
  NF_STORESVR_S2C_DELETEOBJ = 5211,
  NF_STORESVR_C2S_MODIFY = 5212,
  NF_STORESVR_S2C_MODIFY = 5213,
  NF_STORESVR_C2S_MODIFYOBJ = 5214,
  NF_STORESVR_S2C_MODIFYOBJ = 5215,
  NF_STORESVR_C2S_UPDATE = 5216,
  NF_STORESVR_S2C_UPDATE = 5217,
  NF_STORESVR_C2S_UPDATEOBJ = 5218,
  NF_STORESVR_S2C_UPDATEOBJ = 5219,
  NF_STORESVR_C2S_DESCSTORE = 5220,
  NF_STORESVR_S2C_DESCSTORE = 5221,
  NF_STORESVR_C2S_EXECUTE = 5222,
  NF_STORESVR_S2C_EXECUTE = 5223,
  NF_STORESVR_C2S_EXECUTE_MORE = 5224,
  NF_STORESVR_S2C_EXECUTE_MORE = 5225
};
bool Proto_Kernel_CMD_IsValid(int value);
const Proto_Kernel_CMD Proto_Kernel_CMD_MIN = NF_SERVER_TO_SERVER_HEART_BEAT;
const Proto_Kernel_CMD Proto_Kernel_CMD_MAX = NF_STORESVR_S2C_EXECUTE_MORE;
const int Proto_Kernel_CMD_ARRAYSIZE = Proto_Kernel_CMD_MAX + 1;

const ::google::protobuf::EnumDescriptor* Proto_Kernel_CMD_descriptor();
inline const ::std::string& Proto_Kernel_CMD_Name(Proto_Kernel_CMD value) {
  return ::google::protobuf::internal::NameOfEnum(
    Proto_Kernel_CMD_descriptor(), value);
}
inline bool Proto_Kernel_CMD_Parse(
    const ::std::string& name, Proto_Kernel_CMD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Proto_Kernel_CMD>(
    Proto_Kernel_CMD_descriptor(), name, value);
}
enum PacketDispType {
  E_DISP_TYPE_NONE = 0,
  E_DISP_TYPE_BY_TRANSACTION = 1,
  E_DISP_TYPE_BY_ROLEID = 2,
  E_DISP_TYPE_BY_MSGID = 3,
  E_DISP_TYPE_BY_RPC = 4
};
bool PacketDispType_IsValid(int value);
const PacketDispType PacketDispType_MIN = E_DISP_TYPE_NONE;
const PacketDispType PacketDispType_MAX = E_DISP_TYPE_BY_RPC;
const int PacketDispType_ARRAYSIZE = PacketDispType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PacketDispType_descriptor();
inline const ::std::string& PacketDispType_Name(PacketDispType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PacketDispType_descriptor(), value);
}
inline bool PacketDispType_Parse(
    const ::std::string& name, PacketDispType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PacketDispType>(
    PacketDispType_descriptor(), name, value);
}
enum EServerState {
  EST_INIT = 0,
  EST_NARMAL = 1,
  EST_BUSY = 2,
  EST_CRASH = 3
};
bool EServerState_IsValid(int value);
const EServerState EServerState_MIN = EST_INIT;
const EServerState EServerState_MAX = EST_CRASH;
const int EServerState_ARRAYSIZE = EServerState_MAX + 1;

const ::google::protobuf::EnumDescriptor* EServerState_descriptor();
inline const ::std::string& EServerState_Name(EServerState value) {
  return ::google::protobuf::internal::NameOfEnum(
    EServerState_descriptor(), value);
}
inline bool EServerState_Parse(
    const ::std::string& name, EServerState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EServerState>(
    EServerState_descriptor(), name, value);
}
enum Proto_Kernel_ErrorCode {
  ERR_CODE_SVR_OK = 0,
  ERR_CODE_SVR_SYSTEM_ERROR = -1,
  ERR_CODE_SVR_SYSTEM_TIMEOUT = -2,
  ERR_CODE_SVR_SYSTEM_DATABASE_ERROR = -3,
  ERR_CODE_MSG_RPC_BASE = -100,
  ERR_CODE_RPC_INVALID_PARAM = -101,
  ERR_CODE_RPC_ENCODE_FAILED = -102,
  ERR_CODE_RPC_DECODE_FAILED = -103,
  ERR_CODE_RPC_RECV_EXCEPTION_MSG = -104,
  ERR_CODE_RPC_UNKNOWN_TYPE = -105,
  ERR_CODE_RPC_UNSUPPORT_FUNCTION_NAME = -106,
  ERR_CODE_RPC_SESSION_NOT_FOUND = -107,
  ERR_CODE_RPC_SEND_FAILED = -108,
  ERR_CODE_RPC_REQUEST_TIMEOUT = -109,
  ERR_CODE_RPC_FUNCTION_NAME_EXISTED = -110,
  ERR_CODE_RPC_SYSTEM_ERROR = -111,
  ERR_CODE_RPC_PROCESS_TIMEOUT = -112,
  ERR_CODE_RPC_MSG_FUNCTION_UNEXISTED = -113,
  ERR_CODE_RPC_SYSTEM_OVERLOAD_BASE = -114,
  ERR_CODE_RPC_MESSAGE_EXPIRED = -115,
  ERR_CODE_RPC_TASK_OVERLOAD = -116,
  ERR_CODE_RPC_CO_USED = -117,
  ERR_CODE_ZK_SYSTEMERROR = -200,
  ERR_CODE_ZK_RUNTIMEINCONSISTENCY = -201,
  ERR_CODE_ZK_DATAINCONSISTENCY = -203,
  ERR_CODE_ZK_CONNECTIONLOSS = -204,
  ERR_CODE_ZK_MARSHALLINGERROR = -205,
  ERR_CODE_ZK_UNIMPLEMENTED = -206,
  ERR_CODE_ZK_OPERATIONTIMEOUT = -207,
  ERR_CODE_ZK_BADARGUMENTS = -208,
  ERR_CODE_ZK_INVALIDSTATE = -209,
  ERR_CODE_kSM_DNSFAILURE = -210,
  ERR_CODE_ZK_APIERROR = -211,
  ERR_CODE_ZK_NONODE = -212,
  ERR_CODE_ZK_NOAUTH = -213,
  ERR_CODE_ZK_BADVERSION = -214,
  ERR_CODE_ZK_NOCHILDRENFOREPHEMERALS = -215,
  ERR_CODE_ZK_NODEEXISTS = -216,
  ERR_CODE_ZK_NOTEMPTY = -217,
  ERR_CODE_ZK_SESSIONEXPIRED = -218,
  ERR_CODE_ZK_INVALIDCALLBACK = -219,
  ERR_CODE_ZK_INVALIDACL = -220,
  ERR_CODE_ZK_AUTHFAILED = -221,
  ERR_CODE_ZK_CLOSING = -222,
  ERR_CODE_ZK_NOTHING = -223,
  ERR_CODE_ZK_SESSIONMOVED = -224,
  ERR_CODE_ZK_NOQUOTA = -225,
  ERR_CODE_ZK_SERVEROVERLOAD = -226,
  ERR_CODE_ZK_NOT_SET_APPKEY = -227,
  ERR_CODE_MESSAGE_BASE = -300,
  ERR_CODE_NAMING_BASE = -400,
  ERR_CODE_NAMING_NOT_SUPPORTTED = -401,
  ERR_CODE_NAMING_INVAILD_PARAM = -402,
  ERR_CODE_NAMING_URL_REGISTERED = -403,
  ERR_CODE_NAMING_URL_NOT_BINDED = -404,
  ERR_CODE_NAMING_REGISTER_FAILED = -405,
  ERR_CODE_NAMING_FACTORY_MAP_NULL = -406,
  ERR_CODE_NAMING_FACTORY_EXISTED = -407,
  ERR_CODE_ROUTER_BASE = -500,
  ERR_CODE_ROUTER_NOT_SUPPORTTED = -501,
  ERR_CODE_ROUTER_INVAILD_PARAM = -502,
  ERR_CODE_ROUTER_NONE_VALID_HANDLE = -503,
  ERR_CODE_ROUTER_FACTORY_MAP_NULL = -504,
  ERR_CODE_ROUTER_FACTORY_EXISTED = -505,
  NF_CODE_ROUTER_DISPATCHFAILD_DESTSVR_NOTEXIST = -506,
  ERR_CODE_TIMER_BASE = -600,
  ERR_CODE_STORESVR_ERRCODE_BUSY = -701,
  ERR_CODE_STORESVR_ERRCODE_EINVAL = -702,
  ERR_CODE_STORESVR_ERRCODE_PARSEFROMSTRINGFAILED = -703,
  ERR_CODE_STORESVR_ERRCODE_DBNAME_OR_MODKEY_INVALID = -704,
  ERR_CODE_STORESVR_ERRCODE_TBNAME_INVALID = -705,
  ERR_CODE_STORESVR_ERRCODE_SELECT_EMPTY = -706,
  ERR_CODE_STORESVR_ERRCODE_SELECT_FILLMESSAGEBYRESULTFAILED = -707,
  ERR_CODE_STORESVR_ERRCODE_SELECTFAILED = -708,
  ERR_CODE_STORESVR_ERRCODE_INSERTFAILED = -711,
  ERR_CODE_STORESVR_ERRCODE_DELETEFAILED = -712,
  ERR_CODE_STORESVR_ERRCODE_DELETERECORDISNOTEXIST = -713,
  ERR_CODE_STORESVR_ERRCODE_UPDATERECORDISNOTEXIST = -714,
  ERR_CODE_STORESVR_ERRCODE_UPDATENOROWAFFECTED = -715,
  ERR_CODE_STORESVR_ERRCODE_UPDATEFAILED = -716,
  ERR_CODE_STORESVR_ERRCODE_UPDATEINSERTFAILED = -717,
  ERR_CODE_STORESVR_ERRCODE_UNKNOWN = -718,
  ERR_CODE_CO_INVALID_PARAM = -801,
  ERR_CODE_CO_NOT_IN_COROUTINE = -802,
  ERR_CODE_CO_NOT_RUNNING = -803,
  ERR_CODE_CO_START_TIMER_FAILED = -804,
  ERR_CODE_CO_TIMEOUT = -805,
  ERR_CODE_CO_CANNOT_RESUME_IN_COROUTINE = -806,
  ERR_CODE_CO_COROUTINE_UNEXIST = -807,
  ERR_CODE_CO_COROUTINE_STATUS_ERROR = -809,
  ERR_CODE_NFBUS_ERR_PARAMS = -901,
  ERR_CODE_NFBUS_ERR_INNER = -902,
  ERR_CODE_NFBUS_ERR_NO_DATA = -903,
  ERR_CODE_NFBUS_ERR_BUFF_LIMIT = -904,
  ERR_CODE_NFBUS_ERR_MALLOC = -905,
  ERR_CODE_NFBUS_ERR_SCHEME = -906,
  ERR_CODE_NFBUS_ERR_BAD_DATA = -907,
  ERR_CODE_NFBUS_ERR_INVALID_SIZE = -908,
  ERR_CODE_NFBUS_ERR_NOT_INITED = -909,
  ERR_CODE_NFBUS_ERR_ALREADY_INITED = -910,
  ERR_CODE_NFBUS_ERR_ACCESS_DENY = -911,
  ERR_CODE_NFBUS_ERR_UNPACK = -912,
  ERR_CODE_NFBUS_ERR_PACK = -913,
  ERR_CODE_NFBUS_ERR_NFNODE_NOT_FOUND = -920,
  ERR_CODE_NFBUS_ERR_NFNODE_INVALID_ID = -901,
  ERR_CODE_NFBUS_ERR_NFNODE_NO_CONNECTION = -903,
  ERR_CODE_NFBUS_ERR_NFNODE_FAULT_TOLERANT = -904,
  ERR_CODE_NFBUS_ERR_NFNODE_INVALID_MSG = -905,
  ERR_CODE_NFBUS_ERR_NFNODE_BUS_ID_NOT_MNFCH = -906,
  ERR_CODE_NFBUS_ERR_NFNODE_TTL = -907,
  ERR_CODE_NFBUS_ERR_NFNODE_MASK_CONFLICT = -908,
  ERR_CODE_NFBUS_ERR_NFNODE_ID_CONFLICT = -909,
  ERR_CODE_NFBUS_ERR_NFNODE_SRC_DST_IS_SAME = -910,
  ERR_CODE_NFBUS_ERR_CHANNEL_SIZE_TOO_SMALL = -911,
  ERR_CODE_NFBUS_ERR_CHANNEL_BUFFER_INVALID = -912,
  ERR_CODE_NFBUS_ERR_CHANNEL_ADDR_INVALID = -913,
  ERR_CODE_NFBUS_ERR_CHANNEL_CLOSING = -914,
  ERR_CODE_NFBUS_ERR_CHANNEL_NOT_SUPPORT = -915,
  ERR_CODE_NFBUS_ERR_CHANNEL_UNSUPPORTED_VERSION = -916,
  ERR_CODE_NFBUS_ERR_CHANNEL_ALIGN_SIZE_MISMATCH = -917,
  ERR_CODE_NFBUS_ERR_CHANNEL_ARCH_SIZE_T_MISMATCH = -918,
  ERR_CODE_NFBUS_ERR_NODE_BAD_BLOCK_NODE_NUM = -930,
  ERR_CODE_NFBUS_ERR_NODE_BAD_BLOCK_BUFF_SIZE = -940,
  ERR_CODE_NFBUS_ERR_NODE_BAD_BLOCK_WSEQ_ID = -950,
  ERR_CODE_NFBUS_ERR_NODE_BAD_BLOCK_CSEQ_ID = -960,
  ERR_CODE_NFBUS_ERR_NODE_TIMEOUT = -970,
  ERR_CODE_NFBUS_ERR_SHM_GET_FAILED = -980,
  ERR_CODE_NFBUS_ERR_SHM_NOT_FOUND = -981,
  ERR_CODE_NFBUS_ERR_SHM_CLOSE_FAILED = -982,
  ERR_CODE_NFBUS_ERR_SHM_PATH_INVALID = -983,
  ERR_CODE_NFBUS_ERR_SHM_MAP_FAILED = -984,
  ERR_CODE_NFBUS_ERR_SOCK_BIND_FAILED = -990,
  ERR_CODE_NFBUS_ERR_SOCK_LISTEN_FAILED = -991,
  ERR_CODE_NFBUS_ERR_SOCK_CONNECT_FAILED = -992,
  ERR_CODE_NFBUS_ERR_PIPE_BIND_FAILED = -1000,
  ERR_CODE_NFBUS_ERR_PIPE_LISTEN_FAILED = -1001,
  ERR_CODE_NFBUS_ERR_PIPE_CONNECT_FAILED = -1002,
  ERR_CODE_NFBUS_ERR_PIPE_ADDR_TOO_LONG = -1003,
  ERR_CODE_NFBUS_ERR_PIPE_REMOVE_FAILED = -1004,
  ERR_CODE_NFBUS_ERR_DNS_GETADDR_FAILED = -1010,
  ERR_CODE_NFBUS_ERR_CONNECTION_NOT_FOUND = -1011,
  ERR_CODE_NFBUS_ERR_WRITE_FAILED = -1012,
  ERR_CODE_NFBUS_ERR_READ_FAILED = -1013,
  ERR_CODE_NFBUS_ERR_EV_RUN = -1015,
  ERR_CODE_NFBUS_ERR_NO_LISTEN = -1015,
  ERR_CODE_NFBUS_ERR_CLOSING = -1016
};
bool Proto_Kernel_ErrorCode_IsValid(int value);
const Proto_Kernel_ErrorCode Proto_Kernel_ErrorCode_MIN = ERR_CODE_NFBUS_ERR_CLOSING;
const Proto_Kernel_ErrorCode Proto_Kernel_ErrorCode_MAX = ERR_CODE_SVR_OK;
const int Proto_Kernel_ErrorCode_ARRAYSIZE = Proto_Kernel_ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Proto_Kernel_ErrorCode_descriptor();
inline const ::std::string& Proto_Kernel_ErrorCode_Name(Proto_Kernel_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Proto_Kernel_ErrorCode_descriptor(), value);
}
inline bool Proto_Kernel_ErrorCode_Parse(
    const ::std::string& name, Proto_Kernel_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Proto_Kernel_ErrorCode>(
    Proto_Kernel_ErrorCode_descriptor(), name, value);
}
enum NFEventSrcType {
  NF_EVENT_NONE_TYPE = 0,
  NF_EVENT_SERVER_TYPE = 1,
  NF_EVENT_GM_TYPE = 2,
  NF_EVENT_PLAYER_TYPE = 4
};
bool NFEventSrcType_IsValid(int value);
const NFEventSrcType NFEventSrcType_MIN = NF_EVENT_NONE_TYPE;
const NFEventSrcType NFEventSrcType_MAX = NF_EVENT_PLAYER_TYPE;
const int NFEventSrcType_ARRAYSIZE = NFEventSrcType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NFEventSrcType_descriptor();
inline const ::std::string& NFEventSrcType_Name(NFEventSrcType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NFEventSrcType_descriptor(), value);
}
inline bool NFEventSrcType_Parse(
    const ::std::string& name, NFEventSrcType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NFEventSrcType>(
    NFEventSrcType_descriptor(), name, value);
}
enum NFEventIdType {
  NF_EVENT_SERVER_TYPE_BEGIN = 1,
  NF_EVENT_SERVER_TASK_GROUP_FINISH = 2,
  NF_EVENT_SERVER_APP_FINISH_INITED = 5,
  NF_EVENT_SERVER_DEAD_EVENT = 6,
  NF_EVENT_GAME_SERVER_DUMP_EVENT = 8,
  NF_EVENT_LOGIC_SERVER_DUMP_EVENT = 9,
  NF_EVENT_SERVER_TYPE_END = 99,
  NF_EVENT_GM_TYPE_BEGIN = 100,
  NF_EVENT_GM_TYPE_END = 199,
  NF_EVENT_PLAYER_TYPE_BEGIN = 200,
  NF_EVENT_PLAYER_LOGIN_SUCCESS = 201,
  NF_EVENT_PLAYER_LOGIN_FAILED = 202,
  NF_EVENT_PLAYER_RECONNECT_SUCCESS = 203,
  NF_EVENT_PLAYER_DISCONNECT = 204,
  NF_EVENT_PLAYER_TYPE_END = 299
};
bool NFEventIdType_IsValid(int value);
const NFEventIdType NFEventIdType_MIN = NF_EVENT_SERVER_TYPE_BEGIN;
const NFEventIdType NFEventIdType_MAX = NF_EVENT_PLAYER_TYPE_END;
const int NFEventIdType_ARRAYSIZE = NFEventIdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NFEventIdType_descriptor();
inline const ::std::string& NFEventIdType_Name(NFEventIdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NFEventIdType_descriptor(), value);
}
inline bool NFEventIdType_Parse(
    const ::std::string& name, NFEventIdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NFEventIdType>(
    NFEventIdType_descriptor(), name, value);
}
// ===================================================================

class Proto_DispInfo : public ::google::protobuf::Message {
 public:
  Proto_DispInfo();
  virtual ~Proto_DispInfo();

  Proto_DispInfo(const Proto_DispInfo& from);

  inline Proto_DispInfo& operator=(const Proto_DispInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_DispInfo& default_instance();

  void Swap(Proto_DispInfo* other);

  // implements Message ----------------------------------------------

  Proto_DispInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_DispInfo& from);
  void MergeFrom(const Proto_DispInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 user_id() const;
  inline void set_user_id(::google::protobuf::uint64 value);

  // optional int32 req_trans_id = 2;
  inline bool has_req_trans_id() const;
  inline void clear_req_trans_id();
  static const int kReqTransIdFieldNumber = 2;
  inline ::google::protobuf::int32 req_trans_id() const;
  inline void set_req_trans_id(::google::protobuf::int32 value);

  // optional int32 rsp_trans_id = 3;
  inline bool has_rsp_trans_id() const;
  inline void clear_rsp_trans_id();
  static const int kRspTransIdFieldNumber = 3;
  inline ::google::protobuf::int32 rsp_trans_id() const;
  inline void set_rsp_trans_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_DispInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_req_trans_id();
  inline void clear_has_req_trans_id();
  inline void set_has_rsp_trans_id();
  inline void clear_has_rsp_trans_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 user_id_;
  ::google::protobuf::int32 req_trans_id_;
  ::google::protobuf::int32 rsp_trans_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_DispInfo* default_instance_;
};
// -------------------------------------------------------------------

class Proto_StoreInfo_CB : public ::google::protobuf::Message {
 public:
  Proto_StoreInfo_CB();
  virtual ~Proto_StoreInfo_CB();

  Proto_StoreInfo_CB(const Proto_StoreInfo_CB& from);

  inline Proto_StoreInfo_CB& operator=(const Proto_StoreInfo_CB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_StoreInfo_CB& default_instance();

  void Swap(Proto_StoreInfo_CB* other);

  // implements Message ----------------------------------------------

  Proto_StoreInfo_CB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_StoreInfo_CB& from);
  void MergeFrom(const Proto_StoreInfo_CB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto_ff.PacketDispType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::proto_ff::PacketDispType type() const;
  inline void set_type(::proto_ff::PacketDispType value);

  // optional uint64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint32 table_id = 3;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  inline ::google::protobuf::uint32 table_id() const;
  inline void set_table_id(::google::protobuf::uint32 value);

  // optional uint32 seq = 4;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 4;
  inline ::google::protobuf::uint32 seq() const;
  inline void set_seq(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_StoreInfo_CB)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  int type_;
  ::google::protobuf::uint32 table_id_;
  ::google::protobuf::uint32 seq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_StoreInfo_CB* default_instance_;
};
// -------------------------------------------------------------------

class Proto_StoreInfo : public ::google::protobuf::Message {
 public:
  Proto_StoreInfo();
  virtual ~Proto_StoreInfo();

  Proto_StoreInfo(const Proto_StoreInfo& from);

  inline Proto_StoreInfo& operator=(const Proto_StoreInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_StoreInfo& default_instance();

  void Swap(Proto_StoreInfo* other);

  // implements Message ----------------------------------------------

  Proto_StoreInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_StoreInfo& from);
  void MergeFrom(const Proto_StoreInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional int32 err_code = 2;
  inline bool has_err_code() const;
  inline void clear_err_code();
  static const int kErrCodeFieldNumber = 2;
  inline ::google::protobuf::int32 err_code() const;
  inline void set_err_code(::google::protobuf::int32 value);

  // optional .proto_ff.Proto_StoreInfo_CB cb_data = 3;
  inline bool has_cb_data() const;
  inline void clear_cb_data();
  static const int kCbDataFieldNumber = 3;
  inline const ::proto_ff::Proto_StoreInfo_CB& cb_data() const;
  inline ::proto_ff::Proto_StoreInfo_CB* mutable_cb_data();
  inline ::proto_ff::Proto_StoreInfo_CB* release_cb_data();
  inline void set_allocated_cb_data(::proto_ff::Proto_StoreInfo_CB* cb_data);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_StoreInfo)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_err_code();
  inline void clear_has_err_code();
  inline void set_has_cb_data();
  inline void clear_has_cb_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;
  ::google::protobuf::int32 err_code_;
  ::proto_ff::Proto_StoreInfo_CB* cb_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_StoreInfo* default_instance_;
};
// -------------------------------------------------------------------

class Proto_EventInfo : public ::google::protobuf::Message {
 public:
  Proto_EventInfo();
  virtual ~Proto_EventInfo();

  Proto_EventInfo(const Proto_EventInfo& from);

  inline Proto_EventInfo& operator=(const Proto_EventInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_EventInfo& default_instance();

  void Swap(Proto_EventInfo* other);

  // implements Message ----------------------------------------------

  Proto_EventInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_EventInfo& from);
  void MergeFrom(const Proto_EventInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_type = 1;
  inline bool has_server_type() const;
  inline void clear_server_type();
  static const int kServerTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 server_type() const;
  inline void set_server_type(::google::protobuf::uint32 value);

  // optional uint64 event_id = 2;
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 2;
  inline ::google::protobuf::uint64 event_id() const;
  inline void set_event_id(::google::protobuf::uint64 value);

  // optional uint64 src_type = 3;
  inline bool has_src_type() const;
  inline void clear_src_type();
  static const int kSrcTypeFieldNumber = 3;
  inline ::google::protobuf::uint64 src_type() const;
  inline void set_src_type(::google::protobuf::uint64 value);

  // optional uint64 src_id = 4;
  inline bool has_src_id() const;
  inline void clear_src_id();
  static const int kSrcIdFieldNumber = 4;
  inline ::google::protobuf::uint64 src_id() const;
  inline void set_src_id(::google::protobuf::uint64 value);

  // optional string full_message_name = 5;
  inline bool has_full_message_name() const;
  inline void clear_full_message_name();
  static const int kFullMessageNameFieldNumber = 5;
  inline const ::std::string& full_message_name() const;
  inline void set_full_message_name(const ::std::string& value);
  inline void set_full_message_name(const char* value);
  inline void set_full_message_name(const char* value, size_t size);
  inline ::std::string* mutable_full_message_name();
  inline ::std::string* release_full_message_name();
  inline void set_allocated_full_message_name(::std::string* full_message_name);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_EventInfo)
 private:
  inline void set_has_server_type();
  inline void clear_has_server_type();
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_src_type();
  inline void clear_has_src_type();
  inline void set_has_src_id();
  inline void clear_has_src_id();
  inline void set_has_full_message_name();
  inline void clear_has_full_message_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 event_id_;
  ::google::protobuf::uint64 src_type_;
  ::google::protobuf::uint64 src_id_;
  ::std::string* full_message_name_;
  ::google::protobuf::uint32 server_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_EventInfo* default_instance_;
};
// -------------------------------------------------------------------

class Proto_ScriptRpcResult : public ::google::protobuf::Message {
 public:
  Proto_ScriptRpcResult();
  virtual ~Proto_ScriptRpcResult();

  Proto_ScriptRpcResult(const Proto_ScriptRpcResult& from);

  inline Proto_ScriptRpcResult& operator=(const Proto_ScriptRpcResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_ScriptRpcResult& default_instance();

  void Swap(Proto_ScriptRpcResult* other);

  // implements Message ----------------------------------------------

  Proto_ScriptRpcResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_ScriptRpcResult& from);
  void MergeFrom(const Proto_ScriptRpcResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string req_type = 1;
  inline bool has_req_type() const;
  inline void clear_req_type();
  static const int kReqTypeFieldNumber = 1;
  inline const ::std::string& req_type() const;
  inline void set_req_type(const ::std::string& value);
  inline void set_req_type(const char* value);
  inline void set_req_type(const char* value, size_t size);
  inline ::std::string* mutable_req_type();
  inline ::std::string* release_req_type();
  inline void set_allocated_req_type(::std::string* req_type);

  // optional string rsp_type = 2;
  inline bool has_rsp_type() const;
  inline void clear_rsp_type();
  static const int kRspTypeFieldNumber = 2;
  inline const ::std::string& rsp_type() const;
  inline void set_rsp_type(const ::std::string& value);
  inline void set_rsp_type(const char* value);
  inline void set_rsp_type(const char* value, size_t size);
  inline ::std::string* mutable_rsp_type();
  inline ::std::string* release_rsp_type();
  inline void set_allocated_rsp_type(::std::string* rsp_type);

  // optional string respone = 3;
  inline bool has_respone() const;
  inline void clear_respone();
  static const int kResponeFieldNumber = 3;
  inline const ::std::string& respone() const;
  inline void set_respone(const ::std::string& value);
  inline void set_respone(const char* value);
  inline void set_respone(const char* value, size_t size);
  inline ::std::string* mutable_respone();
  inline ::std::string* release_respone();
  inline void set_allocated_respone(::std::string* respone);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_ScriptRpcResult)
 private:
  inline void set_has_req_type();
  inline void clear_has_req_type();
  inline void set_has_rsp_type();
  inline void clear_has_rsp_type();
  inline void set_has_respone();
  inline void clear_has_respone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* req_type_;
  ::std::string* rsp_type_;
  ::std::string* respone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_ScriptRpcResult* default_instance_;
};
// -------------------------------------------------------------------

class Proto_RpcInfo : public ::google::protobuf::Message {
 public:
  Proto_RpcInfo();
  virtual ~Proto_RpcInfo();

  Proto_RpcInfo(const Proto_RpcInfo& from);

  inline Proto_RpcInfo& operator=(const Proto_RpcInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_RpcInfo& default_instance();

  void Swap(Proto_RpcInfo* other);

  // implements Message ----------------------------------------------

  Proto_RpcInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_RpcInfo& from);
  void MergeFrom(const Proto_RpcInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 req_rpc_id = 1;
  inline bool has_req_rpc_id() const;
  inline void clear_req_rpc_id();
  static const int kReqRpcIdFieldNumber = 1;
  inline ::google::protobuf::int64 req_rpc_id() const;
  inline void set_req_rpc_id(::google::protobuf::int64 value);

  // optional int64 rsp_rpc_id = 2;
  inline bool has_rsp_rpc_id() const;
  inline void clear_rsp_rpc_id();
  static const int kRspRpcIdFieldNumber = 2;
  inline ::google::protobuf::int64 rsp_rpc_id() const;
  inline void set_rsp_rpc_id(::google::protobuf::int64 value);

  // optional int32 rpc_ret_code = 3;
  inline bool has_rpc_ret_code() const;
  inline void clear_rpc_ret_code();
  static const int kRpcRetCodeFieldNumber = 3;
  inline ::google::protobuf::int32 rpc_ret_code() const;
  inline void set_rpc_ret_code(::google::protobuf::int32 value);

  // optional uint64 req_rpc_hash = 4;
  inline bool has_req_rpc_hash() const;
  inline void clear_req_rpc_hash();
  static const int kReqRpcHashFieldNumber = 4;
  inline ::google::protobuf::uint64 req_rpc_hash() const;
  inline void set_req_rpc_hash(::google::protobuf::uint64 value);

  // optional uint64 rsp_rpc_hash = 5;
  inline bool has_rsp_rpc_hash() const;
  inline void clear_rsp_rpc_hash();
  static const int kRspRpcHashFieldNumber = 5;
  inline ::google::protobuf::uint64 rsp_rpc_hash() const;
  inline void set_rsp_rpc_hash(::google::protobuf::uint64 value);

  // optional uint32 req_bus_id = 6;
  inline bool has_req_bus_id() const;
  inline void clear_req_bus_id();
  static const int kReqBusIdFieldNumber = 6;
  inline ::google::protobuf::uint32 req_bus_id() const;
  inline void set_req_bus_id(::google::protobuf::uint32 value);

  // optional uint64 req_server_type = 7;
  inline bool has_req_server_type() const;
  inline void clear_req_server_type();
  static const int kReqServerTypeFieldNumber = 7;
  inline ::google::protobuf::uint64 req_server_type() const;
  inline void set_req_server_type(::google::protobuf::uint64 value);

  // optional bool is_script_rpc = 8;
  inline bool has_is_script_rpc() const;
  inline void clear_is_script_rpc();
  static const int kIsScriptRpcFieldNumber = 8;
  inline bool is_script_rpc() const;
  inline void set_is_script_rpc(bool value);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_RpcInfo)
 private:
  inline void set_has_req_rpc_id();
  inline void clear_has_req_rpc_id();
  inline void set_has_rsp_rpc_id();
  inline void clear_has_rsp_rpc_id();
  inline void set_has_rpc_ret_code();
  inline void clear_has_rpc_ret_code();
  inline void set_has_req_rpc_hash();
  inline void clear_has_req_rpc_hash();
  inline void set_has_rsp_rpc_hash();
  inline void clear_has_rsp_rpc_hash();
  inline void set_has_req_bus_id();
  inline void clear_has_req_bus_id();
  inline void set_has_req_server_type();
  inline void clear_has_req_server_type();
  inline void set_has_is_script_rpc();
  inline void clear_has_is_script_rpc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 req_rpc_id_;
  ::google::protobuf::int64 rsp_rpc_id_;
  ::google::protobuf::uint64 req_rpc_hash_;
  ::google::protobuf::int32 rpc_ret_code_;
  ::google::protobuf::uint32 req_bus_id_;
  ::google::protobuf::uint64 rsp_rpc_hash_;
  ::google::protobuf::uint64 req_server_type_;
  bool is_script_rpc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_RpcInfo* default_instance_;
};
// -------------------------------------------------------------------

class Proto_RedirectInfo : public ::google::protobuf::Message {
 public:
  Proto_RedirectInfo();
  virtual ~Proto_RedirectInfo();

  Proto_RedirectInfo(const Proto_RedirectInfo& from);

  inline Proto_RedirectInfo& operator=(const Proto_RedirectInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_RedirectInfo& default_instance();

  void Swap(Proto_RedirectInfo* other);

  // implements Message ----------------------------------------------

  Proto_RedirectInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_RedirectInfo& from);
  void MergeFrom(const Proto_RedirectInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 id = 1;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id(int index) const;
  inline void set_id(int index, ::google::protobuf::uint64 value);
  inline void add_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_id();

  // optional bool all = 2;
  inline bool has_all() const;
  inline void clear_all();
  static const int kAllFieldNumber = 2;
  inline bool all() const;
  inline void set_all(bool value);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_RedirectInfo)
 private:
  inline void set_has_all();
  inline void clear_has_all();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > id_;
  bool all_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_RedirectInfo* default_instance_;
};
// -------------------------------------------------------------------

class Proto_SvrPkg : public ::google::protobuf::Message {
 public:
  Proto_SvrPkg();
  virtual ~Proto_SvrPkg();

  Proto_SvrPkg(const Proto_SvrPkg& from);

  inline Proto_SvrPkg& operator=(const Proto_SvrPkg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_SvrPkg& default_instance();

  void Swap(Proto_SvrPkg* other);

  // implements Message ----------------------------------------------

  Proto_SvrPkg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_SvrPkg& from);
  void MergeFrom(const Proto_SvrPkg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::int32 msg_id() const;
  inline void set_msg_id(::google::protobuf::int32 value);

  // optional bytes msg_data = 2;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 2;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // optional .proto_ff.Proto_DispInfo disp_info = 3;
  inline bool has_disp_info() const;
  inline void clear_disp_info();
  static const int kDispInfoFieldNumber = 3;
  inline const ::proto_ff::Proto_DispInfo& disp_info() const;
  inline ::proto_ff::Proto_DispInfo* mutable_disp_info();
  inline ::proto_ff::Proto_DispInfo* release_disp_info();
  inline void set_allocated_disp_info(::proto_ff::Proto_DispInfo* disp_info);

  // optional .proto_ff.Proto_StoreInfo store_info = 4;
  inline bool has_store_info() const;
  inline void clear_store_info();
  static const int kStoreInfoFieldNumber = 4;
  inline const ::proto_ff::Proto_StoreInfo& store_info() const;
  inline ::proto_ff::Proto_StoreInfo* mutable_store_info();
  inline ::proto_ff::Proto_StoreInfo* release_store_info();
  inline void set_allocated_store_info(::proto_ff::Proto_StoreInfo* store_info);

  // optional .proto_ff.Proto_EventInfo event_info = 5;
  inline bool has_event_info() const;
  inline void clear_event_info();
  static const int kEventInfoFieldNumber = 5;
  inline const ::proto_ff::Proto_EventInfo& event_info() const;
  inline ::proto_ff::Proto_EventInfo* mutable_event_info();
  inline ::proto_ff::Proto_EventInfo* release_event_info();
  inline void set_allocated_event_info(::proto_ff::Proto_EventInfo* event_info);

  // optional .proto_ff.Proto_RedirectInfo redirect_info = 6;
  inline bool has_redirect_info() const;
  inline void clear_redirect_info();
  static const int kRedirectInfoFieldNumber = 6;
  inline const ::proto_ff::Proto_RedirectInfo& redirect_info() const;
  inline ::proto_ff::Proto_RedirectInfo* mutable_redirect_info();
  inline ::proto_ff::Proto_RedirectInfo* release_redirect_info();
  inline void set_allocated_redirect_info(::proto_ff::Proto_RedirectInfo* redirect_info);

  // optional .proto_ff.Proto_RpcInfo rpc_info = 7;
  inline bool has_rpc_info() const;
  inline void clear_rpc_info();
  static const int kRpcInfoFieldNumber = 7;
  inline const ::proto_ff::Proto_RpcInfo& rpc_info() const;
  inline ::proto_ff::Proto_RpcInfo* mutable_rpc_info();
  inline ::proto_ff::Proto_RpcInfo* release_rpc_info();
  inline void set_allocated_rpc_info(::proto_ff::Proto_RpcInfo* rpc_info);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_SvrPkg)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();
  inline void set_has_disp_info();
  inline void clear_has_disp_info();
  inline void set_has_store_info();
  inline void clear_has_store_info();
  inline void set_has_event_info();
  inline void clear_has_event_info();
  inline void set_has_redirect_info();
  inline void clear_has_redirect_info();
  inline void set_has_rpc_info();
  inline void clear_has_rpc_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_data_;
  ::proto_ff::Proto_DispInfo* disp_info_;
  ::proto_ff::Proto_StoreInfo* store_info_;
  ::proto_ff::Proto_EventInfo* event_info_;
  ::proto_ff::Proto_RedirectInfo* redirect_info_;
  ::proto_ff::Proto_RpcInfo* rpc_info_;
  ::google::protobuf::int32 msg_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_SvrPkg* default_instance_;
};
// -------------------------------------------------------------------

class ServerInfoReport : public ::google::protobuf::Message {
 public:
  ServerInfoReport();
  virtual ~ServerInfoReport();

  ServerInfoReport(const ServerInfoReport& from);

  inline ServerInfoReport& operator=(const ServerInfoReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfoReport& default_instance();

  void Swap(ServerInfoReport* other);

  // implements Message ----------------------------------------------

  ServerInfoReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerInfoReport& from);
  void MergeFrom(const ServerInfoReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 bus_id = 1;
  inline bool has_bus_id() const;
  inline void clear_bus_id();
  static const int kBusIdFieldNumber = 1;
  inline ::google::protobuf::uint32 bus_id() const;
  inline void set_bus_id(::google::protobuf::uint32 value);

  // optional string server_id = 2;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 2;
  inline const ::std::string& server_id() const;
  inline void set_server_id(const ::std::string& value);
  inline void set_server_id(const char* value);
  inline void set_server_id(const char* value, size_t size);
  inline ::std::string* mutable_server_id();
  inline ::std::string* release_server_id();
  inline void set_allocated_server_id(::std::string* server_id);

  // optional uint32 server_type = 3;
  inline bool has_server_type() const;
  inline void clear_server_type();
  static const int kServerTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 server_type() const;
  inline void set_server_type(::google::protobuf::uint32 value);

  // optional string server_name = 4;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 4;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const char* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // optional string url = 5;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 5;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string link_mode = 6;
  inline bool has_link_mode() const;
  inline void clear_link_mode();
  static const int kLinkModeFieldNumber = 6;
  inline const ::std::string& link_mode() const;
  inline void set_link_mode(const ::std::string& value);
  inline void set_link_mode(const char* value);
  inline void set_link_mode(const char* value, size_t size);
  inline ::std::string* mutable_link_mode();
  inline ::std::string* release_link_mode();
  inline void set_allocated_link_mode(::std::string* link_mode);

  // optional uint32 bus_length = 7;
  inline bool has_bus_length() const;
  inline void clear_bus_length();
  static const int kBusLengthFieldNumber = 7;
  inline ::google::protobuf::uint32 bus_length() const;
  inline void set_bus_length(::google::protobuf::uint32 value);

  // optional string server_ip = 9;
  inline bool has_server_ip() const;
  inline void clear_server_ip();
  static const int kServerIpFieldNumber = 9;
  inline const ::std::string& server_ip() const;
  inline void set_server_ip(const ::std::string& value);
  inline void set_server_ip(const char* value);
  inline void set_server_ip(const char* value, size_t size);
  inline ::std::string* mutable_server_ip();
  inline ::std::string* release_server_ip();
  inline void set_allocated_server_ip(::std::string* server_ip);

  // optional uint32 server_port = 10;
  inline bool has_server_port() const;
  inline void clear_server_port();
  static const int kServerPortFieldNumber = 10;
  inline ::google::protobuf::uint32 server_port() const;
  inline void set_server_port(::google::protobuf::uint32 value);

  // optional uint32 server_http_port = 11;
  inline bool has_server_http_port() const;
  inline void clear_server_http_port();
  static const int kServerHttpPortFieldNumber = 11;
  inline ::google::protobuf::uint32 server_http_port() const;
  inline void set_server_http_port(::google::protobuf::uint32 value);

  // optional string external_server_ip = 12;
  inline bool has_external_server_ip() const;
  inline void clear_external_server_ip();
  static const int kExternalServerIpFieldNumber = 12;
  inline const ::std::string& external_server_ip() const;
  inline void set_external_server_ip(const ::std::string& value);
  inline void set_external_server_ip(const char* value);
  inline void set_external_server_ip(const char* value, size_t size);
  inline ::std::string* mutable_external_server_ip();
  inline ::std::string* release_external_server_ip();
  inline void set_allocated_external_server_ip(::std::string* external_server_ip);

  // optional uint32 external_server_port = 13;
  inline bool has_external_server_port() const;
  inline void clear_external_server_port();
  static const int kExternalServerPortFieldNumber = 13;
  inline ::google::protobuf::uint32 external_server_port() const;
  inline void set_external_server_port(::google::protobuf::uint32 value);

  // optional bool is_cross_server = 14;
  inline bool has_is_cross_server() const;
  inline void clear_is_cross_server();
  static const int kIsCrossServerFieldNumber = 14;
  inline bool is_cross_server() const;
  inline void set_is_cross_server(bool value);

  // optional string route_svr = 15;
  inline bool has_route_svr() const;
  inline void clear_route_svr();
  static const int kRouteSvrFieldNumber = 15;
  inline const ::std::string& route_svr() const;
  inline void set_route_svr(const ::std::string& value);
  inline void set_route_svr(const char* value);
  inline void set_route_svr(const char* value, size_t size);
  inline ::std::string* mutable_route_svr();
  inline ::std::string* release_route_svr();
  inline void set_allocated_route_svr(::std::string* route_svr);

  // optional uint32 server_max_online = 30;
  inline bool has_server_max_online() const;
  inline void clear_server_max_online();
  static const int kServerMaxOnlineFieldNumber = 30;
  inline ::google::protobuf::uint32 server_max_online() const;
  inline void set_server_max_online(::google::protobuf::uint32 value);

  // optional uint32 server_cur_online = 31;
  inline bool has_server_cur_online() const;
  inline void clear_server_cur_online();
  static const int kServerCurOnlineFieldNumber = 31;
  inline ::google::protobuf::uint32 server_cur_online() const;
  inline void set_server_cur_online(::google::protobuf::uint32 value);

  // optional uint32 server_state = 32;
  inline bool has_server_state() const;
  inline void clear_server_state();
  static const int kServerStateFieldNumber = 32;
  inline ::google::protobuf::uint32 server_state() const;
  inline void set_server_state(::google::protobuf::uint32 value);

  // optional string system_info = 33;
  inline bool has_system_info() const;
  inline void clear_system_info();
  static const int kSystemInfoFieldNumber = 33;
  inline const ::std::string& system_info() const;
  inline void set_system_info(const ::std::string& value);
  inline void set_system_info(const char* value);
  inline void set_system_info(const char* value, size_t size);
  inline ::std::string* mutable_system_info();
  inline ::std::string* release_system_info();
  inline void set_allocated_system_info(::std::string* system_info);

  // optional uint64 total_mem = 34;
  inline bool has_total_mem() const;
  inline void clear_total_mem();
  static const int kTotalMemFieldNumber = 34;
  inline ::google::protobuf::uint64 total_mem() const;
  inline void set_total_mem(::google::protobuf::uint64 value);

  // optional uint64 free_mem = 35;
  inline bool has_free_mem() const;
  inline void clear_free_mem();
  static const int kFreeMemFieldNumber = 35;
  inline ::google::protobuf::uint64 free_mem() const;
  inline void set_free_mem(::google::protobuf::uint64 value);

  // optional uint64 used_mem = 36;
  inline bool has_used_mem() const;
  inline void clear_used_mem();
  static const int kUsedMemFieldNumber = 36;
  inline ::google::protobuf::uint64 used_mem() const;
  inline void set_used_mem(::google::protobuf::uint64 value);

  // optional double proc_cpu = 37;
  inline bool has_proc_cpu() const;
  inline void clear_proc_cpu();
  static const int kProcCpuFieldNumber = 37;
  inline double proc_cpu() const;
  inline void set_proc_cpu(double value);

  // optional uint64 proc_mem = 38;
  inline bool has_proc_mem() const;
  inline void clear_proc_mem();
  static const int kProcMemFieldNumber = 38;
  inline ::google::protobuf::uint64 proc_mem() const;
  inline void set_proc_mem(::google::protobuf::uint64 value);

  // optional uint32 proc_thread = 39;
  inline bool has_proc_thread() const;
  inline void clear_proc_thread();
  static const int kProcThreadFieldNumber = 39;
  inline ::google::protobuf::uint32 proc_thread() const;
  inline void set_proc_thread(::google::protobuf::uint32 value);

  // optional string proc_name = 40;
  inline bool has_proc_name() const;
  inline void clear_proc_name();
  static const int kProcNameFieldNumber = 40;
  inline const ::std::string& proc_name() const;
  inline void set_proc_name(const ::std::string& value);
  inline void set_proc_name(const char* value);
  inline void set_proc_name(const char* value, size_t size);
  inline ::std::string* mutable_proc_name();
  inline ::std::string* release_proc_name();
  inline void set_allocated_proc_name(::std::string* proc_name);

  // optional string proc_cwd = 41;
  inline bool has_proc_cwd() const;
  inline void clear_proc_cwd();
  static const int kProcCwdFieldNumber = 41;
  inline const ::std::string& proc_cwd() const;
  inline void set_proc_cwd(const ::std::string& value);
  inline void set_proc_cwd(const char* value);
  inline void set_proc_cwd(const char* value, size_t size);
  inline ::std::string* mutable_proc_cwd();
  inline ::std::string* release_proc_cwd();
  inline void set_allocated_proc_cwd(::std::string* proc_cwd);

  // optional uint32 proc_pid = 42;
  inline bool has_proc_pid() const;
  inline void clear_proc_pid();
  static const int kProcPidFieldNumber = 42;
  inline ::google::protobuf::uint32 proc_pid() const;
  inline void set_proc_pid(::google::protobuf::uint32 value);

  // optional string last_date = 43;
  inline bool has_last_date() const;
  inline void clear_last_date();
  static const int kLastDateFieldNumber = 43;
  inline const ::std::string& last_date() const;
  inline void set_last_date(const ::std::string& value);
  inline void set_last_date(const char* value);
  inline void set_last_date(const char* value, size_t size);
  inline ::std::string* mutable_last_date();
  inline ::std::string* release_last_date();
  inline void set_allocated_last_date(::std::string* last_date);

  // optional uint64 last_time = 44;
  inline bool has_last_time() const;
  inline void clear_last_time();
  static const int kLastTimeFieldNumber = 44;
  inline ::google::protobuf::uint64 last_time() const;
  inline void set_last_time(::google::protobuf::uint64 value);

  // optional string contract_info = 45;
  inline bool has_contract_info() const;
  inline void clear_contract_info();
  static const int kContractInfoFieldNumber = 45;
  inline const ::std::string& contract_info() const;
  inline void set_contract_info(const ::std::string& value);
  inline void set_contract_info(const char* value);
  inline void set_contract_info(const char* value, size_t size);
  inline ::std::string* mutable_contract_info();
  inline ::std::string* release_contract_info();
  inline void set_allocated_contract_info(::std::string* contract_info);

  // optional string machine_addr = 46;
  inline bool has_machine_addr() const;
  inline void clear_machine_addr();
  static const int kMachineAddrFieldNumber = 46;
  inline const ::std::string& machine_addr() const;
  inline void set_machine_addr(const ::std::string& value);
  inline void set_machine_addr(const char* value);
  inline void set_machine_addr(const char* value, size_t size);
  inline ::std::string* mutable_machine_addr();
  inline ::std::string* release_machine_addr();
  inline void set_allocated_machine_addr(::std::string* machine_addr);

  // repeated string db_name_list = 47;
  inline int db_name_list_size() const;
  inline void clear_db_name_list();
  static const int kDbNameListFieldNumber = 47;
  inline const ::std::string& db_name_list(int index) const;
  inline ::std::string* mutable_db_name_list(int index);
  inline void set_db_name_list(int index, const ::std::string& value);
  inline void set_db_name_list(int index, const char* value);
  inline void set_db_name_list(int index, const char* value, size_t size);
  inline ::std::string* add_db_name_list();
  inline void add_db_name_list(const ::std::string& value);
  inline void add_db_name_list(const char* value);
  inline void add_db_name_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& db_name_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_db_name_list();

  // repeated uint32 msg_id = 48;
  inline int msg_id_size() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 48;
  inline ::google::protobuf::uint32 msg_id(int index) const;
  inline void set_msg_id(int index, ::google::protobuf::uint32 value);
  inline void add_msg_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      msg_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_msg_id();

  // repeated uint64 map_id_list = 49;
  inline int map_id_list_size() const;
  inline void clear_map_id_list();
  static const int kMapIdListFieldNumber = 49;
  inline ::google::protobuf::uint64 map_id_list(int index) const;
  inline void set_map_id_list(int index, ::google::protobuf::uint64 value);
  inline void add_map_id_list(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      map_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_map_id_list();

  // @@protoc_insertion_point(class_scope:proto_ff.ServerInfoReport)
 private:
  inline void set_has_bus_id();
  inline void clear_has_bus_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_server_type();
  inline void clear_has_server_type();
  inline void set_has_server_name();
  inline void clear_has_server_name();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_link_mode();
  inline void clear_has_link_mode();
  inline void set_has_bus_length();
  inline void clear_has_bus_length();
  inline void set_has_server_ip();
  inline void clear_has_server_ip();
  inline void set_has_server_port();
  inline void clear_has_server_port();
  inline void set_has_server_http_port();
  inline void clear_has_server_http_port();
  inline void set_has_external_server_ip();
  inline void clear_has_external_server_ip();
  inline void set_has_external_server_port();
  inline void clear_has_external_server_port();
  inline void set_has_is_cross_server();
  inline void clear_has_is_cross_server();
  inline void set_has_route_svr();
  inline void clear_has_route_svr();
  inline void set_has_server_max_online();
  inline void clear_has_server_max_online();
  inline void set_has_server_cur_online();
  inline void clear_has_server_cur_online();
  inline void set_has_server_state();
  inline void clear_has_server_state();
  inline void set_has_system_info();
  inline void clear_has_system_info();
  inline void set_has_total_mem();
  inline void clear_has_total_mem();
  inline void set_has_free_mem();
  inline void clear_has_free_mem();
  inline void set_has_used_mem();
  inline void clear_has_used_mem();
  inline void set_has_proc_cpu();
  inline void clear_has_proc_cpu();
  inline void set_has_proc_mem();
  inline void clear_has_proc_mem();
  inline void set_has_proc_thread();
  inline void clear_has_proc_thread();
  inline void set_has_proc_name();
  inline void clear_has_proc_name();
  inline void set_has_proc_cwd();
  inline void clear_has_proc_cwd();
  inline void set_has_proc_pid();
  inline void clear_has_proc_pid();
  inline void set_has_last_date();
  inline void clear_has_last_date();
  inline void set_has_last_time();
  inline void clear_has_last_time();
  inline void set_has_contract_info();
  inline void clear_has_contract_info();
  inline void set_has_machine_addr();
  inline void clear_has_machine_addr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 bus_id_;
  ::google::protobuf::uint32 server_type_;
  ::std::string* server_id_;
  ::std::string* server_name_;
  ::std::string* url_;
  ::std::string* link_mode_;
  ::std::string* server_ip_;
  ::google::protobuf::uint32 bus_length_;
  ::google::protobuf::uint32 server_port_;
  ::std::string* external_server_ip_;
  ::google::protobuf::uint32 server_http_port_;
  ::google::protobuf::uint32 external_server_port_;
  ::std::string* route_svr_;
  bool is_cross_server_;
  ::google::protobuf::uint32 server_max_online_;
  ::google::protobuf::uint32 server_cur_online_;
  ::google::protobuf::uint32 server_state_;
  ::std::string* system_info_;
  ::google::protobuf::uint64 total_mem_;
  ::google::protobuf::uint64 free_mem_;
  ::google::protobuf::uint64 used_mem_;
  double proc_cpu_;
  ::google::protobuf::uint64 proc_mem_;
  ::std::string* proc_name_;
  ::google::protobuf::uint32 proc_thread_;
  ::google::protobuf::uint32 proc_pid_;
  ::std::string* proc_cwd_;
  ::std::string* last_date_;
  ::google::protobuf::uint64 last_time_;
  ::std::string* contract_info_;
  ::std::string* machine_addr_;
  ::google::protobuf::RepeatedPtrField< ::std::string> db_name_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > msg_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > map_id_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(34 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static ServerInfoReport* default_instance_;
};
// -------------------------------------------------------------------

class ServerInfoReportList : public ::google::protobuf::Message {
 public:
  ServerInfoReportList();
  virtual ~ServerInfoReportList();

  ServerInfoReportList(const ServerInfoReportList& from);

  inline ServerInfoReportList& operator=(const ServerInfoReportList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfoReportList& default_instance();

  void Swap(ServerInfoReportList* other);

  // implements Message ----------------------------------------------

  ServerInfoReportList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerInfoReportList& from);
  void MergeFrom(const ServerInfoReportList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto_ff.ServerInfoReport server_list = 1;
  inline int server_list_size() const;
  inline void clear_server_list();
  static const int kServerListFieldNumber = 1;
  inline const ::proto_ff::ServerInfoReport& server_list(int index) const;
  inline ::proto_ff::ServerInfoReport* mutable_server_list(int index);
  inline ::proto_ff::ServerInfoReport* add_server_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ServerInfoReport >&
      server_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ServerInfoReport >*
      mutable_server_list();

  // @@protoc_insertion_point(class_scope:proto_ff.ServerInfoReportList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::ServerInfoReport > server_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static ServerInfoReportList* default_instance_;
};
// -------------------------------------------------------------------

class ServerInfoReportListRespne : public ::google::protobuf::Message {
 public:
  ServerInfoReportListRespne();
  virtual ~ServerInfoReportListRespne();

  ServerInfoReportListRespne(const ServerInfoReportListRespne& from);

  inline ServerInfoReportListRespne& operator=(const ServerInfoReportListRespne& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfoReportListRespne& default_instance();

  void Swap(ServerInfoReportListRespne* other);

  // implements Message ----------------------------------------------

  ServerInfoReportListRespne* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerInfoReportListRespne& from);
  void MergeFrom(const ServerInfoReportListRespne& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ret_code = 1;
  inline bool has_ret_code() const;
  inline void clear_ret_code();
  static const int kRetCodeFieldNumber = 1;
  inline ::google::protobuf::int32 ret_code() const;
  inline void set_ret_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ServerInfoReportListRespne)
 private:
  inline void set_has_ret_code();
  inline void clear_has_ret_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static ServerInfoReportListRespne* default_instance_;
};
// -------------------------------------------------------------------

class ZkServerInfo : public ::google::protobuf::Message {
 public:
  ZkServerInfo();
  virtual ~ZkServerInfo();

  ZkServerInfo(const ZkServerInfo& from);

  inline ZkServerInfo& operator=(const ZkServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZkServerInfo& default_instance();

  void Swap(ZkServerInfo* other);

  // implements Message ----------------------------------------------

  ZkServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZkServerInfo& from);
  void MergeFrom(const ZkServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bus_url = 1;
  inline bool has_bus_url() const;
  inline void clear_bus_url();
  static const int kBusUrlFieldNumber = 1;
  inline const ::std::string& bus_url() const;
  inline void set_bus_url(const ::std::string& value);
  inline void set_bus_url(const char* value);
  inline void set_bus_url(const char* value, size_t size);
  inline ::std::string* mutable_bus_url();
  inline ::std::string* release_bus_url();
  inline void set_allocated_bus_url(::std::string* bus_url);

  // optional string tcp_url = 2;
  inline bool has_tcp_url() const;
  inline void clear_tcp_url();
  static const int kTcpUrlFieldNumber = 2;
  inline const ::std::string& tcp_url() const;
  inline void set_tcp_url(const ::std::string& value);
  inline void set_tcp_url(const char* value);
  inline void set_tcp_url(const char* value, size_t size);
  inline ::std::string* mutable_tcp_url();
  inline ::std::string* release_tcp_url();
  inline void set_allocated_tcp_url(::std::string* tcp_url);

  // @@protoc_insertion_point(class_scope:proto_ff.ZkServerInfo)
 private:
  inline void set_has_bus_url();
  inline void clear_has_bus_url();
  inline void set_has_tcp_url();
  inline void clear_has_tcp_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bus_url_;
  ::std::string* tcp_url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static ZkServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class DynLibFileInfo : public ::google::protobuf::Message {
 public:
  DynLibFileInfo();
  virtual ~DynLibFileInfo();

  DynLibFileInfo(const DynLibFileInfo& from);

  inline DynLibFileInfo& operator=(const DynLibFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DynLibFileInfo& default_instance();

  void Swap(DynLibFileInfo* other);

  // implements Message ----------------------------------------------

  DynLibFileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DynLibFileInfo& from);
  void MergeFrom(const DynLibFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_md5 = 1;
  inline bool has_file_md5() const;
  inline void clear_file_md5();
  static const int kFileMd5FieldNumber = 1;
  inline const ::std::string& file_md5() const;
  inline void set_file_md5(const ::std::string& value);
  inline void set_file_md5(const char* value);
  inline void set_file_md5(const char* value, size_t size);
  inline ::std::string* mutable_file_md5();
  inline ::std::string* release_file_md5();
  inline void set_allocated_file_md5(::std::string* file_md5);

  // optional int32 file_size = 2;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 2;
  inline ::google::protobuf::int32 file_size() const;
  inline void set_file_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.DynLibFileInfo)
 private:
  inline void set_has_file_md5();
  inline void clear_has_file_md5();
  inline void set_has_file_size();
  inline void clear_has_file_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_md5_;
  ::google::protobuf::int32 file_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static DynLibFileInfo* default_instance_;
};
// -------------------------------------------------------------------

class DynLibFileInfoArray : public ::google::protobuf::Message {
 public:
  DynLibFileInfoArray();
  virtual ~DynLibFileInfoArray();

  DynLibFileInfoArray(const DynLibFileInfoArray& from);

  inline DynLibFileInfoArray& operator=(const DynLibFileInfoArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DynLibFileInfoArray& default_instance();

  void Swap(DynLibFileInfoArray* other);

  // implements Message ----------------------------------------------

  DynLibFileInfoArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DynLibFileInfoArray& from);
  void MergeFrom(const DynLibFileInfoArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto_ff.DynLibFileInfo file_list = 1;
  inline int file_list_size() const;
  inline void clear_file_list();
  static const int kFileListFieldNumber = 1;
  inline const ::proto_ff::DynLibFileInfo& file_list(int index) const;
  inline ::proto_ff::DynLibFileInfo* mutable_file_list(int index);
  inline ::proto_ff::DynLibFileInfo* add_file_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::DynLibFileInfo >&
      file_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::DynLibFileInfo >*
      mutable_file_list();

  // @@protoc_insertion_point(class_scope:proto_ff.DynLibFileInfoArray)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::DynLibFileInfo > file_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static DynLibFileInfoArray* default_instance_;
};
// -------------------------------------------------------------------

class Proto_KillAllServerNtf : public ::google::protobuf::Message {
 public:
  Proto_KillAllServerNtf();
  virtual ~Proto_KillAllServerNtf();

  Proto_KillAllServerNtf(const Proto_KillAllServerNtf& from);

  inline Proto_KillAllServerNtf& operator=(const Proto_KillAllServerNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_KillAllServerNtf& default_instance();

  void Swap(Proto_KillAllServerNtf* other);

  // implements Message ----------------------------------------------

  Proto_KillAllServerNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_KillAllServerNtf& from);
  void MergeFrom(const Proto_KillAllServerNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_KillAllServerNtf)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_KillAllServerNtf* default_instance_;
};
// -------------------------------------------------------------------

class Proto_KillAllServerRsp : public ::google::protobuf::Message {
 public:
  Proto_KillAllServerRsp();
  virtual ~Proto_KillAllServerRsp();

  Proto_KillAllServerRsp(const Proto_KillAllServerRsp& from);

  inline Proto_KillAllServerRsp& operator=(const Proto_KillAllServerRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_KillAllServerRsp& default_instance();

  void Swap(Proto_KillAllServerRsp* other);

  // implements Message ----------------------------------------------

  Proto_KillAllServerRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_KillAllServerRsp& from);
  void MergeFrom(const Proto_KillAllServerRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_KillAllServerRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_KillAllServerRsp* default_instance_;
};
// -------------------------------------------------------------------

class Proto_STSBroadPlayerMsgNotify : public ::google::protobuf::Message {
 public:
  Proto_STSBroadPlayerMsgNotify();
  virtual ~Proto_STSBroadPlayerMsgNotify();

  Proto_STSBroadPlayerMsgNotify(const Proto_STSBroadPlayerMsgNotify& from);

  inline Proto_STSBroadPlayerMsgNotify& operator=(const Proto_STSBroadPlayerMsgNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_STSBroadPlayerMsgNotify& default_instance();

  void Swap(Proto_STSBroadPlayerMsgNotify* other);

  // implements Message ----------------------------------------------

  Proto_STSBroadPlayerMsgNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_STSBroadPlayerMsgNotify& from);
  void MergeFrom(const Proto_STSBroadPlayerMsgNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 user_id = 1;
  inline int user_id_size() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 user_id(int index) const;
  inline void set_user_id(int index, ::google::protobuf::uint64 value);
  inline void add_user_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      user_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_user_id();

  // optional uint32 msg_id = 2;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 2;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // optional bytes msg_data = 3;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 3;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_STSBroadPlayerMsgNotify)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > user_id_;
  ::std::string* msg_data_;
  ::google::protobuf::uint32 msg_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_STSBroadPlayerMsgNotify* default_instance_;
};
// -------------------------------------------------------------------

class Proto_STWebMsgRspNotify : public ::google::protobuf::Message {
 public:
  Proto_STWebMsgRspNotify();
  virtual ~Proto_STWebMsgRspNotify();

  Proto_STWebMsgRspNotify(const Proto_STWebMsgRspNotify& from);

  inline Proto_STWebMsgRspNotify& operator=(const Proto_STWebMsgRspNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_STWebMsgRspNotify& default_instance();

  void Swap(Proto_STWebMsgRspNotify* other);

  // implements Message ----------------------------------------------

  Proto_STWebMsgRspNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_STWebMsgRspNotify& from);
  void MergeFrom(const Proto_STWebMsgRspNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string err_msg = 3;
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 3;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const char* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  inline void set_allocated_err_msg(::std::string* err_msg);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_STWebMsgRspNotify)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_err_msg();
  inline void clear_has_err_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 request_id_;
  ::std::string* err_msg_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_STWebMsgRspNotify* default_instance_;
};
// -------------------------------------------------------------------

class BehaviorLogHeader : public ::google::protobuf::Message {
 public:
  BehaviorLogHeader();
  virtual ~BehaviorLogHeader();

  BehaviorLogHeader(const BehaviorLogHeader& from);

  inline BehaviorLogHeader& operator=(const BehaviorLogHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BehaviorLogHeader& default_instance();

  void Swap(BehaviorLogHeader* other);

  // implements Message ----------------------------------------------

  BehaviorLogHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BehaviorLogHeader& from);
  void MergeFrom(const BehaviorLogHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 event_id = 1;
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  inline ::google::protobuf::uint64 event_id() const;
  inline void set_event_id(::google::protobuf::uint64 value);

  // optional uint32 sequence = 2;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // optional string bus_name = 3;
  inline bool has_bus_name() const;
  inline void clear_bus_name();
  static const int kBusNameFieldNumber = 3;
  inline const ::std::string& bus_name() const;
  inline void set_bus_name(const ::std::string& value);
  inline void set_bus_name(const char* value);
  inline void set_bus_name(const char* value, size_t size);
  inline ::std::string* mutable_bus_name();
  inline ::std::string* release_bus_name();
  inline void set_allocated_bus_name(::std::string* bus_name);

  // optional string event_time = 4;
  inline bool has_event_time() const;
  inline void clear_event_time();
  static const int kEventTimeFieldNumber = 4;
  inline const ::std::string& event_time() const;
  inline void set_event_time(const ::std::string& value);
  inline void set_event_time(const char* value);
  inline void set_event_time(const char* value, size_t size);
  inline ::std::string* mutable_event_time();
  inline ::std::string* release_event_time();
  inline void set_allocated_event_time(::std::string* event_time);

  // optional uint64 user_id = 5;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 5;
  inline ::google::protobuf::uint64 user_id() const;
  inline void set_user_id(::google::protobuf::uint64 value);

  // optional string user_name = 6;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 6;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:proto_ff.BehaviorLogHeader)
 private:
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_bus_name();
  inline void clear_has_bus_name();
  inline void set_has_event_time();
  inline void clear_has_event_time();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 event_id_;
  ::std::string* bus_name_;
  ::std::string* event_time_;
  ::google::protobuf::uint64 user_id_;
  ::std::string* user_name_;
  ::google::protobuf::uint32 sequence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static BehaviorLogHeader* default_instance_;
};
// -------------------------------------------------------------------

class NFEventNoneData : public ::google::protobuf::Message {
 public:
  NFEventNoneData();
  virtual ~NFEventNoneData();

  NFEventNoneData(const NFEventNoneData& from);

  inline NFEventNoneData& operator=(const NFEventNoneData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NFEventNoneData& default_instance();

  void Swap(NFEventNoneData* other);

  // implements Message ----------------------------------------------

  NFEventNoneData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NFEventNoneData& from);
  void MergeFrom(const NFEventNoneData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 param1 = 1;
  inline bool has_param1() const;
  inline void clear_param1();
  static const int kParam1FieldNumber = 1;
  inline ::google::protobuf::int64 param1() const;
  inline void set_param1(::google::protobuf::int64 value);

  // optional int64 param2 = 2;
  inline bool has_param2() const;
  inline void clear_param2();
  static const int kParam2FieldNumber = 2;
  inline ::google::protobuf::int64 param2() const;
  inline void set_param2(::google::protobuf::int64 value);

  // optional int64 param3 = 3;
  inline bool has_param3() const;
  inline void clear_param3();
  static const int kParam3FieldNumber = 3;
  inline ::google::protobuf::int64 param3() const;
  inline void set_param3(::google::protobuf::int64 value);

  // optional int64 param4 = 4;
  inline bool has_param4() const;
  inline void clear_param4();
  static const int kParam4FieldNumber = 4;
  inline ::google::protobuf::int64 param4() const;
  inline void set_param4(::google::protobuf::int64 value);

  // optional int64 param5 = 5;
  inline bool has_param5() const;
  inline void clear_param5();
  static const int kParam5FieldNumber = 5;
  inline ::google::protobuf::int64 param5() const;
  inline void set_param5(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.NFEventNoneData)
 private:
  inline void set_has_param1();
  inline void clear_has_param1();
  inline void set_has_param2();
  inline void clear_has_param2();
  inline void set_has_param3();
  inline void clear_has_param3();
  inline void set_has_param4();
  inline void clear_has_param4();
  inline void set_has_param5();
  inline void clear_has_param5();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 param1_;
  ::google::protobuf::int64 param2_;
  ::google::protobuf::int64 param3_;
  ::google::protobuf::int64 param4_;
  ::google::protobuf::int64 param5_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static NFEventNoneData* default_instance_;
};
// -------------------------------------------------------------------

class NFEventScriptData : public ::google::protobuf::Message {
 public:
  NFEventScriptData();
  virtual ~NFEventScriptData();

  NFEventScriptData(const NFEventScriptData& from);

  inline NFEventScriptData& operator=(const NFEventScriptData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NFEventScriptData& default_instance();

  void Swap(NFEventScriptData* other);

  // implements Message ----------------------------------------------

  NFEventScriptData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NFEventScriptData& from);
  void MergeFrom(const NFEventScriptData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string event_type = 1;
  inline bool has_event_type() const;
  inline void clear_event_type();
  static const int kEventTypeFieldNumber = 1;
  inline const ::std::string& event_type() const;
  inline void set_event_type(const ::std::string& value);
  inline void set_event_type(const char* value);
  inline void set_event_type(const char* value, size_t size);
  inline ::std::string* mutable_event_type();
  inline ::std::string* release_event_type();
  inline void set_allocated_event_type(::std::string* event_type);

  // optional string event_data = 2;
  inline bool has_event_data() const;
  inline void clear_event_data();
  static const int kEventDataFieldNumber = 2;
  inline const ::std::string& event_data() const;
  inline void set_event_data(const ::std::string& value);
  inline void set_event_data(const char* value);
  inline void set_event_data(const char* value, size_t size);
  inline ::std::string* mutable_event_data();
  inline ::std::string* release_event_data();
  inline void set_allocated_event_data(::std::string* event_data);

  // @@protoc_insertion_point(class_scope:proto_ff.NFEventScriptData)
 private:
  inline void set_has_event_type();
  inline void clear_has_event_type();
  inline void set_has_event_data();
  inline void clear_has_event_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* event_type_;
  ::std::string* event_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static NFEventScriptData* default_instance_;
};
// -------------------------------------------------------------------

class Proto_ServerDumpInfoNtf : public ::google::protobuf::Message {
 public:
  Proto_ServerDumpInfoNtf();
  virtual ~Proto_ServerDumpInfoNtf();

  Proto_ServerDumpInfoNtf(const Proto_ServerDumpInfoNtf& from);

  inline Proto_ServerDumpInfoNtf& operator=(const Proto_ServerDumpInfoNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_ServerDumpInfoNtf& default_instance();

  void Swap(Proto_ServerDumpInfoNtf* other);

  // implements Message ----------------------------------------------

  Proto_ServerDumpInfoNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_ServerDumpInfoNtf& from);
  void MergeFrom(const Proto_ServerDumpInfoNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dump_info = 1;
  inline bool has_dump_info() const;
  inline void clear_dump_info();
  static const int kDumpInfoFieldNumber = 1;
  inline const ::std::string& dump_info() const;
  inline void set_dump_info(const ::std::string& value);
  inline void set_dump_info(const char* value);
  inline void set_dump_info(const char* value, size_t size);
  inline ::std::string* mutable_dump_info();
  inline ::std::string* release_dump_info();
  inline void set_allocated_dump_info(::std::string* dump_info);

  // optional uint32 bus_id = 2;
  inline bool has_bus_id() const;
  inline void clear_bus_id();
  static const int kBusIdFieldNumber = 2;
  inline ::google::protobuf::uint32 bus_id() const;
  inline void set_bus_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_ServerDumpInfoNtf)
 private:
  inline void set_has_dump_info();
  inline void clear_has_dump_info();
  inline void set_has_bus_id();
  inline void clear_has_bus_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dump_info_;
  ::google::protobuf::uint32 bus_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_ServerDumpInfoNtf* default_instance_;
};
// ===================================================================


// ===================================================================

// Proto_DispInfo

// optional uint64 user_id = 1;
inline bool Proto_DispInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_DispInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_DispInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_DispInfo::clear_user_id() {
  user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::uint64 Proto_DispInfo::user_id() const {
  return user_id_;
}
inline void Proto_DispInfo::set_user_id(::google::protobuf::uint64 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional int32 req_trans_id = 2;
inline bool Proto_DispInfo::has_req_trans_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_DispInfo::set_has_req_trans_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_DispInfo::clear_has_req_trans_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_DispInfo::clear_req_trans_id() {
  req_trans_id_ = 0;
  clear_has_req_trans_id();
}
inline ::google::protobuf::int32 Proto_DispInfo::req_trans_id() const {
  return req_trans_id_;
}
inline void Proto_DispInfo::set_req_trans_id(::google::protobuf::int32 value) {
  set_has_req_trans_id();
  req_trans_id_ = value;
}

// optional int32 rsp_trans_id = 3;
inline bool Proto_DispInfo::has_rsp_trans_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_DispInfo::set_has_rsp_trans_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_DispInfo::clear_has_rsp_trans_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_DispInfo::clear_rsp_trans_id() {
  rsp_trans_id_ = 0;
  clear_has_rsp_trans_id();
}
inline ::google::protobuf::int32 Proto_DispInfo::rsp_trans_id() const {
  return rsp_trans_id_;
}
inline void Proto_DispInfo::set_rsp_trans_id(::google::protobuf::int32 value) {
  set_has_rsp_trans_id();
  rsp_trans_id_ = value;
}

// -------------------------------------------------------------------

// Proto_StoreInfo_CB

// optional .proto_ff.PacketDispType type = 1;
inline bool Proto_StoreInfo_CB::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_StoreInfo_CB::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_StoreInfo_CB::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_StoreInfo_CB::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::proto_ff::PacketDispType Proto_StoreInfo_CB::type() const {
  return static_cast< ::proto_ff::PacketDispType >(type_);
}
inline void Proto_StoreInfo_CB::set_type(::proto_ff::PacketDispType value) {
  assert(::proto_ff::PacketDispType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint64 id = 2;
inline bool Proto_StoreInfo_CB::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_StoreInfo_CB::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_StoreInfo_CB::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_StoreInfo_CB::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Proto_StoreInfo_CB::id() const {
  return id_;
}
inline void Proto_StoreInfo_CB::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 table_id = 3;
inline bool Proto_StoreInfo_CB::has_table_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_StoreInfo_CB::set_has_table_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_StoreInfo_CB::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_StoreInfo_CB::clear_table_id() {
  table_id_ = 0u;
  clear_has_table_id();
}
inline ::google::protobuf::uint32 Proto_StoreInfo_CB::table_id() const {
  return table_id_;
}
inline void Proto_StoreInfo_CB::set_table_id(::google::protobuf::uint32 value) {
  set_has_table_id();
  table_id_ = value;
}

// optional uint32 seq = 4;
inline bool Proto_StoreInfo_CB::has_seq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Proto_StoreInfo_CB::set_has_seq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Proto_StoreInfo_CB::clear_has_seq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Proto_StoreInfo_CB::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 Proto_StoreInfo_CB::seq() const {
  return seq_;
}
inline void Proto_StoreInfo_CB::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
}

// -------------------------------------------------------------------

// Proto_StoreInfo

// optional uint32 cmd = 1;
inline bool Proto_StoreInfo::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_StoreInfo::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_StoreInfo::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_StoreInfo::clear_cmd() {
  cmd_ = 0u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 Proto_StoreInfo::cmd() const {
  return cmd_;
}
inline void Proto_StoreInfo::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 err_code = 2;
inline bool Proto_StoreInfo::has_err_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_StoreInfo::set_has_err_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_StoreInfo::clear_has_err_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_StoreInfo::clear_err_code() {
  err_code_ = 0;
  clear_has_err_code();
}
inline ::google::protobuf::int32 Proto_StoreInfo::err_code() const {
  return err_code_;
}
inline void Proto_StoreInfo::set_err_code(::google::protobuf::int32 value) {
  set_has_err_code();
  err_code_ = value;
}

// optional .proto_ff.Proto_StoreInfo_CB cb_data = 3;
inline bool Proto_StoreInfo::has_cb_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_StoreInfo::set_has_cb_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_StoreInfo::clear_has_cb_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_StoreInfo::clear_cb_data() {
  if (cb_data_ != NULL) cb_data_->::proto_ff::Proto_StoreInfo_CB::Clear();
  clear_has_cb_data();
}
inline const ::proto_ff::Proto_StoreInfo_CB& Proto_StoreInfo::cb_data() const {
  return cb_data_ != NULL ? *cb_data_ : *default_instance_->cb_data_;
}
inline ::proto_ff::Proto_StoreInfo_CB* Proto_StoreInfo::mutable_cb_data() {
  set_has_cb_data();
  if (cb_data_ == NULL) cb_data_ = new ::proto_ff::Proto_StoreInfo_CB;
  return cb_data_;
}
inline ::proto_ff::Proto_StoreInfo_CB* Proto_StoreInfo::release_cb_data() {
  clear_has_cb_data();
  ::proto_ff::Proto_StoreInfo_CB* temp = cb_data_;
  cb_data_ = NULL;
  return temp;
}
inline void Proto_StoreInfo::set_allocated_cb_data(::proto_ff::Proto_StoreInfo_CB* cb_data) {
  delete cb_data_;
  cb_data_ = cb_data;
  if (cb_data) {
    set_has_cb_data();
  } else {
    clear_has_cb_data();
  }
}

// -------------------------------------------------------------------

// Proto_EventInfo

// optional uint32 server_type = 1;
inline bool Proto_EventInfo::has_server_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_EventInfo::set_has_server_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_EventInfo::clear_has_server_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_EventInfo::clear_server_type() {
  server_type_ = 0u;
  clear_has_server_type();
}
inline ::google::protobuf::uint32 Proto_EventInfo::server_type() const {
  return server_type_;
}
inline void Proto_EventInfo::set_server_type(::google::protobuf::uint32 value) {
  set_has_server_type();
  server_type_ = value;
}

// optional uint64 event_id = 2;
inline bool Proto_EventInfo::has_event_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_EventInfo::set_has_event_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_EventInfo::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_EventInfo::clear_event_id() {
  event_id_ = GOOGLE_ULONGLONG(0);
  clear_has_event_id();
}
inline ::google::protobuf::uint64 Proto_EventInfo::event_id() const {
  return event_id_;
}
inline void Proto_EventInfo::set_event_id(::google::protobuf::uint64 value) {
  set_has_event_id();
  event_id_ = value;
}

// optional uint64 src_type = 3;
inline bool Proto_EventInfo::has_src_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_EventInfo::set_has_src_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_EventInfo::clear_has_src_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_EventInfo::clear_src_type() {
  src_type_ = GOOGLE_ULONGLONG(0);
  clear_has_src_type();
}
inline ::google::protobuf::uint64 Proto_EventInfo::src_type() const {
  return src_type_;
}
inline void Proto_EventInfo::set_src_type(::google::protobuf::uint64 value) {
  set_has_src_type();
  src_type_ = value;
}

// optional uint64 src_id = 4;
inline bool Proto_EventInfo::has_src_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Proto_EventInfo::set_has_src_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Proto_EventInfo::clear_has_src_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Proto_EventInfo::clear_src_id() {
  src_id_ = GOOGLE_ULONGLONG(0);
  clear_has_src_id();
}
inline ::google::protobuf::uint64 Proto_EventInfo::src_id() const {
  return src_id_;
}
inline void Proto_EventInfo::set_src_id(::google::protobuf::uint64 value) {
  set_has_src_id();
  src_id_ = value;
}

// optional string full_message_name = 5;
inline bool Proto_EventInfo::has_full_message_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Proto_EventInfo::set_has_full_message_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Proto_EventInfo::clear_has_full_message_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Proto_EventInfo::clear_full_message_name() {
  if (full_message_name_ != &::google::protobuf::internal::kEmptyString) {
    full_message_name_->clear();
  }
  clear_has_full_message_name();
}
inline const ::std::string& Proto_EventInfo::full_message_name() const {
  return *full_message_name_;
}
inline void Proto_EventInfo::set_full_message_name(const ::std::string& value) {
  set_has_full_message_name();
  if (full_message_name_ == &::google::protobuf::internal::kEmptyString) {
    full_message_name_ = new ::std::string;
  }
  full_message_name_->assign(value);
}
inline void Proto_EventInfo::set_full_message_name(const char* value) {
  set_has_full_message_name();
  if (full_message_name_ == &::google::protobuf::internal::kEmptyString) {
    full_message_name_ = new ::std::string;
  }
  full_message_name_->assign(value);
}
inline void Proto_EventInfo::set_full_message_name(const char* value, size_t size) {
  set_has_full_message_name();
  if (full_message_name_ == &::google::protobuf::internal::kEmptyString) {
    full_message_name_ = new ::std::string;
  }
  full_message_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Proto_EventInfo::mutable_full_message_name() {
  set_has_full_message_name();
  if (full_message_name_ == &::google::protobuf::internal::kEmptyString) {
    full_message_name_ = new ::std::string;
  }
  return full_message_name_;
}
inline ::std::string* Proto_EventInfo::release_full_message_name() {
  clear_has_full_message_name();
  if (full_message_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = full_message_name_;
    full_message_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Proto_EventInfo::set_allocated_full_message_name(::std::string* full_message_name) {
  if (full_message_name_ != &::google::protobuf::internal::kEmptyString) {
    delete full_message_name_;
  }
  if (full_message_name) {
    set_has_full_message_name();
    full_message_name_ = full_message_name;
  } else {
    clear_has_full_message_name();
    full_message_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Proto_ScriptRpcResult

// optional string req_type = 1;
inline bool Proto_ScriptRpcResult::has_req_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_ScriptRpcResult::set_has_req_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_ScriptRpcResult::clear_has_req_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_ScriptRpcResult::clear_req_type() {
  if (req_type_ != &::google::protobuf::internal::kEmptyString) {
    req_type_->clear();
  }
  clear_has_req_type();
}
inline const ::std::string& Proto_ScriptRpcResult::req_type() const {
  return *req_type_;
}
inline void Proto_ScriptRpcResult::set_req_type(const ::std::string& value) {
  set_has_req_type();
  if (req_type_ == &::google::protobuf::internal::kEmptyString) {
    req_type_ = new ::std::string;
  }
  req_type_->assign(value);
}
inline void Proto_ScriptRpcResult::set_req_type(const char* value) {
  set_has_req_type();
  if (req_type_ == &::google::protobuf::internal::kEmptyString) {
    req_type_ = new ::std::string;
  }
  req_type_->assign(value);
}
inline void Proto_ScriptRpcResult::set_req_type(const char* value, size_t size) {
  set_has_req_type();
  if (req_type_ == &::google::protobuf::internal::kEmptyString) {
    req_type_ = new ::std::string;
  }
  req_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Proto_ScriptRpcResult::mutable_req_type() {
  set_has_req_type();
  if (req_type_ == &::google::protobuf::internal::kEmptyString) {
    req_type_ = new ::std::string;
  }
  return req_type_;
}
inline ::std::string* Proto_ScriptRpcResult::release_req_type() {
  clear_has_req_type();
  if (req_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = req_type_;
    req_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Proto_ScriptRpcResult::set_allocated_req_type(::std::string* req_type) {
  if (req_type_ != &::google::protobuf::internal::kEmptyString) {
    delete req_type_;
  }
  if (req_type) {
    set_has_req_type();
    req_type_ = req_type;
  } else {
    clear_has_req_type();
    req_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string rsp_type = 2;
inline bool Proto_ScriptRpcResult::has_rsp_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_ScriptRpcResult::set_has_rsp_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_ScriptRpcResult::clear_has_rsp_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_ScriptRpcResult::clear_rsp_type() {
  if (rsp_type_ != &::google::protobuf::internal::kEmptyString) {
    rsp_type_->clear();
  }
  clear_has_rsp_type();
}
inline const ::std::string& Proto_ScriptRpcResult::rsp_type() const {
  return *rsp_type_;
}
inline void Proto_ScriptRpcResult::set_rsp_type(const ::std::string& value) {
  set_has_rsp_type();
  if (rsp_type_ == &::google::protobuf::internal::kEmptyString) {
    rsp_type_ = new ::std::string;
  }
  rsp_type_->assign(value);
}
inline void Proto_ScriptRpcResult::set_rsp_type(const char* value) {
  set_has_rsp_type();
  if (rsp_type_ == &::google::protobuf::internal::kEmptyString) {
    rsp_type_ = new ::std::string;
  }
  rsp_type_->assign(value);
}
inline void Proto_ScriptRpcResult::set_rsp_type(const char* value, size_t size) {
  set_has_rsp_type();
  if (rsp_type_ == &::google::protobuf::internal::kEmptyString) {
    rsp_type_ = new ::std::string;
  }
  rsp_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Proto_ScriptRpcResult::mutable_rsp_type() {
  set_has_rsp_type();
  if (rsp_type_ == &::google::protobuf::internal::kEmptyString) {
    rsp_type_ = new ::std::string;
  }
  return rsp_type_;
}
inline ::std::string* Proto_ScriptRpcResult::release_rsp_type() {
  clear_has_rsp_type();
  if (rsp_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rsp_type_;
    rsp_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Proto_ScriptRpcResult::set_allocated_rsp_type(::std::string* rsp_type) {
  if (rsp_type_ != &::google::protobuf::internal::kEmptyString) {
    delete rsp_type_;
  }
  if (rsp_type) {
    set_has_rsp_type();
    rsp_type_ = rsp_type;
  } else {
    clear_has_rsp_type();
    rsp_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string respone = 3;
inline bool Proto_ScriptRpcResult::has_respone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_ScriptRpcResult::set_has_respone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_ScriptRpcResult::clear_has_respone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_ScriptRpcResult::clear_respone() {
  if (respone_ != &::google::protobuf::internal::kEmptyString) {
    respone_->clear();
  }
  clear_has_respone();
}
inline const ::std::string& Proto_ScriptRpcResult::respone() const {
  return *respone_;
}
inline void Proto_ScriptRpcResult::set_respone(const ::std::string& value) {
  set_has_respone();
  if (respone_ == &::google::protobuf::internal::kEmptyString) {
    respone_ = new ::std::string;
  }
  respone_->assign(value);
}
inline void Proto_ScriptRpcResult::set_respone(const char* value) {
  set_has_respone();
  if (respone_ == &::google::protobuf::internal::kEmptyString) {
    respone_ = new ::std::string;
  }
  respone_->assign(value);
}
inline void Proto_ScriptRpcResult::set_respone(const char* value, size_t size) {
  set_has_respone();
  if (respone_ == &::google::protobuf::internal::kEmptyString) {
    respone_ = new ::std::string;
  }
  respone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Proto_ScriptRpcResult::mutable_respone() {
  set_has_respone();
  if (respone_ == &::google::protobuf::internal::kEmptyString) {
    respone_ = new ::std::string;
  }
  return respone_;
}
inline ::std::string* Proto_ScriptRpcResult::release_respone() {
  clear_has_respone();
  if (respone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respone_;
    respone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Proto_ScriptRpcResult::set_allocated_respone(::std::string* respone) {
  if (respone_ != &::google::protobuf::internal::kEmptyString) {
    delete respone_;
  }
  if (respone) {
    set_has_respone();
    respone_ = respone;
  } else {
    clear_has_respone();
    respone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Proto_RpcInfo

// optional int64 req_rpc_id = 1;
inline bool Proto_RpcInfo::has_req_rpc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_RpcInfo::set_has_req_rpc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_RpcInfo::clear_has_req_rpc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_RpcInfo::clear_req_rpc_id() {
  req_rpc_id_ = GOOGLE_LONGLONG(0);
  clear_has_req_rpc_id();
}
inline ::google::protobuf::int64 Proto_RpcInfo::req_rpc_id() const {
  return req_rpc_id_;
}
inline void Proto_RpcInfo::set_req_rpc_id(::google::protobuf::int64 value) {
  set_has_req_rpc_id();
  req_rpc_id_ = value;
}

// optional int64 rsp_rpc_id = 2;
inline bool Proto_RpcInfo::has_rsp_rpc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_RpcInfo::set_has_rsp_rpc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_RpcInfo::clear_has_rsp_rpc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_RpcInfo::clear_rsp_rpc_id() {
  rsp_rpc_id_ = GOOGLE_LONGLONG(0);
  clear_has_rsp_rpc_id();
}
inline ::google::protobuf::int64 Proto_RpcInfo::rsp_rpc_id() const {
  return rsp_rpc_id_;
}
inline void Proto_RpcInfo::set_rsp_rpc_id(::google::protobuf::int64 value) {
  set_has_rsp_rpc_id();
  rsp_rpc_id_ = value;
}

// optional int32 rpc_ret_code = 3;
inline bool Proto_RpcInfo::has_rpc_ret_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_RpcInfo::set_has_rpc_ret_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_RpcInfo::clear_has_rpc_ret_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_RpcInfo::clear_rpc_ret_code() {
  rpc_ret_code_ = 0;
  clear_has_rpc_ret_code();
}
inline ::google::protobuf::int32 Proto_RpcInfo::rpc_ret_code() const {
  return rpc_ret_code_;
}
inline void Proto_RpcInfo::set_rpc_ret_code(::google::protobuf::int32 value) {
  set_has_rpc_ret_code();
  rpc_ret_code_ = value;
}

// optional uint64 req_rpc_hash = 4;
inline bool Proto_RpcInfo::has_req_rpc_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Proto_RpcInfo::set_has_req_rpc_hash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Proto_RpcInfo::clear_has_req_rpc_hash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Proto_RpcInfo::clear_req_rpc_hash() {
  req_rpc_hash_ = GOOGLE_ULONGLONG(0);
  clear_has_req_rpc_hash();
}
inline ::google::protobuf::uint64 Proto_RpcInfo::req_rpc_hash() const {
  return req_rpc_hash_;
}
inline void Proto_RpcInfo::set_req_rpc_hash(::google::protobuf::uint64 value) {
  set_has_req_rpc_hash();
  req_rpc_hash_ = value;
}

// optional uint64 rsp_rpc_hash = 5;
inline bool Proto_RpcInfo::has_rsp_rpc_hash() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Proto_RpcInfo::set_has_rsp_rpc_hash() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Proto_RpcInfo::clear_has_rsp_rpc_hash() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Proto_RpcInfo::clear_rsp_rpc_hash() {
  rsp_rpc_hash_ = GOOGLE_ULONGLONG(0);
  clear_has_rsp_rpc_hash();
}
inline ::google::protobuf::uint64 Proto_RpcInfo::rsp_rpc_hash() const {
  return rsp_rpc_hash_;
}
inline void Proto_RpcInfo::set_rsp_rpc_hash(::google::protobuf::uint64 value) {
  set_has_rsp_rpc_hash();
  rsp_rpc_hash_ = value;
}

// optional uint32 req_bus_id = 6;
inline bool Proto_RpcInfo::has_req_bus_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Proto_RpcInfo::set_has_req_bus_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Proto_RpcInfo::clear_has_req_bus_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Proto_RpcInfo::clear_req_bus_id() {
  req_bus_id_ = 0u;
  clear_has_req_bus_id();
}
inline ::google::protobuf::uint32 Proto_RpcInfo::req_bus_id() const {
  return req_bus_id_;
}
inline void Proto_RpcInfo::set_req_bus_id(::google::protobuf::uint32 value) {
  set_has_req_bus_id();
  req_bus_id_ = value;
}

// optional uint64 req_server_type = 7;
inline bool Proto_RpcInfo::has_req_server_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Proto_RpcInfo::set_has_req_server_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Proto_RpcInfo::clear_has_req_server_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Proto_RpcInfo::clear_req_server_type() {
  req_server_type_ = GOOGLE_ULONGLONG(0);
  clear_has_req_server_type();
}
inline ::google::protobuf::uint64 Proto_RpcInfo::req_server_type() const {
  return req_server_type_;
}
inline void Proto_RpcInfo::set_req_server_type(::google::protobuf::uint64 value) {
  set_has_req_server_type();
  req_server_type_ = value;
}

// optional bool is_script_rpc = 8;
inline bool Proto_RpcInfo::has_is_script_rpc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Proto_RpcInfo::set_has_is_script_rpc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Proto_RpcInfo::clear_has_is_script_rpc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Proto_RpcInfo::clear_is_script_rpc() {
  is_script_rpc_ = false;
  clear_has_is_script_rpc();
}
inline bool Proto_RpcInfo::is_script_rpc() const {
  return is_script_rpc_;
}
inline void Proto_RpcInfo::set_is_script_rpc(bool value) {
  set_has_is_script_rpc();
  is_script_rpc_ = value;
}

// -------------------------------------------------------------------

// Proto_RedirectInfo

// repeated uint64 id = 1;
inline int Proto_RedirectInfo::id_size() const {
  return id_.size();
}
inline void Proto_RedirectInfo::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::uint64 Proto_RedirectInfo::id(int index) const {
  return id_.Get(index);
}
inline void Proto_RedirectInfo::set_id(int index, ::google::protobuf::uint64 value) {
  id_.Set(index, value);
}
inline void Proto_RedirectInfo::add_id(::google::protobuf::uint64 value) {
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Proto_RedirectInfo::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Proto_RedirectInfo::mutable_id() {
  return &id_;
}

// optional bool all = 2;
inline bool Proto_RedirectInfo::has_all() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_RedirectInfo::set_has_all() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_RedirectInfo::clear_has_all() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_RedirectInfo::clear_all() {
  all_ = false;
  clear_has_all();
}
inline bool Proto_RedirectInfo::all() const {
  return all_;
}
inline void Proto_RedirectInfo::set_all(bool value) {
  set_has_all();
  all_ = value;
}

// -------------------------------------------------------------------

// Proto_SvrPkg

// optional int32 msg_id = 1;
inline bool Proto_SvrPkg::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_SvrPkg::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_SvrPkg::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_SvrPkg::clear_msg_id() {
  msg_id_ = 0;
  clear_has_msg_id();
}
inline ::google::protobuf::int32 Proto_SvrPkg::msg_id() const {
  return msg_id_;
}
inline void Proto_SvrPkg::set_msg_id(::google::protobuf::int32 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// optional bytes msg_data = 2;
inline bool Proto_SvrPkg::has_msg_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_SvrPkg::set_has_msg_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_SvrPkg::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_SvrPkg::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& Proto_SvrPkg::msg_data() const {
  return *msg_data_;
}
inline void Proto_SvrPkg::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void Proto_SvrPkg::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void Proto_SvrPkg::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Proto_SvrPkg::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  return msg_data_;
}
inline ::std::string* Proto_SvrPkg::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Proto_SvrPkg::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto_ff.Proto_DispInfo disp_info = 3;
inline bool Proto_SvrPkg::has_disp_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_SvrPkg::set_has_disp_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_SvrPkg::clear_has_disp_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_SvrPkg::clear_disp_info() {
  if (disp_info_ != NULL) disp_info_->::proto_ff::Proto_DispInfo::Clear();
  clear_has_disp_info();
}
inline const ::proto_ff::Proto_DispInfo& Proto_SvrPkg::disp_info() const {
  return disp_info_ != NULL ? *disp_info_ : *default_instance_->disp_info_;
}
inline ::proto_ff::Proto_DispInfo* Proto_SvrPkg::mutable_disp_info() {
  set_has_disp_info();
  if (disp_info_ == NULL) disp_info_ = new ::proto_ff::Proto_DispInfo;
  return disp_info_;
}
inline ::proto_ff::Proto_DispInfo* Proto_SvrPkg::release_disp_info() {
  clear_has_disp_info();
  ::proto_ff::Proto_DispInfo* temp = disp_info_;
  disp_info_ = NULL;
  return temp;
}
inline void Proto_SvrPkg::set_allocated_disp_info(::proto_ff::Proto_DispInfo* disp_info) {
  delete disp_info_;
  disp_info_ = disp_info;
  if (disp_info) {
    set_has_disp_info();
  } else {
    clear_has_disp_info();
  }
}

// optional .proto_ff.Proto_StoreInfo store_info = 4;
inline bool Proto_SvrPkg::has_store_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Proto_SvrPkg::set_has_store_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Proto_SvrPkg::clear_has_store_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Proto_SvrPkg::clear_store_info() {
  if (store_info_ != NULL) store_info_->::proto_ff::Proto_StoreInfo::Clear();
  clear_has_store_info();
}
inline const ::proto_ff::Proto_StoreInfo& Proto_SvrPkg::store_info() const {
  return store_info_ != NULL ? *store_info_ : *default_instance_->store_info_;
}
inline ::proto_ff::Proto_StoreInfo* Proto_SvrPkg::mutable_store_info() {
  set_has_store_info();
  if (store_info_ == NULL) store_info_ = new ::proto_ff::Proto_StoreInfo;
  return store_info_;
}
inline ::proto_ff::Proto_StoreInfo* Proto_SvrPkg::release_store_info() {
  clear_has_store_info();
  ::proto_ff::Proto_StoreInfo* temp = store_info_;
  store_info_ = NULL;
  return temp;
}
inline void Proto_SvrPkg::set_allocated_store_info(::proto_ff::Proto_StoreInfo* store_info) {
  delete store_info_;
  store_info_ = store_info;
  if (store_info) {
    set_has_store_info();
  } else {
    clear_has_store_info();
  }
}

// optional .proto_ff.Proto_EventInfo event_info = 5;
inline bool Proto_SvrPkg::has_event_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Proto_SvrPkg::set_has_event_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Proto_SvrPkg::clear_has_event_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Proto_SvrPkg::clear_event_info() {
  if (event_info_ != NULL) event_info_->::proto_ff::Proto_EventInfo::Clear();
  clear_has_event_info();
}
inline const ::proto_ff::Proto_EventInfo& Proto_SvrPkg::event_info() const {
  return event_info_ != NULL ? *event_info_ : *default_instance_->event_info_;
}
inline ::proto_ff::Proto_EventInfo* Proto_SvrPkg::mutable_event_info() {
  set_has_event_info();
  if (event_info_ == NULL) event_info_ = new ::proto_ff::Proto_EventInfo;
  return event_info_;
}
inline ::proto_ff::Proto_EventInfo* Proto_SvrPkg::release_event_info() {
  clear_has_event_info();
  ::proto_ff::Proto_EventInfo* temp = event_info_;
  event_info_ = NULL;
  return temp;
}
inline void Proto_SvrPkg::set_allocated_event_info(::proto_ff::Proto_EventInfo* event_info) {
  delete event_info_;
  event_info_ = event_info;
  if (event_info) {
    set_has_event_info();
  } else {
    clear_has_event_info();
  }
}

// optional .proto_ff.Proto_RedirectInfo redirect_info = 6;
inline bool Proto_SvrPkg::has_redirect_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Proto_SvrPkg::set_has_redirect_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Proto_SvrPkg::clear_has_redirect_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Proto_SvrPkg::clear_redirect_info() {
  if (redirect_info_ != NULL) redirect_info_->::proto_ff::Proto_RedirectInfo::Clear();
  clear_has_redirect_info();
}
inline const ::proto_ff::Proto_RedirectInfo& Proto_SvrPkg::redirect_info() const {
  return redirect_info_ != NULL ? *redirect_info_ : *default_instance_->redirect_info_;
}
inline ::proto_ff::Proto_RedirectInfo* Proto_SvrPkg::mutable_redirect_info() {
  set_has_redirect_info();
  if (redirect_info_ == NULL) redirect_info_ = new ::proto_ff::Proto_RedirectInfo;
  return redirect_info_;
}
inline ::proto_ff::Proto_RedirectInfo* Proto_SvrPkg::release_redirect_info() {
  clear_has_redirect_info();
  ::proto_ff::Proto_RedirectInfo* temp = redirect_info_;
  redirect_info_ = NULL;
  return temp;
}
inline void Proto_SvrPkg::set_allocated_redirect_info(::proto_ff::Proto_RedirectInfo* redirect_info) {
  delete redirect_info_;
  redirect_info_ = redirect_info;
  if (redirect_info) {
    set_has_redirect_info();
  } else {
    clear_has_redirect_info();
  }
}

// optional .proto_ff.Proto_RpcInfo rpc_info = 7;
inline bool Proto_SvrPkg::has_rpc_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Proto_SvrPkg::set_has_rpc_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Proto_SvrPkg::clear_has_rpc_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Proto_SvrPkg::clear_rpc_info() {
  if (rpc_info_ != NULL) rpc_info_->::proto_ff::Proto_RpcInfo::Clear();
  clear_has_rpc_info();
}
inline const ::proto_ff::Proto_RpcInfo& Proto_SvrPkg::rpc_info() const {
  return rpc_info_ != NULL ? *rpc_info_ : *default_instance_->rpc_info_;
}
inline ::proto_ff::Proto_RpcInfo* Proto_SvrPkg::mutable_rpc_info() {
  set_has_rpc_info();
  if (rpc_info_ == NULL) rpc_info_ = new ::proto_ff::Proto_RpcInfo;
  return rpc_info_;
}
inline ::proto_ff::Proto_RpcInfo* Proto_SvrPkg::release_rpc_info() {
  clear_has_rpc_info();
  ::proto_ff::Proto_RpcInfo* temp = rpc_info_;
  rpc_info_ = NULL;
  return temp;
}
inline void Proto_SvrPkg::set_allocated_rpc_info(::proto_ff::Proto_RpcInfo* rpc_info) {
  delete rpc_info_;
  rpc_info_ = rpc_info;
  if (rpc_info) {
    set_has_rpc_info();
  } else {
    clear_has_rpc_info();
  }
}

// -------------------------------------------------------------------

// ServerInfoReport

// optional uint32 bus_id = 1;
inline bool ServerInfoReport::has_bus_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfoReport::set_has_bus_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfoReport::clear_has_bus_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfoReport::clear_bus_id() {
  bus_id_ = 0u;
  clear_has_bus_id();
}
inline ::google::protobuf::uint32 ServerInfoReport::bus_id() const {
  return bus_id_;
}
inline void ServerInfoReport::set_bus_id(::google::protobuf::uint32 value) {
  set_has_bus_id();
  bus_id_ = value;
}

// optional string server_id = 2;
inline bool ServerInfoReport::has_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerInfoReport::set_has_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerInfoReport::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerInfoReport::clear_server_id() {
  if (server_id_ != &::google::protobuf::internal::kEmptyString) {
    server_id_->clear();
  }
  clear_has_server_id();
}
inline const ::std::string& ServerInfoReport::server_id() const {
  return *server_id_;
}
inline void ServerInfoReport::set_server_id(const ::std::string& value) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(value);
}
inline void ServerInfoReport::set_server_id(const char* value) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(value);
}
inline void ServerInfoReport::set_server_id(const char* value, size_t size) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_server_id() {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  return server_id_;
}
inline ::std::string* ServerInfoReport::release_server_id() {
  clear_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_id_;
    server_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_server_id(::std::string* server_id) {
  if (server_id_ != &::google::protobuf::internal::kEmptyString) {
    delete server_id_;
  }
  if (server_id) {
    set_has_server_id();
    server_id_ = server_id;
  } else {
    clear_has_server_id();
    server_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 server_type = 3;
inline bool ServerInfoReport::has_server_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerInfoReport::set_has_server_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerInfoReport::clear_has_server_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerInfoReport::clear_server_type() {
  server_type_ = 0u;
  clear_has_server_type();
}
inline ::google::protobuf::uint32 ServerInfoReport::server_type() const {
  return server_type_;
}
inline void ServerInfoReport::set_server_type(::google::protobuf::uint32 value) {
  set_has_server_type();
  server_type_ = value;
}

// optional string server_name = 4;
inline bool ServerInfoReport::has_server_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerInfoReport::set_has_server_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerInfoReport::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerInfoReport::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& ServerInfoReport::server_name() const {
  return *server_name_;
}
inline void ServerInfoReport::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void ServerInfoReport::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void ServerInfoReport::set_server_name(const char* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  return server_name_;
}
inline ::std::string* ServerInfoReport::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string url = 5;
inline bool ServerInfoReport::has_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerInfoReport::set_has_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerInfoReport::clear_has_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerInfoReport::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ServerInfoReport::url() const {
  return *url_;
}
inline void ServerInfoReport::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ServerInfoReport::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ServerInfoReport::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ServerInfoReport::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string link_mode = 6;
inline bool ServerInfoReport::has_link_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerInfoReport::set_has_link_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerInfoReport::clear_has_link_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerInfoReport::clear_link_mode() {
  if (link_mode_ != &::google::protobuf::internal::kEmptyString) {
    link_mode_->clear();
  }
  clear_has_link_mode();
}
inline const ::std::string& ServerInfoReport::link_mode() const {
  return *link_mode_;
}
inline void ServerInfoReport::set_link_mode(const ::std::string& value) {
  set_has_link_mode();
  if (link_mode_ == &::google::protobuf::internal::kEmptyString) {
    link_mode_ = new ::std::string;
  }
  link_mode_->assign(value);
}
inline void ServerInfoReport::set_link_mode(const char* value) {
  set_has_link_mode();
  if (link_mode_ == &::google::protobuf::internal::kEmptyString) {
    link_mode_ = new ::std::string;
  }
  link_mode_->assign(value);
}
inline void ServerInfoReport::set_link_mode(const char* value, size_t size) {
  set_has_link_mode();
  if (link_mode_ == &::google::protobuf::internal::kEmptyString) {
    link_mode_ = new ::std::string;
  }
  link_mode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_link_mode() {
  set_has_link_mode();
  if (link_mode_ == &::google::protobuf::internal::kEmptyString) {
    link_mode_ = new ::std::string;
  }
  return link_mode_;
}
inline ::std::string* ServerInfoReport::release_link_mode() {
  clear_has_link_mode();
  if (link_mode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = link_mode_;
    link_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_link_mode(::std::string* link_mode) {
  if (link_mode_ != &::google::protobuf::internal::kEmptyString) {
    delete link_mode_;
  }
  if (link_mode) {
    set_has_link_mode();
    link_mode_ = link_mode;
  } else {
    clear_has_link_mode();
    link_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 bus_length = 7;
inline bool ServerInfoReport::has_bus_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServerInfoReport::set_has_bus_length() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServerInfoReport::clear_has_bus_length() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServerInfoReport::clear_bus_length() {
  bus_length_ = 0u;
  clear_has_bus_length();
}
inline ::google::protobuf::uint32 ServerInfoReport::bus_length() const {
  return bus_length_;
}
inline void ServerInfoReport::set_bus_length(::google::protobuf::uint32 value) {
  set_has_bus_length();
  bus_length_ = value;
}

// optional string server_ip = 9;
inline bool ServerInfoReport::has_server_ip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServerInfoReport::set_has_server_ip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServerInfoReport::clear_has_server_ip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServerInfoReport::clear_server_ip() {
  if (server_ip_ != &::google::protobuf::internal::kEmptyString) {
    server_ip_->clear();
  }
  clear_has_server_ip();
}
inline const ::std::string& ServerInfoReport::server_ip() const {
  return *server_ip_;
}
inline void ServerInfoReport::set_server_ip(const ::std::string& value) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(value);
}
inline void ServerInfoReport::set_server_ip(const char* value) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(value);
}
inline void ServerInfoReport::set_server_ip(const char* value, size_t size) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_server_ip() {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  return server_ip_;
}
inline ::std::string* ServerInfoReport::release_server_ip() {
  clear_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_ip_;
    server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_server_ip(::std::string* server_ip) {
  if (server_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete server_ip_;
  }
  if (server_ip) {
    set_has_server_ip();
    server_ip_ = server_ip;
  } else {
    clear_has_server_ip();
    server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 server_port = 10;
inline bool ServerInfoReport::has_server_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServerInfoReport::set_has_server_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServerInfoReport::clear_has_server_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServerInfoReport::clear_server_port() {
  server_port_ = 0u;
  clear_has_server_port();
}
inline ::google::protobuf::uint32 ServerInfoReport::server_port() const {
  return server_port_;
}
inline void ServerInfoReport::set_server_port(::google::protobuf::uint32 value) {
  set_has_server_port();
  server_port_ = value;
}

// optional uint32 server_http_port = 11;
inline bool ServerInfoReport::has_server_http_port() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ServerInfoReport::set_has_server_http_port() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ServerInfoReport::clear_has_server_http_port() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ServerInfoReport::clear_server_http_port() {
  server_http_port_ = 0u;
  clear_has_server_http_port();
}
inline ::google::protobuf::uint32 ServerInfoReport::server_http_port() const {
  return server_http_port_;
}
inline void ServerInfoReport::set_server_http_port(::google::protobuf::uint32 value) {
  set_has_server_http_port();
  server_http_port_ = value;
}

// optional string external_server_ip = 12;
inline bool ServerInfoReport::has_external_server_ip() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ServerInfoReport::set_has_external_server_ip() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ServerInfoReport::clear_has_external_server_ip() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ServerInfoReport::clear_external_server_ip() {
  if (external_server_ip_ != &::google::protobuf::internal::kEmptyString) {
    external_server_ip_->clear();
  }
  clear_has_external_server_ip();
}
inline const ::std::string& ServerInfoReport::external_server_ip() const {
  return *external_server_ip_;
}
inline void ServerInfoReport::set_external_server_ip(const ::std::string& value) {
  set_has_external_server_ip();
  if (external_server_ip_ == &::google::protobuf::internal::kEmptyString) {
    external_server_ip_ = new ::std::string;
  }
  external_server_ip_->assign(value);
}
inline void ServerInfoReport::set_external_server_ip(const char* value) {
  set_has_external_server_ip();
  if (external_server_ip_ == &::google::protobuf::internal::kEmptyString) {
    external_server_ip_ = new ::std::string;
  }
  external_server_ip_->assign(value);
}
inline void ServerInfoReport::set_external_server_ip(const char* value, size_t size) {
  set_has_external_server_ip();
  if (external_server_ip_ == &::google::protobuf::internal::kEmptyString) {
    external_server_ip_ = new ::std::string;
  }
  external_server_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_external_server_ip() {
  set_has_external_server_ip();
  if (external_server_ip_ == &::google::protobuf::internal::kEmptyString) {
    external_server_ip_ = new ::std::string;
  }
  return external_server_ip_;
}
inline ::std::string* ServerInfoReport::release_external_server_ip() {
  clear_has_external_server_ip();
  if (external_server_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = external_server_ip_;
    external_server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_external_server_ip(::std::string* external_server_ip) {
  if (external_server_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete external_server_ip_;
  }
  if (external_server_ip) {
    set_has_external_server_ip();
    external_server_ip_ = external_server_ip;
  } else {
    clear_has_external_server_ip();
    external_server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 external_server_port = 13;
inline bool ServerInfoReport::has_external_server_port() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ServerInfoReport::set_has_external_server_port() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ServerInfoReport::clear_has_external_server_port() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ServerInfoReport::clear_external_server_port() {
  external_server_port_ = 0u;
  clear_has_external_server_port();
}
inline ::google::protobuf::uint32 ServerInfoReport::external_server_port() const {
  return external_server_port_;
}
inline void ServerInfoReport::set_external_server_port(::google::protobuf::uint32 value) {
  set_has_external_server_port();
  external_server_port_ = value;
}

// optional bool is_cross_server = 14;
inline bool ServerInfoReport::has_is_cross_server() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ServerInfoReport::set_has_is_cross_server() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ServerInfoReport::clear_has_is_cross_server() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ServerInfoReport::clear_is_cross_server() {
  is_cross_server_ = false;
  clear_has_is_cross_server();
}
inline bool ServerInfoReport::is_cross_server() const {
  return is_cross_server_;
}
inline void ServerInfoReport::set_is_cross_server(bool value) {
  set_has_is_cross_server();
  is_cross_server_ = value;
}

// optional string route_svr = 15;
inline bool ServerInfoReport::has_route_svr() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ServerInfoReport::set_has_route_svr() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ServerInfoReport::clear_has_route_svr() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ServerInfoReport::clear_route_svr() {
  if (route_svr_ != &::google::protobuf::internal::kEmptyString) {
    route_svr_->clear();
  }
  clear_has_route_svr();
}
inline const ::std::string& ServerInfoReport::route_svr() const {
  return *route_svr_;
}
inline void ServerInfoReport::set_route_svr(const ::std::string& value) {
  set_has_route_svr();
  if (route_svr_ == &::google::protobuf::internal::kEmptyString) {
    route_svr_ = new ::std::string;
  }
  route_svr_->assign(value);
}
inline void ServerInfoReport::set_route_svr(const char* value) {
  set_has_route_svr();
  if (route_svr_ == &::google::protobuf::internal::kEmptyString) {
    route_svr_ = new ::std::string;
  }
  route_svr_->assign(value);
}
inline void ServerInfoReport::set_route_svr(const char* value, size_t size) {
  set_has_route_svr();
  if (route_svr_ == &::google::protobuf::internal::kEmptyString) {
    route_svr_ = new ::std::string;
  }
  route_svr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_route_svr() {
  set_has_route_svr();
  if (route_svr_ == &::google::protobuf::internal::kEmptyString) {
    route_svr_ = new ::std::string;
  }
  return route_svr_;
}
inline ::std::string* ServerInfoReport::release_route_svr() {
  clear_has_route_svr();
  if (route_svr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = route_svr_;
    route_svr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_route_svr(::std::string* route_svr) {
  if (route_svr_ != &::google::protobuf::internal::kEmptyString) {
    delete route_svr_;
  }
  if (route_svr) {
    set_has_route_svr();
    route_svr_ = route_svr;
  } else {
    clear_has_route_svr();
    route_svr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 server_max_online = 30;
inline bool ServerInfoReport::has_server_max_online() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ServerInfoReport::set_has_server_max_online() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ServerInfoReport::clear_has_server_max_online() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ServerInfoReport::clear_server_max_online() {
  server_max_online_ = 0u;
  clear_has_server_max_online();
}
inline ::google::protobuf::uint32 ServerInfoReport::server_max_online() const {
  return server_max_online_;
}
inline void ServerInfoReport::set_server_max_online(::google::protobuf::uint32 value) {
  set_has_server_max_online();
  server_max_online_ = value;
}

// optional uint32 server_cur_online = 31;
inline bool ServerInfoReport::has_server_cur_online() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ServerInfoReport::set_has_server_cur_online() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ServerInfoReport::clear_has_server_cur_online() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ServerInfoReport::clear_server_cur_online() {
  server_cur_online_ = 0u;
  clear_has_server_cur_online();
}
inline ::google::protobuf::uint32 ServerInfoReport::server_cur_online() const {
  return server_cur_online_;
}
inline void ServerInfoReport::set_server_cur_online(::google::protobuf::uint32 value) {
  set_has_server_cur_online();
  server_cur_online_ = value;
}

// optional uint32 server_state = 32;
inline bool ServerInfoReport::has_server_state() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ServerInfoReport::set_has_server_state() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ServerInfoReport::clear_has_server_state() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ServerInfoReport::clear_server_state() {
  server_state_ = 0u;
  clear_has_server_state();
}
inline ::google::protobuf::uint32 ServerInfoReport::server_state() const {
  return server_state_;
}
inline void ServerInfoReport::set_server_state(::google::protobuf::uint32 value) {
  set_has_server_state();
  server_state_ = value;
}

// optional string system_info = 33;
inline bool ServerInfoReport::has_system_info() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ServerInfoReport::set_has_system_info() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ServerInfoReport::clear_has_system_info() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ServerInfoReport::clear_system_info() {
  if (system_info_ != &::google::protobuf::internal::kEmptyString) {
    system_info_->clear();
  }
  clear_has_system_info();
}
inline const ::std::string& ServerInfoReport::system_info() const {
  return *system_info_;
}
inline void ServerInfoReport::set_system_info(const ::std::string& value) {
  set_has_system_info();
  if (system_info_ == &::google::protobuf::internal::kEmptyString) {
    system_info_ = new ::std::string;
  }
  system_info_->assign(value);
}
inline void ServerInfoReport::set_system_info(const char* value) {
  set_has_system_info();
  if (system_info_ == &::google::protobuf::internal::kEmptyString) {
    system_info_ = new ::std::string;
  }
  system_info_->assign(value);
}
inline void ServerInfoReport::set_system_info(const char* value, size_t size) {
  set_has_system_info();
  if (system_info_ == &::google::protobuf::internal::kEmptyString) {
    system_info_ = new ::std::string;
  }
  system_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_system_info() {
  set_has_system_info();
  if (system_info_ == &::google::protobuf::internal::kEmptyString) {
    system_info_ = new ::std::string;
  }
  return system_info_;
}
inline ::std::string* ServerInfoReport::release_system_info() {
  clear_has_system_info();
  if (system_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = system_info_;
    system_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_system_info(::std::string* system_info) {
  if (system_info_ != &::google::protobuf::internal::kEmptyString) {
    delete system_info_;
  }
  if (system_info) {
    set_has_system_info();
    system_info_ = system_info;
  } else {
    clear_has_system_info();
    system_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 total_mem = 34;
inline bool ServerInfoReport::has_total_mem() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ServerInfoReport::set_has_total_mem() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ServerInfoReport::clear_has_total_mem() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ServerInfoReport::clear_total_mem() {
  total_mem_ = GOOGLE_ULONGLONG(0);
  clear_has_total_mem();
}
inline ::google::protobuf::uint64 ServerInfoReport::total_mem() const {
  return total_mem_;
}
inline void ServerInfoReport::set_total_mem(::google::protobuf::uint64 value) {
  set_has_total_mem();
  total_mem_ = value;
}

// optional uint64 free_mem = 35;
inline bool ServerInfoReport::has_free_mem() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ServerInfoReport::set_has_free_mem() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ServerInfoReport::clear_has_free_mem() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ServerInfoReport::clear_free_mem() {
  free_mem_ = GOOGLE_ULONGLONG(0);
  clear_has_free_mem();
}
inline ::google::protobuf::uint64 ServerInfoReport::free_mem() const {
  return free_mem_;
}
inline void ServerInfoReport::set_free_mem(::google::protobuf::uint64 value) {
  set_has_free_mem();
  free_mem_ = value;
}

// optional uint64 used_mem = 36;
inline bool ServerInfoReport::has_used_mem() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ServerInfoReport::set_has_used_mem() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ServerInfoReport::clear_has_used_mem() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ServerInfoReport::clear_used_mem() {
  used_mem_ = GOOGLE_ULONGLONG(0);
  clear_has_used_mem();
}
inline ::google::protobuf::uint64 ServerInfoReport::used_mem() const {
  return used_mem_;
}
inline void ServerInfoReport::set_used_mem(::google::protobuf::uint64 value) {
  set_has_used_mem();
  used_mem_ = value;
}

// optional double proc_cpu = 37;
inline bool ServerInfoReport::has_proc_cpu() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ServerInfoReport::set_has_proc_cpu() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ServerInfoReport::clear_has_proc_cpu() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ServerInfoReport::clear_proc_cpu() {
  proc_cpu_ = 0;
  clear_has_proc_cpu();
}
inline double ServerInfoReport::proc_cpu() const {
  return proc_cpu_;
}
inline void ServerInfoReport::set_proc_cpu(double value) {
  set_has_proc_cpu();
  proc_cpu_ = value;
}

// optional uint64 proc_mem = 38;
inline bool ServerInfoReport::has_proc_mem() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ServerInfoReport::set_has_proc_mem() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ServerInfoReport::clear_has_proc_mem() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ServerInfoReport::clear_proc_mem() {
  proc_mem_ = GOOGLE_ULONGLONG(0);
  clear_has_proc_mem();
}
inline ::google::protobuf::uint64 ServerInfoReport::proc_mem() const {
  return proc_mem_;
}
inline void ServerInfoReport::set_proc_mem(::google::protobuf::uint64 value) {
  set_has_proc_mem();
  proc_mem_ = value;
}

// optional uint32 proc_thread = 39;
inline bool ServerInfoReport::has_proc_thread() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ServerInfoReport::set_has_proc_thread() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ServerInfoReport::clear_has_proc_thread() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ServerInfoReport::clear_proc_thread() {
  proc_thread_ = 0u;
  clear_has_proc_thread();
}
inline ::google::protobuf::uint32 ServerInfoReport::proc_thread() const {
  return proc_thread_;
}
inline void ServerInfoReport::set_proc_thread(::google::protobuf::uint32 value) {
  set_has_proc_thread();
  proc_thread_ = value;
}

// optional string proc_name = 40;
inline bool ServerInfoReport::has_proc_name() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ServerInfoReport::set_has_proc_name() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ServerInfoReport::clear_has_proc_name() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ServerInfoReport::clear_proc_name() {
  if (proc_name_ != &::google::protobuf::internal::kEmptyString) {
    proc_name_->clear();
  }
  clear_has_proc_name();
}
inline const ::std::string& ServerInfoReport::proc_name() const {
  return *proc_name_;
}
inline void ServerInfoReport::set_proc_name(const ::std::string& value) {
  set_has_proc_name();
  if (proc_name_ == &::google::protobuf::internal::kEmptyString) {
    proc_name_ = new ::std::string;
  }
  proc_name_->assign(value);
}
inline void ServerInfoReport::set_proc_name(const char* value) {
  set_has_proc_name();
  if (proc_name_ == &::google::protobuf::internal::kEmptyString) {
    proc_name_ = new ::std::string;
  }
  proc_name_->assign(value);
}
inline void ServerInfoReport::set_proc_name(const char* value, size_t size) {
  set_has_proc_name();
  if (proc_name_ == &::google::protobuf::internal::kEmptyString) {
    proc_name_ = new ::std::string;
  }
  proc_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_proc_name() {
  set_has_proc_name();
  if (proc_name_ == &::google::protobuf::internal::kEmptyString) {
    proc_name_ = new ::std::string;
  }
  return proc_name_;
}
inline ::std::string* ServerInfoReport::release_proc_name() {
  clear_has_proc_name();
  if (proc_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proc_name_;
    proc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_proc_name(::std::string* proc_name) {
  if (proc_name_ != &::google::protobuf::internal::kEmptyString) {
    delete proc_name_;
  }
  if (proc_name) {
    set_has_proc_name();
    proc_name_ = proc_name;
  } else {
    clear_has_proc_name();
    proc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string proc_cwd = 41;
inline bool ServerInfoReport::has_proc_cwd() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ServerInfoReport::set_has_proc_cwd() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ServerInfoReport::clear_has_proc_cwd() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ServerInfoReport::clear_proc_cwd() {
  if (proc_cwd_ != &::google::protobuf::internal::kEmptyString) {
    proc_cwd_->clear();
  }
  clear_has_proc_cwd();
}
inline const ::std::string& ServerInfoReport::proc_cwd() const {
  return *proc_cwd_;
}
inline void ServerInfoReport::set_proc_cwd(const ::std::string& value) {
  set_has_proc_cwd();
  if (proc_cwd_ == &::google::protobuf::internal::kEmptyString) {
    proc_cwd_ = new ::std::string;
  }
  proc_cwd_->assign(value);
}
inline void ServerInfoReport::set_proc_cwd(const char* value) {
  set_has_proc_cwd();
  if (proc_cwd_ == &::google::protobuf::internal::kEmptyString) {
    proc_cwd_ = new ::std::string;
  }
  proc_cwd_->assign(value);
}
inline void ServerInfoReport::set_proc_cwd(const char* value, size_t size) {
  set_has_proc_cwd();
  if (proc_cwd_ == &::google::protobuf::internal::kEmptyString) {
    proc_cwd_ = new ::std::string;
  }
  proc_cwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_proc_cwd() {
  set_has_proc_cwd();
  if (proc_cwd_ == &::google::protobuf::internal::kEmptyString) {
    proc_cwd_ = new ::std::string;
  }
  return proc_cwd_;
}
inline ::std::string* ServerInfoReport::release_proc_cwd() {
  clear_has_proc_cwd();
  if (proc_cwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proc_cwd_;
    proc_cwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_proc_cwd(::std::string* proc_cwd) {
  if (proc_cwd_ != &::google::protobuf::internal::kEmptyString) {
    delete proc_cwd_;
  }
  if (proc_cwd) {
    set_has_proc_cwd();
    proc_cwd_ = proc_cwd;
  } else {
    clear_has_proc_cwd();
    proc_cwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 proc_pid = 42;
inline bool ServerInfoReport::has_proc_pid() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ServerInfoReport::set_has_proc_pid() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ServerInfoReport::clear_has_proc_pid() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ServerInfoReport::clear_proc_pid() {
  proc_pid_ = 0u;
  clear_has_proc_pid();
}
inline ::google::protobuf::uint32 ServerInfoReport::proc_pid() const {
  return proc_pid_;
}
inline void ServerInfoReport::set_proc_pid(::google::protobuf::uint32 value) {
  set_has_proc_pid();
  proc_pid_ = value;
}

// optional string last_date = 43;
inline bool ServerInfoReport::has_last_date() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ServerInfoReport::set_has_last_date() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ServerInfoReport::clear_has_last_date() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ServerInfoReport::clear_last_date() {
  if (last_date_ != &::google::protobuf::internal::kEmptyString) {
    last_date_->clear();
  }
  clear_has_last_date();
}
inline const ::std::string& ServerInfoReport::last_date() const {
  return *last_date_;
}
inline void ServerInfoReport::set_last_date(const ::std::string& value) {
  set_has_last_date();
  if (last_date_ == &::google::protobuf::internal::kEmptyString) {
    last_date_ = new ::std::string;
  }
  last_date_->assign(value);
}
inline void ServerInfoReport::set_last_date(const char* value) {
  set_has_last_date();
  if (last_date_ == &::google::protobuf::internal::kEmptyString) {
    last_date_ = new ::std::string;
  }
  last_date_->assign(value);
}
inline void ServerInfoReport::set_last_date(const char* value, size_t size) {
  set_has_last_date();
  if (last_date_ == &::google::protobuf::internal::kEmptyString) {
    last_date_ = new ::std::string;
  }
  last_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_last_date() {
  set_has_last_date();
  if (last_date_ == &::google::protobuf::internal::kEmptyString) {
    last_date_ = new ::std::string;
  }
  return last_date_;
}
inline ::std::string* ServerInfoReport::release_last_date() {
  clear_has_last_date();
  if (last_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_date_;
    last_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_last_date(::std::string* last_date) {
  if (last_date_ != &::google::protobuf::internal::kEmptyString) {
    delete last_date_;
  }
  if (last_date) {
    set_has_last_date();
    last_date_ = last_date;
  } else {
    clear_has_last_date();
    last_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 last_time = 44;
inline bool ServerInfoReport::has_last_time() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ServerInfoReport::set_has_last_time() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ServerInfoReport::clear_has_last_time() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ServerInfoReport::clear_last_time() {
  last_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_time();
}
inline ::google::protobuf::uint64 ServerInfoReport::last_time() const {
  return last_time_;
}
inline void ServerInfoReport::set_last_time(::google::protobuf::uint64 value) {
  set_has_last_time();
  last_time_ = value;
}

// optional string contract_info = 45;
inline bool ServerInfoReport::has_contract_info() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ServerInfoReport::set_has_contract_info() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ServerInfoReport::clear_has_contract_info() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ServerInfoReport::clear_contract_info() {
  if (contract_info_ != &::google::protobuf::internal::kEmptyString) {
    contract_info_->clear();
  }
  clear_has_contract_info();
}
inline const ::std::string& ServerInfoReport::contract_info() const {
  return *contract_info_;
}
inline void ServerInfoReport::set_contract_info(const ::std::string& value) {
  set_has_contract_info();
  if (contract_info_ == &::google::protobuf::internal::kEmptyString) {
    contract_info_ = new ::std::string;
  }
  contract_info_->assign(value);
}
inline void ServerInfoReport::set_contract_info(const char* value) {
  set_has_contract_info();
  if (contract_info_ == &::google::protobuf::internal::kEmptyString) {
    contract_info_ = new ::std::string;
  }
  contract_info_->assign(value);
}
inline void ServerInfoReport::set_contract_info(const char* value, size_t size) {
  set_has_contract_info();
  if (contract_info_ == &::google::protobuf::internal::kEmptyString) {
    contract_info_ = new ::std::string;
  }
  contract_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_contract_info() {
  set_has_contract_info();
  if (contract_info_ == &::google::protobuf::internal::kEmptyString) {
    contract_info_ = new ::std::string;
  }
  return contract_info_;
}
inline ::std::string* ServerInfoReport::release_contract_info() {
  clear_has_contract_info();
  if (contract_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contract_info_;
    contract_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_contract_info(::std::string* contract_info) {
  if (contract_info_ != &::google::protobuf::internal::kEmptyString) {
    delete contract_info_;
  }
  if (contract_info) {
    set_has_contract_info();
    contract_info_ = contract_info;
  } else {
    clear_has_contract_info();
    contract_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string machine_addr = 46;
inline bool ServerInfoReport::has_machine_addr() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ServerInfoReport::set_has_machine_addr() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ServerInfoReport::clear_has_machine_addr() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ServerInfoReport::clear_machine_addr() {
  if (machine_addr_ != &::google::protobuf::internal::kEmptyString) {
    machine_addr_->clear();
  }
  clear_has_machine_addr();
}
inline const ::std::string& ServerInfoReport::machine_addr() const {
  return *machine_addr_;
}
inline void ServerInfoReport::set_machine_addr(const ::std::string& value) {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  machine_addr_->assign(value);
}
inline void ServerInfoReport::set_machine_addr(const char* value) {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  machine_addr_->assign(value);
}
inline void ServerInfoReport::set_machine_addr(const char* value, size_t size) {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  machine_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_machine_addr() {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  return machine_addr_;
}
inline ::std::string* ServerInfoReport::release_machine_addr() {
  clear_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_addr_;
    machine_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_machine_addr(::std::string* machine_addr) {
  if (machine_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_addr_;
  }
  if (machine_addr) {
    set_has_machine_addr();
    machine_addr_ = machine_addr;
  } else {
    clear_has_machine_addr();
    machine_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string db_name_list = 47;
inline int ServerInfoReport::db_name_list_size() const {
  return db_name_list_.size();
}
inline void ServerInfoReport::clear_db_name_list() {
  db_name_list_.Clear();
}
inline const ::std::string& ServerInfoReport::db_name_list(int index) const {
  return db_name_list_.Get(index);
}
inline ::std::string* ServerInfoReport::mutable_db_name_list(int index) {
  return db_name_list_.Mutable(index);
}
inline void ServerInfoReport::set_db_name_list(int index, const ::std::string& value) {
  db_name_list_.Mutable(index)->assign(value);
}
inline void ServerInfoReport::set_db_name_list(int index, const char* value) {
  db_name_list_.Mutable(index)->assign(value);
}
inline void ServerInfoReport::set_db_name_list(int index, const char* value, size_t size) {
  db_name_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::add_db_name_list() {
  return db_name_list_.Add();
}
inline void ServerInfoReport::add_db_name_list(const ::std::string& value) {
  db_name_list_.Add()->assign(value);
}
inline void ServerInfoReport::add_db_name_list(const char* value) {
  db_name_list_.Add()->assign(value);
}
inline void ServerInfoReport::add_db_name_list(const char* value, size_t size) {
  db_name_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerInfoReport::db_name_list() const {
  return db_name_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerInfoReport::mutable_db_name_list() {
  return &db_name_list_;
}

// repeated uint32 msg_id = 48;
inline int ServerInfoReport::msg_id_size() const {
  return msg_id_.size();
}
inline void ServerInfoReport::clear_msg_id() {
  msg_id_.Clear();
}
inline ::google::protobuf::uint32 ServerInfoReport::msg_id(int index) const {
  return msg_id_.Get(index);
}
inline void ServerInfoReport::set_msg_id(int index, ::google::protobuf::uint32 value) {
  msg_id_.Set(index, value);
}
inline void ServerInfoReport::add_msg_id(::google::protobuf::uint32 value) {
  msg_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ServerInfoReport::msg_id() const {
  return msg_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ServerInfoReport::mutable_msg_id() {
  return &msg_id_;
}

// repeated uint64 map_id_list = 49;
inline int ServerInfoReport::map_id_list_size() const {
  return map_id_list_.size();
}
inline void ServerInfoReport::clear_map_id_list() {
  map_id_list_.Clear();
}
inline ::google::protobuf::uint64 ServerInfoReport::map_id_list(int index) const {
  return map_id_list_.Get(index);
}
inline void ServerInfoReport::set_map_id_list(int index, ::google::protobuf::uint64 value) {
  map_id_list_.Set(index, value);
}
inline void ServerInfoReport::add_map_id_list(::google::protobuf::uint64 value) {
  map_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ServerInfoReport::map_id_list() const {
  return map_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ServerInfoReport::mutable_map_id_list() {
  return &map_id_list_;
}

// -------------------------------------------------------------------

// ServerInfoReportList

// repeated .proto_ff.ServerInfoReport server_list = 1;
inline int ServerInfoReportList::server_list_size() const {
  return server_list_.size();
}
inline void ServerInfoReportList::clear_server_list() {
  server_list_.Clear();
}
inline const ::proto_ff::ServerInfoReport& ServerInfoReportList::server_list(int index) const {
  return server_list_.Get(index);
}
inline ::proto_ff::ServerInfoReport* ServerInfoReportList::mutable_server_list(int index) {
  return server_list_.Mutable(index);
}
inline ::proto_ff::ServerInfoReport* ServerInfoReportList::add_server_list() {
  return server_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ServerInfoReport >&
ServerInfoReportList::server_list() const {
  return server_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ServerInfoReport >*
ServerInfoReportList::mutable_server_list() {
  return &server_list_;
}

// -------------------------------------------------------------------

// ServerInfoReportListRespne

// optional int32 ret_code = 1;
inline bool ServerInfoReportListRespne::has_ret_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfoReportListRespne::set_has_ret_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfoReportListRespne::clear_has_ret_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfoReportListRespne::clear_ret_code() {
  ret_code_ = 0;
  clear_has_ret_code();
}
inline ::google::protobuf::int32 ServerInfoReportListRespne::ret_code() const {
  return ret_code_;
}
inline void ServerInfoReportListRespne::set_ret_code(::google::protobuf::int32 value) {
  set_has_ret_code();
  ret_code_ = value;
}

// -------------------------------------------------------------------

// ZkServerInfo

// optional string bus_url = 1;
inline bool ZkServerInfo::has_bus_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZkServerInfo::set_has_bus_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZkServerInfo::clear_has_bus_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZkServerInfo::clear_bus_url() {
  if (bus_url_ != &::google::protobuf::internal::kEmptyString) {
    bus_url_->clear();
  }
  clear_has_bus_url();
}
inline const ::std::string& ZkServerInfo::bus_url() const {
  return *bus_url_;
}
inline void ZkServerInfo::set_bus_url(const ::std::string& value) {
  set_has_bus_url();
  if (bus_url_ == &::google::protobuf::internal::kEmptyString) {
    bus_url_ = new ::std::string;
  }
  bus_url_->assign(value);
}
inline void ZkServerInfo::set_bus_url(const char* value) {
  set_has_bus_url();
  if (bus_url_ == &::google::protobuf::internal::kEmptyString) {
    bus_url_ = new ::std::string;
  }
  bus_url_->assign(value);
}
inline void ZkServerInfo::set_bus_url(const char* value, size_t size) {
  set_has_bus_url();
  if (bus_url_ == &::google::protobuf::internal::kEmptyString) {
    bus_url_ = new ::std::string;
  }
  bus_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZkServerInfo::mutable_bus_url() {
  set_has_bus_url();
  if (bus_url_ == &::google::protobuf::internal::kEmptyString) {
    bus_url_ = new ::std::string;
  }
  return bus_url_;
}
inline ::std::string* ZkServerInfo::release_bus_url() {
  clear_has_bus_url();
  if (bus_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bus_url_;
    bus_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZkServerInfo::set_allocated_bus_url(::std::string* bus_url) {
  if (bus_url_ != &::google::protobuf::internal::kEmptyString) {
    delete bus_url_;
  }
  if (bus_url) {
    set_has_bus_url();
    bus_url_ = bus_url;
  } else {
    clear_has_bus_url();
    bus_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tcp_url = 2;
inline bool ZkServerInfo::has_tcp_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZkServerInfo::set_has_tcp_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZkServerInfo::clear_has_tcp_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZkServerInfo::clear_tcp_url() {
  if (tcp_url_ != &::google::protobuf::internal::kEmptyString) {
    tcp_url_->clear();
  }
  clear_has_tcp_url();
}
inline const ::std::string& ZkServerInfo::tcp_url() const {
  return *tcp_url_;
}
inline void ZkServerInfo::set_tcp_url(const ::std::string& value) {
  set_has_tcp_url();
  if (tcp_url_ == &::google::protobuf::internal::kEmptyString) {
    tcp_url_ = new ::std::string;
  }
  tcp_url_->assign(value);
}
inline void ZkServerInfo::set_tcp_url(const char* value) {
  set_has_tcp_url();
  if (tcp_url_ == &::google::protobuf::internal::kEmptyString) {
    tcp_url_ = new ::std::string;
  }
  tcp_url_->assign(value);
}
inline void ZkServerInfo::set_tcp_url(const char* value, size_t size) {
  set_has_tcp_url();
  if (tcp_url_ == &::google::protobuf::internal::kEmptyString) {
    tcp_url_ = new ::std::string;
  }
  tcp_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZkServerInfo::mutable_tcp_url() {
  set_has_tcp_url();
  if (tcp_url_ == &::google::protobuf::internal::kEmptyString) {
    tcp_url_ = new ::std::string;
  }
  return tcp_url_;
}
inline ::std::string* ZkServerInfo::release_tcp_url() {
  clear_has_tcp_url();
  if (tcp_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tcp_url_;
    tcp_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZkServerInfo::set_allocated_tcp_url(::std::string* tcp_url) {
  if (tcp_url_ != &::google::protobuf::internal::kEmptyString) {
    delete tcp_url_;
  }
  if (tcp_url) {
    set_has_tcp_url();
    tcp_url_ = tcp_url;
  } else {
    clear_has_tcp_url();
    tcp_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DynLibFileInfo

// optional string file_md5 = 1;
inline bool DynLibFileInfo::has_file_md5() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DynLibFileInfo::set_has_file_md5() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DynLibFileInfo::clear_has_file_md5() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DynLibFileInfo::clear_file_md5() {
  if (file_md5_ != &::google::protobuf::internal::kEmptyString) {
    file_md5_->clear();
  }
  clear_has_file_md5();
}
inline const ::std::string& DynLibFileInfo::file_md5() const {
  return *file_md5_;
}
inline void DynLibFileInfo::set_file_md5(const ::std::string& value) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(value);
}
inline void DynLibFileInfo::set_file_md5(const char* value) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(value);
}
inline void DynLibFileInfo::set_file_md5(const char* value, size_t size) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DynLibFileInfo::mutable_file_md5() {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  return file_md5_;
}
inline ::std::string* DynLibFileInfo::release_file_md5() {
  clear_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_md5_;
    file_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DynLibFileInfo::set_allocated_file_md5(::std::string* file_md5) {
  if (file_md5_ != &::google::protobuf::internal::kEmptyString) {
    delete file_md5_;
  }
  if (file_md5) {
    set_has_file_md5();
    file_md5_ = file_md5;
  } else {
    clear_has_file_md5();
    file_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 file_size = 2;
inline bool DynLibFileInfo::has_file_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DynLibFileInfo::set_has_file_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DynLibFileInfo::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DynLibFileInfo::clear_file_size() {
  file_size_ = 0;
  clear_has_file_size();
}
inline ::google::protobuf::int32 DynLibFileInfo::file_size() const {
  return file_size_;
}
inline void DynLibFileInfo::set_file_size(::google::protobuf::int32 value) {
  set_has_file_size();
  file_size_ = value;
}

// -------------------------------------------------------------------

// DynLibFileInfoArray

// repeated .proto_ff.DynLibFileInfo file_list = 1;
inline int DynLibFileInfoArray::file_list_size() const {
  return file_list_.size();
}
inline void DynLibFileInfoArray::clear_file_list() {
  file_list_.Clear();
}
inline const ::proto_ff::DynLibFileInfo& DynLibFileInfoArray::file_list(int index) const {
  return file_list_.Get(index);
}
inline ::proto_ff::DynLibFileInfo* DynLibFileInfoArray::mutable_file_list(int index) {
  return file_list_.Mutable(index);
}
inline ::proto_ff::DynLibFileInfo* DynLibFileInfoArray::add_file_list() {
  return file_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::DynLibFileInfo >&
DynLibFileInfoArray::file_list() const {
  return file_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::DynLibFileInfo >*
DynLibFileInfoArray::mutable_file_list() {
  return &file_list_;
}

// -------------------------------------------------------------------

// Proto_KillAllServerNtf

// -------------------------------------------------------------------

// Proto_KillAllServerRsp

// optional int32 result = 1;
inline bool Proto_KillAllServerRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_KillAllServerRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_KillAllServerRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_KillAllServerRsp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 Proto_KillAllServerRsp::result() const {
  return result_;
}
inline void Proto_KillAllServerRsp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// Proto_STSBroadPlayerMsgNotify

// repeated uint64 user_id = 1;
inline int Proto_STSBroadPlayerMsgNotify::user_id_size() const {
  return user_id_.size();
}
inline void Proto_STSBroadPlayerMsgNotify::clear_user_id() {
  user_id_.Clear();
}
inline ::google::protobuf::uint64 Proto_STSBroadPlayerMsgNotify::user_id(int index) const {
  return user_id_.Get(index);
}
inline void Proto_STSBroadPlayerMsgNotify::set_user_id(int index, ::google::protobuf::uint64 value) {
  user_id_.Set(index, value);
}
inline void Proto_STSBroadPlayerMsgNotify::add_user_id(::google::protobuf::uint64 value) {
  user_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Proto_STSBroadPlayerMsgNotify::user_id() const {
  return user_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Proto_STSBroadPlayerMsgNotify::mutable_user_id() {
  return &user_id_;
}

// optional uint32 msg_id = 2;
inline bool Proto_STSBroadPlayerMsgNotify::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_STSBroadPlayerMsgNotify::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_STSBroadPlayerMsgNotify::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_STSBroadPlayerMsgNotify::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 Proto_STSBroadPlayerMsgNotify::msg_id() const {
  return msg_id_;
}
inline void Proto_STSBroadPlayerMsgNotify::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// optional bytes msg_data = 3;
inline bool Proto_STSBroadPlayerMsgNotify::has_msg_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_STSBroadPlayerMsgNotify::set_has_msg_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_STSBroadPlayerMsgNotify::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_STSBroadPlayerMsgNotify::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& Proto_STSBroadPlayerMsgNotify::msg_data() const {
  return *msg_data_;
}
inline void Proto_STSBroadPlayerMsgNotify::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void Proto_STSBroadPlayerMsgNotify::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void Proto_STSBroadPlayerMsgNotify::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Proto_STSBroadPlayerMsgNotify::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  return msg_data_;
}
inline ::std::string* Proto_STSBroadPlayerMsgNotify::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Proto_STSBroadPlayerMsgNotify::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Proto_STWebMsgRspNotify

// optional uint64 request_id = 1;
inline bool Proto_STWebMsgRspNotify::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_STWebMsgRspNotify::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_STWebMsgRspNotify::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_STWebMsgRspNotify::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 Proto_STWebMsgRspNotify::request_id() const {
  return request_id_;
}
inline void Proto_STWebMsgRspNotify::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
}

// optional int32 result = 2;
inline bool Proto_STWebMsgRspNotify::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_STWebMsgRspNotify::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_STWebMsgRspNotify::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_STWebMsgRspNotify::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 Proto_STWebMsgRspNotify::result() const {
  return result_;
}
inline void Proto_STWebMsgRspNotify::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string err_msg = 3;
inline bool Proto_STWebMsgRspNotify::has_err_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_STWebMsgRspNotify::set_has_err_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_STWebMsgRspNotify::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_STWebMsgRspNotify::clear_err_msg() {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    err_msg_->clear();
  }
  clear_has_err_msg();
}
inline const ::std::string& Proto_STWebMsgRspNotify::err_msg() const {
  return *err_msg_;
}
inline void Proto_STWebMsgRspNotify::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void Proto_STWebMsgRspNotify::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void Proto_STWebMsgRspNotify::set_err_msg(const char* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Proto_STWebMsgRspNotify::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  return err_msg_;
}
inline ::std::string* Proto_STWebMsgRspNotify::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Proto_STWebMsgRspNotify::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete err_msg_;
  }
  if (err_msg) {
    set_has_err_msg();
    err_msg_ = err_msg;
  } else {
    clear_has_err_msg();
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BehaviorLogHeader

// optional uint64 event_id = 1;
inline bool BehaviorLogHeader::has_event_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BehaviorLogHeader::set_has_event_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BehaviorLogHeader::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BehaviorLogHeader::clear_event_id() {
  event_id_ = GOOGLE_ULONGLONG(0);
  clear_has_event_id();
}
inline ::google::protobuf::uint64 BehaviorLogHeader::event_id() const {
  return event_id_;
}
inline void BehaviorLogHeader::set_event_id(::google::protobuf::uint64 value) {
  set_has_event_id();
  event_id_ = value;
}

// optional uint32 sequence = 2;
inline bool BehaviorLogHeader::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BehaviorLogHeader::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BehaviorLogHeader::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BehaviorLogHeader::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 BehaviorLogHeader::sequence() const {
  return sequence_;
}
inline void BehaviorLogHeader::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional string bus_name = 3;
inline bool BehaviorLogHeader::has_bus_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BehaviorLogHeader::set_has_bus_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BehaviorLogHeader::clear_has_bus_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BehaviorLogHeader::clear_bus_name() {
  if (bus_name_ != &::google::protobuf::internal::kEmptyString) {
    bus_name_->clear();
  }
  clear_has_bus_name();
}
inline const ::std::string& BehaviorLogHeader::bus_name() const {
  return *bus_name_;
}
inline void BehaviorLogHeader::set_bus_name(const ::std::string& value) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(value);
}
inline void BehaviorLogHeader::set_bus_name(const char* value) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(value);
}
inline void BehaviorLogHeader::set_bus_name(const char* value, size_t size) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BehaviorLogHeader::mutable_bus_name() {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  return bus_name_;
}
inline ::std::string* BehaviorLogHeader::release_bus_name() {
  clear_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bus_name_;
    bus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BehaviorLogHeader::set_allocated_bus_name(::std::string* bus_name) {
  if (bus_name_ != &::google::protobuf::internal::kEmptyString) {
    delete bus_name_;
  }
  if (bus_name) {
    set_has_bus_name();
    bus_name_ = bus_name;
  } else {
    clear_has_bus_name();
    bus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string event_time = 4;
inline bool BehaviorLogHeader::has_event_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BehaviorLogHeader::set_has_event_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BehaviorLogHeader::clear_has_event_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BehaviorLogHeader::clear_event_time() {
  if (event_time_ != &::google::protobuf::internal::kEmptyString) {
    event_time_->clear();
  }
  clear_has_event_time();
}
inline const ::std::string& BehaviorLogHeader::event_time() const {
  return *event_time_;
}
inline void BehaviorLogHeader::set_event_time(const ::std::string& value) {
  set_has_event_time();
  if (event_time_ == &::google::protobuf::internal::kEmptyString) {
    event_time_ = new ::std::string;
  }
  event_time_->assign(value);
}
inline void BehaviorLogHeader::set_event_time(const char* value) {
  set_has_event_time();
  if (event_time_ == &::google::protobuf::internal::kEmptyString) {
    event_time_ = new ::std::string;
  }
  event_time_->assign(value);
}
inline void BehaviorLogHeader::set_event_time(const char* value, size_t size) {
  set_has_event_time();
  if (event_time_ == &::google::protobuf::internal::kEmptyString) {
    event_time_ = new ::std::string;
  }
  event_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BehaviorLogHeader::mutable_event_time() {
  set_has_event_time();
  if (event_time_ == &::google::protobuf::internal::kEmptyString) {
    event_time_ = new ::std::string;
  }
  return event_time_;
}
inline ::std::string* BehaviorLogHeader::release_event_time() {
  clear_has_event_time();
  if (event_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_time_;
    event_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BehaviorLogHeader::set_allocated_event_time(::std::string* event_time) {
  if (event_time_ != &::google::protobuf::internal::kEmptyString) {
    delete event_time_;
  }
  if (event_time) {
    set_has_event_time();
    event_time_ = event_time;
  } else {
    clear_has_event_time();
    event_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 user_id = 5;
inline bool BehaviorLogHeader::has_user_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BehaviorLogHeader::set_has_user_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BehaviorLogHeader::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BehaviorLogHeader::clear_user_id() {
  user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::uint64 BehaviorLogHeader::user_id() const {
  return user_id_;
}
inline void BehaviorLogHeader::set_user_id(::google::protobuf::uint64 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional string user_name = 6;
inline bool BehaviorLogHeader::has_user_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BehaviorLogHeader::set_has_user_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BehaviorLogHeader::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BehaviorLogHeader::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& BehaviorLogHeader::user_name() const {
  return *user_name_;
}
inline void BehaviorLogHeader::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void BehaviorLogHeader::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void BehaviorLogHeader::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BehaviorLogHeader::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* BehaviorLogHeader::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BehaviorLogHeader::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NFEventNoneData

// optional int64 param1 = 1;
inline bool NFEventNoneData::has_param1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NFEventNoneData::set_has_param1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NFEventNoneData::clear_has_param1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NFEventNoneData::clear_param1() {
  param1_ = GOOGLE_LONGLONG(0);
  clear_has_param1();
}
inline ::google::protobuf::int64 NFEventNoneData::param1() const {
  return param1_;
}
inline void NFEventNoneData::set_param1(::google::protobuf::int64 value) {
  set_has_param1();
  param1_ = value;
}

// optional int64 param2 = 2;
inline bool NFEventNoneData::has_param2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NFEventNoneData::set_has_param2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NFEventNoneData::clear_has_param2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NFEventNoneData::clear_param2() {
  param2_ = GOOGLE_LONGLONG(0);
  clear_has_param2();
}
inline ::google::protobuf::int64 NFEventNoneData::param2() const {
  return param2_;
}
inline void NFEventNoneData::set_param2(::google::protobuf::int64 value) {
  set_has_param2();
  param2_ = value;
}

// optional int64 param3 = 3;
inline bool NFEventNoneData::has_param3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NFEventNoneData::set_has_param3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NFEventNoneData::clear_has_param3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NFEventNoneData::clear_param3() {
  param3_ = GOOGLE_LONGLONG(0);
  clear_has_param3();
}
inline ::google::protobuf::int64 NFEventNoneData::param3() const {
  return param3_;
}
inline void NFEventNoneData::set_param3(::google::protobuf::int64 value) {
  set_has_param3();
  param3_ = value;
}

// optional int64 param4 = 4;
inline bool NFEventNoneData::has_param4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NFEventNoneData::set_has_param4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NFEventNoneData::clear_has_param4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NFEventNoneData::clear_param4() {
  param4_ = GOOGLE_LONGLONG(0);
  clear_has_param4();
}
inline ::google::protobuf::int64 NFEventNoneData::param4() const {
  return param4_;
}
inline void NFEventNoneData::set_param4(::google::protobuf::int64 value) {
  set_has_param4();
  param4_ = value;
}

// optional int64 param5 = 5;
inline bool NFEventNoneData::has_param5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NFEventNoneData::set_has_param5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NFEventNoneData::clear_has_param5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NFEventNoneData::clear_param5() {
  param5_ = GOOGLE_LONGLONG(0);
  clear_has_param5();
}
inline ::google::protobuf::int64 NFEventNoneData::param5() const {
  return param5_;
}
inline void NFEventNoneData::set_param5(::google::protobuf::int64 value) {
  set_has_param5();
  param5_ = value;
}

// -------------------------------------------------------------------

// NFEventScriptData

// optional string event_type = 1;
inline bool NFEventScriptData::has_event_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NFEventScriptData::set_has_event_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NFEventScriptData::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NFEventScriptData::clear_event_type() {
  if (event_type_ != &::google::protobuf::internal::kEmptyString) {
    event_type_->clear();
  }
  clear_has_event_type();
}
inline const ::std::string& NFEventScriptData::event_type() const {
  return *event_type_;
}
inline void NFEventScriptData::set_event_type(const ::std::string& value) {
  set_has_event_type();
  if (event_type_ == &::google::protobuf::internal::kEmptyString) {
    event_type_ = new ::std::string;
  }
  event_type_->assign(value);
}
inline void NFEventScriptData::set_event_type(const char* value) {
  set_has_event_type();
  if (event_type_ == &::google::protobuf::internal::kEmptyString) {
    event_type_ = new ::std::string;
  }
  event_type_->assign(value);
}
inline void NFEventScriptData::set_event_type(const char* value, size_t size) {
  set_has_event_type();
  if (event_type_ == &::google::protobuf::internal::kEmptyString) {
    event_type_ = new ::std::string;
  }
  event_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NFEventScriptData::mutable_event_type() {
  set_has_event_type();
  if (event_type_ == &::google::protobuf::internal::kEmptyString) {
    event_type_ = new ::std::string;
  }
  return event_type_;
}
inline ::std::string* NFEventScriptData::release_event_type() {
  clear_has_event_type();
  if (event_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_type_;
    event_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NFEventScriptData::set_allocated_event_type(::std::string* event_type) {
  if (event_type_ != &::google::protobuf::internal::kEmptyString) {
    delete event_type_;
  }
  if (event_type) {
    set_has_event_type();
    event_type_ = event_type;
  } else {
    clear_has_event_type();
    event_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string event_data = 2;
inline bool NFEventScriptData::has_event_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NFEventScriptData::set_has_event_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NFEventScriptData::clear_has_event_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NFEventScriptData::clear_event_data() {
  if (event_data_ != &::google::protobuf::internal::kEmptyString) {
    event_data_->clear();
  }
  clear_has_event_data();
}
inline const ::std::string& NFEventScriptData::event_data() const {
  return *event_data_;
}
inline void NFEventScriptData::set_event_data(const ::std::string& value) {
  set_has_event_data();
  if (event_data_ == &::google::protobuf::internal::kEmptyString) {
    event_data_ = new ::std::string;
  }
  event_data_->assign(value);
}
inline void NFEventScriptData::set_event_data(const char* value) {
  set_has_event_data();
  if (event_data_ == &::google::protobuf::internal::kEmptyString) {
    event_data_ = new ::std::string;
  }
  event_data_->assign(value);
}
inline void NFEventScriptData::set_event_data(const char* value, size_t size) {
  set_has_event_data();
  if (event_data_ == &::google::protobuf::internal::kEmptyString) {
    event_data_ = new ::std::string;
  }
  event_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NFEventScriptData::mutable_event_data() {
  set_has_event_data();
  if (event_data_ == &::google::protobuf::internal::kEmptyString) {
    event_data_ = new ::std::string;
  }
  return event_data_;
}
inline ::std::string* NFEventScriptData::release_event_data() {
  clear_has_event_data();
  if (event_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_data_;
    event_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NFEventScriptData::set_allocated_event_data(::std::string* event_data) {
  if (event_data_ != &::google::protobuf::internal::kEmptyString) {
    delete event_data_;
  }
  if (event_data) {
    set_has_event_data();
    event_data_ = event_data;
  } else {
    clear_has_event_data();
    event_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Proto_ServerDumpInfoNtf

// optional string dump_info = 1;
inline bool Proto_ServerDumpInfoNtf::has_dump_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_ServerDumpInfoNtf::set_has_dump_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_ServerDumpInfoNtf::clear_has_dump_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_ServerDumpInfoNtf::clear_dump_info() {
  if (dump_info_ != &::google::protobuf::internal::kEmptyString) {
    dump_info_->clear();
  }
  clear_has_dump_info();
}
inline const ::std::string& Proto_ServerDumpInfoNtf::dump_info() const {
  return *dump_info_;
}
inline void Proto_ServerDumpInfoNtf::set_dump_info(const ::std::string& value) {
  set_has_dump_info();
  if (dump_info_ == &::google::protobuf::internal::kEmptyString) {
    dump_info_ = new ::std::string;
  }
  dump_info_->assign(value);
}
inline void Proto_ServerDumpInfoNtf::set_dump_info(const char* value) {
  set_has_dump_info();
  if (dump_info_ == &::google::protobuf::internal::kEmptyString) {
    dump_info_ = new ::std::string;
  }
  dump_info_->assign(value);
}
inline void Proto_ServerDumpInfoNtf::set_dump_info(const char* value, size_t size) {
  set_has_dump_info();
  if (dump_info_ == &::google::protobuf::internal::kEmptyString) {
    dump_info_ = new ::std::string;
  }
  dump_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Proto_ServerDumpInfoNtf::mutable_dump_info() {
  set_has_dump_info();
  if (dump_info_ == &::google::protobuf::internal::kEmptyString) {
    dump_info_ = new ::std::string;
  }
  return dump_info_;
}
inline ::std::string* Proto_ServerDumpInfoNtf::release_dump_info() {
  clear_has_dump_info();
  if (dump_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dump_info_;
    dump_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Proto_ServerDumpInfoNtf::set_allocated_dump_info(::std::string* dump_info) {
  if (dump_info_ != &::google::protobuf::internal::kEmptyString) {
    delete dump_info_;
  }
  if (dump_info) {
    set_has_dump_info();
    dump_info_ = dump_info;
  } else {
    clear_has_dump_info();
    dump_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 bus_id = 2;
inline bool Proto_ServerDumpInfoNtf::has_bus_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_ServerDumpInfoNtf::set_has_bus_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_ServerDumpInfoNtf::clear_has_bus_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_ServerDumpInfoNtf::clear_bus_id() {
  bus_id_ = 0u;
  clear_has_bus_id();
}
inline ::google::protobuf::uint32 Proto_ServerDumpInfoNtf::bus_id() const {
  return bus_id_;
}
inline void Proto_ServerDumpInfoNtf::set_bus_id(::google::protobuf::uint32 value) {
  set_has_bus_id();
  bus_id_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::Proto_Kernel_CMD>() {
  return ::proto_ff::Proto_Kernel_CMD_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::PacketDispType>() {
  return ::proto_ff::PacketDispType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EServerState>() {
  return ::proto_ff::EServerState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::Proto_Kernel_ErrorCode>() {
  return ::proto_ff::Proto_Kernel_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::NFEventSrcType>() {
  return ::proto_ff::NFEventSrcType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::NFEventIdType>() {
  return ::proto_ff::NFEventIdType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_5fkernel_2eproto__INCLUDED
