// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto_kernel.proto

#ifndef PROTOBUF_proto_5fkernel_2eproto__INCLUDED
#define PROTOBUF_proto_5fkernel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "yd_fieldoptions.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_5fkernel_2eproto();
void protobuf_AssignDesc_proto_5fkernel_2eproto();
void protobuf_ShutdownFile_proto_5fkernel_2eproto();

class Proto_DispInfo;
class Proto_StoreInfo_CB;
class Proto_StoreInfo;
class Proto_SvrPkg;
class ServerInfoReport;
class ServerInfoReportList;
class ZkServerInfo;
class DynLibFileInfo;
class DynLibFileInfoArray;
class Proto_KillAllServerNtf;
class Proto_KillAllServerRsp;
class Proto_STSBroadPlayerMsgNotify;
class Proto_STWebMsgRspNotify;
class BehaviorLogHeader;
class NFEventNoneData;

enum Proto_Kernel_CMD {
  NF_GTM_KILL_ALL_SERVER_NTF = 3,
  NF_STS_KILL_ALL_SERVER_NTF = 4,
  NF_STMaster_SEND_DUMP_INFO_NTF = 44,
  NF_MasterTMonitor_RELOAD_CMD_REQ = 80,
  NF_MasterTMonitor_RESTART_CMD_REQ = 81,
  NF_MasterTMonitor_START_CMD_REQ = 82,
  NF_MasterTMonitor_STOP_CMD_REQ = 83,
  NF_MasterTMonitor_STOP_ALL_CMD_REQ = 84,
  NF_MasterTMonitor_RELOAD_ALL_CMD_REQ = 85,
  NF_MasterTMonitor_RESTART_ALL_CMD_REQ = 86,
  NF_MasterTMonitor_START_ALL_CMD_REQ = 87,
  NF_MonitorTMaster_RELOAD_CMD_RSP = 90,
  NF_MonitorTMaster_RESTART_CMD_RSP = 91,
  NF_MonitorTMaster_START_CMD_RSP = 92,
  NF_MonitorTMaster_STOP_CMD_RSP = 93,
  NF_MonitorTMaster_STOP_ALL_CMD_RSP = 94,
  NF_MonitorTMaster_RELOAD_ALL_CMD_RSP = 95,
  NF_MonitorTMaster_RESTART_ALL_CMD_RSP = 96,
  NF_MonitorTMaster_START_ALL_CMD_RSP = 97,
  NF_SERVER_TO_SERVER_REGISTER = 100,
  NF_SERVER_TO_SERVER_REGISTER_RSP = 101,
  NF_MASTER_SERVER_SEND_OTHERS_TO_SERVER = 102,
  NF_SERVER_TO_MASTER_SERVER_REPORT = 103,
  NF_ROUTER_CMD_INTERNAL_C2R_REGISTER = 104,
  NF_ROUTER_CMD_INTERNAL_R2C_REGISTER = 105,
  NF_ROUTER_CMD_INTERNAL_C2R_HEARTBEAT = 106,
  NF_ROUTER_CMD_INTERNAL_R2C_HEARTBEAT = 107,
  NF_ROUTER_CMD_DISPATCH_MOD = 108,
  NF_ROUTER_CMD_DISPATCH_ROUNDROBIN = 109,
  NF_ROUTER_CMD_DISPATCH_BROADCAST = 110,
  NF_ROUTER_CMD_DISPATCH_BROADCAST_AND_MASTER = 111,
  NF_ROUTER_CMD_DISPATCH_BORADCAST_MASTER = 112,
  NF_ROUTER_CMD_DISPATCH_BORADCAST_SLAVE = 113,
  NF_ROUTER_CMD_DISPATCH_DIRECT = 114,
  NF_ROUTER_CMD_INTERNAL_R2C_DISPATCHFAILED = 115,
  NF_ROUTER_CMD_INTERNAL_C2R_REG_RAASSOCAPPSVS = 116,
  NF_SERVER_TO_SERVER_TRANS_CMD = 120,
  NF_SERVER_TO_STORE_SERVER_DB_CMD = 121,
  NF_STORE_SERVER_TO_SERVER_DB_CMD = 122,
  NF_WORLD_ROUTER_CMD_TO_SUIT_LOGIC = 123,
  NF_SNS_ROUTER_CMD_TO_SUIT_LOGIC = 124,
  NF_STS_BROAD_PLAYER_MSG_NOTIFY = 125,
  NF_SEVER_TO_WEB_SERVER_RSP_NOTIFY = 126
};
bool Proto_Kernel_CMD_IsValid(int value);
const Proto_Kernel_CMD Proto_Kernel_CMD_MIN = NF_GTM_KILL_ALL_SERVER_NTF;
const Proto_Kernel_CMD Proto_Kernel_CMD_MAX = NF_SEVER_TO_WEB_SERVER_RSP_NOTIFY;
const int Proto_Kernel_CMD_ARRAYSIZE = Proto_Kernel_CMD_MAX + 1;

const ::google::protobuf::EnumDescriptor* Proto_Kernel_CMD_descriptor();
inline const ::std::string& Proto_Kernel_CMD_Name(Proto_Kernel_CMD value) {
  return ::google::protobuf::internal::NameOfEnum(
    Proto_Kernel_CMD_descriptor(), value);
}
inline bool Proto_Kernel_CMD_Parse(
    const ::std::string& name, Proto_Kernel_CMD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Proto_Kernel_CMD>(
    Proto_Kernel_CMD_descriptor(), name, value);
}
enum NFROUTER_ERRCODE {
  NF_ROUTER_ERRCODE_OK = 0,
  NF_ROUTER_ERRCODE_DISPATCHFAILD_DESTSVR_NOTEXIST = 1
};
bool NFROUTER_ERRCODE_IsValid(int value);
const NFROUTER_ERRCODE NFROUTER_ERRCODE_MIN = NF_ROUTER_ERRCODE_OK;
const NFROUTER_ERRCODE NFROUTER_ERRCODE_MAX = NF_ROUTER_ERRCODE_DISPATCHFAILD_DESTSVR_NOTEXIST;
const int NFROUTER_ERRCODE_ARRAYSIZE = NFROUTER_ERRCODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* NFROUTER_ERRCODE_descriptor();
inline const ::std::string& NFROUTER_ERRCODE_Name(NFROUTER_ERRCODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    NFROUTER_ERRCODE_descriptor(), value);
}
inline bool NFROUTER_ERRCODE_Parse(
    const ::std::string& name, NFROUTER_ERRCODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NFROUTER_ERRCODE>(
    NFROUTER_ERRCODE_descriptor(), name, value);
}
enum STORESVR_CS_COMMAND {
  E_STORESVR_C2S_SELECT = 0,
  E_STORESVR_S2C_SELECT = 1,
  E_STORESVR_C2S_SELECTOBJ = 2,
  E_STORESVR_S2C_SELECTOBJ = 3,
  E_STORESVR_C2S_INSERT = 4,
  E_STORESVR_S2C_INSERT = 5,
  E_STORESVR_C2S_DELETE = 6,
  E_STORESVR_S2C_DELETE = 7,
  E_STORESVR_C2S_DELETEOBJ = 8,
  E_STORESVR_S2C_DELETEOBJ = 9,
  E_STORESVR_C2S_MODIFY = 10,
  E_STORESVR_S2C_MODIFY = 11,
  E_STORESVR_C2S_MODIFYOBJ = 12,
  E_STORESVR_S2C_MODIFYOBJ = 13,
  E_STORESVR_C2S_MODINS = 14,
  E_STORESVR_S2C_MODINS = 15,
  E_STORESVR_C2S_MODINSOBJ = 16,
  E_STORESVR_S2C_MODINSOBJ = 17,
  E_STORESVR_C2S_DESCSTORE = 18,
  E_STORESVR_S2C_DESCSTORE = 19,
  E_STORESVR_C2S_EXECUTE = 20,
  E_STORESVR_S2C_EXECUTE = 21
};
bool STORESVR_CS_COMMAND_IsValid(int value);
const STORESVR_CS_COMMAND STORESVR_CS_COMMAND_MIN = E_STORESVR_C2S_SELECT;
const STORESVR_CS_COMMAND STORESVR_CS_COMMAND_MAX = E_STORESVR_S2C_EXECUTE;
const int STORESVR_CS_COMMAND_ARRAYSIZE = STORESVR_CS_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* STORESVR_CS_COMMAND_descriptor();
inline const ::std::string& STORESVR_CS_COMMAND_Name(STORESVR_CS_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    STORESVR_CS_COMMAND_descriptor(), value);
}
inline bool STORESVR_CS_COMMAND_Parse(
    const ::std::string& name, STORESVR_CS_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<STORESVR_CS_COMMAND>(
    STORESVR_CS_COMMAND_descriptor(), name, value);
}
enum STORESVR_ERRCODE {
  E_STORESVR_ERRCODE_OK = 0,
  E_STORESVR_ERRCODE_BUSY = 1,
  E_STORESVR_ERRCODE_EINVAL = 2,
  E_STORESVR_ERRCODE_PARSEFROMSTRINGFAILED = 3,
  E_STORESVR_ERRCODE_DBNAME_OR_MODKEY_INVALID = 4,
  E_STORESVR_ERRCODE_TBNAME_INVALID = 5,
  E_STORESVR_ERRCODE_SELECT_EMPTY = 6,
  E_STORESVR_ERRCODE_SELECT_FILLMESSAGEBYRESULTFAILED = 7,
  E_STORESVR_ERRCODE_CANNOTCREATERECORDMSGOBJECT = 8,
  E_STORESVR_ERRCODE_CANNOTFINDSQLTEMPALTE = 9,
  E_STORESVR_ERRCODE_SETPREPARESTATEMENTFAILED = 10,
  E_STORESVR_ERRCODE_INSERTFAILED = 11,
  E_STORESVR_ERRCODE_DELETEFAILED = 12,
  E_STORESVR_ERRCODE_DELETERECORDISNOTEXIST = 13,
  E_STORESVR_ERRCODE_UPDATERECORDISNOTEXIST = 14,
  E_STORESVR_ERRCODE_UPDATENOROWAFFECTED = 15,
  E_STORESVR_ERRCODE_UPDATEFAILED = 16,
  E_STORESVR_ERRCODE_UPDATEINSERTFAILED = 17,
  E_STORESVR_ERRCODE_UNKNOWN = 18
};
bool STORESVR_ERRCODE_IsValid(int value);
const STORESVR_ERRCODE STORESVR_ERRCODE_MIN = E_STORESVR_ERRCODE_OK;
const STORESVR_ERRCODE STORESVR_ERRCODE_MAX = E_STORESVR_ERRCODE_UNKNOWN;
const int STORESVR_ERRCODE_ARRAYSIZE = STORESVR_ERRCODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* STORESVR_ERRCODE_descriptor();
inline const ::std::string& STORESVR_ERRCODE_Name(STORESVR_ERRCODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    STORESVR_ERRCODE_descriptor(), value);
}
inline bool STORESVR_ERRCODE_Parse(
    const ::std::string& name, STORESVR_ERRCODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<STORESVR_ERRCODE>(
    STORESVR_ERRCODE_descriptor(), name, value);
}
enum PacketDispType {
  E_DISP_TYPE_NONE = 0,
  E_DISP_TYPE_BY_TRANSACTION = 1,
  E_DISP_TYPE_BY_ROLEID = 2,
  E_DISP_TYPE_BY_MSGID = 3,
  E_DISP_TYPE_BY_RPC = 4
};
bool PacketDispType_IsValid(int value);
const PacketDispType PacketDispType_MIN = E_DISP_TYPE_NONE;
const PacketDispType PacketDispType_MAX = E_DISP_TYPE_BY_RPC;
const int PacketDispType_ARRAYSIZE = PacketDispType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PacketDispType_descriptor();
inline const ::std::string& PacketDispType_Name(PacketDispType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PacketDispType_descriptor(), value);
}
inline bool PacketDispType_Parse(
    const ::std::string& name, PacketDispType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PacketDispType>(
    PacketDispType_descriptor(), name, value);
}
enum TableID {
  E_TABLE_NONE = 0,
  E_TABLE_ACCOUNT_PLAYER = 1,
  E_TABLE_USER_MAIL = 2,
  E_TABLE_MAIL_DETAIL = 3,
  E_TABLE_USER_DETAIL = 4,
  E_TABLE_USER_SIMPLE = 5,
  E_TABLE_USER_MISC = 6,
  E_TABLE_GIVE_BANK_JETTON = 7,
  E_TABLE_EVENT_LOG = 8,
  E_TABLE_RANK_COMMON = 9,
  E_TABLE_GAME_ROBOT = 10,
  E_TABLE_MONEY_DETAIL = 11,
  E_TABLE_LOG_SYSTEM_DAY = 12,
  E_TABLE_LOG_GAME_DAY = 13
};
bool TableID_IsValid(int value);
const TableID TableID_MIN = E_TABLE_NONE;
const TableID TableID_MAX = E_TABLE_LOG_GAME_DAY;
const int TableID_ARRAYSIZE = TableID_MAX + 1;

const ::google::protobuf::EnumDescriptor* TableID_descriptor();
inline const ::std::string& TableID_Name(TableID value) {
  return ::google::protobuf::internal::NameOfEnum(
    TableID_descriptor(), value);
}
inline bool TableID_Parse(
    const ::std::string& name, TableID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TableID>(
    TableID_descriptor(), name, value);
}
enum ServerType {
  NF_ST_NONE = 0,
  NF_ST_MASTER_SERVER = 1,
  NF_ST_LOGIN_SERVER = 2,
  NF_ST_WORLD_SERVER = 3,
  NF_ST_GAME_SERVER = 4,
  NF_ST_PROXY_SERVER = 5,
  NF_ST_ROUTE_AGENT_SERVER = 6,
  NF_ST_ROUTE_SERVER = 7,
  NF_ST_STORE_SERVER = 8,
  NF_ST_MAX = 20
};
bool ServerType_IsValid(int value);
const ServerType ServerType_MIN = NF_ST_NONE;
const ServerType ServerType_MAX = NF_ST_MAX;
const int ServerType_ARRAYSIZE = ServerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerType_descriptor();
inline const ::std::string& ServerType_Name(ServerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerType_descriptor(), value);
}
inline bool ServerType_Parse(
    const ::std::string& name, ServerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerType>(
    ServerType_descriptor(), name, value);
}
enum EServerState {
  EST_CRASH = 0,
  EST_NARMAL = 1,
  EST_BUSY = 2,
  EST_FIRE = 3,
  EST_MAINTEN = 4
};
bool EServerState_IsValid(int value);
const EServerState EServerState_MIN = EST_CRASH;
const EServerState EServerState_MAX = EST_MAINTEN;
const int EServerState_ARRAYSIZE = EServerState_MAX + 1;

const ::google::protobuf::EnumDescriptor* EServerState_descriptor();
inline const ::std::string& EServerState_Name(EServerState value) {
  return ::google::protobuf::internal::NameOfEnum(
    EServerState_descriptor(), value);
}
inline bool EServerState_Parse(
    const ::std::string& name, EServerState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EServerState>(
    EServerState_descriptor(), name, value);
}
enum Proto_Kernel_ErrorCode {
  ERR_CODE_ZOOKEEPER_BASE = 0,
  ERR_CODE_ZK_SYSTEMERROR = -1,
  ERR_CODE_ZK_RUNTIMEINCONSISTENCY = -2,
  ERR_CODE_ZK_DATAINCONSISTENCY = -3,
  ERR_CODE_ZK_CONNECTIONLOSS = -4,
  ERR_CODE_ZK_MARSHALLINGERROR = -5,
  ERR_CODE_ZK_UNIMPLEMENTED = -6,
  ERR_CODE_ZK_OPERATIONTIMEOUT = -7,
  ERR_CODE_ZK_BADARGUMENTS = -8,
  ERR_CODE_ZK_INVALIDSTATE = -9,
  ERR_CODE_kSM_DNSFAILURE = -10,
  ERR_CODE_ZK_APIERROR = -100,
  ERR_CODE_ZK_NONODE = -101,
  ERR_CODE_ZK_NOAUTH = -102,
  ERR_CODE_ZK_BADVERSION = -103,
  ERR_CODE_ZK_NOCHILDRENFOREPHEMERALS = -108,
  ERR_CODE_ZK_NODEEXISTS = -110,
  ERR_CODE_ZK_NOTEMPTY = -111,
  ERR_CODE_ZK_SESSIONEXPIRED = -112,
  ERR_CODE_ZK_INVALIDCALLBACK = -113,
  ERR_CODE_ZK_INVALIDACL = -114,
  ERR_CODE_ZK_AUTHFAILED = -115,
  ERR_CODE_ZK_CLOSING = -116,
  ERR_CODE_ZK_NOTHING = -117,
  ERR_CODE_ZK_SESSIONMOVED = -118,
  ERR_CODE_ZK_NOQUOTA = -119,
  ERR_CODE_ZK_SERVEROVERLOAD = -120,
  ERR_CODE_ZK_NOT_SET_APPKEY = -200,
  ERR_CODE_SVR_SYSTEM_ERROR = -1,
  ERR_CODE_SVR_OK = 0,
  ERR_CODE_MSG_RPC_BASE = 100,
  ERR_CODE_SESSION_BASE = 200,
  ERR_CODE_MESSAGE_BASE = 300,
  ERR_CODE_NAMING_BASE = 400,
  ERR_CODE_NAMING_NOT_SUPPORTTED = 401,
  ERR_CODE_NAMING_INVAILD_PARAM = 402,
  ERR_CODE_NAMING_URL_REGISTERED = 403,
  ERR_CODE_NAMING_URL_NOT_BINDED = 404,
  ERR_CODE_NAMING_REGISTER_FAILED = 405,
  ERR_CODE_NAMING_FACTORY_MAP_NULL = 406,
  ERR_CODE_NAMING_FACTORY_EXISTED = 407,
  ERR_CODE_ROUTER_BASE = 500,
  ERR_CODE_ROUTER_NOT_SUPPORTTED = 501,
  ERR_CODE_ROUTER_INVAILD_PARAM = 502,
  ERR_CODE_ROUTER_NONE_VALID_HANDLE = 503,
  ERR_CODE_ROUTER_FACTORY_MAP_NULL = 504,
  ERR_CODE_ROUTER_FACTORY_EXISTED = 505,
  ERR_CODE_TIMER_BASE = 600,
  ERR_CODE_PIPE_BASE = 700,
  ERR_CODE_COROUTINE_BASE = 800,
  ERR_CODE_CO_INVALID_PARAM = 801,
  ERR_CODE_CO_NOT_IN_COROUTINE = 802,
  ERR_CODE_CO_NOT_RUNNING = 803,
  ERR_CODE_CO_START_TIMER_FAILED = 804,
  ERR_CODE_CO_TIMEOUT = 805,
  ERR_CODE_CO_CANNOT_RESUME_IN_COROUTINE = 806,
  ERR_CODE_CO_COROUTINE_UNEXIST = 807,
  ERR_CODE_CO_COROUTINE_STATUS_ERROR = 809,
  ERR_CODE_CHANNEL_BASE = 900,
  ERR_CODE_SVR_SYSTEM_TIMEOUT = 10000,
  ERR_CODE_SVR_SYSTEM_DATABASE_ERROR = 10001
};
bool Proto_Kernel_ErrorCode_IsValid(int value);
const Proto_Kernel_ErrorCode Proto_Kernel_ErrorCode_MIN = ERR_CODE_ZK_NOT_SET_APPKEY;
const Proto_Kernel_ErrorCode Proto_Kernel_ErrorCode_MAX = ERR_CODE_SVR_SYSTEM_DATABASE_ERROR;
const int Proto_Kernel_ErrorCode_ARRAYSIZE = Proto_Kernel_ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Proto_Kernel_ErrorCode_descriptor();
inline const ::std::string& Proto_Kernel_ErrorCode_Name(Proto_Kernel_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Proto_Kernel_ErrorCode_descriptor(), value);
}
inline bool Proto_Kernel_ErrorCode_Parse(
    const ::std::string& name, Proto_Kernel_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Proto_Kernel_ErrorCode>(
    Proto_Kernel_ErrorCode_descriptor(), name, value);
}
enum NFEventSrcType {
  NF_EVENT_NONE_TYPE = 0,
  NF_EVENT_SERVER_TYPE = 1,
  NF_EVENT_GM_TYPE = 2,
  NF_EVENT_PLAYER_TYPE = 3
};
bool NFEventSrcType_IsValid(int value);
const NFEventSrcType NFEventSrcType_MIN = NF_EVENT_NONE_TYPE;
const NFEventSrcType NFEventSrcType_MAX = NF_EVENT_PLAYER_TYPE;
const int NFEventSrcType_ARRAYSIZE = NFEventSrcType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NFEventSrcType_descriptor();
inline const ::std::string& NFEventSrcType_Name(NFEventSrcType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NFEventSrcType_descriptor(), value);
}
inline bool NFEventSrcType_Parse(
    const ::std::string& name, NFEventSrcType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NFEventSrcType>(
    NFEventSrcType_descriptor(), name, value);
}
enum NFEventIdType {
  NF_EVENT_SERVER_TYPE_BEGIN = 1,
  NF_EVENT_SERVER_APP_TASK_FINISH = 2,
  NF_EVENT_SERVER_LOAD_DESC_STORE = 3,
  NF_EVENT_SERVER_OBJ_LOAD_FROM_DB = 4,
  NF_EVENT_SERVER_APP_FINISH_INITED = 5,
  NF_EVENT_SERVER_DEAD_EVENT = 6,
  NF_EVENT_SERVER_REG_EVENT = 7,
  NF_EVENT_GAME_SERVER_DUMP_EVENT = 8,
  NF_EVENT_LOGIC_SERVER_DUMP_EVENT = 9,
  NF_EVENT_SERVER_TYPE_END = 99,
  NF_EVENT_GM_TYPE_BEGIN = 100,
  NF_EVENT_GM_TYPE_END = 199,
  NF_EVENT_PLAYER_TYPE_BEGIN = 200,
  NF_EVENT_PLAYER_LOGIN_SUCCESS = 201,
  NF_EVENT_PLAYER_LOGIN_FAILED = 202,
  NF_EVENT_PLAYER_RECONNECT_SUCCESS = 203,
  NF_EVENT_PLAYER_DISCONNECT = 204,
  NF_EVENT_PLAYER_TYPE_END = 299
};
bool NFEventIdType_IsValid(int value);
const NFEventIdType NFEventIdType_MIN = NF_EVENT_SERVER_TYPE_BEGIN;
const NFEventIdType NFEventIdType_MAX = NF_EVENT_PLAYER_TYPE_END;
const int NFEventIdType_ARRAYSIZE = NFEventIdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NFEventIdType_descriptor();
inline const ::std::string& NFEventIdType_Name(NFEventIdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NFEventIdType_descriptor(), value);
}
inline bool NFEventIdType_Parse(
    const ::std::string& name, NFEventIdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NFEventIdType>(
    NFEventIdType_descriptor(), name, value);
}
// ===================================================================

class Proto_DispInfo : public ::google::protobuf::Message {
 public:
  Proto_DispInfo();
  virtual ~Proto_DispInfo();

  Proto_DispInfo(const Proto_DispInfo& from);

  inline Proto_DispInfo& operator=(const Proto_DispInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_DispInfo& default_instance();

  void Swap(Proto_DispInfo* other);

  // implements Message ----------------------------------------------

  Proto_DispInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_DispInfo& from);
  void MergeFrom(const Proto_DispInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 user_id() const;
  inline void set_user_id(::google::protobuf::uint64 value);

  // optional int32 req_trans_id = 2;
  inline bool has_req_trans_id() const;
  inline void clear_req_trans_id();
  static const int kReqTransIdFieldNumber = 2;
  inline ::google::protobuf::int32 req_trans_id() const;
  inline void set_req_trans_id(::google::protobuf::int32 value);

  // optional int32 rsp_trans_id = 3;
  inline bool has_rsp_trans_id() const;
  inline void clear_rsp_trans_id();
  static const int kRspTransIdFieldNumber = 3;
  inline ::google::protobuf::int32 rsp_trans_id() const;
  inline void set_rsp_trans_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_DispInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_req_trans_id();
  inline void clear_has_req_trans_id();
  inline void set_has_rsp_trans_id();
  inline void clear_has_rsp_trans_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 user_id_;
  ::google::protobuf::int32 req_trans_id_;
  ::google::protobuf::int32 rsp_trans_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_DispInfo* default_instance_;
};
// -------------------------------------------------------------------

class Proto_StoreInfo_CB : public ::google::protobuf::Message {
 public:
  Proto_StoreInfo_CB();
  virtual ~Proto_StoreInfo_CB();

  Proto_StoreInfo_CB(const Proto_StoreInfo_CB& from);

  inline Proto_StoreInfo_CB& operator=(const Proto_StoreInfo_CB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_StoreInfo_CB& default_instance();

  void Swap(Proto_StoreInfo_CB* other);

  // implements Message ----------------------------------------------

  Proto_StoreInfo_CB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_StoreInfo_CB& from);
  void MergeFrom(const Proto_StoreInfo_CB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto_ff.PacketDispType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::proto_ff::PacketDispType type() const;
  inline void set_type(::proto_ff::PacketDispType value);

  // optional uint64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional .proto_ff.TableID table_id = 3;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  inline ::proto_ff::TableID table_id() const;
  inline void set_table_id(::proto_ff::TableID value);

  // optional uint32 seq = 4;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 4;
  inline ::google::protobuf::uint32 seq() const;
  inline void set_seq(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_StoreInfo_CB)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  int type_;
  int table_id_;
  ::google::protobuf::uint32 seq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_StoreInfo_CB* default_instance_;
};
// -------------------------------------------------------------------

class Proto_StoreInfo : public ::google::protobuf::Message {
 public:
  Proto_StoreInfo();
  virtual ~Proto_StoreInfo();

  Proto_StoreInfo(const Proto_StoreInfo& from);

  inline Proto_StoreInfo& operator=(const Proto_StoreInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_StoreInfo& default_instance();

  void Swap(Proto_StoreInfo* other);

  // implements Message ----------------------------------------------

  Proto_StoreInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_StoreInfo& from);
  void MergeFrom(const Proto_StoreInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto_ff.STORESVR_CS_COMMAND cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::proto_ff::STORESVR_CS_COMMAND cmd() const;
  inline void set_cmd(::proto_ff::STORESVR_CS_COMMAND value);

  // optional .proto_ff.STORESVR_ERRCODE err_code = 2;
  inline bool has_err_code() const;
  inline void clear_err_code();
  static const int kErrCodeFieldNumber = 2;
  inline ::proto_ff::STORESVR_ERRCODE err_code() const;
  inline void set_err_code(::proto_ff::STORESVR_ERRCODE value);

  // optional .proto_ff.Proto_StoreInfo_CB cb_data = 3;
  inline bool has_cb_data() const;
  inline void clear_cb_data();
  static const int kCbDataFieldNumber = 3;
  inline const ::proto_ff::Proto_StoreInfo_CB& cb_data() const;
  inline ::proto_ff::Proto_StoreInfo_CB* mutable_cb_data();
  inline ::proto_ff::Proto_StoreInfo_CB* release_cb_data();
  inline void set_allocated_cb_data(::proto_ff::Proto_StoreInfo_CB* cb_data);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_StoreInfo)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_err_code();
  inline void clear_has_err_code();
  inline void set_has_cb_data();
  inline void clear_has_cb_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int cmd_;
  int err_code_;
  ::proto_ff::Proto_StoreInfo_CB* cb_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_StoreInfo* default_instance_;
};
// -------------------------------------------------------------------

class Proto_SvrPkg : public ::google::protobuf::Message {
 public:
  Proto_SvrPkg();
  virtual ~Proto_SvrPkg();

  Proto_SvrPkg(const Proto_SvrPkg& from);

  inline Proto_SvrPkg& operator=(const Proto_SvrPkg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_SvrPkg& default_instance();

  void Swap(Proto_SvrPkg* other);

  // implements Message ----------------------------------------------

  Proto_SvrPkg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_SvrPkg& from);
  void MergeFrom(const Proto_SvrPkg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::int32 msg_id() const;
  inline void set_msg_id(::google::protobuf::int32 value);

  // optional bytes msg_data = 2;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 2;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // optional .proto_ff.Proto_DispInfo disp_info = 3;
  inline bool has_disp_info() const;
  inline void clear_disp_info();
  static const int kDispInfoFieldNumber = 3;
  inline const ::proto_ff::Proto_DispInfo& disp_info() const;
  inline ::proto_ff::Proto_DispInfo* mutable_disp_info();
  inline ::proto_ff::Proto_DispInfo* release_disp_info();
  inline void set_allocated_disp_info(::proto_ff::Proto_DispInfo* disp_info);

  // optional .proto_ff.Proto_StoreInfo store_info = 4;
  inline bool has_store_info() const;
  inline void clear_store_info();
  static const int kStoreInfoFieldNumber = 4;
  inline const ::proto_ff::Proto_StoreInfo& store_info() const;
  inline ::proto_ff::Proto_StoreInfo* mutable_store_info();
  inline ::proto_ff::Proto_StoreInfo* release_store_info();
  inline void set_allocated_store_info(::proto_ff::Proto_StoreInfo* store_info);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_SvrPkg)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();
  inline void set_has_disp_info();
  inline void clear_has_disp_info();
  inline void set_has_store_info();
  inline void clear_has_store_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_data_;
  ::proto_ff::Proto_DispInfo* disp_info_;
  ::proto_ff::Proto_StoreInfo* store_info_;
  ::google::protobuf::int32 msg_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_SvrPkg* default_instance_;
};
// -------------------------------------------------------------------

class ServerInfoReport : public ::google::protobuf::Message {
 public:
  ServerInfoReport();
  virtual ~ServerInfoReport();

  ServerInfoReport(const ServerInfoReport& from);

  inline ServerInfoReport& operator=(const ServerInfoReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfoReport& default_instance();

  void Swap(ServerInfoReport* other);

  // implements Message ----------------------------------------------

  ServerInfoReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerInfoReport& from);
  void MergeFrom(const ServerInfoReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 bus_id = 1;
  inline bool has_bus_id() const;
  inline void clear_bus_id();
  static const int kBusIdFieldNumber = 1;
  inline ::google::protobuf::uint32 bus_id() const;
  inline void set_bus_id(::google::protobuf::uint32 value);

  // optional string bus_name = 2;
  inline bool has_bus_name() const;
  inline void clear_bus_name();
  static const int kBusNameFieldNumber = 2;
  inline const ::std::string& bus_name() const;
  inline void set_bus_name(const ::std::string& value);
  inline void set_bus_name(const char* value);
  inline void set_bus_name(const char* value, size_t size);
  inline ::std::string* mutable_bus_name();
  inline ::std::string* release_bus_name();
  inline void set_allocated_bus_name(::std::string* bus_name);

  // optional uint32 server_type = 3;
  inline bool has_server_type() const;
  inline void clear_server_type();
  static const int kServerTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 server_type() const;
  inline void set_server_type(::google::protobuf::uint32 value);

  // optional string server_name = 4;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 4;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const char* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // optional string url = 5;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 5;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string link_mode = 6;
  inline bool has_link_mode() const;
  inline void clear_link_mode();
  static const int kLinkModeFieldNumber = 6;
  inline const ::std::string& link_mode() const;
  inline void set_link_mode(const ::std::string& value);
  inline void set_link_mode(const char* value);
  inline void set_link_mode(const char* value, size_t size);
  inline ::std::string* mutable_link_mode();
  inline ::std::string* release_link_mode();
  inline void set_allocated_link_mode(::std::string* link_mode);

  // optional uint32 bus_length = 7;
  inline bool has_bus_length() const;
  inline void clear_bus_length();
  static const int kBusLengthFieldNumber = 7;
  inline ::google::protobuf::uint32 bus_length() const;
  inline void set_bus_length(::google::protobuf::uint32 value);

  // optional string server_ip = 9;
  inline bool has_server_ip() const;
  inline void clear_server_ip();
  static const int kServerIpFieldNumber = 9;
  inline const ::std::string& server_ip() const;
  inline void set_server_ip(const ::std::string& value);
  inline void set_server_ip(const char* value);
  inline void set_server_ip(const char* value, size_t size);
  inline ::std::string* mutable_server_ip();
  inline ::std::string* release_server_ip();
  inline void set_allocated_server_ip(::std::string* server_ip);

  // optional uint32 server_port = 10;
  inline bool has_server_port() const;
  inline void clear_server_port();
  static const int kServerPortFieldNumber = 10;
  inline ::google::protobuf::uint32 server_port() const;
  inline void set_server_port(::google::protobuf::uint32 value);

  // optional uint32 server_http_port = 11;
  inline bool has_server_http_port() const;
  inline void clear_server_http_port();
  static const int kServerHttpPortFieldNumber = 11;
  inline ::google::protobuf::uint32 server_http_port() const;
  inline void set_server_http_port(::google::protobuf::uint32 value);

  // optional string external_server_ip = 12;
  inline bool has_external_server_ip() const;
  inline void clear_external_server_ip();
  static const int kExternalServerIpFieldNumber = 12;
  inline const ::std::string& external_server_ip() const;
  inline void set_external_server_ip(const ::std::string& value);
  inline void set_external_server_ip(const char* value);
  inline void set_external_server_ip(const char* value, size_t size);
  inline ::std::string* mutable_external_server_ip();
  inline ::std::string* release_external_server_ip();
  inline void set_allocated_external_server_ip(::std::string* external_server_ip);

  // optional uint32 external_server_port = 13;
  inline bool has_external_server_port() const;
  inline void clear_external_server_port();
  static const int kExternalServerPortFieldNumber = 13;
  inline ::google::protobuf::uint32 external_server_port() const;
  inline void set_external_server_port(::google::protobuf::uint32 value);

  // optional string route_svr = 15;
  inline bool has_route_svr() const;
  inline void clear_route_svr();
  static const int kRouteSvrFieldNumber = 15;
  inline const ::std::string& route_svr() const;
  inline void set_route_svr(const ::std::string& value);
  inline void set_route_svr(const char* value);
  inline void set_route_svr(const char* value, size_t size);
  inline ::std::string* mutable_route_svr();
  inline ::std::string* release_route_svr();
  inline void set_allocated_route_svr(::std::string* route_svr);

  // optional uint32 server_max_online = 30;
  inline bool has_server_max_online() const;
  inline void clear_server_max_online();
  static const int kServerMaxOnlineFieldNumber = 30;
  inline ::google::protobuf::uint32 server_max_online() const;
  inline void set_server_max_online(::google::protobuf::uint32 value);

  // optional uint32 server_cur_online = 31;
  inline bool has_server_cur_online() const;
  inline void clear_server_cur_online();
  static const int kServerCurOnlineFieldNumber = 31;
  inline ::google::protobuf::uint32 server_cur_online() const;
  inline void set_server_cur_online(::google::protobuf::uint32 value);

  // optional uint32 server_state = 32;
  inline bool has_server_state() const;
  inline void clear_server_state();
  static const int kServerStateFieldNumber = 32;
  inline ::google::protobuf::uint32 server_state() const;
  inline void set_server_state(::google::protobuf::uint32 value);

  // optional string system_info = 33;
  inline bool has_system_info() const;
  inline void clear_system_info();
  static const int kSystemInfoFieldNumber = 33;
  inline const ::std::string& system_info() const;
  inline void set_system_info(const ::std::string& value);
  inline void set_system_info(const char* value);
  inline void set_system_info(const char* value, size_t size);
  inline ::std::string* mutable_system_info();
  inline ::std::string* release_system_info();
  inline void set_allocated_system_info(::std::string* system_info);

  // optional uint64 total_mem = 34;
  inline bool has_total_mem() const;
  inline void clear_total_mem();
  static const int kTotalMemFieldNumber = 34;
  inline ::google::protobuf::uint64 total_mem() const;
  inline void set_total_mem(::google::protobuf::uint64 value);

  // optional uint64 free_mem = 35;
  inline bool has_free_mem() const;
  inline void clear_free_mem();
  static const int kFreeMemFieldNumber = 35;
  inline ::google::protobuf::uint64 free_mem() const;
  inline void set_free_mem(::google::protobuf::uint64 value);

  // optional uint64 used_mem = 36;
  inline bool has_used_mem() const;
  inline void clear_used_mem();
  static const int kUsedMemFieldNumber = 36;
  inline ::google::protobuf::uint64 used_mem() const;
  inline void set_used_mem(::google::protobuf::uint64 value);

  // optional double proc_cpu = 37;
  inline bool has_proc_cpu() const;
  inline void clear_proc_cpu();
  static const int kProcCpuFieldNumber = 37;
  inline double proc_cpu() const;
  inline void set_proc_cpu(double value);

  // optional uint64 proc_mem = 38;
  inline bool has_proc_mem() const;
  inline void clear_proc_mem();
  static const int kProcMemFieldNumber = 38;
  inline ::google::protobuf::uint64 proc_mem() const;
  inline void set_proc_mem(::google::protobuf::uint64 value);

  // optional uint32 proc_thread = 39;
  inline bool has_proc_thread() const;
  inline void clear_proc_thread();
  static const int kProcThreadFieldNumber = 39;
  inline ::google::protobuf::uint32 proc_thread() const;
  inline void set_proc_thread(::google::protobuf::uint32 value);

  // optional string proc_name = 40;
  inline bool has_proc_name() const;
  inline void clear_proc_name();
  static const int kProcNameFieldNumber = 40;
  inline const ::std::string& proc_name() const;
  inline void set_proc_name(const ::std::string& value);
  inline void set_proc_name(const char* value);
  inline void set_proc_name(const char* value, size_t size);
  inline ::std::string* mutable_proc_name();
  inline ::std::string* release_proc_name();
  inline void set_allocated_proc_name(::std::string* proc_name);

  // optional string proc_cwd = 41;
  inline bool has_proc_cwd() const;
  inline void clear_proc_cwd();
  static const int kProcCwdFieldNumber = 41;
  inline const ::std::string& proc_cwd() const;
  inline void set_proc_cwd(const ::std::string& value);
  inline void set_proc_cwd(const char* value);
  inline void set_proc_cwd(const char* value, size_t size);
  inline ::std::string* mutable_proc_cwd();
  inline ::std::string* release_proc_cwd();
  inline void set_allocated_proc_cwd(::std::string* proc_cwd);

  // optional uint32 proc_pid = 42;
  inline bool has_proc_pid() const;
  inline void clear_proc_pid();
  static const int kProcPidFieldNumber = 42;
  inline ::google::protobuf::uint32 proc_pid() const;
  inline void set_proc_pid(::google::protobuf::uint32 value);

  // optional string last_date = 43;
  inline bool has_last_date() const;
  inline void clear_last_date();
  static const int kLastDateFieldNumber = 43;
  inline const ::std::string& last_date() const;
  inline void set_last_date(const ::std::string& value);
  inline void set_last_date(const char* value);
  inline void set_last_date(const char* value, size_t size);
  inline ::std::string* mutable_last_date();
  inline ::std::string* release_last_date();
  inline void set_allocated_last_date(::std::string* last_date);

  // optional uint64 last_time = 44;
  inline bool has_last_time() const;
  inline void clear_last_time();
  static const int kLastTimeFieldNumber = 44;
  inline ::google::protobuf::uint64 last_time() const;
  inline void set_last_time(::google::protobuf::uint64 value);

  // optional string contract_info = 45;
  inline bool has_contract_info() const;
  inline void clear_contract_info();
  static const int kContractInfoFieldNumber = 45;
  inline const ::std::string& contract_info() const;
  inline void set_contract_info(const ::std::string& value);
  inline void set_contract_info(const char* value);
  inline void set_contract_info(const char* value, size_t size);
  inline ::std::string* mutable_contract_info();
  inline ::std::string* release_contract_info();
  inline void set_allocated_contract_info(::std::string* contract_info);

  // optional string machine_addr = 46;
  inline bool has_machine_addr() const;
  inline void clear_machine_addr();
  static const int kMachineAddrFieldNumber = 46;
  inline const ::std::string& machine_addr() const;
  inline void set_machine_addr(const ::std::string& value);
  inline void set_machine_addr(const char* value);
  inline void set_machine_addr(const char* value, size_t size);
  inline ::std::string* mutable_machine_addr();
  inline ::std::string* release_machine_addr();
  inline void set_allocated_machine_addr(::std::string* machine_addr);

  // repeated string db_name_list = 47;
  inline int db_name_list_size() const;
  inline void clear_db_name_list();
  static const int kDbNameListFieldNumber = 47;
  inline const ::std::string& db_name_list(int index) const;
  inline ::std::string* mutable_db_name_list(int index);
  inline void set_db_name_list(int index, const ::std::string& value);
  inline void set_db_name_list(int index, const char* value);
  inline void set_db_name_list(int index, const char* value, size_t size);
  inline ::std::string* add_db_name_list();
  inline void add_db_name_list(const ::std::string& value);
  inline void add_db_name_list(const char* value);
  inline void add_db_name_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& db_name_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_db_name_list();

  // @@protoc_insertion_point(class_scope:proto_ff.ServerInfoReport)
 private:
  inline void set_has_bus_id();
  inline void clear_has_bus_id();
  inline void set_has_bus_name();
  inline void clear_has_bus_name();
  inline void set_has_server_type();
  inline void clear_has_server_type();
  inline void set_has_server_name();
  inline void clear_has_server_name();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_link_mode();
  inline void clear_has_link_mode();
  inline void set_has_bus_length();
  inline void clear_has_bus_length();
  inline void set_has_server_ip();
  inline void clear_has_server_ip();
  inline void set_has_server_port();
  inline void clear_has_server_port();
  inline void set_has_server_http_port();
  inline void clear_has_server_http_port();
  inline void set_has_external_server_ip();
  inline void clear_has_external_server_ip();
  inline void set_has_external_server_port();
  inline void clear_has_external_server_port();
  inline void set_has_route_svr();
  inline void clear_has_route_svr();
  inline void set_has_server_max_online();
  inline void clear_has_server_max_online();
  inline void set_has_server_cur_online();
  inline void clear_has_server_cur_online();
  inline void set_has_server_state();
  inline void clear_has_server_state();
  inline void set_has_system_info();
  inline void clear_has_system_info();
  inline void set_has_total_mem();
  inline void clear_has_total_mem();
  inline void set_has_free_mem();
  inline void clear_has_free_mem();
  inline void set_has_used_mem();
  inline void clear_has_used_mem();
  inline void set_has_proc_cpu();
  inline void clear_has_proc_cpu();
  inline void set_has_proc_mem();
  inline void clear_has_proc_mem();
  inline void set_has_proc_thread();
  inline void clear_has_proc_thread();
  inline void set_has_proc_name();
  inline void clear_has_proc_name();
  inline void set_has_proc_cwd();
  inline void clear_has_proc_cwd();
  inline void set_has_proc_pid();
  inline void clear_has_proc_pid();
  inline void set_has_last_date();
  inline void clear_has_last_date();
  inline void set_has_last_time();
  inline void clear_has_last_time();
  inline void set_has_contract_info();
  inline void clear_has_contract_info();
  inline void set_has_machine_addr();
  inline void clear_has_machine_addr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 bus_id_;
  ::google::protobuf::uint32 server_type_;
  ::std::string* bus_name_;
  ::std::string* server_name_;
  ::std::string* url_;
  ::std::string* link_mode_;
  ::std::string* server_ip_;
  ::google::protobuf::uint32 bus_length_;
  ::google::protobuf::uint32 server_port_;
  ::std::string* external_server_ip_;
  ::google::protobuf::uint32 server_http_port_;
  ::google::protobuf::uint32 external_server_port_;
  ::std::string* route_svr_;
  ::google::protobuf::uint32 server_max_online_;
  ::google::protobuf::uint32 server_cur_online_;
  ::std::string* system_info_;
  ::google::protobuf::uint64 total_mem_;
  ::google::protobuf::uint64 free_mem_;
  ::google::protobuf::uint32 server_state_;
  ::google::protobuf::uint32 proc_thread_;
  ::google::protobuf::uint64 used_mem_;
  double proc_cpu_;
  ::google::protobuf::uint64 proc_mem_;
  ::std::string* proc_name_;
  ::std::string* proc_cwd_;
  ::std::string* last_date_;
  ::google::protobuf::uint64 last_time_;
  ::std::string* contract_info_;
  ::std::string* machine_addr_;
  ::google::protobuf::RepeatedPtrField< ::std::string> db_name_list_;
  ::google::protobuf::uint32 proc_pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static ServerInfoReport* default_instance_;
};
// -------------------------------------------------------------------

class ServerInfoReportList : public ::google::protobuf::Message {
 public:
  ServerInfoReportList();
  virtual ~ServerInfoReportList();

  ServerInfoReportList(const ServerInfoReportList& from);

  inline ServerInfoReportList& operator=(const ServerInfoReportList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfoReportList& default_instance();

  void Swap(ServerInfoReportList* other);

  // implements Message ----------------------------------------------

  ServerInfoReportList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerInfoReportList& from);
  void MergeFrom(const ServerInfoReportList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto_ff.ServerInfoReport server_list = 1;
  inline int server_list_size() const;
  inline void clear_server_list();
  static const int kServerListFieldNumber = 1;
  inline const ::proto_ff::ServerInfoReport& server_list(int index) const;
  inline ::proto_ff::ServerInfoReport* mutable_server_list(int index);
  inline ::proto_ff::ServerInfoReport* add_server_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ServerInfoReport >&
      server_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ServerInfoReport >*
      mutable_server_list();

  // @@protoc_insertion_point(class_scope:proto_ff.ServerInfoReportList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::ServerInfoReport > server_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static ServerInfoReportList* default_instance_;
};
// -------------------------------------------------------------------

class ZkServerInfo : public ::google::protobuf::Message {
 public:
  ZkServerInfo();
  virtual ~ZkServerInfo();

  ZkServerInfo(const ZkServerInfo& from);

  inline ZkServerInfo& operator=(const ZkServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZkServerInfo& default_instance();

  void Swap(ZkServerInfo* other);

  // implements Message ----------------------------------------------

  ZkServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZkServerInfo& from);
  void MergeFrom(const ZkServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bus_url = 1;
  inline bool has_bus_url() const;
  inline void clear_bus_url();
  static const int kBusUrlFieldNumber = 1;
  inline const ::std::string& bus_url() const;
  inline void set_bus_url(const ::std::string& value);
  inline void set_bus_url(const char* value);
  inline void set_bus_url(const char* value, size_t size);
  inline ::std::string* mutable_bus_url();
  inline ::std::string* release_bus_url();
  inline void set_allocated_bus_url(::std::string* bus_url);

  // optional string tcp_url = 2;
  inline bool has_tcp_url() const;
  inline void clear_tcp_url();
  static const int kTcpUrlFieldNumber = 2;
  inline const ::std::string& tcp_url() const;
  inline void set_tcp_url(const ::std::string& value);
  inline void set_tcp_url(const char* value);
  inline void set_tcp_url(const char* value, size_t size);
  inline ::std::string* mutable_tcp_url();
  inline ::std::string* release_tcp_url();
  inline void set_allocated_tcp_url(::std::string* tcp_url);

  // @@protoc_insertion_point(class_scope:proto_ff.ZkServerInfo)
 private:
  inline void set_has_bus_url();
  inline void clear_has_bus_url();
  inline void set_has_tcp_url();
  inline void clear_has_tcp_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bus_url_;
  ::std::string* tcp_url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static ZkServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class DynLibFileInfo : public ::google::protobuf::Message {
 public:
  DynLibFileInfo();
  virtual ~DynLibFileInfo();

  DynLibFileInfo(const DynLibFileInfo& from);

  inline DynLibFileInfo& operator=(const DynLibFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DynLibFileInfo& default_instance();

  void Swap(DynLibFileInfo* other);

  // implements Message ----------------------------------------------

  DynLibFileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DynLibFileInfo& from);
  void MergeFrom(const DynLibFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_md5 = 1;
  inline bool has_file_md5() const;
  inline void clear_file_md5();
  static const int kFileMd5FieldNumber = 1;
  inline const ::std::string& file_md5() const;
  inline void set_file_md5(const ::std::string& value);
  inline void set_file_md5(const char* value);
  inline void set_file_md5(const char* value, size_t size);
  inline ::std::string* mutable_file_md5();
  inline ::std::string* release_file_md5();
  inline void set_allocated_file_md5(::std::string* file_md5);

  // optional int32 file_size = 2;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 2;
  inline ::google::protobuf::int32 file_size() const;
  inline void set_file_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.DynLibFileInfo)
 private:
  inline void set_has_file_md5();
  inline void clear_has_file_md5();
  inline void set_has_file_size();
  inline void clear_has_file_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_md5_;
  ::google::protobuf::int32 file_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static DynLibFileInfo* default_instance_;
};
// -------------------------------------------------------------------

class DynLibFileInfoArray : public ::google::protobuf::Message {
 public:
  DynLibFileInfoArray();
  virtual ~DynLibFileInfoArray();

  DynLibFileInfoArray(const DynLibFileInfoArray& from);

  inline DynLibFileInfoArray& operator=(const DynLibFileInfoArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DynLibFileInfoArray& default_instance();

  void Swap(DynLibFileInfoArray* other);

  // implements Message ----------------------------------------------

  DynLibFileInfoArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DynLibFileInfoArray& from);
  void MergeFrom(const DynLibFileInfoArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto_ff.DynLibFileInfo file_list = 1;
  inline int file_list_size() const;
  inline void clear_file_list();
  static const int kFileListFieldNumber = 1;
  inline const ::proto_ff::DynLibFileInfo& file_list(int index) const;
  inline ::proto_ff::DynLibFileInfo* mutable_file_list(int index);
  inline ::proto_ff::DynLibFileInfo* add_file_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::DynLibFileInfo >&
      file_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::DynLibFileInfo >*
      mutable_file_list();

  // @@protoc_insertion_point(class_scope:proto_ff.DynLibFileInfoArray)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::DynLibFileInfo > file_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static DynLibFileInfoArray* default_instance_;
};
// -------------------------------------------------------------------

class Proto_KillAllServerNtf : public ::google::protobuf::Message {
 public:
  Proto_KillAllServerNtf();
  virtual ~Proto_KillAllServerNtf();

  Proto_KillAllServerNtf(const Proto_KillAllServerNtf& from);

  inline Proto_KillAllServerNtf& operator=(const Proto_KillAllServerNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_KillAllServerNtf& default_instance();

  void Swap(Proto_KillAllServerNtf* other);

  // implements Message ----------------------------------------------

  Proto_KillAllServerNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_KillAllServerNtf& from);
  void MergeFrom(const Proto_KillAllServerNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_KillAllServerNtf)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_KillAllServerNtf* default_instance_;
};
// -------------------------------------------------------------------

class Proto_KillAllServerRsp : public ::google::protobuf::Message {
 public:
  Proto_KillAllServerRsp();
  virtual ~Proto_KillAllServerRsp();

  Proto_KillAllServerRsp(const Proto_KillAllServerRsp& from);

  inline Proto_KillAllServerRsp& operator=(const Proto_KillAllServerRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_KillAllServerRsp& default_instance();

  void Swap(Proto_KillAllServerRsp* other);

  // implements Message ----------------------------------------------

  Proto_KillAllServerRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_KillAllServerRsp& from);
  void MergeFrom(const Proto_KillAllServerRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_KillAllServerRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_KillAllServerRsp* default_instance_;
};
// -------------------------------------------------------------------

class Proto_STSBroadPlayerMsgNotify : public ::google::protobuf::Message {
 public:
  Proto_STSBroadPlayerMsgNotify();
  virtual ~Proto_STSBroadPlayerMsgNotify();

  Proto_STSBroadPlayerMsgNotify(const Proto_STSBroadPlayerMsgNotify& from);

  inline Proto_STSBroadPlayerMsgNotify& operator=(const Proto_STSBroadPlayerMsgNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_STSBroadPlayerMsgNotify& default_instance();

  void Swap(Proto_STSBroadPlayerMsgNotify* other);

  // implements Message ----------------------------------------------

  Proto_STSBroadPlayerMsgNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_STSBroadPlayerMsgNotify& from);
  void MergeFrom(const Proto_STSBroadPlayerMsgNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 user_id = 1;
  inline int user_id_size() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 user_id(int index) const;
  inline void set_user_id(int index, ::google::protobuf::uint64 value);
  inline void add_user_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      user_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_user_id();

  // optional uint32 msg_id = 2;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 2;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // optional bytes msg_data = 3;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 3;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_STSBroadPlayerMsgNotify)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > user_id_;
  ::std::string* msg_data_;
  ::google::protobuf::uint32 msg_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_STSBroadPlayerMsgNotify* default_instance_;
};
// -------------------------------------------------------------------

class Proto_STWebMsgRspNotify : public ::google::protobuf::Message {
 public:
  Proto_STWebMsgRspNotify();
  virtual ~Proto_STWebMsgRspNotify();

  Proto_STWebMsgRspNotify(const Proto_STWebMsgRspNotify& from);

  inline Proto_STWebMsgRspNotify& operator=(const Proto_STWebMsgRspNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proto_STWebMsgRspNotify& default_instance();

  void Swap(Proto_STWebMsgRspNotify* other);

  // implements Message ----------------------------------------------

  Proto_STWebMsgRspNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proto_STWebMsgRspNotify& from);
  void MergeFrom(const Proto_STWebMsgRspNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string err_msg = 3;
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 3;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const char* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  inline void set_allocated_err_msg(::std::string* err_msg);

  // @@protoc_insertion_point(class_scope:proto_ff.Proto_STWebMsgRspNotify)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_err_msg();
  inline void clear_has_err_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 request_id_;
  ::std::string* err_msg_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static Proto_STWebMsgRspNotify* default_instance_;
};
// -------------------------------------------------------------------

class BehaviorLogHeader : public ::google::protobuf::Message {
 public:
  BehaviorLogHeader();
  virtual ~BehaviorLogHeader();

  BehaviorLogHeader(const BehaviorLogHeader& from);

  inline BehaviorLogHeader& operator=(const BehaviorLogHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BehaviorLogHeader& default_instance();

  void Swap(BehaviorLogHeader* other);

  // implements Message ----------------------------------------------

  BehaviorLogHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BehaviorLogHeader& from);
  void MergeFrom(const BehaviorLogHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 event_id = 1;
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  inline ::google::protobuf::uint64 event_id() const;
  inline void set_event_id(::google::protobuf::uint64 value);

  // optional uint32 sequence = 2;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // optional string bus_name = 3;
  inline bool has_bus_name() const;
  inline void clear_bus_name();
  static const int kBusNameFieldNumber = 3;
  inline const ::std::string& bus_name() const;
  inline void set_bus_name(const ::std::string& value);
  inline void set_bus_name(const char* value);
  inline void set_bus_name(const char* value, size_t size);
  inline ::std::string* mutable_bus_name();
  inline ::std::string* release_bus_name();
  inline void set_allocated_bus_name(::std::string* bus_name);

  // optional string event_time = 4;
  inline bool has_event_time() const;
  inline void clear_event_time();
  static const int kEventTimeFieldNumber = 4;
  inline const ::std::string& event_time() const;
  inline void set_event_time(const ::std::string& value);
  inline void set_event_time(const char* value);
  inline void set_event_time(const char* value, size_t size);
  inline ::std::string* mutable_event_time();
  inline ::std::string* release_event_time();
  inline void set_allocated_event_time(::std::string* event_time);

  // optional uint64 user_id = 5;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 5;
  inline ::google::protobuf::uint64 user_id() const;
  inline void set_user_id(::google::protobuf::uint64 value);

  // optional string user_name = 6;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 6;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:proto_ff.BehaviorLogHeader)
 private:
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_bus_name();
  inline void clear_has_bus_name();
  inline void set_has_event_time();
  inline void clear_has_event_time();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 event_id_;
  ::std::string* bus_name_;
  ::std::string* event_time_;
  ::google::protobuf::uint64 user_id_;
  ::std::string* user_name_;
  ::google::protobuf::uint32 sequence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static BehaviorLogHeader* default_instance_;
};
// -------------------------------------------------------------------

class NFEventNoneData : public ::google::protobuf::Message {
 public:
  NFEventNoneData();
  virtual ~NFEventNoneData();

  NFEventNoneData(const NFEventNoneData& from);

  inline NFEventNoneData& operator=(const NFEventNoneData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NFEventNoneData& default_instance();

  void Swap(NFEventNoneData* other);

  // implements Message ----------------------------------------------

  NFEventNoneData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NFEventNoneData& from);
  void MergeFrom(const NFEventNoneData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string param1 = 1;
  inline bool has_param1() const;
  inline void clear_param1();
  static const int kParam1FieldNumber = 1;
  inline const ::std::string& param1() const;
  inline void set_param1(const ::std::string& value);
  inline void set_param1(const char* value);
  inline void set_param1(const char* value, size_t size);
  inline ::std::string* mutable_param1();
  inline ::std::string* release_param1();
  inline void set_allocated_param1(::std::string* param1);

  // optional string param2 = 2;
  inline bool has_param2() const;
  inline void clear_param2();
  static const int kParam2FieldNumber = 2;
  inline const ::std::string& param2() const;
  inline void set_param2(const ::std::string& value);
  inline void set_param2(const char* value);
  inline void set_param2(const char* value, size_t size);
  inline ::std::string* mutable_param2();
  inline ::std::string* release_param2();
  inline void set_allocated_param2(::std::string* param2);

  // optional string param3 = 3;
  inline bool has_param3() const;
  inline void clear_param3();
  static const int kParam3FieldNumber = 3;
  inline const ::std::string& param3() const;
  inline void set_param3(const ::std::string& value);
  inline void set_param3(const char* value);
  inline void set_param3(const char* value, size_t size);
  inline ::std::string* mutable_param3();
  inline ::std::string* release_param3();
  inline void set_allocated_param3(::std::string* param3);

  // optional string param4 = 4;
  inline bool has_param4() const;
  inline void clear_param4();
  static const int kParam4FieldNumber = 4;
  inline const ::std::string& param4() const;
  inline void set_param4(const ::std::string& value);
  inline void set_param4(const char* value);
  inline void set_param4(const char* value, size_t size);
  inline ::std::string* mutable_param4();
  inline ::std::string* release_param4();
  inline void set_allocated_param4(::std::string* param4);

  // optional string param5 = 5;
  inline bool has_param5() const;
  inline void clear_param5();
  static const int kParam5FieldNumber = 5;
  inline const ::std::string& param5() const;
  inline void set_param5(const ::std::string& value);
  inline void set_param5(const char* value);
  inline void set_param5(const char* value, size_t size);
  inline ::std::string* mutable_param5();
  inline ::std::string* release_param5();
  inline void set_allocated_param5(::std::string* param5);

  // @@protoc_insertion_point(class_scope:proto_ff.NFEventNoneData)
 private:
  inline void set_has_param1();
  inline void clear_has_param1();
  inline void set_has_param2();
  inline void clear_has_param2();
  inline void set_has_param3();
  inline void clear_has_param3();
  inline void set_has_param4();
  inline void clear_has_param4();
  inline void set_has_param5();
  inline void clear_has_param5();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* param1_;
  ::std::string* param2_;
  ::std::string* param3_;
  ::std::string* param4_;
  ::std::string* param5_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fkernel_2eproto();
  friend void protobuf_AssignDesc_proto_5fkernel_2eproto();
  friend void protobuf_ShutdownFile_proto_5fkernel_2eproto();

  void InitAsDefaultInstance();
  static NFEventNoneData* default_instance_;
};
// ===================================================================


// ===================================================================

// Proto_DispInfo

// optional uint64 user_id = 1;
inline bool Proto_DispInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_DispInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_DispInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_DispInfo::clear_user_id() {
  user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::uint64 Proto_DispInfo::user_id() const {
  return user_id_;
}
inline void Proto_DispInfo::set_user_id(::google::protobuf::uint64 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional int32 req_trans_id = 2;
inline bool Proto_DispInfo::has_req_trans_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_DispInfo::set_has_req_trans_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_DispInfo::clear_has_req_trans_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_DispInfo::clear_req_trans_id() {
  req_trans_id_ = 0;
  clear_has_req_trans_id();
}
inline ::google::protobuf::int32 Proto_DispInfo::req_trans_id() const {
  return req_trans_id_;
}
inline void Proto_DispInfo::set_req_trans_id(::google::protobuf::int32 value) {
  set_has_req_trans_id();
  req_trans_id_ = value;
}

// optional int32 rsp_trans_id = 3;
inline bool Proto_DispInfo::has_rsp_trans_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_DispInfo::set_has_rsp_trans_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_DispInfo::clear_has_rsp_trans_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_DispInfo::clear_rsp_trans_id() {
  rsp_trans_id_ = 0;
  clear_has_rsp_trans_id();
}
inline ::google::protobuf::int32 Proto_DispInfo::rsp_trans_id() const {
  return rsp_trans_id_;
}
inline void Proto_DispInfo::set_rsp_trans_id(::google::protobuf::int32 value) {
  set_has_rsp_trans_id();
  rsp_trans_id_ = value;
}

// -------------------------------------------------------------------

// Proto_StoreInfo_CB

// optional .proto_ff.PacketDispType type = 1;
inline bool Proto_StoreInfo_CB::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_StoreInfo_CB::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_StoreInfo_CB::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_StoreInfo_CB::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::proto_ff::PacketDispType Proto_StoreInfo_CB::type() const {
  return static_cast< ::proto_ff::PacketDispType >(type_);
}
inline void Proto_StoreInfo_CB::set_type(::proto_ff::PacketDispType value) {
  assert(::proto_ff::PacketDispType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint64 id = 2;
inline bool Proto_StoreInfo_CB::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_StoreInfo_CB::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_StoreInfo_CB::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_StoreInfo_CB::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Proto_StoreInfo_CB::id() const {
  return id_;
}
inline void Proto_StoreInfo_CB::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional .proto_ff.TableID table_id = 3;
inline bool Proto_StoreInfo_CB::has_table_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_StoreInfo_CB::set_has_table_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_StoreInfo_CB::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_StoreInfo_CB::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::proto_ff::TableID Proto_StoreInfo_CB::table_id() const {
  return static_cast< ::proto_ff::TableID >(table_id_);
}
inline void Proto_StoreInfo_CB::set_table_id(::proto_ff::TableID value) {
  assert(::proto_ff::TableID_IsValid(value));
  set_has_table_id();
  table_id_ = value;
}

// optional uint32 seq = 4;
inline bool Proto_StoreInfo_CB::has_seq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Proto_StoreInfo_CB::set_has_seq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Proto_StoreInfo_CB::clear_has_seq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Proto_StoreInfo_CB::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 Proto_StoreInfo_CB::seq() const {
  return seq_;
}
inline void Proto_StoreInfo_CB::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
}

// -------------------------------------------------------------------

// Proto_StoreInfo

// optional .proto_ff.STORESVR_CS_COMMAND cmd = 1;
inline bool Proto_StoreInfo::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_StoreInfo::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_StoreInfo::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_StoreInfo::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::proto_ff::STORESVR_CS_COMMAND Proto_StoreInfo::cmd() const {
  return static_cast< ::proto_ff::STORESVR_CS_COMMAND >(cmd_);
}
inline void Proto_StoreInfo::set_cmd(::proto_ff::STORESVR_CS_COMMAND value) {
  assert(::proto_ff::STORESVR_CS_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional .proto_ff.STORESVR_ERRCODE err_code = 2;
inline bool Proto_StoreInfo::has_err_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_StoreInfo::set_has_err_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_StoreInfo::clear_has_err_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_StoreInfo::clear_err_code() {
  err_code_ = 0;
  clear_has_err_code();
}
inline ::proto_ff::STORESVR_ERRCODE Proto_StoreInfo::err_code() const {
  return static_cast< ::proto_ff::STORESVR_ERRCODE >(err_code_);
}
inline void Proto_StoreInfo::set_err_code(::proto_ff::STORESVR_ERRCODE value) {
  assert(::proto_ff::STORESVR_ERRCODE_IsValid(value));
  set_has_err_code();
  err_code_ = value;
}

// optional .proto_ff.Proto_StoreInfo_CB cb_data = 3;
inline bool Proto_StoreInfo::has_cb_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_StoreInfo::set_has_cb_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_StoreInfo::clear_has_cb_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_StoreInfo::clear_cb_data() {
  if (cb_data_ != NULL) cb_data_->::proto_ff::Proto_StoreInfo_CB::Clear();
  clear_has_cb_data();
}
inline const ::proto_ff::Proto_StoreInfo_CB& Proto_StoreInfo::cb_data() const {
  return cb_data_ != NULL ? *cb_data_ : *default_instance_->cb_data_;
}
inline ::proto_ff::Proto_StoreInfo_CB* Proto_StoreInfo::mutable_cb_data() {
  set_has_cb_data();
  if (cb_data_ == NULL) cb_data_ = new ::proto_ff::Proto_StoreInfo_CB;
  return cb_data_;
}
inline ::proto_ff::Proto_StoreInfo_CB* Proto_StoreInfo::release_cb_data() {
  clear_has_cb_data();
  ::proto_ff::Proto_StoreInfo_CB* temp = cb_data_;
  cb_data_ = NULL;
  return temp;
}
inline void Proto_StoreInfo::set_allocated_cb_data(::proto_ff::Proto_StoreInfo_CB* cb_data) {
  delete cb_data_;
  cb_data_ = cb_data;
  if (cb_data) {
    set_has_cb_data();
  } else {
    clear_has_cb_data();
  }
}

// -------------------------------------------------------------------

// Proto_SvrPkg

// optional int32 msg_id = 1;
inline bool Proto_SvrPkg::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_SvrPkg::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_SvrPkg::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_SvrPkg::clear_msg_id() {
  msg_id_ = 0;
  clear_has_msg_id();
}
inline ::google::protobuf::int32 Proto_SvrPkg::msg_id() const {
  return msg_id_;
}
inline void Proto_SvrPkg::set_msg_id(::google::protobuf::int32 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// optional bytes msg_data = 2;
inline bool Proto_SvrPkg::has_msg_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_SvrPkg::set_has_msg_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_SvrPkg::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_SvrPkg::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& Proto_SvrPkg::msg_data() const {
  return *msg_data_;
}
inline void Proto_SvrPkg::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void Proto_SvrPkg::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void Proto_SvrPkg::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Proto_SvrPkg::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  return msg_data_;
}
inline ::std::string* Proto_SvrPkg::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Proto_SvrPkg::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto_ff.Proto_DispInfo disp_info = 3;
inline bool Proto_SvrPkg::has_disp_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_SvrPkg::set_has_disp_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_SvrPkg::clear_has_disp_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_SvrPkg::clear_disp_info() {
  if (disp_info_ != NULL) disp_info_->::proto_ff::Proto_DispInfo::Clear();
  clear_has_disp_info();
}
inline const ::proto_ff::Proto_DispInfo& Proto_SvrPkg::disp_info() const {
  return disp_info_ != NULL ? *disp_info_ : *default_instance_->disp_info_;
}
inline ::proto_ff::Proto_DispInfo* Proto_SvrPkg::mutable_disp_info() {
  set_has_disp_info();
  if (disp_info_ == NULL) disp_info_ = new ::proto_ff::Proto_DispInfo;
  return disp_info_;
}
inline ::proto_ff::Proto_DispInfo* Proto_SvrPkg::release_disp_info() {
  clear_has_disp_info();
  ::proto_ff::Proto_DispInfo* temp = disp_info_;
  disp_info_ = NULL;
  return temp;
}
inline void Proto_SvrPkg::set_allocated_disp_info(::proto_ff::Proto_DispInfo* disp_info) {
  delete disp_info_;
  disp_info_ = disp_info;
  if (disp_info) {
    set_has_disp_info();
  } else {
    clear_has_disp_info();
  }
}

// optional .proto_ff.Proto_StoreInfo store_info = 4;
inline bool Proto_SvrPkg::has_store_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Proto_SvrPkg::set_has_store_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Proto_SvrPkg::clear_has_store_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Proto_SvrPkg::clear_store_info() {
  if (store_info_ != NULL) store_info_->::proto_ff::Proto_StoreInfo::Clear();
  clear_has_store_info();
}
inline const ::proto_ff::Proto_StoreInfo& Proto_SvrPkg::store_info() const {
  return store_info_ != NULL ? *store_info_ : *default_instance_->store_info_;
}
inline ::proto_ff::Proto_StoreInfo* Proto_SvrPkg::mutable_store_info() {
  set_has_store_info();
  if (store_info_ == NULL) store_info_ = new ::proto_ff::Proto_StoreInfo;
  return store_info_;
}
inline ::proto_ff::Proto_StoreInfo* Proto_SvrPkg::release_store_info() {
  clear_has_store_info();
  ::proto_ff::Proto_StoreInfo* temp = store_info_;
  store_info_ = NULL;
  return temp;
}
inline void Proto_SvrPkg::set_allocated_store_info(::proto_ff::Proto_StoreInfo* store_info) {
  delete store_info_;
  store_info_ = store_info;
  if (store_info) {
    set_has_store_info();
  } else {
    clear_has_store_info();
  }
}

// -------------------------------------------------------------------

// ServerInfoReport

// optional uint32 bus_id = 1;
inline bool ServerInfoReport::has_bus_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfoReport::set_has_bus_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfoReport::clear_has_bus_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfoReport::clear_bus_id() {
  bus_id_ = 0u;
  clear_has_bus_id();
}
inline ::google::protobuf::uint32 ServerInfoReport::bus_id() const {
  return bus_id_;
}
inline void ServerInfoReport::set_bus_id(::google::protobuf::uint32 value) {
  set_has_bus_id();
  bus_id_ = value;
}

// optional string bus_name = 2;
inline bool ServerInfoReport::has_bus_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerInfoReport::set_has_bus_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerInfoReport::clear_has_bus_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerInfoReport::clear_bus_name() {
  if (bus_name_ != &::google::protobuf::internal::kEmptyString) {
    bus_name_->clear();
  }
  clear_has_bus_name();
}
inline const ::std::string& ServerInfoReport::bus_name() const {
  return *bus_name_;
}
inline void ServerInfoReport::set_bus_name(const ::std::string& value) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(value);
}
inline void ServerInfoReport::set_bus_name(const char* value) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(value);
}
inline void ServerInfoReport::set_bus_name(const char* value, size_t size) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_bus_name() {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  return bus_name_;
}
inline ::std::string* ServerInfoReport::release_bus_name() {
  clear_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bus_name_;
    bus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_bus_name(::std::string* bus_name) {
  if (bus_name_ != &::google::protobuf::internal::kEmptyString) {
    delete bus_name_;
  }
  if (bus_name) {
    set_has_bus_name();
    bus_name_ = bus_name;
  } else {
    clear_has_bus_name();
    bus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 server_type = 3;
inline bool ServerInfoReport::has_server_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerInfoReport::set_has_server_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerInfoReport::clear_has_server_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerInfoReport::clear_server_type() {
  server_type_ = 0u;
  clear_has_server_type();
}
inline ::google::protobuf::uint32 ServerInfoReport::server_type() const {
  return server_type_;
}
inline void ServerInfoReport::set_server_type(::google::protobuf::uint32 value) {
  set_has_server_type();
  server_type_ = value;
}

// optional string server_name = 4;
inline bool ServerInfoReport::has_server_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerInfoReport::set_has_server_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerInfoReport::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerInfoReport::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& ServerInfoReport::server_name() const {
  return *server_name_;
}
inline void ServerInfoReport::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void ServerInfoReport::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void ServerInfoReport::set_server_name(const char* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  return server_name_;
}
inline ::std::string* ServerInfoReport::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string url = 5;
inline bool ServerInfoReport::has_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerInfoReport::set_has_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerInfoReport::clear_has_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerInfoReport::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ServerInfoReport::url() const {
  return *url_;
}
inline void ServerInfoReport::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ServerInfoReport::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ServerInfoReport::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ServerInfoReport::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string link_mode = 6;
inline bool ServerInfoReport::has_link_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerInfoReport::set_has_link_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerInfoReport::clear_has_link_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerInfoReport::clear_link_mode() {
  if (link_mode_ != &::google::protobuf::internal::kEmptyString) {
    link_mode_->clear();
  }
  clear_has_link_mode();
}
inline const ::std::string& ServerInfoReport::link_mode() const {
  return *link_mode_;
}
inline void ServerInfoReport::set_link_mode(const ::std::string& value) {
  set_has_link_mode();
  if (link_mode_ == &::google::protobuf::internal::kEmptyString) {
    link_mode_ = new ::std::string;
  }
  link_mode_->assign(value);
}
inline void ServerInfoReport::set_link_mode(const char* value) {
  set_has_link_mode();
  if (link_mode_ == &::google::protobuf::internal::kEmptyString) {
    link_mode_ = new ::std::string;
  }
  link_mode_->assign(value);
}
inline void ServerInfoReport::set_link_mode(const char* value, size_t size) {
  set_has_link_mode();
  if (link_mode_ == &::google::protobuf::internal::kEmptyString) {
    link_mode_ = new ::std::string;
  }
  link_mode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_link_mode() {
  set_has_link_mode();
  if (link_mode_ == &::google::protobuf::internal::kEmptyString) {
    link_mode_ = new ::std::string;
  }
  return link_mode_;
}
inline ::std::string* ServerInfoReport::release_link_mode() {
  clear_has_link_mode();
  if (link_mode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = link_mode_;
    link_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_link_mode(::std::string* link_mode) {
  if (link_mode_ != &::google::protobuf::internal::kEmptyString) {
    delete link_mode_;
  }
  if (link_mode) {
    set_has_link_mode();
    link_mode_ = link_mode;
  } else {
    clear_has_link_mode();
    link_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 bus_length = 7;
inline bool ServerInfoReport::has_bus_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServerInfoReport::set_has_bus_length() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServerInfoReport::clear_has_bus_length() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServerInfoReport::clear_bus_length() {
  bus_length_ = 0u;
  clear_has_bus_length();
}
inline ::google::protobuf::uint32 ServerInfoReport::bus_length() const {
  return bus_length_;
}
inline void ServerInfoReport::set_bus_length(::google::protobuf::uint32 value) {
  set_has_bus_length();
  bus_length_ = value;
}

// optional string server_ip = 9;
inline bool ServerInfoReport::has_server_ip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServerInfoReport::set_has_server_ip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServerInfoReport::clear_has_server_ip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServerInfoReport::clear_server_ip() {
  if (server_ip_ != &::google::protobuf::internal::kEmptyString) {
    server_ip_->clear();
  }
  clear_has_server_ip();
}
inline const ::std::string& ServerInfoReport::server_ip() const {
  return *server_ip_;
}
inline void ServerInfoReport::set_server_ip(const ::std::string& value) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(value);
}
inline void ServerInfoReport::set_server_ip(const char* value) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(value);
}
inline void ServerInfoReport::set_server_ip(const char* value, size_t size) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_server_ip() {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    server_ip_ = new ::std::string;
  }
  return server_ip_;
}
inline ::std::string* ServerInfoReport::release_server_ip() {
  clear_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_ip_;
    server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_server_ip(::std::string* server_ip) {
  if (server_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete server_ip_;
  }
  if (server_ip) {
    set_has_server_ip();
    server_ip_ = server_ip;
  } else {
    clear_has_server_ip();
    server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 server_port = 10;
inline bool ServerInfoReport::has_server_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServerInfoReport::set_has_server_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServerInfoReport::clear_has_server_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServerInfoReport::clear_server_port() {
  server_port_ = 0u;
  clear_has_server_port();
}
inline ::google::protobuf::uint32 ServerInfoReport::server_port() const {
  return server_port_;
}
inline void ServerInfoReport::set_server_port(::google::protobuf::uint32 value) {
  set_has_server_port();
  server_port_ = value;
}

// optional uint32 server_http_port = 11;
inline bool ServerInfoReport::has_server_http_port() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ServerInfoReport::set_has_server_http_port() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ServerInfoReport::clear_has_server_http_port() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ServerInfoReport::clear_server_http_port() {
  server_http_port_ = 0u;
  clear_has_server_http_port();
}
inline ::google::protobuf::uint32 ServerInfoReport::server_http_port() const {
  return server_http_port_;
}
inline void ServerInfoReport::set_server_http_port(::google::protobuf::uint32 value) {
  set_has_server_http_port();
  server_http_port_ = value;
}

// optional string external_server_ip = 12;
inline bool ServerInfoReport::has_external_server_ip() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ServerInfoReport::set_has_external_server_ip() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ServerInfoReport::clear_has_external_server_ip() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ServerInfoReport::clear_external_server_ip() {
  if (external_server_ip_ != &::google::protobuf::internal::kEmptyString) {
    external_server_ip_->clear();
  }
  clear_has_external_server_ip();
}
inline const ::std::string& ServerInfoReport::external_server_ip() const {
  return *external_server_ip_;
}
inline void ServerInfoReport::set_external_server_ip(const ::std::string& value) {
  set_has_external_server_ip();
  if (external_server_ip_ == &::google::protobuf::internal::kEmptyString) {
    external_server_ip_ = new ::std::string;
  }
  external_server_ip_->assign(value);
}
inline void ServerInfoReport::set_external_server_ip(const char* value) {
  set_has_external_server_ip();
  if (external_server_ip_ == &::google::protobuf::internal::kEmptyString) {
    external_server_ip_ = new ::std::string;
  }
  external_server_ip_->assign(value);
}
inline void ServerInfoReport::set_external_server_ip(const char* value, size_t size) {
  set_has_external_server_ip();
  if (external_server_ip_ == &::google::protobuf::internal::kEmptyString) {
    external_server_ip_ = new ::std::string;
  }
  external_server_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_external_server_ip() {
  set_has_external_server_ip();
  if (external_server_ip_ == &::google::protobuf::internal::kEmptyString) {
    external_server_ip_ = new ::std::string;
  }
  return external_server_ip_;
}
inline ::std::string* ServerInfoReport::release_external_server_ip() {
  clear_has_external_server_ip();
  if (external_server_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = external_server_ip_;
    external_server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_external_server_ip(::std::string* external_server_ip) {
  if (external_server_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete external_server_ip_;
  }
  if (external_server_ip) {
    set_has_external_server_ip();
    external_server_ip_ = external_server_ip;
  } else {
    clear_has_external_server_ip();
    external_server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 external_server_port = 13;
inline bool ServerInfoReport::has_external_server_port() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ServerInfoReport::set_has_external_server_port() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ServerInfoReport::clear_has_external_server_port() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ServerInfoReport::clear_external_server_port() {
  external_server_port_ = 0u;
  clear_has_external_server_port();
}
inline ::google::protobuf::uint32 ServerInfoReport::external_server_port() const {
  return external_server_port_;
}
inline void ServerInfoReport::set_external_server_port(::google::protobuf::uint32 value) {
  set_has_external_server_port();
  external_server_port_ = value;
}

// optional string route_svr = 15;
inline bool ServerInfoReport::has_route_svr() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ServerInfoReport::set_has_route_svr() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ServerInfoReport::clear_has_route_svr() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ServerInfoReport::clear_route_svr() {
  if (route_svr_ != &::google::protobuf::internal::kEmptyString) {
    route_svr_->clear();
  }
  clear_has_route_svr();
}
inline const ::std::string& ServerInfoReport::route_svr() const {
  return *route_svr_;
}
inline void ServerInfoReport::set_route_svr(const ::std::string& value) {
  set_has_route_svr();
  if (route_svr_ == &::google::protobuf::internal::kEmptyString) {
    route_svr_ = new ::std::string;
  }
  route_svr_->assign(value);
}
inline void ServerInfoReport::set_route_svr(const char* value) {
  set_has_route_svr();
  if (route_svr_ == &::google::protobuf::internal::kEmptyString) {
    route_svr_ = new ::std::string;
  }
  route_svr_->assign(value);
}
inline void ServerInfoReport::set_route_svr(const char* value, size_t size) {
  set_has_route_svr();
  if (route_svr_ == &::google::protobuf::internal::kEmptyString) {
    route_svr_ = new ::std::string;
  }
  route_svr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_route_svr() {
  set_has_route_svr();
  if (route_svr_ == &::google::protobuf::internal::kEmptyString) {
    route_svr_ = new ::std::string;
  }
  return route_svr_;
}
inline ::std::string* ServerInfoReport::release_route_svr() {
  clear_has_route_svr();
  if (route_svr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = route_svr_;
    route_svr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_route_svr(::std::string* route_svr) {
  if (route_svr_ != &::google::protobuf::internal::kEmptyString) {
    delete route_svr_;
  }
  if (route_svr) {
    set_has_route_svr();
    route_svr_ = route_svr;
  } else {
    clear_has_route_svr();
    route_svr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 server_max_online = 30;
inline bool ServerInfoReport::has_server_max_online() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ServerInfoReport::set_has_server_max_online() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ServerInfoReport::clear_has_server_max_online() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ServerInfoReport::clear_server_max_online() {
  server_max_online_ = 0u;
  clear_has_server_max_online();
}
inline ::google::protobuf::uint32 ServerInfoReport::server_max_online() const {
  return server_max_online_;
}
inline void ServerInfoReport::set_server_max_online(::google::protobuf::uint32 value) {
  set_has_server_max_online();
  server_max_online_ = value;
}

// optional uint32 server_cur_online = 31;
inline bool ServerInfoReport::has_server_cur_online() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ServerInfoReport::set_has_server_cur_online() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ServerInfoReport::clear_has_server_cur_online() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ServerInfoReport::clear_server_cur_online() {
  server_cur_online_ = 0u;
  clear_has_server_cur_online();
}
inline ::google::protobuf::uint32 ServerInfoReport::server_cur_online() const {
  return server_cur_online_;
}
inline void ServerInfoReport::set_server_cur_online(::google::protobuf::uint32 value) {
  set_has_server_cur_online();
  server_cur_online_ = value;
}

// optional uint32 server_state = 32;
inline bool ServerInfoReport::has_server_state() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ServerInfoReport::set_has_server_state() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ServerInfoReport::clear_has_server_state() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ServerInfoReport::clear_server_state() {
  server_state_ = 0u;
  clear_has_server_state();
}
inline ::google::protobuf::uint32 ServerInfoReport::server_state() const {
  return server_state_;
}
inline void ServerInfoReport::set_server_state(::google::protobuf::uint32 value) {
  set_has_server_state();
  server_state_ = value;
}

// optional string system_info = 33;
inline bool ServerInfoReport::has_system_info() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ServerInfoReport::set_has_system_info() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ServerInfoReport::clear_has_system_info() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ServerInfoReport::clear_system_info() {
  if (system_info_ != &::google::protobuf::internal::kEmptyString) {
    system_info_->clear();
  }
  clear_has_system_info();
}
inline const ::std::string& ServerInfoReport::system_info() const {
  return *system_info_;
}
inline void ServerInfoReport::set_system_info(const ::std::string& value) {
  set_has_system_info();
  if (system_info_ == &::google::protobuf::internal::kEmptyString) {
    system_info_ = new ::std::string;
  }
  system_info_->assign(value);
}
inline void ServerInfoReport::set_system_info(const char* value) {
  set_has_system_info();
  if (system_info_ == &::google::protobuf::internal::kEmptyString) {
    system_info_ = new ::std::string;
  }
  system_info_->assign(value);
}
inline void ServerInfoReport::set_system_info(const char* value, size_t size) {
  set_has_system_info();
  if (system_info_ == &::google::protobuf::internal::kEmptyString) {
    system_info_ = new ::std::string;
  }
  system_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_system_info() {
  set_has_system_info();
  if (system_info_ == &::google::protobuf::internal::kEmptyString) {
    system_info_ = new ::std::string;
  }
  return system_info_;
}
inline ::std::string* ServerInfoReport::release_system_info() {
  clear_has_system_info();
  if (system_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = system_info_;
    system_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_system_info(::std::string* system_info) {
  if (system_info_ != &::google::protobuf::internal::kEmptyString) {
    delete system_info_;
  }
  if (system_info) {
    set_has_system_info();
    system_info_ = system_info;
  } else {
    clear_has_system_info();
    system_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 total_mem = 34;
inline bool ServerInfoReport::has_total_mem() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ServerInfoReport::set_has_total_mem() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ServerInfoReport::clear_has_total_mem() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ServerInfoReport::clear_total_mem() {
  total_mem_ = GOOGLE_ULONGLONG(0);
  clear_has_total_mem();
}
inline ::google::protobuf::uint64 ServerInfoReport::total_mem() const {
  return total_mem_;
}
inline void ServerInfoReport::set_total_mem(::google::protobuf::uint64 value) {
  set_has_total_mem();
  total_mem_ = value;
}

// optional uint64 free_mem = 35;
inline bool ServerInfoReport::has_free_mem() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ServerInfoReport::set_has_free_mem() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ServerInfoReport::clear_has_free_mem() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ServerInfoReport::clear_free_mem() {
  free_mem_ = GOOGLE_ULONGLONG(0);
  clear_has_free_mem();
}
inline ::google::protobuf::uint64 ServerInfoReport::free_mem() const {
  return free_mem_;
}
inline void ServerInfoReport::set_free_mem(::google::protobuf::uint64 value) {
  set_has_free_mem();
  free_mem_ = value;
}

// optional uint64 used_mem = 36;
inline bool ServerInfoReport::has_used_mem() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ServerInfoReport::set_has_used_mem() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ServerInfoReport::clear_has_used_mem() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ServerInfoReport::clear_used_mem() {
  used_mem_ = GOOGLE_ULONGLONG(0);
  clear_has_used_mem();
}
inline ::google::protobuf::uint64 ServerInfoReport::used_mem() const {
  return used_mem_;
}
inline void ServerInfoReport::set_used_mem(::google::protobuf::uint64 value) {
  set_has_used_mem();
  used_mem_ = value;
}

// optional double proc_cpu = 37;
inline bool ServerInfoReport::has_proc_cpu() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ServerInfoReport::set_has_proc_cpu() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ServerInfoReport::clear_has_proc_cpu() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ServerInfoReport::clear_proc_cpu() {
  proc_cpu_ = 0;
  clear_has_proc_cpu();
}
inline double ServerInfoReport::proc_cpu() const {
  return proc_cpu_;
}
inline void ServerInfoReport::set_proc_cpu(double value) {
  set_has_proc_cpu();
  proc_cpu_ = value;
}

// optional uint64 proc_mem = 38;
inline bool ServerInfoReport::has_proc_mem() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ServerInfoReport::set_has_proc_mem() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ServerInfoReport::clear_has_proc_mem() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ServerInfoReport::clear_proc_mem() {
  proc_mem_ = GOOGLE_ULONGLONG(0);
  clear_has_proc_mem();
}
inline ::google::protobuf::uint64 ServerInfoReport::proc_mem() const {
  return proc_mem_;
}
inline void ServerInfoReport::set_proc_mem(::google::protobuf::uint64 value) {
  set_has_proc_mem();
  proc_mem_ = value;
}

// optional uint32 proc_thread = 39;
inline bool ServerInfoReport::has_proc_thread() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ServerInfoReport::set_has_proc_thread() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ServerInfoReport::clear_has_proc_thread() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ServerInfoReport::clear_proc_thread() {
  proc_thread_ = 0u;
  clear_has_proc_thread();
}
inline ::google::protobuf::uint32 ServerInfoReport::proc_thread() const {
  return proc_thread_;
}
inline void ServerInfoReport::set_proc_thread(::google::protobuf::uint32 value) {
  set_has_proc_thread();
  proc_thread_ = value;
}

// optional string proc_name = 40;
inline bool ServerInfoReport::has_proc_name() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ServerInfoReport::set_has_proc_name() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ServerInfoReport::clear_has_proc_name() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ServerInfoReport::clear_proc_name() {
  if (proc_name_ != &::google::protobuf::internal::kEmptyString) {
    proc_name_->clear();
  }
  clear_has_proc_name();
}
inline const ::std::string& ServerInfoReport::proc_name() const {
  return *proc_name_;
}
inline void ServerInfoReport::set_proc_name(const ::std::string& value) {
  set_has_proc_name();
  if (proc_name_ == &::google::protobuf::internal::kEmptyString) {
    proc_name_ = new ::std::string;
  }
  proc_name_->assign(value);
}
inline void ServerInfoReport::set_proc_name(const char* value) {
  set_has_proc_name();
  if (proc_name_ == &::google::protobuf::internal::kEmptyString) {
    proc_name_ = new ::std::string;
  }
  proc_name_->assign(value);
}
inline void ServerInfoReport::set_proc_name(const char* value, size_t size) {
  set_has_proc_name();
  if (proc_name_ == &::google::protobuf::internal::kEmptyString) {
    proc_name_ = new ::std::string;
  }
  proc_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_proc_name() {
  set_has_proc_name();
  if (proc_name_ == &::google::protobuf::internal::kEmptyString) {
    proc_name_ = new ::std::string;
  }
  return proc_name_;
}
inline ::std::string* ServerInfoReport::release_proc_name() {
  clear_has_proc_name();
  if (proc_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proc_name_;
    proc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_proc_name(::std::string* proc_name) {
  if (proc_name_ != &::google::protobuf::internal::kEmptyString) {
    delete proc_name_;
  }
  if (proc_name) {
    set_has_proc_name();
    proc_name_ = proc_name;
  } else {
    clear_has_proc_name();
    proc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string proc_cwd = 41;
inline bool ServerInfoReport::has_proc_cwd() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ServerInfoReport::set_has_proc_cwd() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ServerInfoReport::clear_has_proc_cwd() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ServerInfoReport::clear_proc_cwd() {
  if (proc_cwd_ != &::google::protobuf::internal::kEmptyString) {
    proc_cwd_->clear();
  }
  clear_has_proc_cwd();
}
inline const ::std::string& ServerInfoReport::proc_cwd() const {
  return *proc_cwd_;
}
inline void ServerInfoReport::set_proc_cwd(const ::std::string& value) {
  set_has_proc_cwd();
  if (proc_cwd_ == &::google::protobuf::internal::kEmptyString) {
    proc_cwd_ = new ::std::string;
  }
  proc_cwd_->assign(value);
}
inline void ServerInfoReport::set_proc_cwd(const char* value) {
  set_has_proc_cwd();
  if (proc_cwd_ == &::google::protobuf::internal::kEmptyString) {
    proc_cwd_ = new ::std::string;
  }
  proc_cwd_->assign(value);
}
inline void ServerInfoReport::set_proc_cwd(const char* value, size_t size) {
  set_has_proc_cwd();
  if (proc_cwd_ == &::google::protobuf::internal::kEmptyString) {
    proc_cwd_ = new ::std::string;
  }
  proc_cwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_proc_cwd() {
  set_has_proc_cwd();
  if (proc_cwd_ == &::google::protobuf::internal::kEmptyString) {
    proc_cwd_ = new ::std::string;
  }
  return proc_cwd_;
}
inline ::std::string* ServerInfoReport::release_proc_cwd() {
  clear_has_proc_cwd();
  if (proc_cwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proc_cwd_;
    proc_cwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_proc_cwd(::std::string* proc_cwd) {
  if (proc_cwd_ != &::google::protobuf::internal::kEmptyString) {
    delete proc_cwd_;
  }
  if (proc_cwd) {
    set_has_proc_cwd();
    proc_cwd_ = proc_cwd;
  } else {
    clear_has_proc_cwd();
    proc_cwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 proc_pid = 42;
inline bool ServerInfoReport::has_proc_pid() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ServerInfoReport::set_has_proc_pid() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ServerInfoReport::clear_has_proc_pid() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ServerInfoReport::clear_proc_pid() {
  proc_pid_ = 0u;
  clear_has_proc_pid();
}
inline ::google::protobuf::uint32 ServerInfoReport::proc_pid() const {
  return proc_pid_;
}
inline void ServerInfoReport::set_proc_pid(::google::protobuf::uint32 value) {
  set_has_proc_pid();
  proc_pid_ = value;
}

// optional string last_date = 43;
inline bool ServerInfoReport::has_last_date() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ServerInfoReport::set_has_last_date() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ServerInfoReport::clear_has_last_date() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ServerInfoReport::clear_last_date() {
  if (last_date_ != &::google::protobuf::internal::kEmptyString) {
    last_date_->clear();
  }
  clear_has_last_date();
}
inline const ::std::string& ServerInfoReport::last_date() const {
  return *last_date_;
}
inline void ServerInfoReport::set_last_date(const ::std::string& value) {
  set_has_last_date();
  if (last_date_ == &::google::protobuf::internal::kEmptyString) {
    last_date_ = new ::std::string;
  }
  last_date_->assign(value);
}
inline void ServerInfoReport::set_last_date(const char* value) {
  set_has_last_date();
  if (last_date_ == &::google::protobuf::internal::kEmptyString) {
    last_date_ = new ::std::string;
  }
  last_date_->assign(value);
}
inline void ServerInfoReport::set_last_date(const char* value, size_t size) {
  set_has_last_date();
  if (last_date_ == &::google::protobuf::internal::kEmptyString) {
    last_date_ = new ::std::string;
  }
  last_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_last_date() {
  set_has_last_date();
  if (last_date_ == &::google::protobuf::internal::kEmptyString) {
    last_date_ = new ::std::string;
  }
  return last_date_;
}
inline ::std::string* ServerInfoReport::release_last_date() {
  clear_has_last_date();
  if (last_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_date_;
    last_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_last_date(::std::string* last_date) {
  if (last_date_ != &::google::protobuf::internal::kEmptyString) {
    delete last_date_;
  }
  if (last_date) {
    set_has_last_date();
    last_date_ = last_date;
  } else {
    clear_has_last_date();
    last_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 last_time = 44;
inline bool ServerInfoReport::has_last_time() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ServerInfoReport::set_has_last_time() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ServerInfoReport::clear_has_last_time() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ServerInfoReport::clear_last_time() {
  last_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_time();
}
inline ::google::protobuf::uint64 ServerInfoReport::last_time() const {
  return last_time_;
}
inline void ServerInfoReport::set_last_time(::google::protobuf::uint64 value) {
  set_has_last_time();
  last_time_ = value;
}

// optional string contract_info = 45;
inline bool ServerInfoReport::has_contract_info() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ServerInfoReport::set_has_contract_info() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ServerInfoReport::clear_has_contract_info() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ServerInfoReport::clear_contract_info() {
  if (contract_info_ != &::google::protobuf::internal::kEmptyString) {
    contract_info_->clear();
  }
  clear_has_contract_info();
}
inline const ::std::string& ServerInfoReport::contract_info() const {
  return *contract_info_;
}
inline void ServerInfoReport::set_contract_info(const ::std::string& value) {
  set_has_contract_info();
  if (contract_info_ == &::google::protobuf::internal::kEmptyString) {
    contract_info_ = new ::std::string;
  }
  contract_info_->assign(value);
}
inline void ServerInfoReport::set_contract_info(const char* value) {
  set_has_contract_info();
  if (contract_info_ == &::google::protobuf::internal::kEmptyString) {
    contract_info_ = new ::std::string;
  }
  contract_info_->assign(value);
}
inline void ServerInfoReport::set_contract_info(const char* value, size_t size) {
  set_has_contract_info();
  if (contract_info_ == &::google::protobuf::internal::kEmptyString) {
    contract_info_ = new ::std::string;
  }
  contract_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_contract_info() {
  set_has_contract_info();
  if (contract_info_ == &::google::protobuf::internal::kEmptyString) {
    contract_info_ = new ::std::string;
  }
  return contract_info_;
}
inline ::std::string* ServerInfoReport::release_contract_info() {
  clear_has_contract_info();
  if (contract_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contract_info_;
    contract_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_contract_info(::std::string* contract_info) {
  if (contract_info_ != &::google::protobuf::internal::kEmptyString) {
    delete contract_info_;
  }
  if (contract_info) {
    set_has_contract_info();
    contract_info_ = contract_info;
  } else {
    clear_has_contract_info();
    contract_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string machine_addr = 46;
inline bool ServerInfoReport::has_machine_addr() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ServerInfoReport::set_has_machine_addr() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ServerInfoReport::clear_has_machine_addr() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ServerInfoReport::clear_machine_addr() {
  if (machine_addr_ != &::google::protobuf::internal::kEmptyString) {
    machine_addr_->clear();
  }
  clear_has_machine_addr();
}
inline const ::std::string& ServerInfoReport::machine_addr() const {
  return *machine_addr_;
}
inline void ServerInfoReport::set_machine_addr(const ::std::string& value) {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  machine_addr_->assign(value);
}
inline void ServerInfoReport::set_machine_addr(const char* value) {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  machine_addr_->assign(value);
}
inline void ServerInfoReport::set_machine_addr(const char* value, size_t size) {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  machine_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::mutable_machine_addr() {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  return machine_addr_;
}
inline ::std::string* ServerInfoReport::release_machine_addr() {
  clear_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_addr_;
    machine_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoReport::set_allocated_machine_addr(::std::string* machine_addr) {
  if (machine_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_addr_;
  }
  if (machine_addr) {
    set_has_machine_addr();
    machine_addr_ = machine_addr;
  } else {
    clear_has_machine_addr();
    machine_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string db_name_list = 47;
inline int ServerInfoReport::db_name_list_size() const {
  return db_name_list_.size();
}
inline void ServerInfoReport::clear_db_name_list() {
  db_name_list_.Clear();
}
inline const ::std::string& ServerInfoReport::db_name_list(int index) const {
  return db_name_list_.Get(index);
}
inline ::std::string* ServerInfoReport::mutable_db_name_list(int index) {
  return db_name_list_.Mutable(index);
}
inline void ServerInfoReport::set_db_name_list(int index, const ::std::string& value) {
  db_name_list_.Mutable(index)->assign(value);
}
inline void ServerInfoReport::set_db_name_list(int index, const char* value) {
  db_name_list_.Mutable(index)->assign(value);
}
inline void ServerInfoReport::set_db_name_list(int index, const char* value, size_t size) {
  db_name_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoReport::add_db_name_list() {
  return db_name_list_.Add();
}
inline void ServerInfoReport::add_db_name_list(const ::std::string& value) {
  db_name_list_.Add()->assign(value);
}
inline void ServerInfoReport::add_db_name_list(const char* value) {
  db_name_list_.Add()->assign(value);
}
inline void ServerInfoReport::add_db_name_list(const char* value, size_t size) {
  db_name_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerInfoReport::db_name_list() const {
  return db_name_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerInfoReport::mutable_db_name_list() {
  return &db_name_list_;
}

// -------------------------------------------------------------------

// ServerInfoReportList

// repeated .proto_ff.ServerInfoReport server_list = 1;
inline int ServerInfoReportList::server_list_size() const {
  return server_list_.size();
}
inline void ServerInfoReportList::clear_server_list() {
  server_list_.Clear();
}
inline const ::proto_ff::ServerInfoReport& ServerInfoReportList::server_list(int index) const {
  return server_list_.Get(index);
}
inline ::proto_ff::ServerInfoReport* ServerInfoReportList::mutable_server_list(int index) {
  return server_list_.Mutable(index);
}
inline ::proto_ff::ServerInfoReport* ServerInfoReportList::add_server_list() {
  return server_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ServerInfoReport >&
ServerInfoReportList::server_list() const {
  return server_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ServerInfoReport >*
ServerInfoReportList::mutable_server_list() {
  return &server_list_;
}

// -------------------------------------------------------------------

// ZkServerInfo

// optional string bus_url = 1;
inline bool ZkServerInfo::has_bus_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZkServerInfo::set_has_bus_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZkServerInfo::clear_has_bus_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZkServerInfo::clear_bus_url() {
  if (bus_url_ != &::google::protobuf::internal::kEmptyString) {
    bus_url_->clear();
  }
  clear_has_bus_url();
}
inline const ::std::string& ZkServerInfo::bus_url() const {
  return *bus_url_;
}
inline void ZkServerInfo::set_bus_url(const ::std::string& value) {
  set_has_bus_url();
  if (bus_url_ == &::google::protobuf::internal::kEmptyString) {
    bus_url_ = new ::std::string;
  }
  bus_url_->assign(value);
}
inline void ZkServerInfo::set_bus_url(const char* value) {
  set_has_bus_url();
  if (bus_url_ == &::google::protobuf::internal::kEmptyString) {
    bus_url_ = new ::std::string;
  }
  bus_url_->assign(value);
}
inline void ZkServerInfo::set_bus_url(const char* value, size_t size) {
  set_has_bus_url();
  if (bus_url_ == &::google::protobuf::internal::kEmptyString) {
    bus_url_ = new ::std::string;
  }
  bus_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZkServerInfo::mutable_bus_url() {
  set_has_bus_url();
  if (bus_url_ == &::google::protobuf::internal::kEmptyString) {
    bus_url_ = new ::std::string;
  }
  return bus_url_;
}
inline ::std::string* ZkServerInfo::release_bus_url() {
  clear_has_bus_url();
  if (bus_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bus_url_;
    bus_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZkServerInfo::set_allocated_bus_url(::std::string* bus_url) {
  if (bus_url_ != &::google::protobuf::internal::kEmptyString) {
    delete bus_url_;
  }
  if (bus_url) {
    set_has_bus_url();
    bus_url_ = bus_url;
  } else {
    clear_has_bus_url();
    bus_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tcp_url = 2;
inline bool ZkServerInfo::has_tcp_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZkServerInfo::set_has_tcp_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZkServerInfo::clear_has_tcp_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZkServerInfo::clear_tcp_url() {
  if (tcp_url_ != &::google::protobuf::internal::kEmptyString) {
    tcp_url_->clear();
  }
  clear_has_tcp_url();
}
inline const ::std::string& ZkServerInfo::tcp_url() const {
  return *tcp_url_;
}
inline void ZkServerInfo::set_tcp_url(const ::std::string& value) {
  set_has_tcp_url();
  if (tcp_url_ == &::google::protobuf::internal::kEmptyString) {
    tcp_url_ = new ::std::string;
  }
  tcp_url_->assign(value);
}
inline void ZkServerInfo::set_tcp_url(const char* value) {
  set_has_tcp_url();
  if (tcp_url_ == &::google::protobuf::internal::kEmptyString) {
    tcp_url_ = new ::std::string;
  }
  tcp_url_->assign(value);
}
inline void ZkServerInfo::set_tcp_url(const char* value, size_t size) {
  set_has_tcp_url();
  if (tcp_url_ == &::google::protobuf::internal::kEmptyString) {
    tcp_url_ = new ::std::string;
  }
  tcp_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZkServerInfo::mutable_tcp_url() {
  set_has_tcp_url();
  if (tcp_url_ == &::google::protobuf::internal::kEmptyString) {
    tcp_url_ = new ::std::string;
  }
  return tcp_url_;
}
inline ::std::string* ZkServerInfo::release_tcp_url() {
  clear_has_tcp_url();
  if (tcp_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tcp_url_;
    tcp_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZkServerInfo::set_allocated_tcp_url(::std::string* tcp_url) {
  if (tcp_url_ != &::google::protobuf::internal::kEmptyString) {
    delete tcp_url_;
  }
  if (tcp_url) {
    set_has_tcp_url();
    tcp_url_ = tcp_url;
  } else {
    clear_has_tcp_url();
    tcp_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DynLibFileInfo

// optional string file_md5 = 1;
inline bool DynLibFileInfo::has_file_md5() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DynLibFileInfo::set_has_file_md5() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DynLibFileInfo::clear_has_file_md5() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DynLibFileInfo::clear_file_md5() {
  if (file_md5_ != &::google::protobuf::internal::kEmptyString) {
    file_md5_->clear();
  }
  clear_has_file_md5();
}
inline const ::std::string& DynLibFileInfo::file_md5() const {
  return *file_md5_;
}
inline void DynLibFileInfo::set_file_md5(const ::std::string& value) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(value);
}
inline void DynLibFileInfo::set_file_md5(const char* value) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(value);
}
inline void DynLibFileInfo::set_file_md5(const char* value, size_t size) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DynLibFileInfo::mutable_file_md5() {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  return file_md5_;
}
inline ::std::string* DynLibFileInfo::release_file_md5() {
  clear_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_md5_;
    file_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DynLibFileInfo::set_allocated_file_md5(::std::string* file_md5) {
  if (file_md5_ != &::google::protobuf::internal::kEmptyString) {
    delete file_md5_;
  }
  if (file_md5) {
    set_has_file_md5();
    file_md5_ = file_md5;
  } else {
    clear_has_file_md5();
    file_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 file_size = 2;
inline bool DynLibFileInfo::has_file_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DynLibFileInfo::set_has_file_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DynLibFileInfo::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DynLibFileInfo::clear_file_size() {
  file_size_ = 0;
  clear_has_file_size();
}
inline ::google::protobuf::int32 DynLibFileInfo::file_size() const {
  return file_size_;
}
inline void DynLibFileInfo::set_file_size(::google::protobuf::int32 value) {
  set_has_file_size();
  file_size_ = value;
}

// -------------------------------------------------------------------

// DynLibFileInfoArray

// repeated .proto_ff.DynLibFileInfo file_list = 1;
inline int DynLibFileInfoArray::file_list_size() const {
  return file_list_.size();
}
inline void DynLibFileInfoArray::clear_file_list() {
  file_list_.Clear();
}
inline const ::proto_ff::DynLibFileInfo& DynLibFileInfoArray::file_list(int index) const {
  return file_list_.Get(index);
}
inline ::proto_ff::DynLibFileInfo* DynLibFileInfoArray::mutable_file_list(int index) {
  return file_list_.Mutable(index);
}
inline ::proto_ff::DynLibFileInfo* DynLibFileInfoArray::add_file_list() {
  return file_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::DynLibFileInfo >&
DynLibFileInfoArray::file_list() const {
  return file_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::DynLibFileInfo >*
DynLibFileInfoArray::mutable_file_list() {
  return &file_list_;
}

// -------------------------------------------------------------------

// Proto_KillAllServerNtf

// -------------------------------------------------------------------

// Proto_KillAllServerRsp

// optional int32 result = 1;
inline bool Proto_KillAllServerRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_KillAllServerRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_KillAllServerRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_KillAllServerRsp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 Proto_KillAllServerRsp::result() const {
  return result_;
}
inline void Proto_KillAllServerRsp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// Proto_STSBroadPlayerMsgNotify

// repeated uint64 user_id = 1;
inline int Proto_STSBroadPlayerMsgNotify::user_id_size() const {
  return user_id_.size();
}
inline void Proto_STSBroadPlayerMsgNotify::clear_user_id() {
  user_id_.Clear();
}
inline ::google::protobuf::uint64 Proto_STSBroadPlayerMsgNotify::user_id(int index) const {
  return user_id_.Get(index);
}
inline void Proto_STSBroadPlayerMsgNotify::set_user_id(int index, ::google::protobuf::uint64 value) {
  user_id_.Set(index, value);
}
inline void Proto_STSBroadPlayerMsgNotify::add_user_id(::google::protobuf::uint64 value) {
  user_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Proto_STSBroadPlayerMsgNotify::user_id() const {
  return user_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Proto_STSBroadPlayerMsgNotify::mutable_user_id() {
  return &user_id_;
}

// optional uint32 msg_id = 2;
inline bool Proto_STSBroadPlayerMsgNotify::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_STSBroadPlayerMsgNotify::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_STSBroadPlayerMsgNotify::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_STSBroadPlayerMsgNotify::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 Proto_STSBroadPlayerMsgNotify::msg_id() const {
  return msg_id_;
}
inline void Proto_STSBroadPlayerMsgNotify::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// optional bytes msg_data = 3;
inline bool Proto_STSBroadPlayerMsgNotify::has_msg_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_STSBroadPlayerMsgNotify::set_has_msg_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_STSBroadPlayerMsgNotify::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_STSBroadPlayerMsgNotify::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& Proto_STSBroadPlayerMsgNotify::msg_data() const {
  return *msg_data_;
}
inline void Proto_STSBroadPlayerMsgNotify::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void Proto_STSBroadPlayerMsgNotify::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void Proto_STSBroadPlayerMsgNotify::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Proto_STSBroadPlayerMsgNotify::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  return msg_data_;
}
inline ::std::string* Proto_STSBroadPlayerMsgNotify::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Proto_STSBroadPlayerMsgNotify::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Proto_STWebMsgRspNotify

// optional uint64 request_id = 1;
inline bool Proto_STWebMsgRspNotify::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_STWebMsgRspNotify::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_STWebMsgRspNotify::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_STWebMsgRspNotify::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 Proto_STWebMsgRspNotify::request_id() const {
  return request_id_;
}
inline void Proto_STWebMsgRspNotify::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
}

// optional int32 result = 2;
inline bool Proto_STWebMsgRspNotify::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proto_STWebMsgRspNotify::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proto_STWebMsgRspNotify::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proto_STWebMsgRspNotify::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 Proto_STWebMsgRspNotify::result() const {
  return result_;
}
inline void Proto_STWebMsgRspNotify::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string err_msg = 3;
inline bool Proto_STWebMsgRspNotify::has_err_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proto_STWebMsgRspNotify::set_has_err_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proto_STWebMsgRspNotify::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proto_STWebMsgRspNotify::clear_err_msg() {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    err_msg_->clear();
  }
  clear_has_err_msg();
}
inline const ::std::string& Proto_STWebMsgRspNotify::err_msg() const {
  return *err_msg_;
}
inline void Proto_STWebMsgRspNotify::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void Proto_STWebMsgRspNotify::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void Proto_STWebMsgRspNotify::set_err_msg(const char* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Proto_STWebMsgRspNotify::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  return err_msg_;
}
inline ::std::string* Proto_STWebMsgRspNotify::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Proto_STWebMsgRspNotify::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete err_msg_;
  }
  if (err_msg) {
    set_has_err_msg();
    err_msg_ = err_msg;
  } else {
    clear_has_err_msg();
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BehaviorLogHeader

// optional uint64 event_id = 1;
inline bool BehaviorLogHeader::has_event_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BehaviorLogHeader::set_has_event_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BehaviorLogHeader::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BehaviorLogHeader::clear_event_id() {
  event_id_ = GOOGLE_ULONGLONG(0);
  clear_has_event_id();
}
inline ::google::protobuf::uint64 BehaviorLogHeader::event_id() const {
  return event_id_;
}
inline void BehaviorLogHeader::set_event_id(::google::protobuf::uint64 value) {
  set_has_event_id();
  event_id_ = value;
}

// optional uint32 sequence = 2;
inline bool BehaviorLogHeader::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BehaviorLogHeader::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BehaviorLogHeader::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BehaviorLogHeader::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 BehaviorLogHeader::sequence() const {
  return sequence_;
}
inline void BehaviorLogHeader::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional string bus_name = 3;
inline bool BehaviorLogHeader::has_bus_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BehaviorLogHeader::set_has_bus_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BehaviorLogHeader::clear_has_bus_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BehaviorLogHeader::clear_bus_name() {
  if (bus_name_ != &::google::protobuf::internal::kEmptyString) {
    bus_name_->clear();
  }
  clear_has_bus_name();
}
inline const ::std::string& BehaviorLogHeader::bus_name() const {
  return *bus_name_;
}
inline void BehaviorLogHeader::set_bus_name(const ::std::string& value) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(value);
}
inline void BehaviorLogHeader::set_bus_name(const char* value) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(value);
}
inline void BehaviorLogHeader::set_bus_name(const char* value, size_t size) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BehaviorLogHeader::mutable_bus_name() {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  return bus_name_;
}
inline ::std::string* BehaviorLogHeader::release_bus_name() {
  clear_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bus_name_;
    bus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BehaviorLogHeader::set_allocated_bus_name(::std::string* bus_name) {
  if (bus_name_ != &::google::protobuf::internal::kEmptyString) {
    delete bus_name_;
  }
  if (bus_name) {
    set_has_bus_name();
    bus_name_ = bus_name;
  } else {
    clear_has_bus_name();
    bus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string event_time = 4;
inline bool BehaviorLogHeader::has_event_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BehaviorLogHeader::set_has_event_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BehaviorLogHeader::clear_has_event_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BehaviorLogHeader::clear_event_time() {
  if (event_time_ != &::google::protobuf::internal::kEmptyString) {
    event_time_->clear();
  }
  clear_has_event_time();
}
inline const ::std::string& BehaviorLogHeader::event_time() const {
  return *event_time_;
}
inline void BehaviorLogHeader::set_event_time(const ::std::string& value) {
  set_has_event_time();
  if (event_time_ == &::google::protobuf::internal::kEmptyString) {
    event_time_ = new ::std::string;
  }
  event_time_->assign(value);
}
inline void BehaviorLogHeader::set_event_time(const char* value) {
  set_has_event_time();
  if (event_time_ == &::google::protobuf::internal::kEmptyString) {
    event_time_ = new ::std::string;
  }
  event_time_->assign(value);
}
inline void BehaviorLogHeader::set_event_time(const char* value, size_t size) {
  set_has_event_time();
  if (event_time_ == &::google::protobuf::internal::kEmptyString) {
    event_time_ = new ::std::string;
  }
  event_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BehaviorLogHeader::mutable_event_time() {
  set_has_event_time();
  if (event_time_ == &::google::protobuf::internal::kEmptyString) {
    event_time_ = new ::std::string;
  }
  return event_time_;
}
inline ::std::string* BehaviorLogHeader::release_event_time() {
  clear_has_event_time();
  if (event_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_time_;
    event_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BehaviorLogHeader::set_allocated_event_time(::std::string* event_time) {
  if (event_time_ != &::google::protobuf::internal::kEmptyString) {
    delete event_time_;
  }
  if (event_time) {
    set_has_event_time();
    event_time_ = event_time;
  } else {
    clear_has_event_time();
    event_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 user_id = 5;
inline bool BehaviorLogHeader::has_user_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BehaviorLogHeader::set_has_user_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BehaviorLogHeader::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BehaviorLogHeader::clear_user_id() {
  user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::uint64 BehaviorLogHeader::user_id() const {
  return user_id_;
}
inline void BehaviorLogHeader::set_user_id(::google::protobuf::uint64 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional string user_name = 6;
inline bool BehaviorLogHeader::has_user_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BehaviorLogHeader::set_has_user_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BehaviorLogHeader::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BehaviorLogHeader::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& BehaviorLogHeader::user_name() const {
  return *user_name_;
}
inline void BehaviorLogHeader::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void BehaviorLogHeader::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void BehaviorLogHeader::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BehaviorLogHeader::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* BehaviorLogHeader::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BehaviorLogHeader::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NFEventNoneData

// optional string param1 = 1;
inline bool NFEventNoneData::has_param1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NFEventNoneData::set_has_param1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NFEventNoneData::clear_has_param1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NFEventNoneData::clear_param1() {
  if (param1_ != &::google::protobuf::internal::kEmptyString) {
    param1_->clear();
  }
  clear_has_param1();
}
inline const ::std::string& NFEventNoneData::param1() const {
  return *param1_;
}
inline void NFEventNoneData::set_param1(const ::std::string& value) {
  set_has_param1();
  if (param1_ == &::google::protobuf::internal::kEmptyString) {
    param1_ = new ::std::string;
  }
  param1_->assign(value);
}
inline void NFEventNoneData::set_param1(const char* value) {
  set_has_param1();
  if (param1_ == &::google::protobuf::internal::kEmptyString) {
    param1_ = new ::std::string;
  }
  param1_->assign(value);
}
inline void NFEventNoneData::set_param1(const char* value, size_t size) {
  set_has_param1();
  if (param1_ == &::google::protobuf::internal::kEmptyString) {
    param1_ = new ::std::string;
  }
  param1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NFEventNoneData::mutable_param1() {
  set_has_param1();
  if (param1_ == &::google::protobuf::internal::kEmptyString) {
    param1_ = new ::std::string;
  }
  return param1_;
}
inline ::std::string* NFEventNoneData::release_param1() {
  clear_has_param1();
  if (param1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param1_;
    param1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NFEventNoneData::set_allocated_param1(::std::string* param1) {
  if (param1_ != &::google::protobuf::internal::kEmptyString) {
    delete param1_;
  }
  if (param1) {
    set_has_param1();
    param1_ = param1;
  } else {
    clear_has_param1();
    param1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string param2 = 2;
inline bool NFEventNoneData::has_param2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NFEventNoneData::set_has_param2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NFEventNoneData::clear_has_param2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NFEventNoneData::clear_param2() {
  if (param2_ != &::google::protobuf::internal::kEmptyString) {
    param2_->clear();
  }
  clear_has_param2();
}
inline const ::std::string& NFEventNoneData::param2() const {
  return *param2_;
}
inline void NFEventNoneData::set_param2(const ::std::string& value) {
  set_has_param2();
  if (param2_ == &::google::protobuf::internal::kEmptyString) {
    param2_ = new ::std::string;
  }
  param2_->assign(value);
}
inline void NFEventNoneData::set_param2(const char* value) {
  set_has_param2();
  if (param2_ == &::google::protobuf::internal::kEmptyString) {
    param2_ = new ::std::string;
  }
  param2_->assign(value);
}
inline void NFEventNoneData::set_param2(const char* value, size_t size) {
  set_has_param2();
  if (param2_ == &::google::protobuf::internal::kEmptyString) {
    param2_ = new ::std::string;
  }
  param2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NFEventNoneData::mutable_param2() {
  set_has_param2();
  if (param2_ == &::google::protobuf::internal::kEmptyString) {
    param2_ = new ::std::string;
  }
  return param2_;
}
inline ::std::string* NFEventNoneData::release_param2() {
  clear_has_param2();
  if (param2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param2_;
    param2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NFEventNoneData::set_allocated_param2(::std::string* param2) {
  if (param2_ != &::google::protobuf::internal::kEmptyString) {
    delete param2_;
  }
  if (param2) {
    set_has_param2();
    param2_ = param2;
  } else {
    clear_has_param2();
    param2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string param3 = 3;
inline bool NFEventNoneData::has_param3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NFEventNoneData::set_has_param3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NFEventNoneData::clear_has_param3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NFEventNoneData::clear_param3() {
  if (param3_ != &::google::protobuf::internal::kEmptyString) {
    param3_->clear();
  }
  clear_has_param3();
}
inline const ::std::string& NFEventNoneData::param3() const {
  return *param3_;
}
inline void NFEventNoneData::set_param3(const ::std::string& value) {
  set_has_param3();
  if (param3_ == &::google::protobuf::internal::kEmptyString) {
    param3_ = new ::std::string;
  }
  param3_->assign(value);
}
inline void NFEventNoneData::set_param3(const char* value) {
  set_has_param3();
  if (param3_ == &::google::protobuf::internal::kEmptyString) {
    param3_ = new ::std::string;
  }
  param3_->assign(value);
}
inline void NFEventNoneData::set_param3(const char* value, size_t size) {
  set_has_param3();
  if (param3_ == &::google::protobuf::internal::kEmptyString) {
    param3_ = new ::std::string;
  }
  param3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NFEventNoneData::mutable_param3() {
  set_has_param3();
  if (param3_ == &::google::protobuf::internal::kEmptyString) {
    param3_ = new ::std::string;
  }
  return param3_;
}
inline ::std::string* NFEventNoneData::release_param3() {
  clear_has_param3();
  if (param3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param3_;
    param3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NFEventNoneData::set_allocated_param3(::std::string* param3) {
  if (param3_ != &::google::protobuf::internal::kEmptyString) {
    delete param3_;
  }
  if (param3) {
    set_has_param3();
    param3_ = param3;
  } else {
    clear_has_param3();
    param3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string param4 = 4;
inline bool NFEventNoneData::has_param4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NFEventNoneData::set_has_param4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NFEventNoneData::clear_has_param4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NFEventNoneData::clear_param4() {
  if (param4_ != &::google::protobuf::internal::kEmptyString) {
    param4_->clear();
  }
  clear_has_param4();
}
inline const ::std::string& NFEventNoneData::param4() const {
  return *param4_;
}
inline void NFEventNoneData::set_param4(const ::std::string& value) {
  set_has_param4();
  if (param4_ == &::google::protobuf::internal::kEmptyString) {
    param4_ = new ::std::string;
  }
  param4_->assign(value);
}
inline void NFEventNoneData::set_param4(const char* value) {
  set_has_param4();
  if (param4_ == &::google::protobuf::internal::kEmptyString) {
    param4_ = new ::std::string;
  }
  param4_->assign(value);
}
inline void NFEventNoneData::set_param4(const char* value, size_t size) {
  set_has_param4();
  if (param4_ == &::google::protobuf::internal::kEmptyString) {
    param4_ = new ::std::string;
  }
  param4_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NFEventNoneData::mutable_param4() {
  set_has_param4();
  if (param4_ == &::google::protobuf::internal::kEmptyString) {
    param4_ = new ::std::string;
  }
  return param4_;
}
inline ::std::string* NFEventNoneData::release_param4() {
  clear_has_param4();
  if (param4_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param4_;
    param4_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NFEventNoneData::set_allocated_param4(::std::string* param4) {
  if (param4_ != &::google::protobuf::internal::kEmptyString) {
    delete param4_;
  }
  if (param4) {
    set_has_param4();
    param4_ = param4;
  } else {
    clear_has_param4();
    param4_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string param5 = 5;
inline bool NFEventNoneData::has_param5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NFEventNoneData::set_has_param5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NFEventNoneData::clear_has_param5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NFEventNoneData::clear_param5() {
  if (param5_ != &::google::protobuf::internal::kEmptyString) {
    param5_->clear();
  }
  clear_has_param5();
}
inline const ::std::string& NFEventNoneData::param5() const {
  return *param5_;
}
inline void NFEventNoneData::set_param5(const ::std::string& value) {
  set_has_param5();
  if (param5_ == &::google::protobuf::internal::kEmptyString) {
    param5_ = new ::std::string;
  }
  param5_->assign(value);
}
inline void NFEventNoneData::set_param5(const char* value) {
  set_has_param5();
  if (param5_ == &::google::protobuf::internal::kEmptyString) {
    param5_ = new ::std::string;
  }
  param5_->assign(value);
}
inline void NFEventNoneData::set_param5(const char* value, size_t size) {
  set_has_param5();
  if (param5_ == &::google::protobuf::internal::kEmptyString) {
    param5_ = new ::std::string;
  }
  param5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NFEventNoneData::mutable_param5() {
  set_has_param5();
  if (param5_ == &::google::protobuf::internal::kEmptyString) {
    param5_ = new ::std::string;
  }
  return param5_;
}
inline ::std::string* NFEventNoneData::release_param5() {
  clear_has_param5();
  if (param5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param5_;
    param5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NFEventNoneData::set_allocated_param5(::std::string* param5) {
  if (param5_ != &::google::protobuf::internal::kEmptyString) {
    delete param5_;
  }
  if (param5) {
    set_has_param5();
    param5_ = param5;
  } else {
    clear_has_param5();
    param5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::Proto_Kernel_CMD>() {
  return ::proto_ff::Proto_Kernel_CMD_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::NFROUTER_ERRCODE>() {
  return ::proto_ff::NFROUTER_ERRCODE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::STORESVR_CS_COMMAND>() {
  return ::proto_ff::STORESVR_CS_COMMAND_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::STORESVR_ERRCODE>() {
  return ::proto_ff::STORESVR_ERRCODE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::PacketDispType>() {
  return ::proto_ff::PacketDispType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::TableID>() {
  return ::proto_ff::TableID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::ServerType>() {
  return ::proto_ff::ServerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EServerState>() {
  return ::proto_ff::EServerState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::Proto_Kernel_ErrorCode>() {
  return ::proto_ff::Proto_Kernel_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::NFEventSrcType>() {
  return ::proto_ff::NFEventSrcType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::NFEventIdType>() {
  return ::proto_ff::NFEventIdType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_5fkernel_2eproto__INCLUDED
