// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: storesvr_sqldata.proto

#ifndef PROTOBUF_storesvr_5fsqldata_2eproto__INCLUDED
#define PROTOBUF_storesvr_5fsqldata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace storesvr_sqldata {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

class storesvr_vk;
class storesvr_wherecond;
class storesvr_baseinfo;
class storesvr_opres;
class storesvr_sel;
class storesvr_sel_res;
class storesvr_selobj;
class storesvr_selobj_res;
class storesvr_ins;
class storesvr_ins_res;
class storesvr_del;
class storesvr_del_res;
class storesvr_delobj;
class storesvr_delobj_res;
class storesvr_mod;
class storesvr_mod_res;
class storesvr_modobj;
class storesvr_modobj_res;
class storesvr_modins;
class storesvr_modins_res;
class storesvr_modinsobj;
class storesvr_modinsobj_res;
class storesvr_execute;
class storesvr_execute_res;

enum storesvr_logic_operator {
  E_LOGICOP_AND = 1,
  E_LOGICOP_OR = 2,
  E_LOGICOP_NONE = 3
};
bool storesvr_logic_operator_IsValid(int value);
const storesvr_logic_operator storesvr_logic_operator_MIN = E_LOGICOP_AND;
const storesvr_logic_operator storesvr_logic_operator_MAX = E_LOGICOP_NONE;
const int storesvr_logic_operator_ARRAYSIZE = storesvr_logic_operator_MAX + 1;

const ::google::protobuf::EnumDescriptor* storesvr_logic_operator_descriptor();
inline const ::std::string& storesvr_logic_operator_Name(storesvr_logic_operator value) {
  return ::google::protobuf::internal::NameOfEnum(
    storesvr_logic_operator_descriptor(), value);
}
inline bool storesvr_logic_operator_Parse(
    const ::std::string& name, storesvr_logic_operator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<storesvr_logic_operator>(
    storesvr_logic_operator_descriptor(), name, value);
}
enum storesvr_cmp_operator {
  E_CMPOP_EQUAL = 1,
  E_CMPOP_GREATER = 2,
  E_CMPOP_LESS = 3,
  E_CMPOP_GREATEREQUAL = 4,
  E_CMPOP_LESSEQUAL = 5,
  E_CMPOP_NOTEQUAL = 6
};
bool storesvr_cmp_operator_IsValid(int value);
const storesvr_cmp_operator storesvr_cmp_operator_MIN = E_CMPOP_EQUAL;
const storesvr_cmp_operator storesvr_cmp_operator_MAX = E_CMPOP_NOTEQUAL;
const int storesvr_cmp_operator_ARRAYSIZE = storesvr_cmp_operator_MAX + 1;

const ::google::protobuf::EnumDescriptor* storesvr_cmp_operator_descriptor();
inline const ::std::string& storesvr_cmp_operator_Name(storesvr_cmp_operator value) {
  return ::google::protobuf::internal::NameOfEnum(
    storesvr_cmp_operator_descriptor(), value);
}
inline bool storesvr_cmp_operator_Parse(
    const ::std::string& name, storesvr_cmp_operator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<storesvr_cmp_operator>(
    storesvr_cmp_operator_descriptor(), name, value);
}
enum storesvr_column_type {
  E_COLUMNTYPE_STRING = 1,
  E_COLUMNTYPE_NUM = 2
};
bool storesvr_column_type_IsValid(int value);
const storesvr_column_type storesvr_column_type_MIN = E_COLUMNTYPE_STRING;
const storesvr_column_type storesvr_column_type_MAX = E_COLUMNTYPE_NUM;
const int storesvr_column_type_ARRAYSIZE = storesvr_column_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* storesvr_column_type_descriptor();
inline const ::std::string& storesvr_column_type_Name(storesvr_column_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    storesvr_column_type_descriptor(), value);
}
inline bool storesvr_column_type_Parse(
    const ::std::string& name, storesvr_column_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<storesvr_column_type>(
    storesvr_column_type_descriptor(), name, value);
}
// ===================================================================

class storesvr_vk : public ::google::protobuf::Message {
 public:
  storesvr_vk();
  virtual ~storesvr_vk();

  storesvr_vk(const storesvr_vk& from);

  inline storesvr_vk& operator=(const storesvr_vk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_vk& default_instance();

  void Swap(storesvr_vk* other);

  // implements Message ----------------------------------------------

  storesvr_vk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_vk& from);
  void MergeFrom(const storesvr_vk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string column_name = 1;
  inline bool has_column_name() const;
  inline void clear_column_name();
  static const int kColumnNameFieldNumber = 1;
  inline const ::std::string& column_name() const;
  inline void set_column_name(const ::std::string& value);
  inline void set_column_name(const char* value);
  inline void set_column_name(const char* value, size_t size);
  inline ::std::string* mutable_column_name();
  inline ::std::string* release_column_name();
  inline void set_allocated_column_name(::std::string* column_name);

  // optional string column_value = 2;
  inline bool has_column_value() const;
  inline void clear_column_value();
  static const int kColumnValueFieldNumber = 2;
  inline const ::std::string& column_value() const;
  inline void set_column_value(const ::std::string& value);
  inline void set_column_value(const char* value);
  inline void set_column_value(const char* value, size_t size);
  inline ::std::string* mutable_column_value();
  inline ::std::string* release_column_value();
  inline void set_allocated_column_value(::std::string* column_value);

  // optional .storesvr_sqldata.storesvr_cmp_operator cmp_operator = 3;
  inline bool has_cmp_operator() const;
  inline void clear_cmp_operator();
  static const int kCmpOperatorFieldNumber = 3;
  inline ::storesvr_sqldata::storesvr_cmp_operator cmp_operator() const;
  inline void set_cmp_operator(::storesvr_sqldata::storesvr_cmp_operator value);

  // optional .storesvr_sqldata.storesvr_column_type column_type = 4 [default = E_COLUMNTYPE_NUM];
  inline bool has_column_type() const;
  inline void clear_column_type();
  static const int kColumnTypeFieldNumber = 4;
  inline ::storesvr_sqldata::storesvr_column_type column_type() const;
  inline void set_column_type(::storesvr_sqldata::storesvr_column_type value);

  // optional .storesvr_sqldata.storesvr_logic_operator logic_operator = 5 [default = E_LOGICOP_NONE];
  inline bool has_logic_operator() const;
  inline void clear_logic_operator();
  static const int kLogicOperatorFieldNumber = 5;
  inline ::storesvr_sqldata::storesvr_logic_operator logic_operator() const;
  inline void set_logic_operator(::storesvr_sqldata::storesvr_logic_operator value);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_vk)
 private:
  inline void set_has_column_name();
  inline void clear_has_column_name();
  inline void set_has_column_value();
  inline void clear_has_column_value();
  inline void set_has_cmp_operator();
  inline void clear_has_cmp_operator();
  inline void set_has_column_type();
  inline void clear_has_column_type();
  inline void set_has_logic_operator();
  inline void clear_has_logic_operator();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* column_name_;
  ::std::string* column_value_;
  int cmp_operator_;
  int column_type_;
  int logic_operator_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_vk* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_wherecond : public ::google::protobuf::Message {
 public:
  storesvr_wherecond();
  virtual ~storesvr_wherecond();

  storesvr_wherecond(const storesvr_wherecond& from);

  inline storesvr_wherecond& operator=(const storesvr_wherecond& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_wherecond& default_instance();

  void Swap(storesvr_wherecond* other);

  // implements Message ----------------------------------------------

  storesvr_wherecond* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_wherecond& from);
  void MergeFrom(const storesvr_wherecond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 mod_key = 1;
  inline bool has_mod_key() const;
  inline void clear_mod_key();
  static const int kModKeyFieldNumber = 1;
  inline ::google::protobuf::uint64 mod_key() const;
  inline void set_mod_key(::google::protobuf::uint64 value);

  // repeated .storesvr_sqldata.storesvr_vk where_conds = 2;
  inline int where_conds_size() const;
  inline void clear_where_conds();
  static const int kWhereCondsFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_vk& where_conds(int index) const;
  inline ::storesvr_sqldata::storesvr_vk* mutable_where_conds(int index);
  inline ::storesvr_sqldata::storesvr_vk* add_where_conds();
  inline const ::google::protobuf::RepeatedPtrField< ::storesvr_sqldata::storesvr_vk >&
      where_conds() const;
  inline ::google::protobuf::RepeatedPtrField< ::storesvr_sqldata::storesvr_vk >*
      mutable_where_conds();

  // optional string where_additional_conds = 3;
  inline bool has_where_additional_conds() const;
  inline void clear_where_additional_conds();
  static const int kWhereAdditionalCondsFieldNumber = 3;
  inline const ::std::string& where_additional_conds() const;
  inline void set_where_additional_conds(const ::std::string& value);
  inline void set_where_additional_conds(const char* value);
  inline void set_where_additional_conds(const char* value, size_t size);
  inline ::std::string* mutable_where_additional_conds();
  inline ::std::string* release_where_additional_conds();
  inline void set_allocated_where_additional_conds(::std::string* where_additional_conds);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_wherecond)
 private:
  inline void set_has_mod_key();
  inline void clear_has_mod_key();
  inline void set_has_where_additional_conds();
  inline void clear_has_where_additional_conds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 mod_key_;
  ::google::protobuf::RepeatedPtrField< ::storesvr_sqldata::storesvr_vk > where_conds_;
  ::std::string* where_additional_conds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_wherecond* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_baseinfo : public ::google::protobuf::Message {
 public:
  storesvr_baseinfo();
  virtual ~storesvr_baseinfo();

  storesvr_baseinfo(const storesvr_baseinfo& from);

  inline storesvr_baseinfo& operator=(const storesvr_baseinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_baseinfo& default_instance();

  void Swap(storesvr_baseinfo* other);

  // implements Message ----------------------------------------------

  storesvr_baseinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_baseinfo& from);
  void MergeFrom(const storesvr_baseinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dbname = 1;
  inline bool has_dbname() const;
  inline void clear_dbname();
  static const int kDbnameFieldNumber = 1;
  inline const ::std::string& dbname() const;
  inline void set_dbname(const ::std::string& value);
  inline void set_dbname(const char* value);
  inline void set_dbname(const char* value, size_t size);
  inline ::std::string* mutable_dbname();
  inline ::std::string* release_dbname();
  inline void set_allocated_dbname(::std::string* dbname);

  // optional string tbname = 2;
  inline bool has_tbname() const;
  inline void clear_tbname();
  static const int kTbnameFieldNumber = 2;
  inline const ::std::string& tbname() const;
  inline void set_tbname(const ::std::string& value);
  inline void set_tbname(const char* value);
  inline void set_tbname(const char* value, size_t size);
  inline ::std::string* mutable_tbname();
  inline ::std::string* release_tbname();
  inline void set_allocated_tbname(::std::string* tbname);

  // optional string clname = 3;
  inline bool has_clname() const;
  inline void clear_clname();
  static const int kClnameFieldNumber = 3;
  inline const ::std::string& clname() const;
  inline void set_clname(const ::std::string& value);
  inline void set_clname(const char* value);
  inline void set_clname(const char* value, size_t size);
  inline ::std::string* mutable_clname();
  inline ::std::string* release_clname();
  inline void set_allocated_clname(::std::string* clname);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_baseinfo)
 private:
  inline void set_has_dbname();
  inline void clear_has_dbname();
  inline void set_has_tbname();
  inline void clear_has_tbname();
  inline void set_has_clname();
  inline void clear_has_clname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dbname_;
  ::std::string* tbname_;
  ::std::string* clname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_baseinfo* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_opres : public ::google::protobuf::Message {
 public:
  storesvr_opres();
  virtual ~storesvr_opres();

  storesvr_opres(const storesvr_opres& from);

  inline storesvr_opres& operator=(const storesvr_opres& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_opres& default_instance();

  void Swap(storesvr_opres* other);

  // implements Message ----------------------------------------------

  storesvr_opres* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_opres& from);
  void MergeFrom(const storesvr_opres& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 mod_key = 1;
  inline bool has_mod_key() const;
  inline void clear_mod_key();
  static const int kModKeyFieldNumber = 1;
  inline ::google::protobuf::uint64 mod_key() const;
  inline void set_mod_key(::google::protobuf::uint64 value);

  // optional string zdb_errmsg = 2;
  inline bool has_zdb_errmsg() const;
  inline void clear_zdb_errmsg();
  static const int kZdbErrmsgFieldNumber = 2;
  inline const ::std::string& zdb_errmsg() const;
  inline void set_zdb_errmsg(const ::std::string& value);
  inline void set_zdb_errmsg(const char* value);
  inline void set_zdb_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_zdb_errmsg();
  inline ::std::string* release_zdb_errmsg();
  inline void set_allocated_zdb_errmsg(::std::string* zdb_errmsg);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_opres)
 private:
  inline void set_has_mod_key();
  inline void clear_has_mod_key();
  inline void set_has_zdb_errmsg();
  inline void clear_has_zdb_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 mod_key_;
  ::std::string* zdb_errmsg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_opres* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_sel : public ::google::protobuf::Message {
 public:
  storesvr_sel();
  virtual ~storesvr_sel();

  storesvr_sel(const storesvr_sel& from);

  inline storesvr_sel& operator=(const storesvr_sel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_sel& default_instance();

  void Swap(storesvr_sel* other);

  // implements Message ----------------------------------------------

  storesvr_sel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_sel& from);
  void MergeFrom(const storesvr_sel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_wherecond sel_cond = 2;
  inline bool has_sel_cond() const;
  inline void clear_sel_cond();
  static const int kSelCondFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_wherecond& sel_cond() const;
  inline ::storesvr_sqldata::storesvr_wherecond* mutable_sel_cond();
  inline ::storesvr_sqldata::storesvr_wherecond* release_sel_cond();
  inline void set_allocated_sel_cond(::storesvr_sqldata::storesvr_wherecond* sel_cond);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_sel)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_sel_cond();
  inline void clear_has_sel_cond();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_wherecond* sel_cond_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_sel* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_sel_res : public ::google::protobuf::Message {
 public:
  storesvr_sel_res();
  virtual ~storesvr_sel_res();

  storesvr_sel_res(const storesvr_sel_res& from);

  inline storesvr_sel_res& operator=(const storesvr_sel_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_sel_res& default_instance();

  void Swap(storesvr_sel_res* other);

  // implements Message ----------------------------------------------

  storesvr_sel_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_sel_res& from);
  void MergeFrom(const storesvr_sel_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_opres sel_opres = 2;
  inline bool has_sel_opres() const;
  inline void clear_sel_opres();
  static const int kSelOpresFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_opres& sel_opres() const;
  inline ::storesvr_sqldata::storesvr_opres* mutable_sel_opres();
  inline ::storesvr_sqldata::storesvr_opres* release_sel_opres();
  inline void set_allocated_sel_opres(::storesvr_sqldata::storesvr_opres* sel_opres);

  // optional bool is_lastbatch = 3;
  inline bool has_is_lastbatch() const;
  inline void clear_is_lastbatch();
  static const int kIsLastbatchFieldNumber = 3;
  inline bool is_lastbatch() const;
  inline void set_is_lastbatch(bool value);

  // optional int32 row_count = 4;
  inline bool has_row_count() const;
  inline void clear_row_count();
  static const int kRowCountFieldNumber = 4;
  inline ::google::protobuf::int32 row_count() const;
  inline void set_row_count(::google::protobuf::int32 value);

  // repeated bytes sel_records = 5;
  inline int sel_records_size() const;
  inline void clear_sel_records();
  static const int kSelRecordsFieldNumber = 5;
  inline const ::std::string& sel_records(int index) const;
  inline ::std::string* mutable_sel_records(int index);
  inline void set_sel_records(int index, const ::std::string& value);
  inline void set_sel_records(int index, const char* value);
  inline void set_sel_records(int index, const void* value, size_t size);
  inline ::std::string* add_sel_records();
  inline void add_sel_records(const ::std::string& value);
  inline void add_sel_records(const char* value);
  inline void add_sel_records(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sel_records() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sel_records();

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_sel_res)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_sel_opres();
  inline void clear_has_sel_opres();
  inline void set_has_is_lastbatch();
  inline void clear_has_is_lastbatch();
  inline void set_has_row_count();
  inline void clear_has_row_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_opres* sel_opres_;
  bool is_lastbatch_;
  ::google::protobuf::int32 row_count_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sel_records_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_sel_res* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_selobj : public ::google::protobuf::Message {
 public:
  storesvr_selobj();
  virtual ~storesvr_selobj();

  storesvr_selobj(const storesvr_selobj& from);

  inline storesvr_selobj& operator=(const storesvr_selobj& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_selobj& default_instance();

  void Swap(storesvr_selobj* other);

  // implements Message ----------------------------------------------

  storesvr_selobj* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_selobj& from);
  void MergeFrom(const storesvr_selobj& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional uint64 mod_key = 2;
  inline bool has_mod_key() const;
  inline void clear_mod_key();
  static const int kModKeyFieldNumber = 2;
  inline ::google::protobuf::uint64 mod_key() const;
  inline void set_mod_key(::google::protobuf::uint64 value);

  // optional bytes sel_record = 3;
  inline bool has_sel_record() const;
  inline void clear_sel_record();
  static const int kSelRecordFieldNumber = 3;
  inline const ::std::string& sel_record() const;
  inline void set_sel_record(const ::std::string& value);
  inline void set_sel_record(const char* value);
  inline void set_sel_record(const void* value, size_t size);
  inline ::std::string* mutable_sel_record();
  inline ::std::string* release_sel_record();
  inline void set_allocated_sel_record(::std::string* sel_record);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_selobj)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_mod_key();
  inline void clear_has_mod_key();
  inline void set_has_sel_record();
  inline void clear_has_sel_record();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::google::protobuf::uint64 mod_key_;
  ::std::string* sel_record_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_selobj* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_selobj_res : public ::google::protobuf::Message {
 public:
  storesvr_selobj_res();
  virtual ~storesvr_selobj_res();

  storesvr_selobj_res(const storesvr_selobj_res& from);

  inline storesvr_selobj_res& operator=(const storesvr_selobj_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_selobj_res& default_instance();

  void Swap(storesvr_selobj_res* other);

  // implements Message ----------------------------------------------

  storesvr_selobj_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_selobj_res& from);
  void MergeFrom(const storesvr_selobj_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_opres sel_opres = 2;
  inline bool has_sel_opres() const;
  inline void clear_sel_opres();
  static const int kSelOpresFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_opres& sel_opres() const;
  inline ::storesvr_sqldata::storesvr_opres* mutable_sel_opres();
  inline ::storesvr_sqldata::storesvr_opres* release_sel_opres();
  inline void set_allocated_sel_opres(::storesvr_sqldata::storesvr_opres* sel_opres);

  // optional bytes sel_record = 3;
  inline bool has_sel_record() const;
  inline void clear_sel_record();
  static const int kSelRecordFieldNumber = 3;
  inline const ::std::string& sel_record() const;
  inline void set_sel_record(const ::std::string& value);
  inline void set_sel_record(const char* value);
  inline void set_sel_record(const void* value, size_t size);
  inline ::std::string* mutable_sel_record();
  inline ::std::string* release_sel_record();
  inline void set_allocated_sel_record(::std::string* sel_record);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_selobj_res)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_sel_opres();
  inline void clear_has_sel_opres();
  inline void set_has_sel_record();
  inline void clear_has_sel_record();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_opres* sel_opres_;
  ::std::string* sel_record_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_selobj_res* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_ins : public ::google::protobuf::Message {
 public:
  storesvr_ins();
  virtual ~storesvr_ins();

  storesvr_ins(const storesvr_ins& from);

  inline storesvr_ins& operator=(const storesvr_ins& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_ins& default_instance();

  void Swap(storesvr_ins* other);

  // implements Message ----------------------------------------------

  storesvr_ins* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_ins& from);
  void MergeFrom(const storesvr_ins& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional uint64 mod_key = 2;
  inline bool has_mod_key() const;
  inline void clear_mod_key();
  static const int kModKeyFieldNumber = 2;
  inline ::google::protobuf::uint64 mod_key() const;
  inline void set_mod_key(::google::protobuf::uint64 value);

  // optional bytes ins_record = 3;
  inline bool has_ins_record() const;
  inline void clear_ins_record();
  static const int kInsRecordFieldNumber = 3;
  inline const ::std::string& ins_record() const;
  inline void set_ins_record(const ::std::string& value);
  inline void set_ins_record(const char* value);
  inline void set_ins_record(const void* value, size_t size);
  inline ::std::string* mutable_ins_record();
  inline ::std::string* release_ins_record();
  inline void set_allocated_ins_record(::std::string* ins_record);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_ins)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_mod_key();
  inline void clear_has_mod_key();
  inline void set_has_ins_record();
  inline void clear_has_ins_record();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::google::protobuf::uint64 mod_key_;
  ::std::string* ins_record_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_ins* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_ins_res : public ::google::protobuf::Message {
 public:
  storesvr_ins_res();
  virtual ~storesvr_ins_res();

  storesvr_ins_res(const storesvr_ins_res& from);

  inline storesvr_ins_res& operator=(const storesvr_ins_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_ins_res& default_instance();

  void Swap(storesvr_ins_res* other);

  // implements Message ----------------------------------------------

  storesvr_ins_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_ins_res& from);
  void MergeFrom(const storesvr_ins_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_opres ins_opres = 2;
  inline bool has_ins_opres() const;
  inline void clear_ins_opres();
  static const int kInsOpresFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_opres& ins_opres() const;
  inline ::storesvr_sqldata::storesvr_opres* mutable_ins_opres();
  inline ::storesvr_sqldata::storesvr_opres* release_ins_opres();
  inline void set_allocated_ins_opres(::storesvr_sqldata::storesvr_opres* ins_opres);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_ins_res)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_ins_opres();
  inline void clear_has_ins_opres();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_opres* ins_opres_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_ins_res* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_del : public ::google::protobuf::Message {
 public:
  storesvr_del();
  virtual ~storesvr_del();

  storesvr_del(const storesvr_del& from);

  inline storesvr_del& operator=(const storesvr_del& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_del& default_instance();

  void Swap(storesvr_del* other);

  // implements Message ----------------------------------------------

  storesvr_del* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_del& from);
  void MergeFrom(const storesvr_del& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_wherecond del_cond = 2;
  inline bool has_del_cond() const;
  inline void clear_del_cond();
  static const int kDelCondFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_wherecond& del_cond() const;
  inline ::storesvr_sqldata::storesvr_wherecond* mutable_del_cond();
  inline ::storesvr_sqldata::storesvr_wherecond* release_del_cond();
  inline void set_allocated_del_cond(::storesvr_sqldata::storesvr_wherecond* del_cond);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_del)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_del_cond();
  inline void clear_has_del_cond();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_wherecond* del_cond_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_del* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_del_res : public ::google::protobuf::Message {
 public:
  storesvr_del_res();
  virtual ~storesvr_del_res();

  storesvr_del_res(const storesvr_del_res& from);

  inline storesvr_del_res& operator=(const storesvr_del_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_del_res& default_instance();

  void Swap(storesvr_del_res* other);

  // implements Message ----------------------------------------------

  storesvr_del_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_del_res& from);
  void MergeFrom(const storesvr_del_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_opres del_opres = 2;
  inline bool has_del_opres() const;
  inline void clear_del_opres();
  static const int kDelOpresFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_opres& del_opres() const;
  inline ::storesvr_sqldata::storesvr_opres* mutable_del_opres();
  inline ::storesvr_sqldata::storesvr_opres* release_del_opres();
  inline void set_allocated_del_opres(::storesvr_sqldata::storesvr_opres* del_opres);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_del_res)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_del_opres();
  inline void clear_has_del_opres();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_opres* del_opres_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_del_res* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_delobj : public ::google::protobuf::Message {
 public:
  storesvr_delobj();
  virtual ~storesvr_delobj();

  storesvr_delobj(const storesvr_delobj& from);

  inline storesvr_delobj& operator=(const storesvr_delobj& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_delobj& default_instance();

  void Swap(storesvr_delobj* other);

  // implements Message ----------------------------------------------

  storesvr_delobj* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_delobj& from);
  void MergeFrom(const storesvr_delobj& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional uint64 mod_key = 2;
  inline bool has_mod_key() const;
  inline void clear_mod_key();
  static const int kModKeyFieldNumber = 2;
  inline ::google::protobuf::uint64 mod_key() const;
  inline void set_mod_key(::google::protobuf::uint64 value);

  // optional bytes del_record = 3;
  inline bool has_del_record() const;
  inline void clear_del_record();
  static const int kDelRecordFieldNumber = 3;
  inline const ::std::string& del_record() const;
  inline void set_del_record(const ::std::string& value);
  inline void set_del_record(const char* value);
  inline void set_del_record(const void* value, size_t size);
  inline ::std::string* mutable_del_record();
  inline ::std::string* release_del_record();
  inline void set_allocated_del_record(::std::string* del_record);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_delobj)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_mod_key();
  inline void clear_has_mod_key();
  inline void set_has_del_record();
  inline void clear_has_del_record();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::google::protobuf::uint64 mod_key_;
  ::std::string* del_record_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_delobj* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_delobj_res : public ::google::protobuf::Message {
 public:
  storesvr_delobj_res();
  virtual ~storesvr_delobj_res();

  storesvr_delobj_res(const storesvr_delobj_res& from);

  inline storesvr_delobj_res& operator=(const storesvr_delobj_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_delobj_res& default_instance();

  void Swap(storesvr_delobj_res* other);

  // implements Message ----------------------------------------------

  storesvr_delobj_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_delobj_res& from);
  void MergeFrom(const storesvr_delobj_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_opres del_opres = 2;
  inline bool has_del_opres() const;
  inline void clear_del_opres();
  static const int kDelOpresFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_opres& del_opres() const;
  inline ::storesvr_sqldata::storesvr_opres* mutable_del_opres();
  inline ::storesvr_sqldata::storesvr_opres* release_del_opres();
  inline void set_allocated_del_opres(::storesvr_sqldata::storesvr_opres* del_opres);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_delobj_res)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_del_opres();
  inline void clear_has_del_opres();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_opres* del_opres_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_delobj_res* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_mod : public ::google::protobuf::Message {
 public:
  storesvr_mod();
  virtual ~storesvr_mod();

  storesvr_mod(const storesvr_mod& from);

  inline storesvr_mod& operator=(const storesvr_mod& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_mod& default_instance();

  void Swap(storesvr_mod* other);

  // implements Message ----------------------------------------------

  storesvr_mod* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_mod& from);
  void MergeFrom(const storesvr_mod& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_wherecond mod_cond = 2;
  inline bool has_mod_cond() const;
  inline void clear_mod_cond();
  static const int kModCondFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_wherecond& mod_cond() const;
  inline ::storesvr_sqldata::storesvr_wherecond* mutable_mod_cond();
  inline ::storesvr_sqldata::storesvr_wherecond* release_mod_cond();
  inline void set_allocated_mod_cond(::storesvr_sqldata::storesvr_wherecond* mod_cond);

  // optional bytes mod_record = 3;
  inline bool has_mod_record() const;
  inline void clear_mod_record();
  static const int kModRecordFieldNumber = 3;
  inline const ::std::string& mod_record() const;
  inline void set_mod_record(const ::std::string& value);
  inline void set_mod_record(const char* value);
  inline void set_mod_record(const void* value, size_t size);
  inline ::std::string* mutable_mod_record();
  inline ::std::string* release_mod_record();
  inline void set_allocated_mod_record(::std::string* mod_record);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_mod)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_mod_cond();
  inline void clear_has_mod_cond();
  inline void set_has_mod_record();
  inline void clear_has_mod_record();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_wherecond* mod_cond_;
  ::std::string* mod_record_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_mod* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_mod_res : public ::google::protobuf::Message {
 public:
  storesvr_mod_res();
  virtual ~storesvr_mod_res();

  storesvr_mod_res(const storesvr_mod_res& from);

  inline storesvr_mod_res& operator=(const storesvr_mod_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_mod_res& default_instance();

  void Swap(storesvr_mod_res* other);

  // implements Message ----------------------------------------------

  storesvr_mod_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_mod_res& from);
  void MergeFrom(const storesvr_mod_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_opres mod_opres = 2;
  inline bool has_mod_opres() const;
  inline void clear_mod_opres();
  static const int kModOpresFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_opres& mod_opres() const;
  inline ::storesvr_sqldata::storesvr_opres* mutable_mod_opres();
  inline ::storesvr_sqldata::storesvr_opres* release_mod_opres();
  inline void set_allocated_mod_opres(::storesvr_sqldata::storesvr_opres* mod_opres);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_mod_res)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_mod_opres();
  inline void clear_has_mod_opres();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_opres* mod_opres_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_mod_res* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_modobj : public ::google::protobuf::Message {
 public:
  storesvr_modobj();
  virtual ~storesvr_modobj();

  storesvr_modobj(const storesvr_modobj& from);

  inline storesvr_modobj& operator=(const storesvr_modobj& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_modobj& default_instance();

  void Swap(storesvr_modobj* other);

  // implements Message ----------------------------------------------

  storesvr_modobj* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_modobj& from);
  void MergeFrom(const storesvr_modobj& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional uint64 mod_key = 2;
  inline bool has_mod_key() const;
  inline void clear_mod_key();
  static const int kModKeyFieldNumber = 2;
  inline ::google::protobuf::uint64 mod_key() const;
  inline void set_mod_key(::google::protobuf::uint64 value);

  // optional bytes mod_record = 3;
  inline bool has_mod_record() const;
  inline void clear_mod_record();
  static const int kModRecordFieldNumber = 3;
  inline const ::std::string& mod_record() const;
  inline void set_mod_record(const ::std::string& value);
  inline void set_mod_record(const char* value);
  inline void set_mod_record(const void* value, size_t size);
  inline ::std::string* mutable_mod_record();
  inline ::std::string* release_mod_record();
  inline void set_allocated_mod_record(::std::string* mod_record);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_modobj)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_mod_key();
  inline void clear_has_mod_key();
  inline void set_has_mod_record();
  inline void clear_has_mod_record();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::google::protobuf::uint64 mod_key_;
  ::std::string* mod_record_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_modobj* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_modobj_res : public ::google::protobuf::Message {
 public:
  storesvr_modobj_res();
  virtual ~storesvr_modobj_res();

  storesvr_modobj_res(const storesvr_modobj_res& from);

  inline storesvr_modobj_res& operator=(const storesvr_modobj_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_modobj_res& default_instance();

  void Swap(storesvr_modobj_res* other);

  // implements Message ----------------------------------------------

  storesvr_modobj_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_modobj_res& from);
  void MergeFrom(const storesvr_modobj_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_opres mod_opres = 2;
  inline bool has_mod_opres() const;
  inline void clear_mod_opres();
  static const int kModOpresFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_opres& mod_opres() const;
  inline ::storesvr_sqldata::storesvr_opres* mutable_mod_opres();
  inline ::storesvr_sqldata::storesvr_opres* release_mod_opres();
  inline void set_allocated_mod_opres(::storesvr_sqldata::storesvr_opres* mod_opres);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_modobj_res)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_mod_opres();
  inline void clear_has_mod_opres();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_opres* mod_opres_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_modobj_res* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_modins : public ::google::protobuf::Message {
 public:
  storesvr_modins();
  virtual ~storesvr_modins();

  storesvr_modins(const storesvr_modins& from);

  inline storesvr_modins& operator=(const storesvr_modins& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_modins& default_instance();

  void Swap(storesvr_modins* other);

  // implements Message ----------------------------------------------

  storesvr_modins* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_modins& from);
  void MergeFrom(const storesvr_modins& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_wherecond mod_cond = 2;
  inline bool has_mod_cond() const;
  inline void clear_mod_cond();
  static const int kModCondFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_wherecond& mod_cond() const;
  inline ::storesvr_sqldata::storesvr_wherecond* mutable_mod_cond();
  inline ::storesvr_sqldata::storesvr_wherecond* release_mod_cond();
  inline void set_allocated_mod_cond(::storesvr_sqldata::storesvr_wherecond* mod_cond);

  // optional bytes mod_record = 3;
  inline bool has_mod_record() const;
  inline void clear_mod_record();
  static const int kModRecordFieldNumber = 3;
  inline const ::std::string& mod_record() const;
  inline void set_mod_record(const ::std::string& value);
  inline void set_mod_record(const char* value);
  inline void set_mod_record(const void* value, size_t size);
  inline ::std::string* mutable_mod_record();
  inline ::std::string* release_mod_record();
  inline void set_allocated_mod_record(::std::string* mod_record);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_modins)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_mod_cond();
  inline void clear_has_mod_cond();
  inline void set_has_mod_record();
  inline void clear_has_mod_record();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_wherecond* mod_cond_;
  ::std::string* mod_record_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_modins* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_modins_res : public ::google::protobuf::Message {
 public:
  storesvr_modins_res();
  virtual ~storesvr_modins_res();

  storesvr_modins_res(const storesvr_modins_res& from);

  inline storesvr_modins_res& operator=(const storesvr_modins_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_modins_res& default_instance();

  void Swap(storesvr_modins_res* other);

  // implements Message ----------------------------------------------

  storesvr_modins_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_modins_res& from);
  void MergeFrom(const storesvr_modins_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_opres mod_opres = 2;
  inline bool has_mod_opres() const;
  inline void clear_mod_opres();
  static const int kModOpresFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_opres& mod_opres() const;
  inline ::storesvr_sqldata::storesvr_opres* mutable_mod_opres();
  inline ::storesvr_sqldata::storesvr_opres* release_mod_opres();
  inline void set_allocated_mod_opres(::storesvr_sqldata::storesvr_opres* mod_opres);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_modins_res)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_mod_opres();
  inline void clear_has_mod_opres();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_opres* mod_opres_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_modins_res* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_modinsobj : public ::google::protobuf::Message {
 public:
  storesvr_modinsobj();
  virtual ~storesvr_modinsobj();

  storesvr_modinsobj(const storesvr_modinsobj& from);

  inline storesvr_modinsobj& operator=(const storesvr_modinsobj& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_modinsobj& default_instance();

  void Swap(storesvr_modinsobj* other);

  // implements Message ----------------------------------------------

  storesvr_modinsobj* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_modinsobj& from);
  void MergeFrom(const storesvr_modinsobj& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional uint64 mod_key = 2;
  inline bool has_mod_key() const;
  inline void clear_mod_key();
  static const int kModKeyFieldNumber = 2;
  inline ::google::protobuf::uint64 mod_key() const;
  inline void set_mod_key(::google::protobuf::uint64 value);

  // optional bytes modins_record = 3;
  inline bool has_modins_record() const;
  inline void clear_modins_record();
  static const int kModinsRecordFieldNumber = 3;
  inline const ::std::string& modins_record() const;
  inline void set_modins_record(const ::std::string& value);
  inline void set_modins_record(const char* value);
  inline void set_modins_record(const void* value, size_t size);
  inline ::std::string* mutable_modins_record();
  inline ::std::string* release_modins_record();
  inline void set_allocated_modins_record(::std::string* modins_record);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_modinsobj)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_mod_key();
  inline void clear_has_mod_key();
  inline void set_has_modins_record();
  inline void clear_has_modins_record();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::google::protobuf::uint64 mod_key_;
  ::std::string* modins_record_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_modinsobj* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_modinsobj_res : public ::google::protobuf::Message {
 public:
  storesvr_modinsobj_res();
  virtual ~storesvr_modinsobj_res();

  storesvr_modinsobj_res(const storesvr_modinsobj_res& from);

  inline storesvr_modinsobj_res& operator=(const storesvr_modinsobj_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_modinsobj_res& default_instance();

  void Swap(storesvr_modinsobj_res* other);

  // implements Message ----------------------------------------------

  storesvr_modinsobj_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_modinsobj_res& from);
  void MergeFrom(const storesvr_modinsobj_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_opres modins_opres = 2;
  inline bool has_modins_opres() const;
  inline void clear_modins_opres();
  static const int kModinsOpresFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_opres& modins_opres() const;
  inline ::storesvr_sqldata::storesvr_opres* mutable_modins_opres();
  inline ::storesvr_sqldata::storesvr_opres* release_modins_opres();
  inline void set_allocated_modins_opres(::storesvr_sqldata::storesvr_opres* modins_opres);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_modinsobj_res)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_modins_opres();
  inline void clear_has_modins_opres();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_opres* modins_opres_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_modinsobj_res* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_execute : public ::google::protobuf::Message {
 public:
  storesvr_execute();
  virtual ~storesvr_execute();

  storesvr_execute(const storesvr_execute& from);

  inline storesvr_execute& operator=(const storesvr_execute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_execute& default_instance();

  void Swap(storesvr_execute* other);

  // implements Message ----------------------------------------------

  storesvr_execute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_execute& from);
  void MergeFrom(const storesvr_execute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional uint64 mod_key = 2;
  inline bool has_mod_key() const;
  inline void clear_mod_key();
  static const int kModKeyFieldNumber = 2;
  inline ::google::protobuf::uint64 mod_key() const;
  inline void set_mod_key(::google::protobuf::uint64 value);

  // optional bytes execute_record = 3;
  inline bool has_execute_record() const;
  inline void clear_execute_record();
  static const int kExecuteRecordFieldNumber = 3;
  inline const ::std::string& execute_record() const;
  inline void set_execute_record(const ::std::string& value);
  inline void set_execute_record(const char* value);
  inline void set_execute_record(const void* value, size_t size);
  inline ::std::string* mutable_execute_record();
  inline ::std::string* release_execute_record();
  inline void set_allocated_execute_record(::std::string* execute_record);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_execute)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_mod_key();
  inline void clear_has_mod_key();
  inline void set_has_execute_record();
  inline void clear_has_execute_record();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::google::protobuf::uint64 mod_key_;
  ::std::string* execute_record_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_execute* default_instance_;
};
// -------------------------------------------------------------------

class storesvr_execute_res : public ::google::protobuf::Message {
 public:
  storesvr_execute_res();
  virtual ~storesvr_execute_res();

  storesvr_execute_res(const storesvr_execute_res& from);

  inline storesvr_execute_res& operator=(const storesvr_execute_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const storesvr_execute_res& default_instance();

  void Swap(storesvr_execute_res* other);

  // implements Message ----------------------------------------------

  storesvr_execute_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const storesvr_execute_res& from);
  void MergeFrom(const storesvr_execute_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  inline const ::storesvr_sqldata::storesvr_baseinfo& baseinfo() const;
  inline ::storesvr_sqldata::storesvr_baseinfo* mutable_baseinfo();
  inline ::storesvr_sqldata::storesvr_baseinfo* release_baseinfo();
  inline void set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo);

  // optional .storesvr_sqldata.storesvr_opres exe_opres = 2;
  inline bool has_exe_opres() const;
  inline void clear_exe_opres();
  static const int kExeOpresFieldNumber = 2;
  inline const ::storesvr_sqldata::storesvr_opres& exe_opres() const;
  inline ::storesvr_sqldata::storesvr_opres* mutable_exe_opres();
  inline ::storesvr_sqldata::storesvr_opres* release_exe_opres();
  inline void set_allocated_exe_opres(::storesvr_sqldata::storesvr_opres* exe_opres);

  // @@protoc_insertion_point(class_scope:storesvr_sqldata.storesvr_execute_res)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_exe_opres();
  inline void clear_has_exe_opres();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::storesvr_sqldata::storesvr_baseinfo* baseinfo_;
  ::storesvr_sqldata::storesvr_opres* exe_opres_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_AssignDesc_storesvr_5fsqldata_2eproto();
  friend void protobuf_ShutdownFile_storesvr_5fsqldata_2eproto();

  void InitAsDefaultInstance();
  static storesvr_execute_res* default_instance_;
};
// ===================================================================


// ===================================================================

// storesvr_vk

// optional string column_name = 1;
inline bool storesvr_vk::has_column_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_vk::set_has_column_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_vk::clear_has_column_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_vk::clear_column_name() {
  if (column_name_ != &::google::protobuf::internal::kEmptyString) {
    column_name_->clear();
  }
  clear_has_column_name();
}
inline const ::std::string& storesvr_vk::column_name() const {
  return *column_name_;
}
inline void storesvr_vk::set_column_name(const ::std::string& value) {
  set_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    column_name_ = new ::std::string;
  }
  column_name_->assign(value);
}
inline void storesvr_vk::set_column_name(const char* value) {
  set_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    column_name_ = new ::std::string;
  }
  column_name_->assign(value);
}
inline void storesvr_vk::set_column_name(const char* value, size_t size) {
  set_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    column_name_ = new ::std::string;
  }
  column_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_vk::mutable_column_name() {
  set_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    column_name_ = new ::std::string;
  }
  return column_name_;
}
inline ::std::string* storesvr_vk::release_column_name() {
  clear_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = column_name_;
    column_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_vk::set_allocated_column_name(::std::string* column_name) {
  if (column_name_ != &::google::protobuf::internal::kEmptyString) {
    delete column_name_;
  }
  if (column_name) {
    set_has_column_name();
    column_name_ = column_name;
  } else {
    clear_has_column_name();
    column_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string column_value = 2;
inline bool storesvr_vk::has_column_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_vk::set_has_column_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_vk::clear_has_column_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_vk::clear_column_value() {
  if (column_value_ != &::google::protobuf::internal::kEmptyString) {
    column_value_->clear();
  }
  clear_has_column_value();
}
inline const ::std::string& storesvr_vk::column_value() const {
  return *column_value_;
}
inline void storesvr_vk::set_column_value(const ::std::string& value) {
  set_has_column_value();
  if (column_value_ == &::google::protobuf::internal::kEmptyString) {
    column_value_ = new ::std::string;
  }
  column_value_->assign(value);
}
inline void storesvr_vk::set_column_value(const char* value) {
  set_has_column_value();
  if (column_value_ == &::google::protobuf::internal::kEmptyString) {
    column_value_ = new ::std::string;
  }
  column_value_->assign(value);
}
inline void storesvr_vk::set_column_value(const char* value, size_t size) {
  set_has_column_value();
  if (column_value_ == &::google::protobuf::internal::kEmptyString) {
    column_value_ = new ::std::string;
  }
  column_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_vk::mutable_column_value() {
  set_has_column_value();
  if (column_value_ == &::google::protobuf::internal::kEmptyString) {
    column_value_ = new ::std::string;
  }
  return column_value_;
}
inline ::std::string* storesvr_vk::release_column_value() {
  clear_has_column_value();
  if (column_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = column_value_;
    column_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_vk::set_allocated_column_value(::std::string* column_value) {
  if (column_value_ != &::google::protobuf::internal::kEmptyString) {
    delete column_value_;
  }
  if (column_value) {
    set_has_column_value();
    column_value_ = column_value;
  } else {
    clear_has_column_value();
    column_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .storesvr_sqldata.storesvr_cmp_operator cmp_operator = 3;
inline bool storesvr_vk::has_cmp_operator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_vk::set_has_cmp_operator() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_vk::clear_has_cmp_operator() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_vk::clear_cmp_operator() {
  cmp_operator_ = 1;
  clear_has_cmp_operator();
}
inline ::storesvr_sqldata::storesvr_cmp_operator storesvr_vk::cmp_operator() const {
  return static_cast< ::storesvr_sqldata::storesvr_cmp_operator >(cmp_operator_);
}
inline void storesvr_vk::set_cmp_operator(::storesvr_sqldata::storesvr_cmp_operator value) {
  assert(::storesvr_sqldata::storesvr_cmp_operator_IsValid(value));
  set_has_cmp_operator();
  cmp_operator_ = value;
}

// optional .storesvr_sqldata.storesvr_column_type column_type = 4 [default = E_COLUMNTYPE_NUM];
inline bool storesvr_vk::has_column_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void storesvr_vk::set_has_column_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void storesvr_vk::clear_has_column_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void storesvr_vk::clear_column_type() {
  column_type_ = 2;
  clear_has_column_type();
}
inline ::storesvr_sqldata::storesvr_column_type storesvr_vk::column_type() const {
  return static_cast< ::storesvr_sqldata::storesvr_column_type >(column_type_);
}
inline void storesvr_vk::set_column_type(::storesvr_sqldata::storesvr_column_type value) {
  assert(::storesvr_sqldata::storesvr_column_type_IsValid(value));
  set_has_column_type();
  column_type_ = value;
}

// optional .storesvr_sqldata.storesvr_logic_operator logic_operator = 5 [default = E_LOGICOP_NONE];
inline bool storesvr_vk::has_logic_operator() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void storesvr_vk::set_has_logic_operator() {
  _has_bits_[0] |= 0x00000010u;
}
inline void storesvr_vk::clear_has_logic_operator() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void storesvr_vk::clear_logic_operator() {
  logic_operator_ = 3;
  clear_has_logic_operator();
}
inline ::storesvr_sqldata::storesvr_logic_operator storesvr_vk::logic_operator() const {
  return static_cast< ::storesvr_sqldata::storesvr_logic_operator >(logic_operator_);
}
inline void storesvr_vk::set_logic_operator(::storesvr_sqldata::storesvr_logic_operator value) {
  assert(::storesvr_sqldata::storesvr_logic_operator_IsValid(value));
  set_has_logic_operator();
  logic_operator_ = value;
}

// -------------------------------------------------------------------

// storesvr_wherecond

// optional uint64 mod_key = 1;
inline bool storesvr_wherecond::has_mod_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_wherecond::set_has_mod_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_wherecond::clear_has_mod_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_wherecond::clear_mod_key() {
  mod_key_ = GOOGLE_ULONGLONG(0);
  clear_has_mod_key();
}
inline ::google::protobuf::uint64 storesvr_wherecond::mod_key() const {
  return mod_key_;
}
inline void storesvr_wherecond::set_mod_key(::google::protobuf::uint64 value) {
  set_has_mod_key();
  mod_key_ = value;
}

// repeated .storesvr_sqldata.storesvr_vk where_conds = 2;
inline int storesvr_wherecond::where_conds_size() const {
  return where_conds_.size();
}
inline void storesvr_wherecond::clear_where_conds() {
  where_conds_.Clear();
}
inline const ::storesvr_sqldata::storesvr_vk& storesvr_wherecond::where_conds(int index) const {
  return where_conds_.Get(index);
}
inline ::storesvr_sqldata::storesvr_vk* storesvr_wherecond::mutable_where_conds(int index) {
  return where_conds_.Mutable(index);
}
inline ::storesvr_sqldata::storesvr_vk* storesvr_wherecond::add_where_conds() {
  return where_conds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::storesvr_sqldata::storesvr_vk >&
storesvr_wherecond::where_conds() const {
  return where_conds_;
}
inline ::google::protobuf::RepeatedPtrField< ::storesvr_sqldata::storesvr_vk >*
storesvr_wherecond::mutable_where_conds() {
  return &where_conds_;
}

// optional string where_additional_conds = 3;
inline bool storesvr_wherecond::has_where_additional_conds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_wherecond::set_has_where_additional_conds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_wherecond::clear_has_where_additional_conds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_wherecond::clear_where_additional_conds() {
  if (where_additional_conds_ != &::google::protobuf::internal::kEmptyString) {
    where_additional_conds_->clear();
  }
  clear_has_where_additional_conds();
}
inline const ::std::string& storesvr_wherecond::where_additional_conds() const {
  return *where_additional_conds_;
}
inline void storesvr_wherecond::set_where_additional_conds(const ::std::string& value) {
  set_has_where_additional_conds();
  if (where_additional_conds_ == &::google::protobuf::internal::kEmptyString) {
    where_additional_conds_ = new ::std::string;
  }
  where_additional_conds_->assign(value);
}
inline void storesvr_wherecond::set_where_additional_conds(const char* value) {
  set_has_where_additional_conds();
  if (where_additional_conds_ == &::google::protobuf::internal::kEmptyString) {
    where_additional_conds_ = new ::std::string;
  }
  where_additional_conds_->assign(value);
}
inline void storesvr_wherecond::set_where_additional_conds(const char* value, size_t size) {
  set_has_where_additional_conds();
  if (where_additional_conds_ == &::google::protobuf::internal::kEmptyString) {
    where_additional_conds_ = new ::std::string;
  }
  where_additional_conds_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_wherecond::mutable_where_additional_conds() {
  set_has_where_additional_conds();
  if (where_additional_conds_ == &::google::protobuf::internal::kEmptyString) {
    where_additional_conds_ = new ::std::string;
  }
  return where_additional_conds_;
}
inline ::std::string* storesvr_wherecond::release_where_additional_conds() {
  clear_has_where_additional_conds();
  if (where_additional_conds_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = where_additional_conds_;
    where_additional_conds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_wherecond::set_allocated_where_additional_conds(::std::string* where_additional_conds) {
  if (where_additional_conds_ != &::google::protobuf::internal::kEmptyString) {
    delete where_additional_conds_;
  }
  if (where_additional_conds) {
    set_has_where_additional_conds();
    where_additional_conds_ = where_additional_conds;
  } else {
    clear_has_where_additional_conds();
    where_additional_conds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// storesvr_baseinfo

// optional string dbname = 1;
inline bool storesvr_baseinfo::has_dbname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_baseinfo::set_has_dbname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_baseinfo::clear_has_dbname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_baseinfo::clear_dbname() {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    dbname_->clear();
  }
  clear_has_dbname();
}
inline const ::std::string& storesvr_baseinfo::dbname() const {
  return *dbname_;
}
inline void storesvr_baseinfo::set_dbname(const ::std::string& value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void storesvr_baseinfo::set_dbname(const char* value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void storesvr_baseinfo::set_dbname(const char* value, size_t size) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_baseinfo::mutable_dbname() {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  return dbname_;
}
inline ::std::string* storesvr_baseinfo::release_dbname() {
  clear_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbname_;
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_baseinfo::set_allocated_dbname(::std::string* dbname) {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    delete dbname_;
  }
  if (dbname) {
    set_has_dbname();
    dbname_ = dbname;
  } else {
    clear_has_dbname();
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tbname = 2;
inline bool storesvr_baseinfo::has_tbname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_baseinfo::set_has_tbname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_baseinfo::clear_has_tbname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_baseinfo::clear_tbname() {
  if (tbname_ != &::google::protobuf::internal::kEmptyString) {
    tbname_->clear();
  }
  clear_has_tbname();
}
inline const ::std::string& storesvr_baseinfo::tbname() const {
  return *tbname_;
}
inline void storesvr_baseinfo::set_tbname(const ::std::string& value) {
  set_has_tbname();
  if (tbname_ == &::google::protobuf::internal::kEmptyString) {
    tbname_ = new ::std::string;
  }
  tbname_->assign(value);
}
inline void storesvr_baseinfo::set_tbname(const char* value) {
  set_has_tbname();
  if (tbname_ == &::google::protobuf::internal::kEmptyString) {
    tbname_ = new ::std::string;
  }
  tbname_->assign(value);
}
inline void storesvr_baseinfo::set_tbname(const char* value, size_t size) {
  set_has_tbname();
  if (tbname_ == &::google::protobuf::internal::kEmptyString) {
    tbname_ = new ::std::string;
  }
  tbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_baseinfo::mutable_tbname() {
  set_has_tbname();
  if (tbname_ == &::google::protobuf::internal::kEmptyString) {
    tbname_ = new ::std::string;
  }
  return tbname_;
}
inline ::std::string* storesvr_baseinfo::release_tbname() {
  clear_has_tbname();
  if (tbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tbname_;
    tbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_baseinfo::set_allocated_tbname(::std::string* tbname) {
  if (tbname_ != &::google::protobuf::internal::kEmptyString) {
    delete tbname_;
  }
  if (tbname) {
    set_has_tbname();
    tbname_ = tbname;
  } else {
    clear_has_tbname();
    tbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string clname = 3;
inline bool storesvr_baseinfo::has_clname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_baseinfo::set_has_clname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_baseinfo::clear_has_clname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_baseinfo::clear_clname() {
  if (clname_ != &::google::protobuf::internal::kEmptyString) {
    clname_->clear();
  }
  clear_has_clname();
}
inline const ::std::string& storesvr_baseinfo::clname() const {
  return *clname_;
}
inline void storesvr_baseinfo::set_clname(const ::std::string& value) {
  set_has_clname();
  if (clname_ == &::google::protobuf::internal::kEmptyString) {
    clname_ = new ::std::string;
  }
  clname_->assign(value);
}
inline void storesvr_baseinfo::set_clname(const char* value) {
  set_has_clname();
  if (clname_ == &::google::protobuf::internal::kEmptyString) {
    clname_ = new ::std::string;
  }
  clname_->assign(value);
}
inline void storesvr_baseinfo::set_clname(const char* value, size_t size) {
  set_has_clname();
  if (clname_ == &::google::protobuf::internal::kEmptyString) {
    clname_ = new ::std::string;
  }
  clname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_baseinfo::mutable_clname() {
  set_has_clname();
  if (clname_ == &::google::protobuf::internal::kEmptyString) {
    clname_ = new ::std::string;
  }
  return clname_;
}
inline ::std::string* storesvr_baseinfo::release_clname() {
  clear_has_clname();
  if (clname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clname_;
    clname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_baseinfo::set_allocated_clname(::std::string* clname) {
  if (clname_ != &::google::protobuf::internal::kEmptyString) {
    delete clname_;
  }
  if (clname) {
    set_has_clname();
    clname_ = clname;
  } else {
    clear_has_clname();
    clname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// storesvr_opres

// optional uint64 mod_key = 1;
inline bool storesvr_opres::has_mod_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_opres::set_has_mod_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_opres::clear_has_mod_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_opres::clear_mod_key() {
  mod_key_ = GOOGLE_ULONGLONG(0);
  clear_has_mod_key();
}
inline ::google::protobuf::uint64 storesvr_opres::mod_key() const {
  return mod_key_;
}
inline void storesvr_opres::set_mod_key(::google::protobuf::uint64 value) {
  set_has_mod_key();
  mod_key_ = value;
}

// optional string zdb_errmsg = 2;
inline bool storesvr_opres::has_zdb_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_opres::set_has_zdb_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_opres::clear_has_zdb_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_opres::clear_zdb_errmsg() {
  if (zdb_errmsg_ != &::google::protobuf::internal::kEmptyString) {
    zdb_errmsg_->clear();
  }
  clear_has_zdb_errmsg();
}
inline const ::std::string& storesvr_opres::zdb_errmsg() const {
  return *zdb_errmsg_;
}
inline void storesvr_opres::set_zdb_errmsg(const ::std::string& value) {
  set_has_zdb_errmsg();
  if (zdb_errmsg_ == &::google::protobuf::internal::kEmptyString) {
    zdb_errmsg_ = new ::std::string;
  }
  zdb_errmsg_->assign(value);
}
inline void storesvr_opres::set_zdb_errmsg(const char* value) {
  set_has_zdb_errmsg();
  if (zdb_errmsg_ == &::google::protobuf::internal::kEmptyString) {
    zdb_errmsg_ = new ::std::string;
  }
  zdb_errmsg_->assign(value);
}
inline void storesvr_opres::set_zdb_errmsg(const char* value, size_t size) {
  set_has_zdb_errmsg();
  if (zdb_errmsg_ == &::google::protobuf::internal::kEmptyString) {
    zdb_errmsg_ = new ::std::string;
  }
  zdb_errmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_opres::mutable_zdb_errmsg() {
  set_has_zdb_errmsg();
  if (zdb_errmsg_ == &::google::protobuf::internal::kEmptyString) {
    zdb_errmsg_ = new ::std::string;
  }
  return zdb_errmsg_;
}
inline ::std::string* storesvr_opres::release_zdb_errmsg() {
  clear_has_zdb_errmsg();
  if (zdb_errmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zdb_errmsg_;
    zdb_errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_opres::set_allocated_zdb_errmsg(::std::string* zdb_errmsg) {
  if (zdb_errmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete zdb_errmsg_;
  }
  if (zdb_errmsg) {
    set_has_zdb_errmsg();
    zdb_errmsg_ = zdb_errmsg;
  } else {
    clear_has_zdb_errmsg();
    zdb_errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// storesvr_sel

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_sel::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_sel::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_sel::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_sel::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_sel::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_sel::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_sel::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_sel::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_wherecond sel_cond = 2;
inline bool storesvr_sel::has_sel_cond() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_sel::set_has_sel_cond() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_sel::clear_has_sel_cond() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_sel::clear_sel_cond() {
  if (sel_cond_ != NULL) sel_cond_->::storesvr_sqldata::storesvr_wherecond::Clear();
  clear_has_sel_cond();
}
inline const ::storesvr_sqldata::storesvr_wherecond& storesvr_sel::sel_cond() const {
  return sel_cond_ != NULL ? *sel_cond_ : *default_instance_->sel_cond_;
}
inline ::storesvr_sqldata::storesvr_wherecond* storesvr_sel::mutable_sel_cond() {
  set_has_sel_cond();
  if (sel_cond_ == NULL) sel_cond_ = new ::storesvr_sqldata::storesvr_wherecond;
  return sel_cond_;
}
inline ::storesvr_sqldata::storesvr_wherecond* storesvr_sel::release_sel_cond() {
  clear_has_sel_cond();
  ::storesvr_sqldata::storesvr_wherecond* temp = sel_cond_;
  sel_cond_ = NULL;
  return temp;
}
inline void storesvr_sel::set_allocated_sel_cond(::storesvr_sqldata::storesvr_wherecond* sel_cond) {
  delete sel_cond_;
  sel_cond_ = sel_cond;
  if (sel_cond) {
    set_has_sel_cond();
  } else {
    clear_has_sel_cond();
  }
}

// -------------------------------------------------------------------

// storesvr_sel_res

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_sel_res::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_sel_res::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_sel_res::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_sel_res::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_sel_res::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_sel_res::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_sel_res::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_sel_res::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_opres sel_opres = 2;
inline bool storesvr_sel_res::has_sel_opres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_sel_res::set_has_sel_opres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_sel_res::clear_has_sel_opres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_sel_res::clear_sel_opres() {
  if (sel_opres_ != NULL) sel_opres_->::storesvr_sqldata::storesvr_opres::Clear();
  clear_has_sel_opres();
}
inline const ::storesvr_sqldata::storesvr_opres& storesvr_sel_res::sel_opres() const {
  return sel_opres_ != NULL ? *sel_opres_ : *default_instance_->sel_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_sel_res::mutable_sel_opres() {
  set_has_sel_opres();
  if (sel_opres_ == NULL) sel_opres_ = new ::storesvr_sqldata::storesvr_opres;
  return sel_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_sel_res::release_sel_opres() {
  clear_has_sel_opres();
  ::storesvr_sqldata::storesvr_opres* temp = sel_opres_;
  sel_opres_ = NULL;
  return temp;
}
inline void storesvr_sel_res::set_allocated_sel_opres(::storesvr_sqldata::storesvr_opres* sel_opres) {
  delete sel_opres_;
  sel_opres_ = sel_opres;
  if (sel_opres) {
    set_has_sel_opres();
  } else {
    clear_has_sel_opres();
  }
}

// optional bool is_lastbatch = 3;
inline bool storesvr_sel_res::has_is_lastbatch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_sel_res::set_has_is_lastbatch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_sel_res::clear_has_is_lastbatch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_sel_res::clear_is_lastbatch() {
  is_lastbatch_ = false;
  clear_has_is_lastbatch();
}
inline bool storesvr_sel_res::is_lastbatch() const {
  return is_lastbatch_;
}
inline void storesvr_sel_res::set_is_lastbatch(bool value) {
  set_has_is_lastbatch();
  is_lastbatch_ = value;
}

// optional int32 row_count = 4;
inline bool storesvr_sel_res::has_row_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void storesvr_sel_res::set_has_row_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void storesvr_sel_res::clear_has_row_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void storesvr_sel_res::clear_row_count() {
  row_count_ = 0;
  clear_has_row_count();
}
inline ::google::protobuf::int32 storesvr_sel_res::row_count() const {
  return row_count_;
}
inline void storesvr_sel_res::set_row_count(::google::protobuf::int32 value) {
  set_has_row_count();
  row_count_ = value;
}

// repeated bytes sel_records = 5;
inline int storesvr_sel_res::sel_records_size() const {
  return sel_records_.size();
}
inline void storesvr_sel_res::clear_sel_records() {
  sel_records_.Clear();
}
inline const ::std::string& storesvr_sel_res::sel_records(int index) const {
  return sel_records_.Get(index);
}
inline ::std::string* storesvr_sel_res::mutable_sel_records(int index) {
  return sel_records_.Mutable(index);
}
inline void storesvr_sel_res::set_sel_records(int index, const ::std::string& value) {
  sel_records_.Mutable(index)->assign(value);
}
inline void storesvr_sel_res::set_sel_records(int index, const char* value) {
  sel_records_.Mutable(index)->assign(value);
}
inline void storesvr_sel_res::set_sel_records(int index, const void* value, size_t size) {
  sel_records_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_sel_res::add_sel_records() {
  return sel_records_.Add();
}
inline void storesvr_sel_res::add_sel_records(const ::std::string& value) {
  sel_records_.Add()->assign(value);
}
inline void storesvr_sel_res::add_sel_records(const char* value) {
  sel_records_.Add()->assign(value);
}
inline void storesvr_sel_res::add_sel_records(const void* value, size_t size) {
  sel_records_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
storesvr_sel_res::sel_records() const {
  return sel_records_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
storesvr_sel_res::mutable_sel_records() {
  return &sel_records_;
}

// -------------------------------------------------------------------

// storesvr_selobj

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_selobj::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_selobj::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_selobj::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_selobj::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_selobj::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_selobj::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_selobj::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_selobj::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional uint64 mod_key = 2;
inline bool storesvr_selobj::has_mod_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_selobj::set_has_mod_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_selobj::clear_has_mod_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_selobj::clear_mod_key() {
  mod_key_ = GOOGLE_ULONGLONG(0);
  clear_has_mod_key();
}
inline ::google::protobuf::uint64 storesvr_selobj::mod_key() const {
  return mod_key_;
}
inline void storesvr_selobj::set_mod_key(::google::protobuf::uint64 value) {
  set_has_mod_key();
  mod_key_ = value;
}

// optional bytes sel_record = 3;
inline bool storesvr_selobj::has_sel_record() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_selobj::set_has_sel_record() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_selobj::clear_has_sel_record() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_selobj::clear_sel_record() {
  if (sel_record_ != &::google::protobuf::internal::kEmptyString) {
    sel_record_->clear();
  }
  clear_has_sel_record();
}
inline const ::std::string& storesvr_selobj::sel_record() const {
  return *sel_record_;
}
inline void storesvr_selobj::set_sel_record(const ::std::string& value) {
  set_has_sel_record();
  if (sel_record_ == &::google::protobuf::internal::kEmptyString) {
    sel_record_ = new ::std::string;
  }
  sel_record_->assign(value);
}
inline void storesvr_selobj::set_sel_record(const char* value) {
  set_has_sel_record();
  if (sel_record_ == &::google::protobuf::internal::kEmptyString) {
    sel_record_ = new ::std::string;
  }
  sel_record_->assign(value);
}
inline void storesvr_selobj::set_sel_record(const void* value, size_t size) {
  set_has_sel_record();
  if (sel_record_ == &::google::protobuf::internal::kEmptyString) {
    sel_record_ = new ::std::string;
  }
  sel_record_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_selobj::mutable_sel_record() {
  set_has_sel_record();
  if (sel_record_ == &::google::protobuf::internal::kEmptyString) {
    sel_record_ = new ::std::string;
  }
  return sel_record_;
}
inline ::std::string* storesvr_selobj::release_sel_record() {
  clear_has_sel_record();
  if (sel_record_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sel_record_;
    sel_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_selobj::set_allocated_sel_record(::std::string* sel_record) {
  if (sel_record_ != &::google::protobuf::internal::kEmptyString) {
    delete sel_record_;
  }
  if (sel_record) {
    set_has_sel_record();
    sel_record_ = sel_record;
  } else {
    clear_has_sel_record();
    sel_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// storesvr_selobj_res

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_selobj_res::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_selobj_res::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_selobj_res::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_selobj_res::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_selobj_res::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_selobj_res::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_selobj_res::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_selobj_res::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_opres sel_opres = 2;
inline bool storesvr_selobj_res::has_sel_opres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_selobj_res::set_has_sel_opres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_selobj_res::clear_has_sel_opres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_selobj_res::clear_sel_opres() {
  if (sel_opres_ != NULL) sel_opres_->::storesvr_sqldata::storesvr_opres::Clear();
  clear_has_sel_opres();
}
inline const ::storesvr_sqldata::storesvr_opres& storesvr_selobj_res::sel_opres() const {
  return sel_opres_ != NULL ? *sel_opres_ : *default_instance_->sel_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_selobj_res::mutable_sel_opres() {
  set_has_sel_opres();
  if (sel_opres_ == NULL) sel_opres_ = new ::storesvr_sqldata::storesvr_opres;
  return sel_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_selobj_res::release_sel_opres() {
  clear_has_sel_opres();
  ::storesvr_sqldata::storesvr_opres* temp = sel_opres_;
  sel_opres_ = NULL;
  return temp;
}
inline void storesvr_selobj_res::set_allocated_sel_opres(::storesvr_sqldata::storesvr_opres* sel_opres) {
  delete sel_opres_;
  sel_opres_ = sel_opres;
  if (sel_opres) {
    set_has_sel_opres();
  } else {
    clear_has_sel_opres();
  }
}

// optional bytes sel_record = 3;
inline bool storesvr_selobj_res::has_sel_record() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_selobj_res::set_has_sel_record() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_selobj_res::clear_has_sel_record() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_selobj_res::clear_sel_record() {
  if (sel_record_ != &::google::protobuf::internal::kEmptyString) {
    sel_record_->clear();
  }
  clear_has_sel_record();
}
inline const ::std::string& storesvr_selobj_res::sel_record() const {
  return *sel_record_;
}
inline void storesvr_selobj_res::set_sel_record(const ::std::string& value) {
  set_has_sel_record();
  if (sel_record_ == &::google::protobuf::internal::kEmptyString) {
    sel_record_ = new ::std::string;
  }
  sel_record_->assign(value);
}
inline void storesvr_selobj_res::set_sel_record(const char* value) {
  set_has_sel_record();
  if (sel_record_ == &::google::protobuf::internal::kEmptyString) {
    sel_record_ = new ::std::string;
  }
  sel_record_->assign(value);
}
inline void storesvr_selobj_res::set_sel_record(const void* value, size_t size) {
  set_has_sel_record();
  if (sel_record_ == &::google::protobuf::internal::kEmptyString) {
    sel_record_ = new ::std::string;
  }
  sel_record_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_selobj_res::mutable_sel_record() {
  set_has_sel_record();
  if (sel_record_ == &::google::protobuf::internal::kEmptyString) {
    sel_record_ = new ::std::string;
  }
  return sel_record_;
}
inline ::std::string* storesvr_selobj_res::release_sel_record() {
  clear_has_sel_record();
  if (sel_record_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sel_record_;
    sel_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_selobj_res::set_allocated_sel_record(::std::string* sel_record) {
  if (sel_record_ != &::google::protobuf::internal::kEmptyString) {
    delete sel_record_;
  }
  if (sel_record) {
    set_has_sel_record();
    sel_record_ = sel_record;
  } else {
    clear_has_sel_record();
    sel_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// storesvr_ins

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_ins::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_ins::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_ins::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_ins::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_ins::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_ins::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_ins::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_ins::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional uint64 mod_key = 2;
inline bool storesvr_ins::has_mod_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_ins::set_has_mod_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_ins::clear_has_mod_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_ins::clear_mod_key() {
  mod_key_ = GOOGLE_ULONGLONG(0);
  clear_has_mod_key();
}
inline ::google::protobuf::uint64 storesvr_ins::mod_key() const {
  return mod_key_;
}
inline void storesvr_ins::set_mod_key(::google::protobuf::uint64 value) {
  set_has_mod_key();
  mod_key_ = value;
}

// optional bytes ins_record = 3;
inline bool storesvr_ins::has_ins_record() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_ins::set_has_ins_record() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_ins::clear_has_ins_record() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_ins::clear_ins_record() {
  if (ins_record_ != &::google::protobuf::internal::kEmptyString) {
    ins_record_->clear();
  }
  clear_has_ins_record();
}
inline const ::std::string& storesvr_ins::ins_record() const {
  return *ins_record_;
}
inline void storesvr_ins::set_ins_record(const ::std::string& value) {
  set_has_ins_record();
  if (ins_record_ == &::google::protobuf::internal::kEmptyString) {
    ins_record_ = new ::std::string;
  }
  ins_record_->assign(value);
}
inline void storesvr_ins::set_ins_record(const char* value) {
  set_has_ins_record();
  if (ins_record_ == &::google::protobuf::internal::kEmptyString) {
    ins_record_ = new ::std::string;
  }
  ins_record_->assign(value);
}
inline void storesvr_ins::set_ins_record(const void* value, size_t size) {
  set_has_ins_record();
  if (ins_record_ == &::google::protobuf::internal::kEmptyString) {
    ins_record_ = new ::std::string;
  }
  ins_record_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_ins::mutable_ins_record() {
  set_has_ins_record();
  if (ins_record_ == &::google::protobuf::internal::kEmptyString) {
    ins_record_ = new ::std::string;
  }
  return ins_record_;
}
inline ::std::string* storesvr_ins::release_ins_record() {
  clear_has_ins_record();
  if (ins_record_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ins_record_;
    ins_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_ins::set_allocated_ins_record(::std::string* ins_record) {
  if (ins_record_ != &::google::protobuf::internal::kEmptyString) {
    delete ins_record_;
  }
  if (ins_record) {
    set_has_ins_record();
    ins_record_ = ins_record;
  } else {
    clear_has_ins_record();
    ins_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// storesvr_ins_res

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_ins_res::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_ins_res::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_ins_res::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_ins_res::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_ins_res::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_ins_res::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_ins_res::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_ins_res::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_opres ins_opres = 2;
inline bool storesvr_ins_res::has_ins_opres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_ins_res::set_has_ins_opres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_ins_res::clear_has_ins_opres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_ins_res::clear_ins_opres() {
  if (ins_opres_ != NULL) ins_opres_->::storesvr_sqldata::storesvr_opres::Clear();
  clear_has_ins_opres();
}
inline const ::storesvr_sqldata::storesvr_opres& storesvr_ins_res::ins_opres() const {
  return ins_opres_ != NULL ? *ins_opres_ : *default_instance_->ins_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_ins_res::mutable_ins_opres() {
  set_has_ins_opres();
  if (ins_opres_ == NULL) ins_opres_ = new ::storesvr_sqldata::storesvr_opres;
  return ins_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_ins_res::release_ins_opres() {
  clear_has_ins_opres();
  ::storesvr_sqldata::storesvr_opres* temp = ins_opres_;
  ins_opres_ = NULL;
  return temp;
}
inline void storesvr_ins_res::set_allocated_ins_opres(::storesvr_sqldata::storesvr_opres* ins_opres) {
  delete ins_opres_;
  ins_opres_ = ins_opres;
  if (ins_opres) {
    set_has_ins_opres();
  } else {
    clear_has_ins_opres();
  }
}

// -------------------------------------------------------------------

// storesvr_del

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_del::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_del::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_del::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_del::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_del::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_del::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_del::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_del::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_wherecond del_cond = 2;
inline bool storesvr_del::has_del_cond() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_del::set_has_del_cond() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_del::clear_has_del_cond() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_del::clear_del_cond() {
  if (del_cond_ != NULL) del_cond_->::storesvr_sqldata::storesvr_wherecond::Clear();
  clear_has_del_cond();
}
inline const ::storesvr_sqldata::storesvr_wherecond& storesvr_del::del_cond() const {
  return del_cond_ != NULL ? *del_cond_ : *default_instance_->del_cond_;
}
inline ::storesvr_sqldata::storesvr_wherecond* storesvr_del::mutable_del_cond() {
  set_has_del_cond();
  if (del_cond_ == NULL) del_cond_ = new ::storesvr_sqldata::storesvr_wherecond;
  return del_cond_;
}
inline ::storesvr_sqldata::storesvr_wherecond* storesvr_del::release_del_cond() {
  clear_has_del_cond();
  ::storesvr_sqldata::storesvr_wherecond* temp = del_cond_;
  del_cond_ = NULL;
  return temp;
}
inline void storesvr_del::set_allocated_del_cond(::storesvr_sqldata::storesvr_wherecond* del_cond) {
  delete del_cond_;
  del_cond_ = del_cond;
  if (del_cond) {
    set_has_del_cond();
  } else {
    clear_has_del_cond();
  }
}

// -------------------------------------------------------------------

// storesvr_del_res

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_del_res::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_del_res::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_del_res::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_del_res::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_del_res::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_del_res::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_del_res::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_del_res::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_opres del_opres = 2;
inline bool storesvr_del_res::has_del_opres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_del_res::set_has_del_opres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_del_res::clear_has_del_opres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_del_res::clear_del_opres() {
  if (del_opres_ != NULL) del_opres_->::storesvr_sqldata::storesvr_opres::Clear();
  clear_has_del_opres();
}
inline const ::storesvr_sqldata::storesvr_opres& storesvr_del_res::del_opres() const {
  return del_opres_ != NULL ? *del_opres_ : *default_instance_->del_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_del_res::mutable_del_opres() {
  set_has_del_opres();
  if (del_opres_ == NULL) del_opres_ = new ::storesvr_sqldata::storesvr_opres;
  return del_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_del_res::release_del_opres() {
  clear_has_del_opres();
  ::storesvr_sqldata::storesvr_opres* temp = del_opres_;
  del_opres_ = NULL;
  return temp;
}
inline void storesvr_del_res::set_allocated_del_opres(::storesvr_sqldata::storesvr_opres* del_opres) {
  delete del_opres_;
  del_opres_ = del_opres;
  if (del_opres) {
    set_has_del_opres();
  } else {
    clear_has_del_opres();
  }
}

// -------------------------------------------------------------------

// storesvr_delobj

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_delobj::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_delobj::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_delobj::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_delobj::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_delobj::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_delobj::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_delobj::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_delobj::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional uint64 mod_key = 2;
inline bool storesvr_delobj::has_mod_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_delobj::set_has_mod_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_delobj::clear_has_mod_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_delobj::clear_mod_key() {
  mod_key_ = GOOGLE_ULONGLONG(0);
  clear_has_mod_key();
}
inline ::google::protobuf::uint64 storesvr_delobj::mod_key() const {
  return mod_key_;
}
inline void storesvr_delobj::set_mod_key(::google::protobuf::uint64 value) {
  set_has_mod_key();
  mod_key_ = value;
}

// optional bytes del_record = 3;
inline bool storesvr_delobj::has_del_record() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_delobj::set_has_del_record() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_delobj::clear_has_del_record() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_delobj::clear_del_record() {
  if (del_record_ != &::google::protobuf::internal::kEmptyString) {
    del_record_->clear();
  }
  clear_has_del_record();
}
inline const ::std::string& storesvr_delobj::del_record() const {
  return *del_record_;
}
inline void storesvr_delobj::set_del_record(const ::std::string& value) {
  set_has_del_record();
  if (del_record_ == &::google::protobuf::internal::kEmptyString) {
    del_record_ = new ::std::string;
  }
  del_record_->assign(value);
}
inline void storesvr_delobj::set_del_record(const char* value) {
  set_has_del_record();
  if (del_record_ == &::google::protobuf::internal::kEmptyString) {
    del_record_ = new ::std::string;
  }
  del_record_->assign(value);
}
inline void storesvr_delobj::set_del_record(const void* value, size_t size) {
  set_has_del_record();
  if (del_record_ == &::google::protobuf::internal::kEmptyString) {
    del_record_ = new ::std::string;
  }
  del_record_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_delobj::mutable_del_record() {
  set_has_del_record();
  if (del_record_ == &::google::protobuf::internal::kEmptyString) {
    del_record_ = new ::std::string;
  }
  return del_record_;
}
inline ::std::string* storesvr_delobj::release_del_record() {
  clear_has_del_record();
  if (del_record_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = del_record_;
    del_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_delobj::set_allocated_del_record(::std::string* del_record) {
  if (del_record_ != &::google::protobuf::internal::kEmptyString) {
    delete del_record_;
  }
  if (del_record) {
    set_has_del_record();
    del_record_ = del_record;
  } else {
    clear_has_del_record();
    del_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// storesvr_delobj_res

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_delobj_res::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_delobj_res::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_delobj_res::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_delobj_res::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_delobj_res::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_delobj_res::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_delobj_res::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_delobj_res::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_opres del_opres = 2;
inline bool storesvr_delobj_res::has_del_opres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_delobj_res::set_has_del_opres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_delobj_res::clear_has_del_opres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_delobj_res::clear_del_opres() {
  if (del_opres_ != NULL) del_opres_->::storesvr_sqldata::storesvr_opres::Clear();
  clear_has_del_opres();
}
inline const ::storesvr_sqldata::storesvr_opres& storesvr_delobj_res::del_opres() const {
  return del_opres_ != NULL ? *del_opres_ : *default_instance_->del_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_delobj_res::mutable_del_opres() {
  set_has_del_opres();
  if (del_opres_ == NULL) del_opres_ = new ::storesvr_sqldata::storesvr_opres;
  return del_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_delobj_res::release_del_opres() {
  clear_has_del_opres();
  ::storesvr_sqldata::storesvr_opres* temp = del_opres_;
  del_opres_ = NULL;
  return temp;
}
inline void storesvr_delobj_res::set_allocated_del_opres(::storesvr_sqldata::storesvr_opres* del_opres) {
  delete del_opres_;
  del_opres_ = del_opres;
  if (del_opres) {
    set_has_del_opres();
  } else {
    clear_has_del_opres();
  }
}

// -------------------------------------------------------------------

// storesvr_mod

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_mod::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_mod::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_mod::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_mod::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_mod::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_mod::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_mod::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_mod::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_wherecond mod_cond = 2;
inline bool storesvr_mod::has_mod_cond() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_mod::set_has_mod_cond() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_mod::clear_has_mod_cond() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_mod::clear_mod_cond() {
  if (mod_cond_ != NULL) mod_cond_->::storesvr_sqldata::storesvr_wherecond::Clear();
  clear_has_mod_cond();
}
inline const ::storesvr_sqldata::storesvr_wherecond& storesvr_mod::mod_cond() const {
  return mod_cond_ != NULL ? *mod_cond_ : *default_instance_->mod_cond_;
}
inline ::storesvr_sqldata::storesvr_wherecond* storesvr_mod::mutable_mod_cond() {
  set_has_mod_cond();
  if (mod_cond_ == NULL) mod_cond_ = new ::storesvr_sqldata::storesvr_wherecond;
  return mod_cond_;
}
inline ::storesvr_sqldata::storesvr_wherecond* storesvr_mod::release_mod_cond() {
  clear_has_mod_cond();
  ::storesvr_sqldata::storesvr_wherecond* temp = mod_cond_;
  mod_cond_ = NULL;
  return temp;
}
inline void storesvr_mod::set_allocated_mod_cond(::storesvr_sqldata::storesvr_wherecond* mod_cond) {
  delete mod_cond_;
  mod_cond_ = mod_cond;
  if (mod_cond) {
    set_has_mod_cond();
  } else {
    clear_has_mod_cond();
  }
}

// optional bytes mod_record = 3;
inline bool storesvr_mod::has_mod_record() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_mod::set_has_mod_record() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_mod::clear_has_mod_record() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_mod::clear_mod_record() {
  if (mod_record_ != &::google::protobuf::internal::kEmptyString) {
    mod_record_->clear();
  }
  clear_has_mod_record();
}
inline const ::std::string& storesvr_mod::mod_record() const {
  return *mod_record_;
}
inline void storesvr_mod::set_mod_record(const ::std::string& value) {
  set_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    mod_record_ = new ::std::string;
  }
  mod_record_->assign(value);
}
inline void storesvr_mod::set_mod_record(const char* value) {
  set_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    mod_record_ = new ::std::string;
  }
  mod_record_->assign(value);
}
inline void storesvr_mod::set_mod_record(const void* value, size_t size) {
  set_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    mod_record_ = new ::std::string;
  }
  mod_record_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_mod::mutable_mod_record() {
  set_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    mod_record_ = new ::std::string;
  }
  return mod_record_;
}
inline ::std::string* storesvr_mod::release_mod_record() {
  clear_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mod_record_;
    mod_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_mod::set_allocated_mod_record(::std::string* mod_record) {
  if (mod_record_ != &::google::protobuf::internal::kEmptyString) {
    delete mod_record_;
  }
  if (mod_record) {
    set_has_mod_record();
    mod_record_ = mod_record;
  } else {
    clear_has_mod_record();
    mod_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// storesvr_mod_res

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_mod_res::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_mod_res::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_mod_res::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_mod_res::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_mod_res::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_mod_res::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_mod_res::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_mod_res::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_opres mod_opres = 2;
inline bool storesvr_mod_res::has_mod_opres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_mod_res::set_has_mod_opres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_mod_res::clear_has_mod_opres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_mod_res::clear_mod_opres() {
  if (mod_opres_ != NULL) mod_opres_->::storesvr_sqldata::storesvr_opres::Clear();
  clear_has_mod_opres();
}
inline const ::storesvr_sqldata::storesvr_opres& storesvr_mod_res::mod_opres() const {
  return mod_opres_ != NULL ? *mod_opres_ : *default_instance_->mod_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_mod_res::mutable_mod_opres() {
  set_has_mod_opres();
  if (mod_opres_ == NULL) mod_opres_ = new ::storesvr_sqldata::storesvr_opres;
  return mod_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_mod_res::release_mod_opres() {
  clear_has_mod_opres();
  ::storesvr_sqldata::storesvr_opres* temp = mod_opres_;
  mod_opres_ = NULL;
  return temp;
}
inline void storesvr_mod_res::set_allocated_mod_opres(::storesvr_sqldata::storesvr_opres* mod_opres) {
  delete mod_opres_;
  mod_opres_ = mod_opres;
  if (mod_opres) {
    set_has_mod_opres();
  } else {
    clear_has_mod_opres();
  }
}

// -------------------------------------------------------------------

// storesvr_modobj

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_modobj::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_modobj::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_modobj::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_modobj::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_modobj::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_modobj::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_modobj::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_modobj::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional uint64 mod_key = 2;
inline bool storesvr_modobj::has_mod_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_modobj::set_has_mod_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_modobj::clear_has_mod_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_modobj::clear_mod_key() {
  mod_key_ = GOOGLE_ULONGLONG(0);
  clear_has_mod_key();
}
inline ::google::protobuf::uint64 storesvr_modobj::mod_key() const {
  return mod_key_;
}
inline void storesvr_modobj::set_mod_key(::google::protobuf::uint64 value) {
  set_has_mod_key();
  mod_key_ = value;
}

// optional bytes mod_record = 3;
inline bool storesvr_modobj::has_mod_record() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_modobj::set_has_mod_record() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_modobj::clear_has_mod_record() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_modobj::clear_mod_record() {
  if (mod_record_ != &::google::protobuf::internal::kEmptyString) {
    mod_record_->clear();
  }
  clear_has_mod_record();
}
inline const ::std::string& storesvr_modobj::mod_record() const {
  return *mod_record_;
}
inline void storesvr_modobj::set_mod_record(const ::std::string& value) {
  set_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    mod_record_ = new ::std::string;
  }
  mod_record_->assign(value);
}
inline void storesvr_modobj::set_mod_record(const char* value) {
  set_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    mod_record_ = new ::std::string;
  }
  mod_record_->assign(value);
}
inline void storesvr_modobj::set_mod_record(const void* value, size_t size) {
  set_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    mod_record_ = new ::std::string;
  }
  mod_record_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_modobj::mutable_mod_record() {
  set_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    mod_record_ = new ::std::string;
  }
  return mod_record_;
}
inline ::std::string* storesvr_modobj::release_mod_record() {
  clear_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mod_record_;
    mod_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_modobj::set_allocated_mod_record(::std::string* mod_record) {
  if (mod_record_ != &::google::protobuf::internal::kEmptyString) {
    delete mod_record_;
  }
  if (mod_record) {
    set_has_mod_record();
    mod_record_ = mod_record;
  } else {
    clear_has_mod_record();
    mod_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// storesvr_modobj_res

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_modobj_res::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_modobj_res::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_modobj_res::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_modobj_res::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_modobj_res::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_modobj_res::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_modobj_res::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_modobj_res::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_opres mod_opres = 2;
inline bool storesvr_modobj_res::has_mod_opres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_modobj_res::set_has_mod_opres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_modobj_res::clear_has_mod_opres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_modobj_res::clear_mod_opres() {
  if (mod_opres_ != NULL) mod_opres_->::storesvr_sqldata::storesvr_opres::Clear();
  clear_has_mod_opres();
}
inline const ::storesvr_sqldata::storesvr_opres& storesvr_modobj_res::mod_opres() const {
  return mod_opres_ != NULL ? *mod_opres_ : *default_instance_->mod_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_modobj_res::mutable_mod_opres() {
  set_has_mod_opres();
  if (mod_opres_ == NULL) mod_opres_ = new ::storesvr_sqldata::storesvr_opres;
  return mod_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_modobj_res::release_mod_opres() {
  clear_has_mod_opres();
  ::storesvr_sqldata::storesvr_opres* temp = mod_opres_;
  mod_opres_ = NULL;
  return temp;
}
inline void storesvr_modobj_res::set_allocated_mod_opres(::storesvr_sqldata::storesvr_opres* mod_opres) {
  delete mod_opres_;
  mod_opres_ = mod_opres;
  if (mod_opres) {
    set_has_mod_opres();
  } else {
    clear_has_mod_opres();
  }
}

// -------------------------------------------------------------------

// storesvr_modins

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_modins::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_modins::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_modins::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_modins::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_modins::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_modins::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_modins::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_modins::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_wherecond mod_cond = 2;
inline bool storesvr_modins::has_mod_cond() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_modins::set_has_mod_cond() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_modins::clear_has_mod_cond() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_modins::clear_mod_cond() {
  if (mod_cond_ != NULL) mod_cond_->::storesvr_sqldata::storesvr_wherecond::Clear();
  clear_has_mod_cond();
}
inline const ::storesvr_sqldata::storesvr_wherecond& storesvr_modins::mod_cond() const {
  return mod_cond_ != NULL ? *mod_cond_ : *default_instance_->mod_cond_;
}
inline ::storesvr_sqldata::storesvr_wherecond* storesvr_modins::mutable_mod_cond() {
  set_has_mod_cond();
  if (mod_cond_ == NULL) mod_cond_ = new ::storesvr_sqldata::storesvr_wherecond;
  return mod_cond_;
}
inline ::storesvr_sqldata::storesvr_wherecond* storesvr_modins::release_mod_cond() {
  clear_has_mod_cond();
  ::storesvr_sqldata::storesvr_wherecond* temp = mod_cond_;
  mod_cond_ = NULL;
  return temp;
}
inline void storesvr_modins::set_allocated_mod_cond(::storesvr_sqldata::storesvr_wherecond* mod_cond) {
  delete mod_cond_;
  mod_cond_ = mod_cond;
  if (mod_cond) {
    set_has_mod_cond();
  } else {
    clear_has_mod_cond();
  }
}

// optional bytes mod_record = 3;
inline bool storesvr_modins::has_mod_record() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_modins::set_has_mod_record() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_modins::clear_has_mod_record() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_modins::clear_mod_record() {
  if (mod_record_ != &::google::protobuf::internal::kEmptyString) {
    mod_record_->clear();
  }
  clear_has_mod_record();
}
inline const ::std::string& storesvr_modins::mod_record() const {
  return *mod_record_;
}
inline void storesvr_modins::set_mod_record(const ::std::string& value) {
  set_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    mod_record_ = new ::std::string;
  }
  mod_record_->assign(value);
}
inline void storesvr_modins::set_mod_record(const char* value) {
  set_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    mod_record_ = new ::std::string;
  }
  mod_record_->assign(value);
}
inline void storesvr_modins::set_mod_record(const void* value, size_t size) {
  set_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    mod_record_ = new ::std::string;
  }
  mod_record_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_modins::mutable_mod_record() {
  set_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    mod_record_ = new ::std::string;
  }
  return mod_record_;
}
inline ::std::string* storesvr_modins::release_mod_record() {
  clear_has_mod_record();
  if (mod_record_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mod_record_;
    mod_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_modins::set_allocated_mod_record(::std::string* mod_record) {
  if (mod_record_ != &::google::protobuf::internal::kEmptyString) {
    delete mod_record_;
  }
  if (mod_record) {
    set_has_mod_record();
    mod_record_ = mod_record;
  } else {
    clear_has_mod_record();
    mod_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// storesvr_modins_res

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_modins_res::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_modins_res::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_modins_res::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_modins_res::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_modins_res::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_modins_res::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_modins_res::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_modins_res::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_opres mod_opres = 2;
inline bool storesvr_modins_res::has_mod_opres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_modins_res::set_has_mod_opres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_modins_res::clear_has_mod_opres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_modins_res::clear_mod_opres() {
  if (mod_opres_ != NULL) mod_opres_->::storesvr_sqldata::storesvr_opres::Clear();
  clear_has_mod_opres();
}
inline const ::storesvr_sqldata::storesvr_opres& storesvr_modins_res::mod_opres() const {
  return mod_opres_ != NULL ? *mod_opres_ : *default_instance_->mod_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_modins_res::mutable_mod_opres() {
  set_has_mod_opres();
  if (mod_opres_ == NULL) mod_opres_ = new ::storesvr_sqldata::storesvr_opres;
  return mod_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_modins_res::release_mod_opres() {
  clear_has_mod_opres();
  ::storesvr_sqldata::storesvr_opres* temp = mod_opres_;
  mod_opres_ = NULL;
  return temp;
}
inline void storesvr_modins_res::set_allocated_mod_opres(::storesvr_sqldata::storesvr_opres* mod_opres) {
  delete mod_opres_;
  mod_opres_ = mod_opres;
  if (mod_opres) {
    set_has_mod_opres();
  } else {
    clear_has_mod_opres();
  }
}

// -------------------------------------------------------------------

// storesvr_modinsobj

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_modinsobj::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_modinsobj::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_modinsobj::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_modinsobj::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_modinsobj::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_modinsobj::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_modinsobj::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_modinsobj::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional uint64 mod_key = 2;
inline bool storesvr_modinsobj::has_mod_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_modinsobj::set_has_mod_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_modinsobj::clear_has_mod_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_modinsobj::clear_mod_key() {
  mod_key_ = GOOGLE_ULONGLONG(0);
  clear_has_mod_key();
}
inline ::google::protobuf::uint64 storesvr_modinsobj::mod_key() const {
  return mod_key_;
}
inline void storesvr_modinsobj::set_mod_key(::google::protobuf::uint64 value) {
  set_has_mod_key();
  mod_key_ = value;
}

// optional bytes modins_record = 3;
inline bool storesvr_modinsobj::has_modins_record() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_modinsobj::set_has_modins_record() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_modinsobj::clear_has_modins_record() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_modinsobj::clear_modins_record() {
  if (modins_record_ != &::google::protobuf::internal::kEmptyString) {
    modins_record_->clear();
  }
  clear_has_modins_record();
}
inline const ::std::string& storesvr_modinsobj::modins_record() const {
  return *modins_record_;
}
inline void storesvr_modinsobj::set_modins_record(const ::std::string& value) {
  set_has_modins_record();
  if (modins_record_ == &::google::protobuf::internal::kEmptyString) {
    modins_record_ = new ::std::string;
  }
  modins_record_->assign(value);
}
inline void storesvr_modinsobj::set_modins_record(const char* value) {
  set_has_modins_record();
  if (modins_record_ == &::google::protobuf::internal::kEmptyString) {
    modins_record_ = new ::std::string;
  }
  modins_record_->assign(value);
}
inline void storesvr_modinsobj::set_modins_record(const void* value, size_t size) {
  set_has_modins_record();
  if (modins_record_ == &::google::protobuf::internal::kEmptyString) {
    modins_record_ = new ::std::string;
  }
  modins_record_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_modinsobj::mutable_modins_record() {
  set_has_modins_record();
  if (modins_record_ == &::google::protobuf::internal::kEmptyString) {
    modins_record_ = new ::std::string;
  }
  return modins_record_;
}
inline ::std::string* storesvr_modinsobj::release_modins_record() {
  clear_has_modins_record();
  if (modins_record_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modins_record_;
    modins_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_modinsobj::set_allocated_modins_record(::std::string* modins_record) {
  if (modins_record_ != &::google::protobuf::internal::kEmptyString) {
    delete modins_record_;
  }
  if (modins_record) {
    set_has_modins_record();
    modins_record_ = modins_record;
  } else {
    clear_has_modins_record();
    modins_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// storesvr_modinsobj_res

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_modinsobj_res::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_modinsobj_res::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_modinsobj_res::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_modinsobj_res::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_modinsobj_res::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_modinsobj_res::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_modinsobj_res::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_modinsobj_res::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_opres modins_opres = 2;
inline bool storesvr_modinsobj_res::has_modins_opres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_modinsobj_res::set_has_modins_opres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_modinsobj_res::clear_has_modins_opres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_modinsobj_res::clear_modins_opres() {
  if (modins_opres_ != NULL) modins_opres_->::storesvr_sqldata::storesvr_opres::Clear();
  clear_has_modins_opres();
}
inline const ::storesvr_sqldata::storesvr_opres& storesvr_modinsobj_res::modins_opres() const {
  return modins_opres_ != NULL ? *modins_opres_ : *default_instance_->modins_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_modinsobj_res::mutable_modins_opres() {
  set_has_modins_opres();
  if (modins_opres_ == NULL) modins_opres_ = new ::storesvr_sqldata::storesvr_opres;
  return modins_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_modinsobj_res::release_modins_opres() {
  clear_has_modins_opres();
  ::storesvr_sqldata::storesvr_opres* temp = modins_opres_;
  modins_opres_ = NULL;
  return temp;
}
inline void storesvr_modinsobj_res::set_allocated_modins_opres(::storesvr_sqldata::storesvr_opres* modins_opres) {
  delete modins_opres_;
  modins_opres_ = modins_opres;
  if (modins_opres) {
    set_has_modins_opres();
  } else {
    clear_has_modins_opres();
  }
}

// -------------------------------------------------------------------

// storesvr_execute

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_execute::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_execute::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_execute::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_execute::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_execute::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_execute::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_execute::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_execute::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional uint64 mod_key = 2;
inline bool storesvr_execute::has_mod_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_execute::set_has_mod_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_execute::clear_has_mod_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_execute::clear_mod_key() {
  mod_key_ = GOOGLE_ULONGLONG(0);
  clear_has_mod_key();
}
inline ::google::protobuf::uint64 storesvr_execute::mod_key() const {
  return mod_key_;
}
inline void storesvr_execute::set_mod_key(::google::protobuf::uint64 value) {
  set_has_mod_key();
  mod_key_ = value;
}

// optional bytes execute_record = 3;
inline bool storesvr_execute::has_execute_record() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void storesvr_execute::set_has_execute_record() {
  _has_bits_[0] |= 0x00000004u;
}
inline void storesvr_execute::clear_has_execute_record() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void storesvr_execute::clear_execute_record() {
  if (execute_record_ != &::google::protobuf::internal::kEmptyString) {
    execute_record_->clear();
  }
  clear_has_execute_record();
}
inline const ::std::string& storesvr_execute::execute_record() const {
  return *execute_record_;
}
inline void storesvr_execute::set_execute_record(const ::std::string& value) {
  set_has_execute_record();
  if (execute_record_ == &::google::protobuf::internal::kEmptyString) {
    execute_record_ = new ::std::string;
  }
  execute_record_->assign(value);
}
inline void storesvr_execute::set_execute_record(const char* value) {
  set_has_execute_record();
  if (execute_record_ == &::google::protobuf::internal::kEmptyString) {
    execute_record_ = new ::std::string;
  }
  execute_record_->assign(value);
}
inline void storesvr_execute::set_execute_record(const void* value, size_t size) {
  set_has_execute_record();
  if (execute_record_ == &::google::protobuf::internal::kEmptyString) {
    execute_record_ = new ::std::string;
  }
  execute_record_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* storesvr_execute::mutable_execute_record() {
  set_has_execute_record();
  if (execute_record_ == &::google::protobuf::internal::kEmptyString) {
    execute_record_ = new ::std::string;
  }
  return execute_record_;
}
inline ::std::string* storesvr_execute::release_execute_record() {
  clear_has_execute_record();
  if (execute_record_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = execute_record_;
    execute_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void storesvr_execute::set_allocated_execute_record(::std::string* execute_record) {
  if (execute_record_ != &::google::protobuf::internal::kEmptyString) {
    delete execute_record_;
  }
  if (execute_record) {
    set_has_execute_record();
    execute_record_ = execute_record;
  } else {
    clear_has_execute_record();
    execute_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// storesvr_execute_res

// optional .storesvr_sqldata.storesvr_baseinfo baseinfo = 1;
inline bool storesvr_execute_res::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void storesvr_execute_res::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void storesvr_execute_res::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void storesvr_execute_res::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::storesvr_sqldata::storesvr_baseinfo::Clear();
  clear_has_baseinfo();
}
inline const ::storesvr_sqldata::storesvr_baseinfo& storesvr_execute_res::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_execute_res::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::storesvr_sqldata::storesvr_baseinfo;
  return baseinfo_;
}
inline ::storesvr_sqldata::storesvr_baseinfo* storesvr_execute_res::release_baseinfo() {
  clear_has_baseinfo();
  ::storesvr_sqldata::storesvr_baseinfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void storesvr_execute_res::set_allocated_baseinfo(::storesvr_sqldata::storesvr_baseinfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// optional .storesvr_sqldata.storesvr_opres exe_opres = 2;
inline bool storesvr_execute_res::has_exe_opres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void storesvr_execute_res::set_has_exe_opres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void storesvr_execute_res::clear_has_exe_opres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void storesvr_execute_res::clear_exe_opres() {
  if (exe_opres_ != NULL) exe_opres_->::storesvr_sqldata::storesvr_opres::Clear();
  clear_has_exe_opres();
}
inline const ::storesvr_sqldata::storesvr_opres& storesvr_execute_res::exe_opres() const {
  return exe_opres_ != NULL ? *exe_opres_ : *default_instance_->exe_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_execute_res::mutable_exe_opres() {
  set_has_exe_opres();
  if (exe_opres_ == NULL) exe_opres_ = new ::storesvr_sqldata::storesvr_opres;
  return exe_opres_;
}
inline ::storesvr_sqldata::storesvr_opres* storesvr_execute_res::release_exe_opres() {
  clear_has_exe_opres();
  ::storesvr_sqldata::storesvr_opres* temp = exe_opres_;
  exe_opres_ = NULL;
  return temp;
}
inline void storesvr_execute_res::set_allocated_exe_opres(::storesvr_sqldata::storesvr_opres* exe_opres) {
  delete exe_opres_;
  exe_opres_ = exe_opres;
  if (exe_opres) {
    set_has_exe_opres();
  } else {
    clear_has_exe_opres();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace storesvr_sqldata

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::storesvr_sqldata::storesvr_logic_operator>() {
  return ::storesvr_sqldata::storesvr_logic_operator_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::storesvr_sqldata::storesvr_cmp_operator>() {
  return ::storesvr_sqldata::storesvr_cmp_operator_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::storesvr_sqldata::storesvr_column_type>() {
  return ::storesvr_sqldata::storesvr_column_type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_storesvr_5fsqldata_2eproto__INCLUDED
