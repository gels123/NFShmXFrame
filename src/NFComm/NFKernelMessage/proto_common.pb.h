// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto_common.proto

#ifndef PROTOBUF_proto_5fcommon_2eproto__INCLUDED
#define PROTOBUF_proto_5fcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "yd_fieldoptions.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_5fcommon_2eproto();
void protobuf_AssignDesc_proto_5fcommon_2eproto();
void protobuf_ShutdownFile_proto_5fcommon_2eproto();

class tbServerMgr;
class pbMysqlConfig;
class pbRedisConfig;
class pbRouteConfig;
class pbNetConfig;
class pbAllServerConfig;
class pbPluginConfig;
class pbTableConfig;
class pbNFServerConfig;

enum NF_SERVER_TYPE {
  NF_ST_NONE = 0,
  NF_ST_MASTER_SERVER = 1,
  NF_ST_ROUTE_AGENT_SERVER = 2,
  NF_ST_ROUTE_SERVER = 3,
  NF_ST_PROXY_SERVER = 4,
  NF_ST_PROXY_SERVER_FOR_CLIENT = 5,
  NF_ST_PROXY_AGENT_SERVER = 6,
  NF_ST_STORE_SERVER = 7,
  NF_ST_LOGIN_SERVER = 8,
  NF_ST_WORLD_SERVER = 9,
  NF_ST_LOGIC_SERVER = 10,
  NF_ST_GAME_SERVER = 11,
  NF_ST_SNS_SERVER = 12,
  NF_ST_WEB_SERVER = 13,
  NF_ST_MONITOR_SERVER = 14,
  NF_ST_MAX = 20
};
bool NF_SERVER_TYPE_IsValid(int value);
const NF_SERVER_TYPE NF_SERVER_TYPE_MIN = NF_ST_NONE;
const NF_SERVER_TYPE NF_SERVER_TYPE_MAX = NF_ST_MAX;
const int NF_SERVER_TYPE_ARRAYSIZE = NF_SERVER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* NF_SERVER_TYPE_descriptor();
inline const ::std::string& NF_SERVER_TYPE_Name(NF_SERVER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    NF_SERVER_TYPE_descriptor(), value);
}
inline bool NF_SERVER_TYPE_Parse(
    const ::std::string& name, NF_SERVER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NF_SERVER_TYPE>(
    NF_SERVER_TYPE_descriptor(), name, value);
}
// ===================================================================

class tbServerMgr : public ::google::protobuf::Message {
 public:
  tbServerMgr();
  virtual ~tbServerMgr();

  tbServerMgr(const tbServerMgr& from);

  inline tbServerMgr& operator=(const tbServerMgr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tbServerMgr& default_instance();

  void Swap(tbServerMgr* other);

  // implements Message ----------------------------------------------

  tbServerMgr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tbServerMgr& from);
  void MergeFrom(const tbServerMgr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string contract = 2;
  inline bool has_contract() const;
  inline void clear_contract();
  static const int kContractFieldNumber = 2;
  inline const ::std::string& contract() const;
  inline void set_contract(const ::std::string& value);
  inline void set_contract(const char* value);
  inline void set_contract(const char* value, size_t size);
  inline ::std::string* mutable_contract();
  inline ::std::string* release_contract();
  inline void set_allocated_contract(::std::string* contract);

  // optional string machine_addr = 3;
  inline bool has_machine_addr() const;
  inline void clear_machine_addr();
  static const int kMachineAddrFieldNumber = 3;
  inline const ::std::string& machine_addr() const;
  inline void set_machine_addr(const ::std::string& value);
  inline void set_machine_addr(const char* value);
  inline void set_machine_addr(const char* value, size_t size);
  inline ::std::string* mutable_machine_addr();
  inline ::std::string* release_machine_addr();
  inline void set_allocated_machine_addr(::std::string* machine_addr);

  // optional string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string bus_name = 5;
  inline bool has_bus_name() const;
  inline void clear_bus_name();
  static const int kBusNameFieldNumber = 5;
  inline const ::std::string& bus_name() const;
  inline void set_bus_name(const ::std::string& value);
  inline void set_bus_name(const char* value);
  inline void set_bus_name(const char* value, size_t size);
  inline ::std::string* mutable_bus_name();
  inline ::std::string* release_bus_name();
  inline void set_allocated_bus_name(::std::string* bus_name);

  // optional string server_desc = 6;
  inline bool has_server_desc() const;
  inline void clear_server_desc();
  static const int kServerDescFieldNumber = 6;
  inline const ::std::string& server_desc() const;
  inline void set_server_desc(const ::std::string& value);
  inline void set_server_desc(const char* value);
  inline void set_server_desc(const char* value, size_t size);
  inline ::std::string* mutable_server_desc();
  inline ::std::string* release_server_desc();
  inline void set_allocated_server_desc(::std::string* server_desc);

  // optional uint32 cur_count = 7;
  inline bool has_cur_count() const;
  inline void clear_cur_count();
  static const int kCurCountFieldNumber = 7;
  inline ::google::protobuf::uint32 cur_count() const;
  inline void set_cur_count(::google::protobuf::uint32 value);

  // optional uint64 last_login_time = 8;
  inline bool has_last_login_time() const;
  inline void clear_last_login_time();
  static const int kLastLoginTimeFieldNumber = 8;
  inline ::google::protobuf::uint64 last_login_time() const;
  inline void set_last_login_time(::google::protobuf::uint64 value);

  // optional uint64 last_logout_time = 9;
  inline bool has_last_logout_time() const;
  inline void clear_last_logout_time();
  static const int kLastLogoutTimeFieldNumber = 9;
  inline ::google::protobuf::uint64 last_logout_time() const;
  inline void set_last_logout_time(::google::protobuf::uint64 value);

  // optional uint64 create_time = 10;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 10;
  inline ::google::protobuf::uint64 create_time() const;
  inline void set_create_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.tbServerMgr)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_contract();
  inline void clear_has_contract();
  inline void set_has_machine_addr();
  inline void clear_has_machine_addr();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_bus_name();
  inline void clear_has_bus_name();
  inline void set_has_server_desc();
  inline void clear_has_server_desc();
  inline void set_has_cur_count();
  inline void clear_has_cur_count();
  inline void set_has_last_login_time();
  inline void clear_has_last_login_time();
  inline void set_has_last_logout_time();
  inline void clear_has_last_logout_time();
  inline void set_has_create_time();
  inline void clear_has_create_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* contract_;
  ::std::string* machine_addr_;
  ::std::string* ip_;
  ::std::string* bus_name_;
  ::std::string* server_desc_;
  ::google::protobuf::uint64 last_login_time_;
  ::google::protobuf::uint64 last_logout_time_;
  ::google::protobuf::uint64 create_time_;
  ::google::protobuf::uint32 cur_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static tbServerMgr* default_instance_;
};
// -------------------------------------------------------------------

class pbMysqlConfig : public ::google::protobuf::Message {
 public:
  pbMysqlConfig();
  virtual ~pbMysqlConfig();

  pbMysqlConfig(const pbMysqlConfig& from);

  inline pbMysqlConfig& operator=(const pbMysqlConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbMysqlConfig& default_instance();

  void Swap(pbMysqlConfig* other);

  // implements Message ----------------------------------------------

  pbMysqlConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbMysqlConfig& from);
  void MergeFrom(const pbMysqlConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string MysqlIp = 1;
  inline bool has_mysqlip() const;
  inline void clear_mysqlip();
  static const int kMysqlIpFieldNumber = 1;
  inline const ::std::string& mysqlip() const;
  inline void set_mysqlip(const ::std::string& value);
  inline void set_mysqlip(const char* value);
  inline void set_mysqlip(const char* value, size_t size);
  inline ::std::string* mutable_mysqlip();
  inline ::std::string* release_mysqlip();
  inline void set_allocated_mysqlip(::std::string* mysqlip);

  // optional uint32 MysqlPort = 2;
  inline bool has_mysqlport() const;
  inline void clear_mysqlport();
  static const int kMysqlPortFieldNumber = 2;
  inline ::google::protobuf::uint32 mysqlport() const;
  inline void set_mysqlport(::google::protobuf::uint32 value);

  // optional string MysqlDbName = 3;
  inline bool has_mysqldbname() const;
  inline void clear_mysqldbname();
  static const int kMysqlDbNameFieldNumber = 3;
  inline const ::std::string& mysqldbname() const;
  inline void set_mysqldbname(const ::std::string& value);
  inline void set_mysqldbname(const char* value);
  inline void set_mysqldbname(const char* value, size_t size);
  inline ::std::string* mutable_mysqldbname();
  inline ::std::string* release_mysqldbname();
  inline void set_allocated_mysqldbname(::std::string* mysqldbname);

  // optional string MysqlUser = 4;
  inline bool has_mysqluser() const;
  inline void clear_mysqluser();
  static const int kMysqlUserFieldNumber = 4;
  inline const ::std::string& mysqluser() const;
  inline void set_mysqluser(const ::std::string& value);
  inline void set_mysqluser(const char* value);
  inline void set_mysqluser(const char* value, size_t size);
  inline ::std::string* mutable_mysqluser();
  inline ::std::string* release_mysqluser();
  inline void set_allocated_mysqluser(::std::string* mysqluser);

  // optional string MysqlPassword = 5;
  inline bool has_mysqlpassword() const;
  inline void clear_mysqlpassword();
  static const int kMysqlPasswordFieldNumber = 5;
  inline const ::std::string& mysqlpassword() const;
  inline void set_mysqlpassword(const ::std::string& value);
  inline void set_mysqlpassword(const char* value);
  inline void set_mysqlpassword(const char* value, size_t size);
  inline ::std::string* mutable_mysqlpassword();
  inline ::std::string* release_mysqlpassword();
  inline void set_allocated_mysqlpassword(::std::string* mysqlpassword);

  // repeated .proto_ff.pbTableConfig TBConfList = 6;
  inline int tbconflist_size() const;
  inline void clear_tbconflist();
  static const int kTBConfListFieldNumber = 6;
  inline const ::proto_ff::pbTableConfig& tbconflist(int index) const;
  inline ::proto_ff::pbTableConfig* mutable_tbconflist(int index);
  inline ::proto_ff::pbTableConfig* add_tbconflist();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig >&
      tbconflist() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig >*
      mutable_tbconflist();

  // @@protoc_insertion_point(class_scope:proto_ff.pbMysqlConfig)
 private:
  inline void set_has_mysqlip();
  inline void clear_has_mysqlip();
  inline void set_has_mysqlport();
  inline void clear_has_mysqlport();
  inline void set_has_mysqldbname();
  inline void clear_has_mysqldbname();
  inline void set_has_mysqluser();
  inline void clear_has_mysqluser();
  inline void set_has_mysqlpassword();
  inline void clear_has_mysqlpassword();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mysqlip_;
  ::std::string* mysqldbname_;
  ::std::string* mysqluser_;
  ::std::string* mysqlpassword_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig > tbconflist_;
  ::google::protobuf::uint32 mysqlport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbMysqlConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbRedisConfig : public ::google::protobuf::Message {
 public:
  pbRedisConfig();
  virtual ~pbRedisConfig();

  pbRedisConfig(const pbRedisConfig& from);

  inline pbRedisConfig& operator=(const pbRedisConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbRedisConfig& default_instance();

  void Swap(pbRedisConfig* other);

  // implements Message ----------------------------------------------

  pbRedisConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbRedisConfig& from);
  void MergeFrom(const pbRedisConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RedisIp = 1;
  inline bool has_redisip() const;
  inline void clear_redisip();
  static const int kRedisIpFieldNumber = 1;
  inline const ::std::string& redisip() const;
  inline void set_redisip(const ::std::string& value);
  inline void set_redisip(const char* value);
  inline void set_redisip(const char* value, size_t size);
  inline ::std::string* mutable_redisip();
  inline ::std::string* release_redisip();
  inline void set_allocated_redisip(::std::string* redisip);

  // optional uint32 RedisPort = 2;
  inline bool has_redisport() const;
  inline void clear_redisport();
  static const int kRedisPortFieldNumber = 2;
  inline ::google::protobuf::uint32 redisport() const;
  inline void set_redisport(::google::protobuf::uint32 value);

  // optional string RedisPass = 3;
  inline bool has_redispass() const;
  inline void clear_redispass();
  static const int kRedisPassFieldNumber = 3;
  inline const ::std::string& redispass() const;
  inline void set_redispass(const ::std::string& value);
  inline void set_redispass(const char* value);
  inline void set_redispass(const char* value, size_t size);
  inline ::std::string* mutable_redispass();
  inline ::std::string* release_redispass();
  inline void set_allocated_redispass(::std::string* redispass);

  // @@protoc_insertion_point(class_scope:proto_ff.pbRedisConfig)
 private:
  inline void set_has_redisip();
  inline void clear_has_redisip();
  inline void set_has_redisport();
  inline void clear_has_redisport();
  inline void set_has_redispass();
  inline void clear_has_redispass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* redisip_;
  ::std::string* redispass_;
  ::google::protobuf::uint32 redisport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbRedisConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbRouteConfig : public ::google::protobuf::Message {
 public:
  pbRouteConfig();
  virtual ~pbRouteConfig();

  pbRouteConfig(const pbRouteConfig& from);

  inline pbRouteConfig& operator=(const pbRouteConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbRouteConfig& default_instance();

  void Swap(pbRouteConfig* other);

  // implements Message ----------------------------------------------

  pbRouteConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbRouteConfig& from);
  void MergeFrom(const pbRouteConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string MasterIp = 1;
  inline bool has_masterip() const;
  inline void clear_masterip();
  static const int kMasterIpFieldNumber = 1;
  inline const ::std::string& masterip() const;
  inline void set_masterip(const ::std::string& value);
  inline void set_masterip(const char* value);
  inline void set_masterip(const char* value, size_t size);
  inline ::std::string* mutable_masterip();
  inline ::std::string* release_masterip();
  inline void set_allocated_masterip(::std::string* masterip);

  // optional uint32 MasterPort = 2;
  inline bool has_masterport() const;
  inline void clear_masterport();
  static const int kMasterPortFieldNumber = 2;
  inline ::google::protobuf::uint32 masterport() const;
  inline void set_masterport(::google::protobuf::uint32 value);

  // optional string NamingHost = 3;
  inline bool has_naminghost() const;
  inline void clear_naminghost();
  static const int kNamingHostFieldNumber = 3;
  inline const ::std::string& naminghost() const;
  inline void set_naminghost(const ::std::string& value);
  inline void set_naminghost(const char* value);
  inline void set_naminghost(const char* value, size_t size);
  inline ::std::string* mutable_naminghost();
  inline ::std::string* release_naminghost();
  inline void set_allocated_naminghost(::std::string* naminghost);

  // optional string NamingPath = 4;
  inline bool has_namingpath() const;
  inline void clear_namingpath();
  static const int kNamingPathFieldNumber = 4;
  inline const ::std::string& namingpath() const;
  inline void set_namingpath(const ::std::string& value);
  inline void set_namingpath(const char* value);
  inline void set_namingpath(const char* value, size_t size);
  inline ::std::string* mutable_namingpath();
  inline ::std::string* release_namingpath();
  inline void set_allocated_namingpath(::std::string* namingpath);

  // optional string RouteAgent = 5;
  inline bool has_routeagent() const;
  inline void clear_routeagent();
  static const int kRouteAgentFieldNumber = 5;
  inline const ::std::string& routeagent() const;
  inline void set_routeagent(const ::std::string& value);
  inline void set_routeagent(const char* value);
  inline void set_routeagent(const char* value, size_t size);
  inline ::std::string* mutable_routeagent();
  inline ::std::string* release_routeagent();
  inline void set_allocated_routeagent(::std::string* routeagent);

  // @@protoc_insertion_point(class_scope:proto_ff.pbRouteConfig)
 private:
  inline void set_has_masterip();
  inline void clear_has_masterip();
  inline void set_has_masterport();
  inline void clear_has_masterport();
  inline void set_has_naminghost();
  inline void clear_has_naminghost();
  inline void set_has_namingpath();
  inline void clear_has_namingpath();
  inline void set_has_routeagent();
  inline void clear_has_routeagent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* masterip_;
  ::std::string* naminghost_;
  ::std::string* namingpath_;
  ::std::string* routeagent_;
  ::google::protobuf::uint32 masterport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbRouteConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbNetConfig : public ::google::protobuf::Message {
 public:
  pbNetConfig();
  virtual ~pbNetConfig();

  pbNetConfig(const pbNetConfig& from);

  inline pbNetConfig& operator=(const pbNetConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbNetConfig& default_instance();

  void Swap(pbNetConfig* other);

  // implements Message ----------------------------------------------

  pbNetConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbNetConfig& from);
  void MergeFrom(const pbNetConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ServerIp = 1;
  inline bool has_serverip() const;
  inline void clear_serverip();
  static const int kServerIpFieldNumber = 1;
  inline const ::std::string& serverip() const;
  inline void set_serverip(const ::std::string& value);
  inline void set_serverip(const char* value);
  inline void set_serverip(const char* value, size_t size);
  inline ::std::string* mutable_serverip();
  inline ::std::string* release_serverip();
  inline void set_allocated_serverip(::std::string* serverip);

  // optional uint32 ServerPort = 2;
  inline bool has_serverport() const;
  inline void clear_serverport();
  static const int kServerPortFieldNumber = 2;
  inline ::google::protobuf::uint32 serverport() const;
  inline void set_serverport(::google::protobuf::uint32 value);

  // optional string ExternalServerIp = 3;
  inline bool has_externalserverip() const;
  inline void clear_externalserverip();
  static const int kExternalServerIpFieldNumber = 3;
  inline const ::std::string& externalserverip() const;
  inline void set_externalserverip(const ::std::string& value);
  inline void set_externalserverip(const char* value);
  inline void set_externalserverip(const char* value, size_t size);
  inline ::std::string* mutable_externalserverip();
  inline ::std::string* release_externalserverip();
  inline void set_allocated_externalserverip(::std::string* externalserverip);

  // optional uint32 ExternalServerPort = 4;
  inline bool has_externalserverport() const;
  inline void clear_externalserverport();
  static const int kExternalServerPortFieldNumber = 4;
  inline ::google::protobuf::uint32 externalserverport() const;
  inline void set_externalserverport(::google::protobuf::uint32 value);

  // optional uint32 HttpPort = 5;
  inline bool has_httpport() const;
  inline void clear_httpport();
  static const int kHttpPortFieldNumber = 5;
  inline ::google::protobuf::uint32 httpport() const;
  inline void set_httpport(::google::protobuf::uint32 value);

  // optional uint32 MaxConnectNum = 6;
  inline bool has_maxconnectnum() const;
  inline void clear_maxconnectnum();
  static const int kMaxConnectNumFieldNumber = 6;
  inline ::google::protobuf::uint32 maxconnectnum() const;
  inline void set_maxconnectnum(::google::protobuf::uint32 value);

  // optional uint32 WorkThreadNum = 7;
  inline bool has_workthreadnum() const;
  inline void clear_workthreadnum();
  static const int kWorkThreadNumFieldNumber = 7;
  inline ::google::protobuf::uint32 workthreadnum() const;
  inline void set_workthreadnum(::google::protobuf::uint32 value);

  // optional uint32 NetThreadNum = 8;
  inline bool has_netthreadnum() const;
  inline void clear_netthreadnum();
  static const int kNetThreadNumFieldNumber = 8;
  inline ::google::protobuf::uint32 netthreadnum() const;
  inline void set_netthreadnum(::google::protobuf::uint32 value);

  // optional bool Security = 9;
  inline bool has_security() const;
  inline void clear_security();
  static const int kSecurityFieldNumber = 9;
  inline bool security() const;
  inline void set_security(bool value);

  // optional bool WebSocket = 10;
  inline bool has_websocket() const;
  inline void clear_websocket();
  static const int kWebSocketFieldNumber = 10;
  inline bool websocket() const;
  inline void set_websocket(bool value);

  // optional uint32 mParseType = 11;
  inline bool has_mparsetype() const;
  inline void clear_mparsetype();
  static const int kMParseTypeFieldNumber = 11;
  inline ::google::protobuf::uint32 mparsetype() const;
  inline void set_mparsetype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.pbNetConfig)
 private:
  inline void set_has_serverip();
  inline void clear_has_serverip();
  inline void set_has_serverport();
  inline void clear_has_serverport();
  inline void set_has_externalserverip();
  inline void clear_has_externalserverip();
  inline void set_has_externalserverport();
  inline void clear_has_externalserverport();
  inline void set_has_httpport();
  inline void clear_has_httpport();
  inline void set_has_maxconnectnum();
  inline void clear_has_maxconnectnum();
  inline void set_has_workthreadnum();
  inline void clear_has_workthreadnum();
  inline void set_has_netthreadnum();
  inline void clear_has_netthreadnum();
  inline void set_has_security();
  inline void clear_has_security();
  inline void set_has_websocket();
  inline void clear_has_websocket();
  inline void set_has_mparsetype();
  inline void clear_has_mparsetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* serverip_;
  ::std::string* externalserverip_;
  ::google::protobuf::uint32 serverport_;
  ::google::protobuf::uint32 externalserverport_;
  ::google::protobuf::uint32 httpport_;
  ::google::protobuf::uint32 maxconnectnum_;
  ::google::protobuf::uint32 workthreadnum_;
  ::google::protobuf::uint32 netthreadnum_;
  bool security_;
  bool websocket_;
  ::google::protobuf::uint32 mparsetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbNetConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbAllServerConfig : public ::google::protobuf::Message {
 public:
  pbAllServerConfig();
  virtual ~pbAllServerConfig();

  pbAllServerConfig(const pbAllServerConfig& from);

  inline pbAllServerConfig& operator=(const pbAllServerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbAllServerConfig& default_instance();

  void Swap(pbAllServerConfig* other);

  // implements Message ----------------------------------------------

  pbAllServerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbAllServerConfig& from);
  void MergeFrom(const pbAllServerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Server = 1;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 1;
  inline const ::std::string& server() const;
  inline void set_server(const ::std::string& value);
  inline void set_server(const char* value);
  inline void set_server(const char* value, size_t size);
  inline ::std::string* mutable_server();
  inline ::std::string* release_server();
  inline void set_allocated_server(::std::string* server);

  // optional string ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional uint32 ServerType = 3;
  inline bool has_servertype() const;
  inline void clear_servertype();
  static const int kServerTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 servertype() const;
  inline void set_servertype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.pbAllServerConfig)
 private:
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_servertype();
  inline void clear_has_servertype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* server_;
  ::std::string* id_;
  ::google::protobuf::uint32 servertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbAllServerConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbPluginConfig : public ::google::protobuf::Message {
 public:
  pbPluginConfig();
  virtual ~pbPluginConfig();

  pbPluginConfig(const pbPluginConfig& from);

  inline pbPluginConfig& operator=(const pbPluginConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbPluginConfig& default_instance();

  void Swap(pbPluginConfig* other);

  // implements Message ----------------------------------------------

  pbPluginConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbPluginConfig& from);
  void MergeFrom(const pbPluginConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ServerType = 1;
  inline bool has_servertype() const;
  inline void clear_servertype();
  static const int kServerTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 servertype() const;
  inline void set_servertype(::google::protobuf::uint32 value);

  // repeated string ServerPlugins = 2;
  inline int serverplugins_size() const;
  inline void clear_serverplugins();
  static const int kServerPluginsFieldNumber = 2;
  inline const ::std::string& serverplugins(int index) const;
  inline ::std::string* mutable_serverplugins(int index);
  inline void set_serverplugins(int index, const ::std::string& value);
  inline void set_serverplugins(int index, const char* value);
  inline void set_serverplugins(int index, const char* value, size_t size);
  inline ::std::string* add_serverplugins();
  inline void add_serverplugins(const ::std::string& value);
  inline void add_serverplugins(const char* value);
  inline void add_serverplugins(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& serverplugins() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_serverplugins();

  // repeated .proto_ff.pbAllServerConfig ServerList = 3;
  inline int serverlist_size() const;
  inline void clear_serverlist();
  static const int kServerListFieldNumber = 3;
  inline const ::proto_ff::pbAllServerConfig& serverlist(int index) const;
  inline ::proto_ff::pbAllServerConfig* mutable_serverlist(int index);
  inline ::proto_ff::pbAllServerConfig* add_serverlist();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::pbAllServerConfig >&
      serverlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::pbAllServerConfig >*
      mutable_serverlist();

  // @@protoc_insertion_point(class_scope:proto_ff.pbPluginConfig)
 private:
  inline void set_has_servertype();
  inline void clear_has_servertype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> serverplugins_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::pbAllServerConfig > serverlist_;
  ::google::protobuf::uint32 servertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbPluginConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbTableConfig : public ::google::protobuf::Message {
 public:
  pbTableConfig();
  virtual ~pbTableConfig();

  pbTableConfig(const pbTableConfig& from);

  inline pbTableConfig& operator=(const pbTableConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbTableConfig& default_instance();

  void Swap(pbTableConfig* other);

  // implements Message ----------------------------------------------

  pbTableConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbTableConfig& from);
  void MergeFrom(const pbTableConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TableName = 1;
  inline bool has_tablename() const;
  inline void clear_tablename();
  static const int kTableNameFieldNumber = 1;
  inline const ::std::string& tablename() const;
  inline void set_tablename(const ::std::string& value);
  inline void set_tablename(const char* value);
  inline void set_tablename(const char* value, size_t size);
  inline ::std::string* mutable_tablename();
  inline ::std::string* release_tablename();
  inline void set_allocated_tablename(::std::string* tablename);

  // optional uint32 TableCount = 2;
  inline bool has_tablecount() const;
  inline void clear_tablecount();
  static const int kTableCountFieldNumber = 2;
  inline ::google::protobuf::uint32 tablecount() const;
  inline void set_tablecount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.pbTableConfig)
 private:
  inline void set_has_tablename();
  inline void clear_has_tablename();
  inline void set_has_tablecount();
  inline void clear_has_tablecount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tablename_;
  ::google::protobuf::uint32 tablecount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbTableConfig* default_instance_;
};
// -------------------------------------------------------------------

class pbNFServerConfig : public ::google::protobuf::Message {
 public:
  pbNFServerConfig();
  virtual ~pbNFServerConfig();

  pbNFServerConfig(const pbNFServerConfig& from);

  inline pbNFServerConfig& operator=(const pbNFServerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbNFServerConfig& default_instance();

  void Swap(pbNFServerConfig* other);

  // implements Message ----------------------------------------------

  pbNFServerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbNFServerConfig& from);
  void MergeFrom(const pbNFServerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ServerId = 1;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIdFieldNumber = 1;
  inline const ::std::string& serverid() const;
  inline void set_serverid(const ::std::string& value);
  inline void set_serverid(const char* value);
  inline void set_serverid(const char* value, size_t size);
  inline ::std::string* mutable_serverid();
  inline ::std::string* release_serverid();
  inline void set_allocated_serverid(::std::string* serverid);

  // optional uint32 ServerType = 2;
  inline bool has_servertype() const;
  inline void clear_servertype();
  static const int kServerTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 servertype() const;
  inline void set_servertype(::google::protobuf::uint32 value);

  // optional string ServerName = 3;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServerNameFieldNumber = 3;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // optional uint32 BusId = 4;
  inline bool has_busid() const;
  inline void clear_busid();
  static const int kBusIdFieldNumber = 4;
  inline ::google::protobuf::uint32 busid() const;
  inline void set_busid(::google::protobuf::uint32 value);

  // optional uint32 BusLength = 5;
  inline bool has_buslength() const;
  inline void clear_buslength();
  static const int kBusLengthFieldNumber = 5;
  inline ::google::protobuf::uint32 buslength() const;
  inline void set_buslength(::google::protobuf::uint32 value);

  // optional string LinkMode = 7;
  inline bool has_linkmode() const;
  inline void clear_linkmode();
  static const int kLinkModeFieldNumber = 7;
  inline const ::std::string& linkmode() const;
  inline void set_linkmode(const ::std::string& value);
  inline void set_linkmode(const char* value);
  inline void set_linkmode(const char* value, size_t size);
  inline ::std::string* mutable_linkmode();
  inline ::std::string* release_linkmode();
  inline void set_allocated_linkmode(::std::string* linkmode);

  // optional string Url = 8;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 8;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional uint32 IdleSleepUs = 9;
  inline bool has_idlesleepus() const;
  inline void clear_idlesleepus();
  static const int kIdleSleepUsFieldNumber = 9;
  inline ::google::protobuf::uint32 idlesleepus() const;
  inline void set_idlesleepus(::google::protobuf::uint32 value);

  // optional string ServerIp = 20;
  inline bool has_serverip() const;
  inline void clear_serverip();
  static const int kServerIpFieldNumber = 20;
  inline const ::std::string& serverip() const;
  inline void set_serverip(const ::std::string& value);
  inline void set_serverip(const char* value);
  inline void set_serverip(const char* value, size_t size);
  inline ::std::string* mutable_serverip();
  inline ::std::string* release_serverip();
  inline void set_allocated_serverip(::std::string* serverip);

  // optional uint32 ServerPort = 21;
  inline bool has_serverport() const;
  inline void clear_serverport();
  static const int kServerPortFieldNumber = 21;
  inline ::google::protobuf::uint32 serverport() const;
  inline void set_serverport(::google::protobuf::uint32 value);

  // optional string ExternalServerIp = 22;
  inline bool has_externalserverip() const;
  inline void clear_externalserverip();
  static const int kExternalServerIpFieldNumber = 22;
  inline const ::std::string& externalserverip() const;
  inline void set_externalserverip(const ::std::string& value);
  inline void set_externalserverip(const char* value);
  inline void set_externalserverip(const char* value, size_t size);
  inline ::std::string* mutable_externalserverip();
  inline ::std::string* release_externalserverip();
  inline void set_allocated_externalserverip(::std::string* externalserverip);

  // optional uint32 ExternalServerPort = 23;
  inline bool has_externalserverport() const;
  inline void clear_externalserverport();
  static const int kExternalServerPortFieldNumber = 23;
  inline ::google::protobuf::uint32 externalserverport() const;
  inline void set_externalserverport(::google::protobuf::uint32 value);

  // optional uint32 HttpPort = 24;
  inline bool has_httpport() const;
  inline void clear_httpport();
  static const int kHttpPortFieldNumber = 24;
  inline ::google::protobuf::uint32 httpport() const;
  inline void set_httpport(::google::protobuf::uint32 value);

  // optional uint32 MaxConnectNum = 25;
  inline bool has_maxconnectnum() const;
  inline void clear_maxconnectnum();
  static const int kMaxConnectNumFieldNumber = 25;
  inline ::google::protobuf::uint32 maxconnectnum() const;
  inline void set_maxconnectnum(::google::protobuf::uint32 value);

  // optional uint32 WorkThreadNum = 26;
  inline bool has_workthreadnum() const;
  inline void clear_workthreadnum();
  static const int kWorkThreadNumFieldNumber = 26;
  inline ::google::protobuf::uint32 workthreadnum() const;
  inline void set_workthreadnum(::google::protobuf::uint32 value);

  // optional uint32 NetThreadNum = 27;
  inline bool has_netthreadnum() const;
  inline void clear_netthreadnum();
  static const int kNetThreadNumFieldNumber = 27;
  inline ::google::protobuf::uint32 netthreadnum() const;
  inline void set_netthreadnum(::google::protobuf::uint32 value);

  // optional bool Security = 28;
  inline bool has_security() const;
  inline void clear_security();
  static const int kSecurityFieldNumber = 28;
  inline bool security() const;
  inline void set_security(bool value);

  // optional bool WebSocket = 29;
  inline bool has_websocket() const;
  inline void clear_websocket();
  static const int kWebSocketFieldNumber = 29;
  inline bool websocket() const;
  inline void set_websocket(bool value);

  // optional uint32 ParseType = 30;
  inline bool has_parsetype() const;
  inline void clear_parsetype();
  static const int kParseTypeFieldNumber = 30;
  inline ::google::protobuf::uint32 parsetype() const;
  inline void set_parsetype(::google::protobuf::uint32 value);

  // optional string MasterIp = 50;
  inline bool has_masterip() const;
  inline void clear_masterip();
  static const int kMasterIpFieldNumber = 50;
  inline const ::std::string& masterip() const;
  inline void set_masterip(const ::std::string& value);
  inline void set_masterip(const char* value);
  inline void set_masterip(const char* value, size_t size);
  inline ::std::string* mutable_masterip();
  inline ::std::string* release_masterip();
  inline void set_allocated_masterip(::std::string* masterip);

  // optional uint32 MasterPort = 51;
  inline bool has_masterport() const;
  inline void clear_masterport();
  static const int kMasterPortFieldNumber = 51;
  inline ::google::protobuf::uint32 masterport() const;
  inline void set_masterport(::google::protobuf::uint32 value);

  // optional string NamingHost = 52;
  inline bool has_naminghost() const;
  inline void clear_naminghost();
  static const int kNamingHostFieldNumber = 52;
  inline const ::std::string& naminghost() const;
  inline void set_naminghost(const ::std::string& value);
  inline void set_naminghost(const char* value);
  inline void set_naminghost(const char* value, size_t size);
  inline ::std::string* mutable_naminghost();
  inline ::std::string* release_naminghost();
  inline void set_allocated_naminghost(::std::string* naminghost);

  // optional string NamingPath = 53;
  inline bool has_namingpath() const;
  inline void clear_namingpath();
  static const int kNamingPathFieldNumber = 53;
  inline const ::std::string& namingpath() const;
  inline void set_namingpath(const ::std::string& value);
  inline void set_namingpath(const char* value);
  inline void set_namingpath(const char* value, size_t size);
  inline ::std::string* mutable_namingpath();
  inline ::std::string* release_namingpath();
  inline void set_allocated_namingpath(::std::string* namingpath);

  // optional string RouteAgent = 54;
  inline bool has_routeagent() const;
  inline void clear_routeagent();
  static const int kRouteAgentFieldNumber = 54;
  inline const ::std::string& routeagent() const;
  inline void set_routeagent(const ::std::string& value);
  inline void set_routeagent(const char* value);
  inline void set_routeagent(const char* value, size_t size);
  inline ::std::string* mutable_routeagent();
  inline ::std::string* release_routeagent();
  inline void set_allocated_routeagent(::std::string* routeagent);

  // optional string MysqlIp = 70;
  inline bool has_mysqlip() const;
  inline void clear_mysqlip();
  static const int kMysqlIpFieldNumber = 70;
  inline const ::std::string& mysqlip() const;
  inline void set_mysqlip(const ::std::string& value);
  inline void set_mysqlip(const char* value);
  inline void set_mysqlip(const char* value, size_t size);
  inline ::std::string* mutable_mysqlip();
  inline ::std::string* release_mysqlip();
  inline void set_allocated_mysqlip(::std::string* mysqlip);

  // optional uint32 MysqlPort = 71;
  inline bool has_mysqlport() const;
  inline void clear_mysqlport();
  static const int kMysqlPortFieldNumber = 71;
  inline ::google::protobuf::uint32 mysqlport() const;
  inline void set_mysqlport(::google::protobuf::uint32 value);

  // optional string MysqlDbName = 72;
  inline bool has_mysqldbname() const;
  inline void clear_mysqldbname();
  static const int kMysqlDbNameFieldNumber = 72;
  inline const ::std::string& mysqldbname() const;
  inline void set_mysqldbname(const ::std::string& value);
  inline void set_mysqldbname(const char* value);
  inline void set_mysqldbname(const char* value, size_t size);
  inline ::std::string* mutable_mysqldbname();
  inline ::std::string* release_mysqldbname();
  inline void set_allocated_mysqldbname(::std::string* mysqldbname);

  // optional string MysqlUser = 73;
  inline bool has_mysqluser() const;
  inline void clear_mysqluser();
  static const int kMysqlUserFieldNumber = 73;
  inline const ::std::string& mysqluser() const;
  inline void set_mysqluser(const ::std::string& value);
  inline void set_mysqluser(const char* value);
  inline void set_mysqluser(const char* value, size_t size);
  inline ::std::string* mutable_mysqluser();
  inline ::std::string* release_mysqluser();
  inline void set_allocated_mysqluser(::std::string* mysqluser);

  // optional string MysqlPassword = 74;
  inline bool has_mysqlpassword() const;
  inline void clear_mysqlpassword();
  static const int kMysqlPasswordFieldNumber = 74;
  inline const ::std::string& mysqlpassword() const;
  inline void set_mysqlpassword(const ::std::string& value);
  inline void set_mysqlpassword(const char* value);
  inline void set_mysqlpassword(const char* value, size_t size);
  inline ::std::string* mutable_mysqlpassword();
  inline ::std::string* release_mysqlpassword();
  inline void set_allocated_mysqlpassword(::std::string* mysqlpassword);

  // optional string DefaultDBName = 75;
  inline bool has_defaultdbname() const;
  inline void clear_defaultdbname();
  static const int kDefaultDBNameFieldNumber = 75;
  inline const ::std::string& defaultdbname() const;
  inline void set_defaultdbname(const ::std::string& value);
  inline void set_defaultdbname(const char* value);
  inline void set_defaultdbname(const char* value, size_t size);
  inline ::std::string* mutable_defaultdbname();
  inline ::std::string* release_defaultdbname();
  inline void set_allocated_defaultdbname(::std::string* defaultdbname);

  // optional string CrossDBName = 76;
  inline bool has_crossdbname() const;
  inline void clear_crossdbname();
  static const int kCrossDBNameFieldNumber = 76;
  inline const ::std::string& crossdbname() const;
  inline void set_crossdbname(const ::std::string& value);
  inline void set_crossdbname(const char* value);
  inline void set_crossdbname(const char* value, size_t size);
  inline ::std::string* mutable_crossdbname();
  inline ::std::string* release_crossdbname();
  inline void set_allocated_crossdbname(::std::string* crossdbname);

  // repeated .proto_ff.pbTableConfig TBConfList = 77;
  inline int tbconflist_size() const;
  inline void clear_tbconflist();
  static const int kTBConfListFieldNumber = 77;
  inline const ::proto_ff::pbTableConfig& tbconflist(int index) const;
  inline ::proto_ff::pbTableConfig* mutable_tbconflist(int index);
  inline ::proto_ff::pbTableConfig* add_tbconflist();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig >&
      tbconflist() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig >*
      mutable_tbconflist();

  // optional string RedisIp = 80;
  inline bool has_redisip() const;
  inline void clear_redisip();
  static const int kRedisIpFieldNumber = 80;
  inline const ::std::string& redisip() const;
  inline void set_redisip(const ::std::string& value);
  inline void set_redisip(const char* value);
  inline void set_redisip(const char* value, size_t size);
  inline ::std::string* mutable_redisip();
  inline ::std::string* release_redisip();
  inline void set_allocated_redisip(::std::string* redisip);

  // optional uint32 RedisPort = 81;
  inline bool has_redisport() const;
  inline void clear_redisport();
  static const int kRedisPortFieldNumber = 81;
  inline ::google::protobuf::uint32 redisport() const;
  inline void set_redisport(::google::protobuf::uint32 value);

  // optional string RedisPass = 82;
  inline bool has_redispass() const;
  inline void clear_redispass();
  static const int kRedisPassFieldNumber = 82;
  inline const ::std::string& redispass() const;
  inline void set_redispass(const ::std::string& value);
  inline void set_redispass(const char* value);
  inline void set_redispass(const char* value, size_t size);
  inline ::std::string* mutable_redispass();
  inline ::std::string* release_redispass();
  inline void set_allocated_redispass(::std::string* redispass);

  // optional string WwwUrl = 90;
  inline bool has_wwwurl() const;
  inline void clear_wwwurl();
  static const int kWwwUrlFieldNumber = 90;
  inline const ::std::string& wwwurl() const;
  inline void set_wwwurl(const ::std::string& value);
  inline void set_wwwurl(const char* value);
  inline void set_wwwurl(const char* value, size_t size);
  inline ::std::string* mutable_wwwurl();
  inline ::std::string* release_wwwurl();
  inline void set_allocated_wwwurl(::std::string* wwwurl);

  // optional string Email = 91;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 91;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional uint32 MaxOnlinePlayerNum = 100;
  inline bool has_maxonlineplayernum() const;
  inline void clear_maxonlineplayernum();
  static const int kMaxOnlinePlayerNumFieldNumber = 100;
  inline ::google::protobuf::uint32 maxonlineplayernum() const;
  inline void set_maxonlineplayernum(::google::protobuf::uint32 value);

  // optional uint32 HeartBeatTimeout = 101;
  inline bool has_heartbeattimeout() const;
  inline void clear_heartbeattimeout();
  static const int kHeartBeatTimeoutFieldNumber = 101;
  inline ::google::protobuf::uint32 heartbeattimeout() const;
  inline void set_heartbeattimeout(::google::protobuf::uint32 value);

  // optional uint32 ClientKeepAliveTimeout = 102;
  inline bool has_clientkeepalivetimeout() const;
  inline void clear_clientkeepalivetimeout();
  static const int kClientKeepAliveTimeoutFieldNumber = 102;
  inline ::google::protobuf::uint32 clientkeepalivetimeout() const;
  inline void set_clientkeepalivetimeout(::google::protobuf::uint32 value);

  // optional uint32 ClientVersion = 103;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 103;
  inline ::google::protobuf::uint32 clientversion() const;
  inline void set_clientversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.pbNFServerConfig)
 private:
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_servertype();
  inline void clear_has_servertype();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_busid();
  inline void clear_has_busid();
  inline void set_has_buslength();
  inline void clear_has_buslength();
  inline void set_has_linkmode();
  inline void clear_has_linkmode();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_idlesleepus();
  inline void clear_has_idlesleepus();
  inline void set_has_serverip();
  inline void clear_has_serverip();
  inline void set_has_serverport();
  inline void clear_has_serverport();
  inline void set_has_externalserverip();
  inline void clear_has_externalserverip();
  inline void set_has_externalserverport();
  inline void clear_has_externalserverport();
  inline void set_has_httpport();
  inline void clear_has_httpport();
  inline void set_has_maxconnectnum();
  inline void clear_has_maxconnectnum();
  inline void set_has_workthreadnum();
  inline void clear_has_workthreadnum();
  inline void set_has_netthreadnum();
  inline void clear_has_netthreadnum();
  inline void set_has_security();
  inline void clear_has_security();
  inline void set_has_websocket();
  inline void clear_has_websocket();
  inline void set_has_parsetype();
  inline void clear_has_parsetype();
  inline void set_has_masterip();
  inline void clear_has_masterip();
  inline void set_has_masterport();
  inline void clear_has_masterport();
  inline void set_has_naminghost();
  inline void clear_has_naminghost();
  inline void set_has_namingpath();
  inline void clear_has_namingpath();
  inline void set_has_routeagent();
  inline void clear_has_routeagent();
  inline void set_has_mysqlip();
  inline void clear_has_mysqlip();
  inline void set_has_mysqlport();
  inline void clear_has_mysqlport();
  inline void set_has_mysqldbname();
  inline void clear_has_mysqldbname();
  inline void set_has_mysqluser();
  inline void clear_has_mysqluser();
  inline void set_has_mysqlpassword();
  inline void clear_has_mysqlpassword();
  inline void set_has_defaultdbname();
  inline void clear_has_defaultdbname();
  inline void set_has_crossdbname();
  inline void clear_has_crossdbname();
  inline void set_has_redisip();
  inline void clear_has_redisip();
  inline void set_has_redisport();
  inline void clear_has_redisport();
  inline void set_has_redispass();
  inline void clear_has_redispass();
  inline void set_has_wwwurl();
  inline void clear_has_wwwurl();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_maxonlineplayernum();
  inline void clear_has_maxonlineplayernum();
  inline void set_has_heartbeattimeout();
  inline void clear_has_heartbeattimeout();
  inline void set_has_clientkeepalivetimeout();
  inline void clear_has_clientkeepalivetimeout();
  inline void set_has_clientversion();
  inline void clear_has_clientversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* serverid_;
  ::std::string* servername_;
  ::google::protobuf::uint32 servertype_;
  ::google::protobuf::uint32 busid_;
  ::std::string* linkmode_;
  ::google::protobuf::uint32 buslength_;
  ::google::protobuf::uint32 idlesleepus_;
  ::std::string* url_;
  ::std::string* serverip_;
  ::google::protobuf::uint32 serverport_;
  ::google::protobuf::uint32 externalserverport_;
  ::std::string* externalserverip_;
  ::google::protobuf::uint32 httpport_;
  ::google::protobuf::uint32 maxconnectnum_;
  ::google::protobuf::uint32 workthreadnum_;
  ::google::protobuf::uint32 netthreadnum_;
  bool security_;
  bool websocket_;
  ::google::protobuf::uint32 parsetype_;
  ::std::string* masterip_;
  ::std::string* naminghost_;
  ::std::string* namingpath_;
  ::google::protobuf::uint32 masterport_;
  ::google::protobuf::uint32 mysqlport_;
  ::std::string* routeagent_;
  ::std::string* mysqlip_;
  ::std::string* mysqldbname_;
  ::std::string* mysqluser_;
  ::std::string* mysqlpassword_;
  ::std::string* defaultdbname_;
  ::std::string* crossdbname_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig > tbconflist_;
  ::std::string* redisip_;
  ::std::string* redispass_;
  ::std::string* wwwurl_;
  ::google::protobuf::uint32 redisport_;
  ::google::protobuf::uint32 maxonlineplayernum_;
  ::std::string* email_;
  ::google::protobuf::uint32 heartbeattimeout_;
  ::google::protobuf::uint32 clientkeepalivetimeout_;
  ::google::protobuf::uint32 clientversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(41 + 31) / 32];

  friend void  protobuf_AddDesc_proto_5fcommon_2eproto();
  friend void protobuf_AssignDesc_proto_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_proto_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static pbNFServerConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// tbServerMgr

// optional uint64 id = 1;
inline bool tbServerMgr::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tbServerMgr::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tbServerMgr::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tbServerMgr::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 tbServerMgr::id() const {
  return id_;
}
inline void tbServerMgr::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string contract = 2;
inline bool tbServerMgr::has_contract() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tbServerMgr::set_has_contract() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tbServerMgr::clear_has_contract() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tbServerMgr::clear_contract() {
  if (contract_ != &::google::protobuf::internal::kEmptyString) {
    contract_->clear();
  }
  clear_has_contract();
}
inline const ::std::string& tbServerMgr::contract() const {
  return *contract_;
}
inline void tbServerMgr::set_contract(const ::std::string& value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::kEmptyString) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
}
inline void tbServerMgr::set_contract(const char* value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::kEmptyString) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
}
inline void tbServerMgr::set_contract(const char* value, size_t size) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::kEmptyString) {
    contract_ = new ::std::string;
  }
  contract_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tbServerMgr::mutable_contract() {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::kEmptyString) {
    contract_ = new ::std::string;
  }
  return contract_;
}
inline ::std::string* tbServerMgr::release_contract() {
  clear_has_contract();
  if (contract_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contract_;
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tbServerMgr::set_allocated_contract(::std::string* contract) {
  if (contract_ != &::google::protobuf::internal::kEmptyString) {
    delete contract_;
  }
  if (contract) {
    set_has_contract();
    contract_ = contract;
  } else {
    clear_has_contract();
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string machine_addr = 3;
inline bool tbServerMgr::has_machine_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tbServerMgr::set_has_machine_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tbServerMgr::clear_has_machine_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tbServerMgr::clear_machine_addr() {
  if (machine_addr_ != &::google::protobuf::internal::kEmptyString) {
    machine_addr_->clear();
  }
  clear_has_machine_addr();
}
inline const ::std::string& tbServerMgr::machine_addr() const {
  return *machine_addr_;
}
inline void tbServerMgr::set_machine_addr(const ::std::string& value) {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  machine_addr_->assign(value);
}
inline void tbServerMgr::set_machine_addr(const char* value) {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  machine_addr_->assign(value);
}
inline void tbServerMgr::set_machine_addr(const char* value, size_t size) {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  machine_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tbServerMgr::mutable_machine_addr() {
  set_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    machine_addr_ = new ::std::string;
  }
  return machine_addr_;
}
inline ::std::string* tbServerMgr::release_machine_addr() {
  clear_has_machine_addr();
  if (machine_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_addr_;
    machine_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tbServerMgr::set_allocated_machine_addr(::std::string* machine_addr) {
  if (machine_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_addr_;
  }
  if (machine_addr) {
    set_has_machine_addr();
    machine_addr_ = machine_addr;
  } else {
    clear_has_machine_addr();
    machine_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 4;
inline bool tbServerMgr::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void tbServerMgr::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void tbServerMgr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void tbServerMgr::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& tbServerMgr::ip() const {
  return *ip_;
}
inline void tbServerMgr::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void tbServerMgr::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void tbServerMgr::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tbServerMgr::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* tbServerMgr::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tbServerMgr::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bus_name = 5;
inline bool tbServerMgr::has_bus_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void tbServerMgr::set_has_bus_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void tbServerMgr::clear_has_bus_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void tbServerMgr::clear_bus_name() {
  if (bus_name_ != &::google::protobuf::internal::kEmptyString) {
    bus_name_->clear();
  }
  clear_has_bus_name();
}
inline const ::std::string& tbServerMgr::bus_name() const {
  return *bus_name_;
}
inline void tbServerMgr::set_bus_name(const ::std::string& value) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(value);
}
inline void tbServerMgr::set_bus_name(const char* value) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(value);
}
inline void tbServerMgr::set_bus_name(const char* value, size_t size) {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  bus_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tbServerMgr::mutable_bus_name() {
  set_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    bus_name_ = new ::std::string;
  }
  return bus_name_;
}
inline ::std::string* tbServerMgr::release_bus_name() {
  clear_has_bus_name();
  if (bus_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bus_name_;
    bus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tbServerMgr::set_allocated_bus_name(::std::string* bus_name) {
  if (bus_name_ != &::google::protobuf::internal::kEmptyString) {
    delete bus_name_;
  }
  if (bus_name) {
    set_has_bus_name();
    bus_name_ = bus_name;
  } else {
    clear_has_bus_name();
    bus_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string server_desc = 6;
inline bool tbServerMgr::has_server_desc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void tbServerMgr::set_has_server_desc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void tbServerMgr::clear_has_server_desc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void tbServerMgr::clear_server_desc() {
  if (server_desc_ != &::google::protobuf::internal::kEmptyString) {
    server_desc_->clear();
  }
  clear_has_server_desc();
}
inline const ::std::string& tbServerMgr::server_desc() const {
  return *server_desc_;
}
inline void tbServerMgr::set_server_desc(const ::std::string& value) {
  set_has_server_desc();
  if (server_desc_ == &::google::protobuf::internal::kEmptyString) {
    server_desc_ = new ::std::string;
  }
  server_desc_->assign(value);
}
inline void tbServerMgr::set_server_desc(const char* value) {
  set_has_server_desc();
  if (server_desc_ == &::google::protobuf::internal::kEmptyString) {
    server_desc_ = new ::std::string;
  }
  server_desc_->assign(value);
}
inline void tbServerMgr::set_server_desc(const char* value, size_t size) {
  set_has_server_desc();
  if (server_desc_ == &::google::protobuf::internal::kEmptyString) {
    server_desc_ = new ::std::string;
  }
  server_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tbServerMgr::mutable_server_desc() {
  set_has_server_desc();
  if (server_desc_ == &::google::protobuf::internal::kEmptyString) {
    server_desc_ = new ::std::string;
  }
  return server_desc_;
}
inline ::std::string* tbServerMgr::release_server_desc() {
  clear_has_server_desc();
  if (server_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_desc_;
    server_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tbServerMgr::set_allocated_server_desc(::std::string* server_desc) {
  if (server_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete server_desc_;
  }
  if (server_desc) {
    set_has_server_desc();
    server_desc_ = server_desc;
  } else {
    clear_has_server_desc();
    server_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 cur_count = 7;
inline bool tbServerMgr::has_cur_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void tbServerMgr::set_has_cur_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void tbServerMgr::clear_has_cur_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void tbServerMgr::clear_cur_count() {
  cur_count_ = 0u;
  clear_has_cur_count();
}
inline ::google::protobuf::uint32 tbServerMgr::cur_count() const {
  return cur_count_;
}
inline void tbServerMgr::set_cur_count(::google::protobuf::uint32 value) {
  set_has_cur_count();
  cur_count_ = value;
}

// optional uint64 last_login_time = 8;
inline bool tbServerMgr::has_last_login_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void tbServerMgr::set_has_last_login_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void tbServerMgr::clear_has_last_login_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void tbServerMgr::clear_last_login_time() {
  last_login_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_login_time();
}
inline ::google::protobuf::uint64 tbServerMgr::last_login_time() const {
  return last_login_time_;
}
inline void tbServerMgr::set_last_login_time(::google::protobuf::uint64 value) {
  set_has_last_login_time();
  last_login_time_ = value;
}

// optional uint64 last_logout_time = 9;
inline bool tbServerMgr::has_last_logout_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void tbServerMgr::set_has_last_logout_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void tbServerMgr::clear_has_last_logout_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void tbServerMgr::clear_last_logout_time() {
  last_logout_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_logout_time();
}
inline ::google::protobuf::uint64 tbServerMgr::last_logout_time() const {
  return last_logout_time_;
}
inline void tbServerMgr::set_last_logout_time(::google::protobuf::uint64 value) {
  set_has_last_logout_time();
  last_logout_time_ = value;
}

// optional uint64 create_time = 10;
inline bool tbServerMgr::has_create_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void tbServerMgr::set_has_create_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void tbServerMgr::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void tbServerMgr::clear_create_time() {
  create_time_ = GOOGLE_ULONGLONG(0);
  clear_has_create_time();
}
inline ::google::protobuf::uint64 tbServerMgr::create_time() const {
  return create_time_;
}
inline void tbServerMgr::set_create_time(::google::protobuf::uint64 value) {
  set_has_create_time();
  create_time_ = value;
}

// -------------------------------------------------------------------

// pbMysqlConfig

// optional string MysqlIp = 1;
inline bool pbMysqlConfig::has_mysqlip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbMysqlConfig::set_has_mysqlip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbMysqlConfig::clear_has_mysqlip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbMysqlConfig::clear_mysqlip() {
  if (mysqlip_ != &::google::protobuf::internal::kEmptyString) {
    mysqlip_->clear();
  }
  clear_has_mysqlip();
}
inline const ::std::string& pbMysqlConfig::mysqlip() const {
  return *mysqlip_;
}
inline void pbMysqlConfig::set_mysqlip(const ::std::string& value) {
  set_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    mysqlip_ = new ::std::string;
  }
  mysqlip_->assign(value);
}
inline void pbMysqlConfig::set_mysqlip(const char* value) {
  set_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    mysqlip_ = new ::std::string;
  }
  mysqlip_->assign(value);
}
inline void pbMysqlConfig::set_mysqlip(const char* value, size_t size) {
  set_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    mysqlip_ = new ::std::string;
  }
  mysqlip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbMysqlConfig::mutable_mysqlip() {
  set_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    mysqlip_ = new ::std::string;
  }
  return mysqlip_;
}
inline ::std::string* pbMysqlConfig::release_mysqlip() {
  clear_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqlip_;
    mysqlip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbMysqlConfig::set_allocated_mysqlip(::std::string* mysqlip) {
  if (mysqlip_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqlip_;
  }
  if (mysqlip) {
    set_has_mysqlip();
    mysqlip_ = mysqlip;
  } else {
    clear_has_mysqlip();
    mysqlip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 MysqlPort = 2;
inline bool pbMysqlConfig::has_mysqlport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbMysqlConfig::set_has_mysqlport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbMysqlConfig::clear_has_mysqlport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbMysqlConfig::clear_mysqlport() {
  mysqlport_ = 0u;
  clear_has_mysqlport();
}
inline ::google::protobuf::uint32 pbMysqlConfig::mysqlport() const {
  return mysqlport_;
}
inline void pbMysqlConfig::set_mysqlport(::google::protobuf::uint32 value) {
  set_has_mysqlport();
  mysqlport_ = value;
}

// optional string MysqlDbName = 3;
inline bool pbMysqlConfig::has_mysqldbname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbMysqlConfig::set_has_mysqldbname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbMysqlConfig::clear_has_mysqldbname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbMysqlConfig::clear_mysqldbname() {
  if (mysqldbname_ != &::google::protobuf::internal::kEmptyString) {
    mysqldbname_->clear();
  }
  clear_has_mysqldbname();
}
inline const ::std::string& pbMysqlConfig::mysqldbname() const {
  return *mysqldbname_;
}
inline void pbMysqlConfig::set_mysqldbname(const ::std::string& value) {
  set_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    mysqldbname_ = new ::std::string;
  }
  mysqldbname_->assign(value);
}
inline void pbMysqlConfig::set_mysqldbname(const char* value) {
  set_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    mysqldbname_ = new ::std::string;
  }
  mysqldbname_->assign(value);
}
inline void pbMysqlConfig::set_mysqldbname(const char* value, size_t size) {
  set_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    mysqldbname_ = new ::std::string;
  }
  mysqldbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbMysqlConfig::mutable_mysqldbname() {
  set_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    mysqldbname_ = new ::std::string;
  }
  return mysqldbname_;
}
inline ::std::string* pbMysqlConfig::release_mysqldbname() {
  clear_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqldbname_;
    mysqldbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbMysqlConfig::set_allocated_mysqldbname(::std::string* mysqldbname) {
  if (mysqldbname_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqldbname_;
  }
  if (mysqldbname) {
    set_has_mysqldbname();
    mysqldbname_ = mysqldbname;
  } else {
    clear_has_mysqldbname();
    mysqldbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MysqlUser = 4;
inline bool pbMysqlConfig::has_mysqluser() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbMysqlConfig::set_has_mysqluser() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbMysqlConfig::clear_has_mysqluser() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbMysqlConfig::clear_mysqluser() {
  if (mysqluser_ != &::google::protobuf::internal::kEmptyString) {
    mysqluser_->clear();
  }
  clear_has_mysqluser();
}
inline const ::std::string& pbMysqlConfig::mysqluser() const {
  return *mysqluser_;
}
inline void pbMysqlConfig::set_mysqluser(const ::std::string& value) {
  set_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    mysqluser_ = new ::std::string;
  }
  mysqluser_->assign(value);
}
inline void pbMysqlConfig::set_mysqluser(const char* value) {
  set_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    mysqluser_ = new ::std::string;
  }
  mysqluser_->assign(value);
}
inline void pbMysqlConfig::set_mysqluser(const char* value, size_t size) {
  set_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    mysqluser_ = new ::std::string;
  }
  mysqluser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbMysqlConfig::mutable_mysqluser() {
  set_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    mysqluser_ = new ::std::string;
  }
  return mysqluser_;
}
inline ::std::string* pbMysqlConfig::release_mysqluser() {
  clear_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqluser_;
    mysqluser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbMysqlConfig::set_allocated_mysqluser(::std::string* mysqluser) {
  if (mysqluser_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqluser_;
  }
  if (mysqluser) {
    set_has_mysqluser();
    mysqluser_ = mysqluser;
  } else {
    clear_has_mysqluser();
    mysqluser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MysqlPassword = 5;
inline bool pbMysqlConfig::has_mysqlpassword() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbMysqlConfig::set_has_mysqlpassword() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbMysqlConfig::clear_has_mysqlpassword() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbMysqlConfig::clear_mysqlpassword() {
  if (mysqlpassword_ != &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_->clear();
  }
  clear_has_mysqlpassword();
}
inline const ::std::string& pbMysqlConfig::mysqlpassword() const {
  return *mysqlpassword_;
}
inline void pbMysqlConfig::set_mysqlpassword(const ::std::string& value) {
  set_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_ = new ::std::string;
  }
  mysqlpassword_->assign(value);
}
inline void pbMysqlConfig::set_mysqlpassword(const char* value) {
  set_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_ = new ::std::string;
  }
  mysqlpassword_->assign(value);
}
inline void pbMysqlConfig::set_mysqlpassword(const char* value, size_t size) {
  set_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_ = new ::std::string;
  }
  mysqlpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbMysqlConfig::mutable_mysqlpassword() {
  set_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_ = new ::std::string;
  }
  return mysqlpassword_;
}
inline ::std::string* pbMysqlConfig::release_mysqlpassword() {
  clear_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqlpassword_;
    mysqlpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbMysqlConfig::set_allocated_mysqlpassword(::std::string* mysqlpassword) {
  if (mysqlpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqlpassword_;
  }
  if (mysqlpassword) {
    set_has_mysqlpassword();
    mysqlpassword_ = mysqlpassword;
  } else {
    clear_has_mysqlpassword();
    mysqlpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto_ff.pbTableConfig TBConfList = 6;
inline int pbMysqlConfig::tbconflist_size() const {
  return tbconflist_.size();
}
inline void pbMysqlConfig::clear_tbconflist() {
  tbconflist_.Clear();
}
inline const ::proto_ff::pbTableConfig& pbMysqlConfig::tbconflist(int index) const {
  return tbconflist_.Get(index);
}
inline ::proto_ff::pbTableConfig* pbMysqlConfig::mutable_tbconflist(int index) {
  return tbconflist_.Mutable(index);
}
inline ::proto_ff::pbTableConfig* pbMysqlConfig::add_tbconflist() {
  return tbconflist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig >&
pbMysqlConfig::tbconflist() const {
  return tbconflist_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig >*
pbMysqlConfig::mutable_tbconflist() {
  return &tbconflist_;
}

// -------------------------------------------------------------------

// pbRedisConfig

// optional string RedisIp = 1;
inline bool pbRedisConfig::has_redisip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbRedisConfig::set_has_redisip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbRedisConfig::clear_has_redisip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbRedisConfig::clear_redisip() {
  if (redisip_ != &::google::protobuf::internal::kEmptyString) {
    redisip_->clear();
  }
  clear_has_redisip();
}
inline const ::std::string& pbRedisConfig::redisip() const {
  return *redisip_;
}
inline void pbRedisConfig::set_redisip(const ::std::string& value) {
  set_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    redisip_ = new ::std::string;
  }
  redisip_->assign(value);
}
inline void pbRedisConfig::set_redisip(const char* value) {
  set_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    redisip_ = new ::std::string;
  }
  redisip_->assign(value);
}
inline void pbRedisConfig::set_redisip(const char* value, size_t size) {
  set_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    redisip_ = new ::std::string;
  }
  redisip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbRedisConfig::mutable_redisip() {
  set_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    redisip_ = new ::std::string;
  }
  return redisip_;
}
inline ::std::string* pbRedisConfig::release_redisip() {
  clear_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = redisip_;
    redisip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbRedisConfig::set_allocated_redisip(::std::string* redisip) {
  if (redisip_ != &::google::protobuf::internal::kEmptyString) {
    delete redisip_;
  }
  if (redisip) {
    set_has_redisip();
    redisip_ = redisip;
  } else {
    clear_has_redisip();
    redisip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 RedisPort = 2;
inline bool pbRedisConfig::has_redisport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbRedisConfig::set_has_redisport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbRedisConfig::clear_has_redisport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbRedisConfig::clear_redisport() {
  redisport_ = 0u;
  clear_has_redisport();
}
inline ::google::protobuf::uint32 pbRedisConfig::redisport() const {
  return redisport_;
}
inline void pbRedisConfig::set_redisport(::google::protobuf::uint32 value) {
  set_has_redisport();
  redisport_ = value;
}

// optional string RedisPass = 3;
inline bool pbRedisConfig::has_redispass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbRedisConfig::set_has_redispass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbRedisConfig::clear_has_redispass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbRedisConfig::clear_redispass() {
  if (redispass_ != &::google::protobuf::internal::kEmptyString) {
    redispass_->clear();
  }
  clear_has_redispass();
}
inline const ::std::string& pbRedisConfig::redispass() const {
  return *redispass_;
}
inline void pbRedisConfig::set_redispass(const ::std::string& value) {
  set_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    redispass_ = new ::std::string;
  }
  redispass_->assign(value);
}
inline void pbRedisConfig::set_redispass(const char* value) {
  set_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    redispass_ = new ::std::string;
  }
  redispass_->assign(value);
}
inline void pbRedisConfig::set_redispass(const char* value, size_t size) {
  set_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    redispass_ = new ::std::string;
  }
  redispass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbRedisConfig::mutable_redispass() {
  set_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    redispass_ = new ::std::string;
  }
  return redispass_;
}
inline ::std::string* pbRedisConfig::release_redispass() {
  clear_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = redispass_;
    redispass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbRedisConfig::set_allocated_redispass(::std::string* redispass) {
  if (redispass_ != &::google::protobuf::internal::kEmptyString) {
    delete redispass_;
  }
  if (redispass) {
    set_has_redispass();
    redispass_ = redispass;
  } else {
    clear_has_redispass();
    redispass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// pbRouteConfig

// optional string MasterIp = 1;
inline bool pbRouteConfig::has_masterip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbRouteConfig::set_has_masterip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbRouteConfig::clear_has_masterip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbRouteConfig::clear_masterip() {
  if (masterip_ != &::google::protobuf::internal::kEmptyString) {
    masterip_->clear();
  }
  clear_has_masterip();
}
inline const ::std::string& pbRouteConfig::masterip() const {
  return *masterip_;
}
inline void pbRouteConfig::set_masterip(const ::std::string& value) {
  set_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    masterip_ = new ::std::string;
  }
  masterip_->assign(value);
}
inline void pbRouteConfig::set_masterip(const char* value) {
  set_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    masterip_ = new ::std::string;
  }
  masterip_->assign(value);
}
inline void pbRouteConfig::set_masterip(const char* value, size_t size) {
  set_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    masterip_ = new ::std::string;
  }
  masterip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbRouteConfig::mutable_masterip() {
  set_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    masterip_ = new ::std::string;
  }
  return masterip_;
}
inline ::std::string* pbRouteConfig::release_masterip() {
  clear_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = masterip_;
    masterip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbRouteConfig::set_allocated_masterip(::std::string* masterip) {
  if (masterip_ != &::google::protobuf::internal::kEmptyString) {
    delete masterip_;
  }
  if (masterip) {
    set_has_masterip();
    masterip_ = masterip;
  } else {
    clear_has_masterip();
    masterip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 MasterPort = 2;
inline bool pbRouteConfig::has_masterport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbRouteConfig::set_has_masterport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbRouteConfig::clear_has_masterport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbRouteConfig::clear_masterport() {
  masterport_ = 0u;
  clear_has_masterport();
}
inline ::google::protobuf::uint32 pbRouteConfig::masterport() const {
  return masterport_;
}
inline void pbRouteConfig::set_masterport(::google::protobuf::uint32 value) {
  set_has_masterport();
  masterport_ = value;
}

// optional string NamingHost = 3;
inline bool pbRouteConfig::has_naminghost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbRouteConfig::set_has_naminghost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbRouteConfig::clear_has_naminghost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbRouteConfig::clear_naminghost() {
  if (naminghost_ != &::google::protobuf::internal::kEmptyString) {
    naminghost_->clear();
  }
  clear_has_naminghost();
}
inline const ::std::string& pbRouteConfig::naminghost() const {
  return *naminghost_;
}
inline void pbRouteConfig::set_naminghost(const ::std::string& value) {
  set_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    naminghost_ = new ::std::string;
  }
  naminghost_->assign(value);
}
inline void pbRouteConfig::set_naminghost(const char* value) {
  set_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    naminghost_ = new ::std::string;
  }
  naminghost_->assign(value);
}
inline void pbRouteConfig::set_naminghost(const char* value, size_t size) {
  set_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    naminghost_ = new ::std::string;
  }
  naminghost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbRouteConfig::mutable_naminghost() {
  set_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    naminghost_ = new ::std::string;
  }
  return naminghost_;
}
inline ::std::string* pbRouteConfig::release_naminghost() {
  clear_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = naminghost_;
    naminghost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbRouteConfig::set_allocated_naminghost(::std::string* naminghost) {
  if (naminghost_ != &::google::protobuf::internal::kEmptyString) {
    delete naminghost_;
  }
  if (naminghost) {
    set_has_naminghost();
    naminghost_ = naminghost;
  } else {
    clear_has_naminghost();
    naminghost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string NamingPath = 4;
inline bool pbRouteConfig::has_namingpath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbRouteConfig::set_has_namingpath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbRouteConfig::clear_has_namingpath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbRouteConfig::clear_namingpath() {
  if (namingpath_ != &::google::protobuf::internal::kEmptyString) {
    namingpath_->clear();
  }
  clear_has_namingpath();
}
inline const ::std::string& pbRouteConfig::namingpath() const {
  return *namingpath_;
}
inline void pbRouteConfig::set_namingpath(const ::std::string& value) {
  set_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    namingpath_ = new ::std::string;
  }
  namingpath_->assign(value);
}
inline void pbRouteConfig::set_namingpath(const char* value) {
  set_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    namingpath_ = new ::std::string;
  }
  namingpath_->assign(value);
}
inline void pbRouteConfig::set_namingpath(const char* value, size_t size) {
  set_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    namingpath_ = new ::std::string;
  }
  namingpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbRouteConfig::mutable_namingpath() {
  set_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    namingpath_ = new ::std::string;
  }
  return namingpath_;
}
inline ::std::string* pbRouteConfig::release_namingpath() {
  clear_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = namingpath_;
    namingpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbRouteConfig::set_allocated_namingpath(::std::string* namingpath) {
  if (namingpath_ != &::google::protobuf::internal::kEmptyString) {
    delete namingpath_;
  }
  if (namingpath) {
    set_has_namingpath();
    namingpath_ = namingpath;
  } else {
    clear_has_namingpath();
    namingpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string RouteAgent = 5;
inline bool pbRouteConfig::has_routeagent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbRouteConfig::set_has_routeagent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbRouteConfig::clear_has_routeagent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbRouteConfig::clear_routeagent() {
  if (routeagent_ != &::google::protobuf::internal::kEmptyString) {
    routeagent_->clear();
  }
  clear_has_routeagent();
}
inline const ::std::string& pbRouteConfig::routeagent() const {
  return *routeagent_;
}
inline void pbRouteConfig::set_routeagent(const ::std::string& value) {
  set_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    routeagent_ = new ::std::string;
  }
  routeagent_->assign(value);
}
inline void pbRouteConfig::set_routeagent(const char* value) {
  set_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    routeagent_ = new ::std::string;
  }
  routeagent_->assign(value);
}
inline void pbRouteConfig::set_routeagent(const char* value, size_t size) {
  set_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    routeagent_ = new ::std::string;
  }
  routeagent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbRouteConfig::mutable_routeagent() {
  set_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    routeagent_ = new ::std::string;
  }
  return routeagent_;
}
inline ::std::string* pbRouteConfig::release_routeagent() {
  clear_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = routeagent_;
    routeagent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbRouteConfig::set_allocated_routeagent(::std::string* routeagent) {
  if (routeagent_ != &::google::protobuf::internal::kEmptyString) {
    delete routeagent_;
  }
  if (routeagent) {
    set_has_routeagent();
    routeagent_ = routeagent;
  } else {
    clear_has_routeagent();
    routeagent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// pbNetConfig

// optional string ServerIp = 1;
inline bool pbNetConfig::has_serverip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbNetConfig::set_has_serverip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbNetConfig::clear_has_serverip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbNetConfig::clear_serverip() {
  if (serverip_ != &::google::protobuf::internal::kEmptyString) {
    serverip_->clear();
  }
  clear_has_serverip();
}
inline const ::std::string& pbNetConfig::serverip() const {
  return *serverip_;
}
inline void pbNetConfig::set_serverip(const ::std::string& value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
}
inline void pbNetConfig::set_serverip(const char* value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
}
inline void pbNetConfig::set_serverip(const char* value, size_t size) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNetConfig::mutable_serverip() {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    serverip_ = new ::std::string;
  }
  return serverip_;
}
inline ::std::string* pbNetConfig::release_serverip() {
  clear_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverip_;
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNetConfig::set_allocated_serverip(::std::string* serverip) {
  if (serverip_ != &::google::protobuf::internal::kEmptyString) {
    delete serverip_;
  }
  if (serverip) {
    set_has_serverip();
    serverip_ = serverip;
  } else {
    clear_has_serverip();
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ServerPort = 2;
inline bool pbNetConfig::has_serverport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbNetConfig::set_has_serverport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbNetConfig::clear_has_serverport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbNetConfig::clear_serverport() {
  serverport_ = 0u;
  clear_has_serverport();
}
inline ::google::protobuf::uint32 pbNetConfig::serverport() const {
  return serverport_;
}
inline void pbNetConfig::set_serverport(::google::protobuf::uint32 value) {
  set_has_serverport();
  serverport_ = value;
}

// optional string ExternalServerIp = 3;
inline bool pbNetConfig::has_externalserverip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbNetConfig::set_has_externalserverip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbNetConfig::clear_has_externalserverip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbNetConfig::clear_externalserverip() {
  if (externalserverip_ != &::google::protobuf::internal::kEmptyString) {
    externalserverip_->clear();
  }
  clear_has_externalserverip();
}
inline const ::std::string& pbNetConfig::externalserverip() const {
  return *externalserverip_;
}
inline void pbNetConfig::set_externalserverip(const ::std::string& value) {
  set_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    externalserverip_ = new ::std::string;
  }
  externalserverip_->assign(value);
}
inline void pbNetConfig::set_externalserverip(const char* value) {
  set_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    externalserverip_ = new ::std::string;
  }
  externalserverip_->assign(value);
}
inline void pbNetConfig::set_externalserverip(const char* value, size_t size) {
  set_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    externalserverip_ = new ::std::string;
  }
  externalserverip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNetConfig::mutable_externalserverip() {
  set_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    externalserverip_ = new ::std::string;
  }
  return externalserverip_;
}
inline ::std::string* pbNetConfig::release_externalserverip() {
  clear_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = externalserverip_;
    externalserverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNetConfig::set_allocated_externalserverip(::std::string* externalserverip) {
  if (externalserverip_ != &::google::protobuf::internal::kEmptyString) {
    delete externalserverip_;
  }
  if (externalserverip) {
    set_has_externalserverip();
    externalserverip_ = externalserverip;
  } else {
    clear_has_externalserverip();
    externalserverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ExternalServerPort = 4;
inline bool pbNetConfig::has_externalserverport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbNetConfig::set_has_externalserverport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbNetConfig::clear_has_externalserverport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbNetConfig::clear_externalserverport() {
  externalserverport_ = 0u;
  clear_has_externalserverport();
}
inline ::google::protobuf::uint32 pbNetConfig::externalserverport() const {
  return externalserverport_;
}
inline void pbNetConfig::set_externalserverport(::google::protobuf::uint32 value) {
  set_has_externalserverport();
  externalserverport_ = value;
}

// optional uint32 HttpPort = 5;
inline bool pbNetConfig::has_httpport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbNetConfig::set_has_httpport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbNetConfig::clear_has_httpport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbNetConfig::clear_httpport() {
  httpport_ = 0u;
  clear_has_httpport();
}
inline ::google::protobuf::uint32 pbNetConfig::httpport() const {
  return httpport_;
}
inline void pbNetConfig::set_httpport(::google::protobuf::uint32 value) {
  set_has_httpport();
  httpport_ = value;
}

// optional uint32 MaxConnectNum = 6;
inline bool pbNetConfig::has_maxconnectnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbNetConfig::set_has_maxconnectnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbNetConfig::clear_has_maxconnectnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbNetConfig::clear_maxconnectnum() {
  maxconnectnum_ = 0u;
  clear_has_maxconnectnum();
}
inline ::google::protobuf::uint32 pbNetConfig::maxconnectnum() const {
  return maxconnectnum_;
}
inline void pbNetConfig::set_maxconnectnum(::google::protobuf::uint32 value) {
  set_has_maxconnectnum();
  maxconnectnum_ = value;
}

// optional uint32 WorkThreadNum = 7;
inline bool pbNetConfig::has_workthreadnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbNetConfig::set_has_workthreadnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbNetConfig::clear_has_workthreadnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbNetConfig::clear_workthreadnum() {
  workthreadnum_ = 0u;
  clear_has_workthreadnum();
}
inline ::google::protobuf::uint32 pbNetConfig::workthreadnum() const {
  return workthreadnum_;
}
inline void pbNetConfig::set_workthreadnum(::google::protobuf::uint32 value) {
  set_has_workthreadnum();
  workthreadnum_ = value;
}

// optional uint32 NetThreadNum = 8;
inline bool pbNetConfig::has_netthreadnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbNetConfig::set_has_netthreadnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbNetConfig::clear_has_netthreadnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbNetConfig::clear_netthreadnum() {
  netthreadnum_ = 0u;
  clear_has_netthreadnum();
}
inline ::google::protobuf::uint32 pbNetConfig::netthreadnum() const {
  return netthreadnum_;
}
inline void pbNetConfig::set_netthreadnum(::google::protobuf::uint32 value) {
  set_has_netthreadnum();
  netthreadnum_ = value;
}

// optional bool Security = 9;
inline bool pbNetConfig::has_security() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbNetConfig::set_has_security() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbNetConfig::clear_has_security() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbNetConfig::clear_security() {
  security_ = false;
  clear_has_security();
}
inline bool pbNetConfig::security() const {
  return security_;
}
inline void pbNetConfig::set_security(bool value) {
  set_has_security();
  security_ = value;
}

// optional bool WebSocket = 10;
inline bool pbNetConfig::has_websocket() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pbNetConfig::set_has_websocket() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pbNetConfig::clear_has_websocket() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pbNetConfig::clear_websocket() {
  websocket_ = false;
  clear_has_websocket();
}
inline bool pbNetConfig::websocket() const {
  return websocket_;
}
inline void pbNetConfig::set_websocket(bool value) {
  set_has_websocket();
  websocket_ = value;
}

// optional uint32 mParseType = 11;
inline bool pbNetConfig::has_mparsetype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void pbNetConfig::set_has_mparsetype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void pbNetConfig::clear_has_mparsetype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void pbNetConfig::clear_mparsetype() {
  mparsetype_ = 0u;
  clear_has_mparsetype();
}
inline ::google::protobuf::uint32 pbNetConfig::mparsetype() const {
  return mparsetype_;
}
inline void pbNetConfig::set_mparsetype(::google::protobuf::uint32 value) {
  set_has_mparsetype();
  mparsetype_ = value;
}

// -------------------------------------------------------------------

// pbAllServerConfig

// optional string Server = 1;
inline bool pbAllServerConfig::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbAllServerConfig::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbAllServerConfig::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbAllServerConfig::clear_server() {
  if (server_ != &::google::protobuf::internal::kEmptyString) {
    server_->clear();
  }
  clear_has_server();
}
inline const ::std::string& pbAllServerConfig::server() const {
  return *server_;
}
inline void pbAllServerConfig::set_server(const ::std::string& value) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void pbAllServerConfig::set_server(const char* value) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void pbAllServerConfig::set_server(const char* value, size_t size) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbAllServerConfig::mutable_server() {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  return server_;
}
inline ::std::string* pbAllServerConfig::release_server() {
  clear_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_;
    server_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbAllServerConfig::set_allocated_server(::std::string* server) {
  if (server_ != &::google::protobuf::internal::kEmptyString) {
    delete server_;
  }
  if (server) {
    set_has_server();
    server_ = server;
  } else {
    clear_has_server();
    server_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ID = 2;
inline bool pbAllServerConfig::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbAllServerConfig::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbAllServerConfig::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbAllServerConfig::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& pbAllServerConfig::id() const {
  return *id_;
}
inline void pbAllServerConfig::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void pbAllServerConfig::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void pbAllServerConfig::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbAllServerConfig::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* pbAllServerConfig::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbAllServerConfig::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ServerType = 3;
inline bool pbAllServerConfig::has_servertype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbAllServerConfig::set_has_servertype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbAllServerConfig::clear_has_servertype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbAllServerConfig::clear_servertype() {
  servertype_ = 0u;
  clear_has_servertype();
}
inline ::google::protobuf::uint32 pbAllServerConfig::servertype() const {
  return servertype_;
}
inline void pbAllServerConfig::set_servertype(::google::protobuf::uint32 value) {
  set_has_servertype();
  servertype_ = value;
}

// -------------------------------------------------------------------

// pbPluginConfig

// optional uint32 ServerType = 1;
inline bool pbPluginConfig::has_servertype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbPluginConfig::set_has_servertype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbPluginConfig::clear_has_servertype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbPluginConfig::clear_servertype() {
  servertype_ = 0u;
  clear_has_servertype();
}
inline ::google::protobuf::uint32 pbPluginConfig::servertype() const {
  return servertype_;
}
inline void pbPluginConfig::set_servertype(::google::protobuf::uint32 value) {
  set_has_servertype();
  servertype_ = value;
}

// repeated string ServerPlugins = 2;
inline int pbPluginConfig::serverplugins_size() const {
  return serverplugins_.size();
}
inline void pbPluginConfig::clear_serverplugins() {
  serverplugins_.Clear();
}
inline const ::std::string& pbPluginConfig::serverplugins(int index) const {
  return serverplugins_.Get(index);
}
inline ::std::string* pbPluginConfig::mutable_serverplugins(int index) {
  return serverplugins_.Mutable(index);
}
inline void pbPluginConfig::set_serverplugins(int index, const ::std::string& value) {
  serverplugins_.Mutable(index)->assign(value);
}
inline void pbPluginConfig::set_serverplugins(int index, const char* value) {
  serverplugins_.Mutable(index)->assign(value);
}
inline void pbPluginConfig::set_serverplugins(int index, const char* value, size_t size) {
  serverplugins_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbPluginConfig::add_serverplugins() {
  return serverplugins_.Add();
}
inline void pbPluginConfig::add_serverplugins(const ::std::string& value) {
  serverplugins_.Add()->assign(value);
}
inline void pbPluginConfig::add_serverplugins(const char* value) {
  serverplugins_.Add()->assign(value);
}
inline void pbPluginConfig::add_serverplugins(const char* value, size_t size) {
  serverplugins_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
pbPluginConfig::serverplugins() const {
  return serverplugins_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
pbPluginConfig::mutable_serverplugins() {
  return &serverplugins_;
}

// repeated .proto_ff.pbAllServerConfig ServerList = 3;
inline int pbPluginConfig::serverlist_size() const {
  return serverlist_.size();
}
inline void pbPluginConfig::clear_serverlist() {
  serverlist_.Clear();
}
inline const ::proto_ff::pbAllServerConfig& pbPluginConfig::serverlist(int index) const {
  return serverlist_.Get(index);
}
inline ::proto_ff::pbAllServerConfig* pbPluginConfig::mutable_serverlist(int index) {
  return serverlist_.Mutable(index);
}
inline ::proto_ff::pbAllServerConfig* pbPluginConfig::add_serverlist() {
  return serverlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::pbAllServerConfig >&
pbPluginConfig::serverlist() const {
  return serverlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::pbAllServerConfig >*
pbPluginConfig::mutable_serverlist() {
  return &serverlist_;
}

// -------------------------------------------------------------------

// pbTableConfig

// optional string TableName = 1;
inline bool pbTableConfig::has_tablename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbTableConfig::set_has_tablename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbTableConfig::clear_has_tablename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbTableConfig::clear_tablename() {
  if (tablename_ != &::google::protobuf::internal::kEmptyString) {
    tablename_->clear();
  }
  clear_has_tablename();
}
inline const ::std::string& pbTableConfig::tablename() const {
  return *tablename_;
}
inline void pbTableConfig::set_tablename(const ::std::string& value) {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(value);
}
inline void pbTableConfig::set_tablename(const char* value) {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(value);
}
inline void pbTableConfig::set_tablename(const char* value, size_t size) {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbTableConfig::mutable_tablename() {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  return tablename_;
}
inline ::std::string* pbTableConfig::release_tablename() {
  clear_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tablename_;
    tablename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbTableConfig::set_allocated_tablename(::std::string* tablename) {
  if (tablename_ != &::google::protobuf::internal::kEmptyString) {
    delete tablename_;
  }
  if (tablename) {
    set_has_tablename();
    tablename_ = tablename;
  } else {
    clear_has_tablename();
    tablename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 TableCount = 2;
inline bool pbTableConfig::has_tablecount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbTableConfig::set_has_tablecount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbTableConfig::clear_has_tablecount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbTableConfig::clear_tablecount() {
  tablecount_ = 0u;
  clear_has_tablecount();
}
inline ::google::protobuf::uint32 pbTableConfig::tablecount() const {
  return tablecount_;
}
inline void pbTableConfig::set_tablecount(::google::protobuf::uint32 value) {
  set_has_tablecount();
  tablecount_ = value;
}

// -------------------------------------------------------------------

// pbNFServerConfig

// optional string ServerId = 1;
inline bool pbNFServerConfig::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbNFServerConfig::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbNFServerConfig::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbNFServerConfig::clear_serverid() {
  if (serverid_ != &::google::protobuf::internal::kEmptyString) {
    serverid_->clear();
  }
  clear_has_serverid();
}
inline const ::std::string& pbNFServerConfig::serverid() const {
  return *serverid_;
}
inline void pbNFServerConfig::set_serverid(const ::std::string& value) {
  set_has_serverid();
  if (serverid_ == &::google::protobuf::internal::kEmptyString) {
    serverid_ = new ::std::string;
  }
  serverid_->assign(value);
}
inline void pbNFServerConfig::set_serverid(const char* value) {
  set_has_serverid();
  if (serverid_ == &::google::protobuf::internal::kEmptyString) {
    serverid_ = new ::std::string;
  }
  serverid_->assign(value);
}
inline void pbNFServerConfig::set_serverid(const char* value, size_t size) {
  set_has_serverid();
  if (serverid_ == &::google::protobuf::internal::kEmptyString) {
    serverid_ = new ::std::string;
  }
  serverid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_serverid() {
  set_has_serverid();
  if (serverid_ == &::google::protobuf::internal::kEmptyString) {
    serverid_ = new ::std::string;
  }
  return serverid_;
}
inline ::std::string* pbNFServerConfig::release_serverid() {
  clear_has_serverid();
  if (serverid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverid_;
    serverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_serverid(::std::string* serverid) {
  if (serverid_ != &::google::protobuf::internal::kEmptyString) {
    delete serverid_;
  }
  if (serverid) {
    set_has_serverid();
    serverid_ = serverid;
  } else {
    clear_has_serverid();
    serverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ServerType = 2;
inline bool pbNFServerConfig::has_servertype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbNFServerConfig::set_has_servertype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbNFServerConfig::clear_has_servertype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbNFServerConfig::clear_servertype() {
  servertype_ = 0u;
  clear_has_servertype();
}
inline ::google::protobuf::uint32 pbNFServerConfig::servertype() const {
  return servertype_;
}
inline void pbNFServerConfig::set_servertype(::google::protobuf::uint32 value) {
  set_has_servertype();
  servertype_ = value;
}

// optional string ServerName = 3;
inline bool pbNFServerConfig::has_servername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbNFServerConfig::set_has_servername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbNFServerConfig::clear_has_servername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbNFServerConfig::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& pbNFServerConfig::servername() const {
  return *servername_;
}
inline void pbNFServerConfig::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void pbNFServerConfig::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void pbNFServerConfig::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* pbNFServerConfig::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 BusId = 4;
inline bool pbNFServerConfig::has_busid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbNFServerConfig::set_has_busid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbNFServerConfig::clear_has_busid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbNFServerConfig::clear_busid() {
  busid_ = 0u;
  clear_has_busid();
}
inline ::google::protobuf::uint32 pbNFServerConfig::busid() const {
  return busid_;
}
inline void pbNFServerConfig::set_busid(::google::protobuf::uint32 value) {
  set_has_busid();
  busid_ = value;
}

// optional uint32 BusLength = 5;
inline bool pbNFServerConfig::has_buslength() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbNFServerConfig::set_has_buslength() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbNFServerConfig::clear_has_buslength() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbNFServerConfig::clear_buslength() {
  buslength_ = 0u;
  clear_has_buslength();
}
inline ::google::protobuf::uint32 pbNFServerConfig::buslength() const {
  return buslength_;
}
inline void pbNFServerConfig::set_buslength(::google::protobuf::uint32 value) {
  set_has_buslength();
  buslength_ = value;
}

// optional string LinkMode = 7;
inline bool pbNFServerConfig::has_linkmode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbNFServerConfig::set_has_linkmode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbNFServerConfig::clear_has_linkmode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbNFServerConfig::clear_linkmode() {
  if (linkmode_ != &::google::protobuf::internal::kEmptyString) {
    linkmode_->clear();
  }
  clear_has_linkmode();
}
inline const ::std::string& pbNFServerConfig::linkmode() const {
  return *linkmode_;
}
inline void pbNFServerConfig::set_linkmode(const ::std::string& value) {
  set_has_linkmode();
  if (linkmode_ == &::google::protobuf::internal::kEmptyString) {
    linkmode_ = new ::std::string;
  }
  linkmode_->assign(value);
}
inline void pbNFServerConfig::set_linkmode(const char* value) {
  set_has_linkmode();
  if (linkmode_ == &::google::protobuf::internal::kEmptyString) {
    linkmode_ = new ::std::string;
  }
  linkmode_->assign(value);
}
inline void pbNFServerConfig::set_linkmode(const char* value, size_t size) {
  set_has_linkmode();
  if (linkmode_ == &::google::protobuf::internal::kEmptyString) {
    linkmode_ = new ::std::string;
  }
  linkmode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_linkmode() {
  set_has_linkmode();
  if (linkmode_ == &::google::protobuf::internal::kEmptyString) {
    linkmode_ = new ::std::string;
  }
  return linkmode_;
}
inline ::std::string* pbNFServerConfig::release_linkmode() {
  clear_has_linkmode();
  if (linkmode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = linkmode_;
    linkmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_linkmode(::std::string* linkmode) {
  if (linkmode_ != &::google::protobuf::internal::kEmptyString) {
    delete linkmode_;
  }
  if (linkmode) {
    set_has_linkmode();
    linkmode_ = linkmode;
  } else {
    clear_has_linkmode();
    linkmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Url = 8;
inline bool pbNFServerConfig::has_url() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbNFServerConfig::set_has_url() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbNFServerConfig::clear_has_url() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbNFServerConfig::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& pbNFServerConfig::url() const {
  return *url_;
}
inline void pbNFServerConfig::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void pbNFServerConfig::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void pbNFServerConfig::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* pbNFServerConfig::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 IdleSleepUs = 9;
inline bool pbNFServerConfig::has_idlesleepus() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbNFServerConfig::set_has_idlesleepus() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbNFServerConfig::clear_has_idlesleepus() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbNFServerConfig::clear_idlesleepus() {
  idlesleepus_ = 0u;
  clear_has_idlesleepus();
}
inline ::google::protobuf::uint32 pbNFServerConfig::idlesleepus() const {
  return idlesleepus_;
}
inline void pbNFServerConfig::set_idlesleepus(::google::protobuf::uint32 value) {
  set_has_idlesleepus();
  idlesleepus_ = value;
}

// optional string ServerIp = 20;
inline bool pbNFServerConfig::has_serverip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbNFServerConfig::set_has_serverip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbNFServerConfig::clear_has_serverip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbNFServerConfig::clear_serverip() {
  if (serverip_ != &::google::protobuf::internal::kEmptyString) {
    serverip_->clear();
  }
  clear_has_serverip();
}
inline const ::std::string& pbNFServerConfig::serverip() const {
  return *serverip_;
}
inline void pbNFServerConfig::set_serverip(const ::std::string& value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
}
inline void pbNFServerConfig::set_serverip(const char* value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
}
inline void pbNFServerConfig::set_serverip(const char* value, size_t size) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_serverip() {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    serverip_ = new ::std::string;
  }
  return serverip_;
}
inline ::std::string* pbNFServerConfig::release_serverip() {
  clear_has_serverip();
  if (serverip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverip_;
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_serverip(::std::string* serverip) {
  if (serverip_ != &::google::protobuf::internal::kEmptyString) {
    delete serverip_;
  }
  if (serverip) {
    set_has_serverip();
    serverip_ = serverip;
  } else {
    clear_has_serverip();
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ServerPort = 21;
inline bool pbNFServerConfig::has_serverport() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pbNFServerConfig::set_has_serverport() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pbNFServerConfig::clear_has_serverport() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pbNFServerConfig::clear_serverport() {
  serverport_ = 0u;
  clear_has_serverport();
}
inline ::google::protobuf::uint32 pbNFServerConfig::serverport() const {
  return serverport_;
}
inline void pbNFServerConfig::set_serverport(::google::protobuf::uint32 value) {
  set_has_serverport();
  serverport_ = value;
}

// optional string ExternalServerIp = 22;
inline bool pbNFServerConfig::has_externalserverip() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void pbNFServerConfig::set_has_externalserverip() {
  _has_bits_[0] |= 0x00000400u;
}
inline void pbNFServerConfig::clear_has_externalserverip() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void pbNFServerConfig::clear_externalserverip() {
  if (externalserverip_ != &::google::protobuf::internal::kEmptyString) {
    externalserverip_->clear();
  }
  clear_has_externalserverip();
}
inline const ::std::string& pbNFServerConfig::externalserverip() const {
  return *externalserverip_;
}
inline void pbNFServerConfig::set_externalserverip(const ::std::string& value) {
  set_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    externalserverip_ = new ::std::string;
  }
  externalserverip_->assign(value);
}
inline void pbNFServerConfig::set_externalserverip(const char* value) {
  set_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    externalserverip_ = new ::std::string;
  }
  externalserverip_->assign(value);
}
inline void pbNFServerConfig::set_externalserverip(const char* value, size_t size) {
  set_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    externalserverip_ = new ::std::string;
  }
  externalserverip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_externalserverip() {
  set_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    externalserverip_ = new ::std::string;
  }
  return externalserverip_;
}
inline ::std::string* pbNFServerConfig::release_externalserverip() {
  clear_has_externalserverip();
  if (externalserverip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = externalserverip_;
    externalserverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_externalserverip(::std::string* externalserverip) {
  if (externalserverip_ != &::google::protobuf::internal::kEmptyString) {
    delete externalserverip_;
  }
  if (externalserverip) {
    set_has_externalserverip();
    externalserverip_ = externalserverip;
  } else {
    clear_has_externalserverip();
    externalserverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ExternalServerPort = 23;
inline bool pbNFServerConfig::has_externalserverport() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void pbNFServerConfig::set_has_externalserverport() {
  _has_bits_[0] |= 0x00000800u;
}
inline void pbNFServerConfig::clear_has_externalserverport() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void pbNFServerConfig::clear_externalserverport() {
  externalserverport_ = 0u;
  clear_has_externalserverport();
}
inline ::google::protobuf::uint32 pbNFServerConfig::externalserverport() const {
  return externalserverport_;
}
inline void pbNFServerConfig::set_externalserverport(::google::protobuf::uint32 value) {
  set_has_externalserverport();
  externalserverport_ = value;
}

// optional uint32 HttpPort = 24;
inline bool pbNFServerConfig::has_httpport() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void pbNFServerConfig::set_has_httpport() {
  _has_bits_[0] |= 0x00001000u;
}
inline void pbNFServerConfig::clear_has_httpport() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void pbNFServerConfig::clear_httpport() {
  httpport_ = 0u;
  clear_has_httpport();
}
inline ::google::protobuf::uint32 pbNFServerConfig::httpport() const {
  return httpport_;
}
inline void pbNFServerConfig::set_httpport(::google::protobuf::uint32 value) {
  set_has_httpport();
  httpport_ = value;
}

// optional uint32 MaxConnectNum = 25;
inline bool pbNFServerConfig::has_maxconnectnum() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void pbNFServerConfig::set_has_maxconnectnum() {
  _has_bits_[0] |= 0x00002000u;
}
inline void pbNFServerConfig::clear_has_maxconnectnum() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void pbNFServerConfig::clear_maxconnectnum() {
  maxconnectnum_ = 0u;
  clear_has_maxconnectnum();
}
inline ::google::protobuf::uint32 pbNFServerConfig::maxconnectnum() const {
  return maxconnectnum_;
}
inline void pbNFServerConfig::set_maxconnectnum(::google::protobuf::uint32 value) {
  set_has_maxconnectnum();
  maxconnectnum_ = value;
}

// optional uint32 WorkThreadNum = 26;
inline bool pbNFServerConfig::has_workthreadnum() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void pbNFServerConfig::set_has_workthreadnum() {
  _has_bits_[0] |= 0x00004000u;
}
inline void pbNFServerConfig::clear_has_workthreadnum() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void pbNFServerConfig::clear_workthreadnum() {
  workthreadnum_ = 0u;
  clear_has_workthreadnum();
}
inline ::google::protobuf::uint32 pbNFServerConfig::workthreadnum() const {
  return workthreadnum_;
}
inline void pbNFServerConfig::set_workthreadnum(::google::protobuf::uint32 value) {
  set_has_workthreadnum();
  workthreadnum_ = value;
}

// optional uint32 NetThreadNum = 27;
inline bool pbNFServerConfig::has_netthreadnum() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void pbNFServerConfig::set_has_netthreadnum() {
  _has_bits_[0] |= 0x00008000u;
}
inline void pbNFServerConfig::clear_has_netthreadnum() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void pbNFServerConfig::clear_netthreadnum() {
  netthreadnum_ = 0u;
  clear_has_netthreadnum();
}
inline ::google::protobuf::uint32 pbNFServerConfig::netthreadnum() const {
  return netthreadnum_;
}
inline void pbNFServerConfig::set_netthreadnum(::google::protobuf::uint32 value) {
  set_has_netthreadnum();
  netthreadnum_ = value;
}

// optional bool Security = 28;
inline bool pbNFServerConfig::has_security() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void pbNFServerConfig::set_has_security() {
  _has_bits_[0] |= 0x00010000u;
}
inline void pbNFServerConfig::clear_has_security() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void pbNFServerConfig::clear_security() {
  security_ = false;
  clear_has_security();
}
inline bool pbNFServerConfig::security() const {
  return security_;
}
inline void pbNFServerConfig::set_security(bool value) {
  set_has_security();
  security_ = value;
}

// optional bool WebSocket = 29;
inline bool pbNFServerConfig::has_websocket() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void pbNFServerConfig::set_has_websocket() {
  _has_bits_[0] |= 0x00020000u;
}
inline void pbNFServerConfig::clear_has_websocket() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void pbNFServerConfig::clear_websocket() {
  websocket_ = false;
  clear_has_websocket();
}
inline bool pbNFServerConfig::websocket() const {
  return websocket_;
}
inline void pbNFServerConfig::set_websocket(bool value) {
  set_has_websocket();
  websocket_ = value;
}

// optional uint32 ParseType = 30;
inline bool pbNFServerConfig::has_parsetype() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void pbNFServerConfig::set_has_parsetype() {
  _has_bits_[0] |= 0x00040000u;
}
inline void pbNFServerConfig::clear_has_parsetype() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void pbNFServerConfig::clear_parsetype() {
  parsetype_ = 0u;
  clear_has_parsetype();
}
inline ::google::protobuf::uint32 pbNFServerConfig::parsetype() const {
  return parsetype_;
}
inline void pbNFServerConfig::set_parsetype(::google::protobuf::uint32 value) {
  set_has_parsetype();
  parsetype_ = value;
}

// optional string MasterIp = 50;
inline bool pbNFServerConfig::has_masterip() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void pbNFServerConfig::set_has_masterip() {
  _has_bits_[0] |= 0x00080000u;
}
inline void pbNFServerConfig::clear_has_masterip() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void pbNFServerConfig::clear_masterip() {
  if (masterip_ != &::google::protobuf::internal::kEmptyString) {
    masterip_->clear();
  }
  clear_has_masterip();
}
inline const ::std::string& pbNFServerConfig::masterip() const {
  return *masterip_;
}
inline void pbNFServerConfig::set_masterip(const ::std::string& value) {
  set_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    masterip_ = new ::std::string;
  }
  masterip_->assign(value);
}
inline void pbNFServerConfig::set_masterip(const char* value) {
  set_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    masterip_ = new ::std::string;
  }
  masterip_->assign(value);
}
inline void pbNFServerConfig::set_masterip(const char* value, size_t size) {
  set_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    masterip_ = new ::std::string;
  }
  masterip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_masterip() {
  set_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    masterip_ = new ::std::string;
  }
  return masterip_;
}
inline ::std::string* pbNFServerConfig::release_masterip() {
  clear_has_masterip();
  if (masterip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = masterip_;
    masterip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_masterip(::std::string* masterip) {
  if (masterip_ != &::google::protobuf::internal::kEmptyString) {
    delete masterip_;
  }
  if (masterip) {
    set_has_masterip();
    masterip_ = masterip;
  } else {
    clear_has_masterip();
    masterip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 MasterPort = 51;
inline bool pbNFServerConfig::has_masterport() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void pbNFServerConfig::set_has_masterport() {
  _has_bits_[0] |= 0x00100000u;
}
inline void pbNFServerConfig::clear_has_masterport() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void pbNFServerConfig::clear_masterport() {
  masterport_ = 0u;
  clear_has_masterport();
}
inline ::google::protobuf::uint32 pbNFServerConfig::masterport() const {
  return masterport_;
}
inline void pbNFServerConfig::set_masterport(::google::protobuf::uint32 value) {
  set_has_masterport();
  masterport_ = value;
}

// optional string NamingHost = 52;
inline bool pbNFServerConfig::has_naminghost() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void pbNFServerConfig::set_has_naminghost() {
  _has_bits_[0] |= 0x00200000u;
}
inline void pbNFServerConfig::clear_has_naminghost() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void pbNFServerConfig::clear_naminghost() {
  if (naminghost_ != &::google::protobuf::internal::kEmptyString) {
    naminghost_->clear();
  }
  clear_has_naminghost();
}
inline const ::std::string& pbNFServerConfig::naminghost() const {
  return *naminghost_;
}
inline void pbNFServerConfig::set_naminghost(const ::std::string& value) {
  set_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    naminghost_ = new ::std::string;
  }
  naminghost_->assign(value);
}
inline void pbNFServerConfig::set_naminghost(const char* value) {
  set_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    naminghost_ = new ::std::string;
  }
  naminghost_->assign(value);
}
inline void pbNFServerConfig::set_naminghost(const char* value, size_t size) {
  set_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    naminghost_ = new ::std::string;
  }
  naminghost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_naminghost() {
  set_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    naminghost_ = new ::std::string;
  }
  return naminghost_;
}
inline ::std::string* pbNFServerConfig::release_naminghost() {
  clear_has_naminghost();
  if (naminghost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = naminghost_;
    naminghost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_naminghost(::std::string* naminghost) {
  if (naminghost_ != &::google::protobuf::internal::kEmptyString) {
    delete naminghost_;
  }
  if (naminghost) {
    set_has_naminghost();
    naminghost_ = naminghost;
  } else {
    clear_has_naminghost();
    naminghost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string NamingPath = 53;
inline bool pbNFServerConfig::has_namingpath() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void pbNFServerConfig::set_has_namingpath() {
  _has_bits_[0] |= 0x00400000u;
}
inline void pbNFServerConfig::clear_has_namingpath() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void pbNFServerConfig::clear_namingpath() {
  if (namingpath_ != &::google::protobuf::internal::kEmptyString) {
    namingpath_->clear();
  }
  clear_has_namingpath();
}
inline const ::std::string& pbNFServerConfig::namingpath() const {
  return *namingpath_;
}
inline void pbNFServerConfig::set_namingpath(const ::std::string& value) {
  set_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    namingpath_ = new ::std::string;
  }
  namingpath_->assign(value);
}
inline void pbNFServerConfig::set_namingpath(const char* value) {
  set_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    namingpath_ = new ::std::string;
  }
  namingpath_->assign(value);
}
inline void pbNFServerConfig::set_namingpath(const char* value, size_t size) {
  set_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    namingpath_ = new ::std::string;
  }
  namingpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_namingpath() {
  set_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    namingpath_ = new ::std::string;
  }
  return namingpath_;
}
inline ::std::string* pbNFServerConfig::release_namingpath() {
  clear_has_namingpath();
  if (namingpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = namingpath_;
    namingpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_namingpath(::std::string* namingpath) {
  if (namingpath_ != &::google::protobuf::internal::kEmptyString) {
    delete namingpath_;
  }
  if (namingpath) {
    set_has_namingpath();
    namingpath_ = namingpath;
  } else {
    clear_has_namingpath();
    namingpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string RouteAgent = 54;
inline bool pbNFServerConfig::has_routeagent() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void pbNFServerConfig::set_has_routeagent() {
  _has_bits_[0] |= 0x00800000u;
}
inline void pbNFServerConfig::clear_has_routeagent() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void pbNFServerConfig::clear_routeagent() {
  if (routeagent_ != &::google::protobuf::internal::kEmptyString) {
    routeagent_->clear();
  }
  clear_has_routeagent();
}
inline const ::std::string& pbNFServerConfig::routeagent() const {
  return *routeagent_;
}
inline void pbNFServerConfig::set_routeagent(const ::std::string& value) {
  set_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    routeagent_ = new ::std::string;
  }
  routeagent_->assign(value);
}
inline void pbNFServerConfig::set_routeagent(const char* value) {
  set_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    routeagent_ = new ::std::string;
  }
  routeagent_->assign(value);
}
inline void pbNFServerConfig::set_routeagent(const char* value, size_t size) {
  set_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    routeagent_ = new ::std::string;
  }
  routeagent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_routeagent() {
  set_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    routeagent_ = new ::std::string;
  }
  return routeagent_;
}
inline ::std::string* pbNFServerConfig::release_routeagent() {
  clear_has_routeagent();
  if (routeagent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = routeagent_;
    routeagent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_routeagent(::std::string* routeagent) {
  if (routeagent_ != &::google::protobuf::internal::kEmptyString) {
    delete routeagent_;
  }
  if (routeagent) {
    set_has_routeagent();
    routeagent_ = routeagent;
  } else {
    clear_has_routeagent();
    routeagent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MysqlIp = 70;
inline bool pbNFServerConfig::has_mysqlip() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void pbNFServerConfig::set_has_mysqlip() {
  _has_bits_[0] |= 0x01000000u;
}
inline void pbNFServerConfig::clear_has_mysqlip() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void pbNFServerConfig::clear_mysqlip() {
  if (mysqlip_ != &::google::protobuf::internal::kEmptyString) {
    mysqlip_->clear();
  }
  clear_has_mysqlip();
}
inline const ::std::string& pbNFServerConfig::mysqlip() const {
  return *mysqlip_;
}
inline void pbNFServerConfig::set_mysqlip(const ::std::string& value) {
  set_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    mysqlip_ = new ::std::string;
  }
  mysqlip_->assign(value);
}
inline void pbNFServerConfig::set_mysqlip(const char* value) {
  set_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    mysqlip_ = new ::std::string;
  }
  mysqlip_->assign(value);
}
inline void pbNFServerConfig::set_mysqlip(const char* value, size_t size) {
  set_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    mysqlip_ = new ::std::string;
  }
  mysqlip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_mysqlip() {
  set_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    mysqlip_ = new ::std::string;
  }
  return mysqlip_;
}
inline ::std::string* pbNFServerConfig::release_mysqlip() {
  clear_has_mysqlip();
  if (mysqlip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqlip_;
    mysqlip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_mysqlip(::std::string* mysqlip) {
  if (mysqlip_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqlip_;
  }
  if (mysqlip) {
    set_has_mysqlip();
    mysqlip_ = mysqlip;
  } else {
    clear_has_mysqlip();
    mysqlip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 MysqlPort = 71;
inline bool pbNFServerConfig::has_mysqlport() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void pbNFServerConfig::set_has_mysqlport() {
  _has_bits_[0] |= 0x02000000u;
}
inline void pbNFServerConfig::clear_has_mysqlport() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void pbNFServerConfig::clear_mysqlport() {
  mysqlport_ = 0u;
  clear_has_mysqlport();
}
inline ::google::protobuf::uint32 pbNFServerConfig::mysqlport() const {
  return mysqlport_;
}
inline void pbNFServerConfig::set_mysqlport(::google::protobuf::uint32 value) {
  set_has_mysqlport();
  mysqlport_ = value;
}

// optional string MysqlDbName = 72;
inline bool pbNFServerConfig::has_mysqldbname() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void pbNFServerConfig::set_has_mysqldbname() {
  _has_bits_[0] |= 0x04000000u;
}
inline void pbNFServerConfig::clear_has_mysqldbname() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void pbNFServerConfig::clear_mysqldbname() {
  if (mysqldbname_ != &::google::protobuf::internal::kEmptyString) {
    mysqldbname_->clear();
  }
  clear_has_mysqldbname();
}
inline const ::std::string& pbNFServerConfig::mysqldbname() const {
  return *mysqldbname_;
}
inline void pbNFServerConfig::set_mysqldbname(const ::std::string& value) {
  set_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    mysqldbname_ = new ::std::string;
  }
  mysqldbname_->assign(value);
}
inline void pbNFServerConfig::set_mysqldbname(const char* value) {
  set_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    mysqldbname_ = new ::std::string;
  }
  mysqldbname_->assign(value);
}
inline void pbNFServerConfig::set_mysqldbname(const char* value, size_t size) {
  set_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    mysqldbname_ = new ::std::string;
  }
  mysqldbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_mysqldbname() {
  set_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    mysqldbname_ = new ::std::string;
  }
  return mysqldbname_;
}
inline ::std::string* pbNFServerConfig::release_mysqldbname() {
  clear_has_mysqldbname();
  if (mysqldbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqldbname_;
    mysqldbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_mysqldbname(::std::string* mysqldbname) {
  if (mysqldbname_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqldbname_;
  }
  if (mysqldbname) {
    set_has_mysqldbname();
    mysqldbname_ = mysqldbname;
  } else {
    clear_has_mysqldbname();
    mysqldbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MysqlUser = 73;
inline bool pbNFServerConfig::has_mysqluser() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void pbNFServerConfig::set_has_mysqluser() {
  _has_bits_[0] |= 0x08000000u;
}
inline void pbNFServerConfig::clear_has_mysqluser() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void pbNFServerConfig::clear_mysqluser() {
  if (mysqluser_ != &::google::protobuf::internal::kEmptyString) {
    mysqluser_->clear();
  }
  clear_has_mysqluser();
}
inline const ::std::string& pbNFServerConfig::mysqluser() const {
  return *mysqluser_;
}
inline void pbNFServerConfig::set_mysqluser(const ::std::string& value) {
  set_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    mysqluser_ = new ::std::string;
  }
  mysqluser_->assign(value);
}
inline void pbNFServerConfig::set_mysqluser(const char* value) {
  set_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    mysqluser_ = new ::std::string;
  }
  mysqluser_->assign(value);
}
inline void pbNFServerConfig::set_mysqluser(const char* value, size_t size) {
  set_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    mysqluser_ = new ::std::string;
  }
  mysqluser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_mysqluser() {
  set_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    mysqluser_ = new ::std::string;
  }
  return mysqluser_;
}
inline ::std::string* pbNFServerConfig::release_mysqluser() {
  clear_has_mysqluser();
  if (mysqluser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqluser_;
    mysqluser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_mysqluser(::std::string* mysqluser) {
  if (mysqluser_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqluser_;
  }
  if (mysqluser) {
    set_has_mysqluser();
    mysqluser_ = mysqluser;
  } else {
    clear_has_mysqluser();
    mysqluser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MysqlPassword = 74;
inline bool pbNFServerConfig::has_mysqlpassword() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void pbNFServerConfig::set_has_mysqlpassword() {
  _has_bits_[0] |= 0x10000000u;
}
inline void pbNFServerConfig::clear_has_mysqlpassword() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void pbNFServerConfig::clear_mysqlpassword() {
  if (mysqlpassword_ != &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_->clear();
  }
  clear_has_mysqlpassword();
}
inline const ::std::string& pbNFServerConfig::mysqlpassword() const {
  return *mysqlpassword_;
}
inline void pbNFServerConfig::set_mysqlpassword(const ::std::string& value) {
  set_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_ = new ::std::string;
  }
  mysqlpassword_->assign(value);
}
inline void pbNFServerConfig::set_mysqlpassword(const char* value) {
  set_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_ = new ::std::string;
  }
  mysqlpassword_->assign(value);
}
inline void pbNFServerConfig::set_mysqlpassword(const char* value, size_t size) {
  set_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_ = new ::std::string;
  }
  mysqlpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_mysqlpassword() {
  set_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    mysqlpassword_ = new ::std::string;
  }
  return mysqlpassword_;
}
inline ::std::string* pbNFServerConfig::release_mysqlpassword() {
  clear_has_mysqlpassword();
  if (mysqlpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqlpassword_;
    mysqlpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_mysqlpassword(::std::string* mysqlpassword) {
  if (mysqlpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqlpassword_;
  }
  if (mysqlpassword) {
    set_has_mysqlpassword();
    mysqlpassword_ = mysqlpassword;
  } else {
    clear_has_mysqlpassword();
    mysqlpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string DefaultDBName = 75;
inline bool pbNFServerConfig::has_defaultdbname() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void pbNFServerConfig::set_has_defaultdbname() {
  _has_bits_[0] |= 0x20000000u;
}
inline void pbNFServerConfig::clear_has_defaultdbname() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void pbNFServerConfig::clear_defaultdbname() {
  if (defaultdbname_ != &::google::protobuf::internal::kEmptyString) {
    defaultdbname_->clear();
  }
  clear_has_defaultdbname();
}
inline const ::std::string& pbNFServerConfig::defaultdbname() const {
  return *defaultdbname_;
}
inline void pbNFServerConfig::set_defaultdbname(const ::std::string& value) {
  set_has_defaultdbname();
  if (defaultdbname_ == &::google::protobuf::internal::kEmptyString) {
    defaultdbname_ = new ::std::string;
  }
  defaultdbname_->assign(value);
}
inline void pbNFServerConfig::set_defaultdbname(const char* value) {
  set_has_defaultdbname();
  if (defaultdbname_ == &::google::protobuf::internal::kEmptyString) {
    defaultdbname_ = new ::std::string;
  }
  defaultdbname_->assign(value);
}
inline void pbNFServerConfig::set_defaultdbname(const char* value, size_t size) {
  set_has_defaultdbname();
  if (defaultdbname_ == &::google::protobuf::internal::kEmptyString) {
    defaultdbname_ = new ::std::string;
  }
  defaultdbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_defaultdbname() {
  set_has_defaultdbname();
  if (defaultdbname_ == &::google::protobuf::internal::kEmptyString) {
    defaultdbname_ = new ::std::string;
  }
  return defaultdbname_;
}
inline ::std::string* pbNFServerConfig::release_defaultdbname() {
  clear_has_defaultdbname();
  if (defaultdbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defaultdbname_;
    defaultdbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_defaultdbname(::std::string* defaultdbname) {
  if (defaultdbname_ != &::google::protobuf::internal::kEmptyString) {
    delete defaultdbname_;
  }
  if (defaultdbname) {
    set_has_defaultdbname();
    defaultdbname_ = defaultdbname;
  } else {
    clear_has_defaultdbname();
    defaultdbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CrossDBName = 76;
inline bool pbNFServerConfig::has_crossdbname() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void pbNFServerConfig::set_has_crossdbname() {
  _has_bits_[0] |= 0x40000000u;
}
inline void pbNFServerConfig::clear_has_crossdbname() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void pbNFServerConfig::clear_crossdbname() {
  if (crossdbname_ != &::google::protobuf::internal::kEmptyString) {
    crossdbname_->clear();
  }
  clear_has_crossdbname();
}
inline const ::std::string& pbNFServerConfig::crossdbname() const {
  return *crossdbname_;
}
inline void pbNFServerConfig::set_crossdbname(const ::std::string& value) {
  set_has_crossdbname();
  if (crossdbname_ == &::google::protobuf::internal::kEmptyString) {
    crossdbname_ = new ::std::string;
  }
  crossdbname_->assign(value);
}
inline void pbNFServerConfig::set_crossdbname(const char* value) {
  set_has_crossdbname();
  if (crossdbname_ == &::google::protobuf::internal::kEmptyString) {
    crossdbname_ = new ::std::string;
  }
  crossdbname_->assign(value);
}
inline void pbNFServerConfig::set_crossdbname(const char* value, size_t size) {
  set_has_crossdbname();
  if (crossdbname_ == &::google::protobuf::internal::kEmptyString) {
    crossdbname_ = new ::std::string;
  }
  crossdbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_crossdbname() {
  set_has_crossdbname();
  if (crossdbname_ == &::google::protobuf::internal::kEmptyString) {
    crossdbname_ = new ::std::string;
  }
  return crossdbname_;
}
inline ::std::string* pbNFServerConfig::release_crossdbname() {
  clear_has_crossdbname();
  if (crossdbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crossdbname_;
    crossdbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_crossdbname(::std::string* crossdbname) {
  if (crossdbname_ != &::google::protobuf::internal::kEmptyString) {
    delete crossdbname_;
  }
  if (crossdbname) {
    set_has_crossdbname();
    crossdbname_ = crossdbname;
  } else {
    clear_has_crossdbname();
    crossdbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto_ff.pbTableConfig TBConfList = 77;
inline int pbNFServerConfig::tbconflist_size() const {
  return tbconflist_.size();
}
inline void pbNFServerConfig::clear_tbconflist() {
  tbconflist_.Clear();
}
inline const ::proto_ff::pbTableConfig& pbNFServerConfig::tbconflist(int index) const {
  return tbconflist_.Get(index);
}
inline ::proto_ff::pbTableConfig* pbNFServerConfig::mutable_tbconflist(int index) {
  return tbconflist_.Mutable(index);
}
inline ::proto_ff::pbTableConfig* pbNFServerConfig::add_tbconflist() {
  return tbconflist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig >&
pbNFServerConfig::tbconflist() const {
  return tbconflist_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::pbTableConfig >*
pbNFServerConfig::mutable_tbconflist() {
  return &tbconflist_;
}

// optional string RedisIp = 80;
inline bool pbNFServerConfig::has_redisip() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void pbNFServerConfig::set_has_redisip() {
  _has_bits_[1] |= 0x00000001u;
}
inline void pbNFServerConfig::clear_has_redisip() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void pbNFServerConfig::clear_redisip() {
  if (redisip_ != &::google::protobuf::internal::kEmptyString) {
    redisip_->clear();
  }
  clear_has_redisip();
}
inline const ::std::string& pbNFServerConfig::redisip() const {
  return *redisip_;
}
inline void pbNFServerConfig::set_redisip(const ::std::string& value) {
  set_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    redisip_ = new ::std::string;
  }
  redisip_->assign(value);
}
inline void pbNFServerConfig::set_redisip(const char* value) {
  set_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    redisip_ = new ::std::string;
  }
  redisip_->assign(value);
}
inline void pbNFServerConfig::set_redisip(const char* value, size_t size) {
  set_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    redisip_ = new ::std::string;
  }
  redisip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_redisip() {
  set_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    redisip_ = new ::std::string;
  }
  return redisip_;
}
inline ::std::string* pbNFServerConfig::release_redisip() {
  clear_has_redisip();
  if (redisip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = redisip_;
    redisip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_redisip(::std::string* redisip) {
  if (redisip_ != &::google::protobuf::internal::kEmptyString) {
    delete redisip_;
  }
  if (redisip) {
    set_has_redisip();
    redisip_ = redisip;
  } else {
    clear_has_redisip();
    redisip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 RedisPort = 81;
inline bool pbNFServerConfig::has_redisport() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void pbNFServerConfig::set_has_redisport() {
  _has_bits_[1] |= 0x00000002u;
}
inline void pbNFServerConfig::clear_has_redisport() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void pbNFServerConfig::clear_redisport() {
  redisport_ = 0u;
  clear_has_redisport();
}
inline ::google::protobuf::uint32 pbNFServerConfig::redisport() const {
  return redisport_;
}
inline void pbNFServerConfig::set_redisport(::google::protobuf::uint32 value) {
  set_has_redisport();
  redisport_ = value;
}

// optional string RedisPass = 82;
inline bool pbNFServerConfig::has_redispass() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void pbNFServerConfig::set_has_redispass() {
  _has_bits_[1] |= 0x00000004u;
}
inline void pbNFServerConfig::clear_has_redispass() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void pbNFServerConfig::clear_redispass() {
  if (redispass_ != &::google::protobuf::internal::kEmptyString) {
    redispass_->clear();
  }
  clear_has_redispass();
}
inline const ::std::string& pbNFServerConfig::redispass() const {
  return *redispass_;
}
inline void pbNFServerConfig::set_redispass(const ::std::string& value) {
  set_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    redispass_ = new ::std::string;
  }
  redispass_->assign(value);
}
inline void pbNFServerConfig::set_redispass(const char* value) {
  set_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    redispass_ = new ::std::string;
  }
  redispass_->assign(value);
}
inline void pbNFServerConfig::set_redispass(const char* value, size_t size) {
  set_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    redispass_ = new ::std::string;
  }
  redispass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_redispass() {
  set_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    redispass_ = new ::std::string;
  }
  return redispass_;
}
inline ::std::string* pbNFServerConfig::release_redispass() {
  clear_has_redispass();
  if (redispass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = redispass_;
    redispass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_redispass(::std::string* redispass) {
  if (redispass_ != &::google::protobuf::internal::kEmptyString) {
    delete redispass_;
  }
  if (redispass) {
    set_has_redispass();
    redispass_ = redispass;
  } else {
    clear_has_redispass();
    redispass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string WwwUrl = 90;
inline bool pbNFServerConfig::has_wwwurl() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void pbNFServerConfig::set_has_wwwurl() {
  _has_bits_[1] |= 0x00000008u;
}
inline void pbNFServerConfig::clear_has_wwwurl() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void pbNFServerConfig::clear_wwwurl() {
  if (wwwurl_ != &::google::protobuf::internal::kEmptyString) {
    wwwurl_->clear();
  }
  clear_has_wwwurl();
}
inline const ::std::string& pbNFServerConfig::wwwurl() const {
  return *wwwurl_;
}
inline void pbNFServerConfig::set_wwwurl(const ::std::string& value) {
  set_has_wwwurl();
  if (wwwurl_ == &::google::protobuf::internal::kEmptyString) {
    wwwurl_ = new ::std::string;
  }
  wwwurl_->assign(value);
}
inline void pbNFServerConfig::set_wwwurl(const char* value) {
  set_has_wwwurl();
  if (wwwurl_ == &::google::protobuf::internal::kEmptyString) {
    wwwurl_ = new ::std::string;
  }
  wwwurl_->assign(value);
}
inline void pbNFServerConfig::set_wwwurl(const char* value, size_t size) {
  set_has_wwwurl();
  if (wwwurl_ == &::google::protobuf::internal::kEmptyString) {
    wwwurl_ = new ::std::string;
  }
  wwwurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_wwwurl() {
  set_has_wwwurl();
  if (wwwurl_ == &::google::protobuf::internal::kEmptyString) {
    wwwurl_ = new ::std::string;
  }
  return wwwurl_;
}
inline ::std::string* pbNFServerConfig::release_wwwurl() {
  clear_has_wwwurl();
  if (wwwurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wwwurl_;
    wwwurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_wwwurl(::std::string* wwwurl) {
  if (wwwurl_ != &::google::protobuf::internal::kEmptyString) {
    delete wwwurl_;
  }
  if (wwwurl) {
    set_has_wwwurl();
    wwwurl_ = wwwurl;
  } else {
    clear_has_wwwurl();
    wwwurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Email = 91;
inline bool pbNFServerConfig::has_email() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void pbNFServerConfig::set_has_email() {
  _has_bits_[1] |= 0x00000010u;
}
inline void pbNFServerConfig::clear_has_email() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void pbNFServerConfig::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& pbNFServerConfig::email() const {
  return *email_;
}
inline void pbNFServerConfig::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void pbNFServerConfig::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void pbNFServerConfig::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbNFServerConfig::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* pbNFServerConfig::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbNFServerConfig::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 MaxOnlinePlayerNum = 100;
inline bool pbNFServerConfig::has_maxonlineplayernum() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void pbNFServerConfig::set_has_maxonlineplayernum() {
  _has_bits_[1] |= 0x00000020u;
}
inline void pbNFServerConfig::clear_has_maxonlineplayernum() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void pbNFServerConfig::clear_maxonlineplayernum() {
  maxonlineplayernum_ = 0u;
  clear_has_maxonlineplayernum();
}
inline ::google::protobuf::uint32 pbNFServerConfig::maxonlineplayernum() const {
  return maxonlineplayernum_;
}
inline void pbNFServerConfig::set_maxonlineplayernum(::google::protobuf::uint32 value) {
  set_has_maxonlineplayernum();
  maxonlineplayernum_ = value;
}

// optional uint32 HeartBeatTimeout = 101;
inline bool pbNFServerConfig::has_heartbeattimeout() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void pbNFServerConfig::set_has_heartbeattimeout() {
  _has_bits_[1] |= 0x00000040u;
}
inline void pbNFServerConfig::clear_has_heartbeattimeout() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void pbNFServerConfig::clear_heartbeattimeout() {
  heartbeattimeout_ = 0u;
  clear_has_heartbeattimeout();
}
inline ::google::protobuf::uint32 pbNFServerConfig::heartbeattimeout() const {
  return heartbeattimeout_;
}
inline void pbNFServerConfig::set_heartbeattimeout(::google::protobuf::uint32 value) {
  set_has_heartbeattimeout();
  heartbeattimeout_ = value;
}

// optional uint32 ClientKeepAliveTimeout = 102;
inline bool pbNFServerConfig::has_clientkeepalivetimeout() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void pbNFServerConfig::set_has_clientkeepalivetimeout() {
  _has_bits_[1] |= 0x00000080u;
}
inline void pbNFServerConfig::clear_has_clientkeepalivetimeout() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void pbNFServerConfig::clear_clientkeepalivetimeout() {
  clientkeepalivetimeout_ = 0u;
  clear_has_clientkeepalivetimeout();
}
inline ::google::protobuf::uint32 pbNFServerConfig::clientkeepalivetimeout() const {
  return clientkeepalivetimeout_;
}
inline void pbNFServerConfig::set_clientkeepalivetimeout(::google::protobuf::uint32 value) {
  set_has_clientkeepalivetimeout();
  clientkeepalivetimeout_ = value;
}

// optional uint32 ClientVersion = 103;
inline bool pbNFServerConfig::has_clientversion() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void pbNFServerConfig::set_has_clientversion() {
  _has_bits_[1] |= 0x00000100u;
}
inline void pbNFServerConfig::clear_has_clientversion() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void pbNFServerConfig::clear_clientversion() {
  clientversion_ = 0u;
  clear_has_clientversion();
}
inline ::google::protobuf::uint32 pbNFServerConfig::clientversion() const {
  return clientversion_;
}
inline void pbNFServerConfig::set_clientversion(::google::protobuf::uint32 value) {
  set_has_clientversion();
  clientversion_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::NF_SERVER_TYPE>() {
  return ::proto_ff::NF_SERVER_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_5fcommon_2eproto__INCLUDED
