// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: st_human.proto

#ifndef PROTOBUF_st_5fhuman_2eproto__INCLUDED
#define PROTOBUF_st_5fhuman_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace progame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_st_5fhuman_2eproto();
void protobuf_AssignDesc_st_5fhuman_2eproto();
void protobuf_ShutdownFile_st_5fhuman_2eproto();

class playerinfo;
class playerstats;
class goodsinfo;
class goodslist;
class noticeinfo;
class playersimpleinfo;
class broadcastinfo;
class mailinfo;
class maillist;
class inviteinfo;
class agencyinfo;
class intlist;
class stringlist;
class useraward;
class banktransferrecord;
class specialcardreward;
class specialinfo;

// ===================================================================

class playerinfo : public ::google::protobuf::Message {
 public:
  playerinfo();
  virtual ~playerinfo();

  playerinfo(const playerinfo& from);

  inline playerinfo& operator=(const playerinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const playerinfo& default_instance();

  void Swap(playerinfo* other);

  // implements Message ----------------------------------------------

  playerinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const playerinfo& from);
  void MergeFrom(const playerinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional string cid = 2;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 2;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string nickname = 5;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 5;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string regdate = 7;
  inline bool has_regdate() const;
  inline void clear_regdate();
  static const int kRegdateFieldNumber = 7;
  inline const ::std::string& regdate() const;
  inline void set_regdate(const ::std::string& value);
  inline void set_regdate(const char* value);
  inline void set_regdate(const char* value, size_t size);
  inline ::std::string* mutable_regdate();
  inline ::std::string* release_regdate();
  inline void set_allocated_regdate(::std::string* regdate);

  // optional int32 sex = 8;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 8;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional int32 age = 9;
  inline bool has_age() const;
  inline void clear_age();
  static const int kAgeFieldNumber = 9;
  inline ::google::protobuf::int32 age() const;
  inline void set_age(::google::protobuf::int32 value);

  // optional string email = 10;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 10;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string phonenum = 11;
  inline bool has_phonenum() const;
  inline void clear_phonenum();
  static const int kPhonenumFieldNumber = 11;
  inline const ::std::string& phonenum() const;
  inline void set_phonenum(const ::std::string& value);
  inline void set_phonenum(const char* value);
  inline void set_phonenum(const char* value, size_t size);
  inline ::std::string* mutable_phonenum();
  inline ::std::string* release_phonenum();
  inline void set_allocated_phonenum(::std::string* phonenum);

  // optional int32 exp = 12;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 12;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 level = 13;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 13;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 viplevel = 14;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kViplevelFieldNumber = 14;
  inline ::google::protobuf::int32 viplevel() const;
  inline void set_viplevel(::google::protobuf::int32 value);

  // optional string jetton = 15;
  inline bool has_jetton() const;
  inline void clear_jetton();
  static const int kJettonFieldNumber = 15;
  inline const ::std::string& jetton() const;
  inline void set_jetton(const ::std::string& value);
  inline void set_jetton(const char* value);
  inline void set_jetton(const char* value, size_t size);
  inline ::std::string* mutable_jetton();
  inline ::std::string* release_jetton();
  inline void set_allocated_jetton(::std::string* jetton);

  // optional int32 gold = 16;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 16;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional int32 money = 17;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 17;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional string channel = 18;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 18;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // optional string province = 19;
  inline bool has_province() const;
  inline void clear_province();
  static const int kProvinceFieldNumber = 19;
  inline const ::std::string& province() const;
  inline void set_province(const ::std::string& value);
  inline void set_province(const char* value);
  inline void set_province(const char* value, size_t size);
  inline ::std::string* mutable_province();
  inline ::std::string* release_province();
  inline void set_allocated_province(::std::string* province);

  // optional string city = 20;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 20;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional int32 popularity = 21;
  inline bool has_popularity() const;
  inline void clear_popularity();
  static const int kPopularityFieldNumber = 21;
  inline ::google::protobuf::int32 popularity() const;
  inline void set_popularity(::google::protobuf::int32 value);

  // optional int32 idenstatus = 22;
  inline bool has_idenstatus() const;
  inline void clear_idenstatus();
  static const int kIdenstatusFieldNumber = 22;
  inline ::google::protobuf::int32 idenstatus() const;
  inline void set_idenstatus(::google::protobuf::int32 value);

  // optional int32 bindtype = 23;
  inline bool has_bindtype() const;
  inline void clear_bindtype();
  static const int kBindtypeFieldNumber = 23;
  inline ::google::protobuf::int32 bindtype() const;
  inline void set_bindtype(::google::protobuf::int32 value);

  // optional string bindnick = 24;
  inline bool has_bindnick() const;
  inline void clear_bindnick();
  static const int kBindnickFieldNumber = 24;
  inline const ::std::string& bindnick() const;
  inline void set_bindnick(const ::std::string& value);
  inline void set_bindnick(const char* value);
  inline void set_bindnick(const char* value, size_t size);
  inline ::std::string* mutable_bindnick();
  inline ::std::string* release_bindnick();
  inline void set_allocated_bindnick(::std::string* bindnick);

  // optional string platformid = 25;
  inline bool has_platformid() const;
  inline void clear_platformid();
  static const int kPlatformidFieldNumber = 25;
  inline const ::std::string& platformid() const;
  inline void set_platformid(const ::std::string& value);
  inline void set_platformid(const char* value);
  inline void set_platformid(const char* value, size_t size);
  inline ::std::string* mutable_platformid();
  inline ::std::string* release_platformid();
  inline void set_allocated_platformid(::std::string* platformid);

  // optional string imei = 26;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 26;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional string devname = 27;
  inline bool has_devname() const;
  inline void clear_devname();
  static const int kDevnameFieldNumber = 27;
  inline const ::std::string& devname() const;
  inline void set_devname(const ::std::string& value);
  inline void set_devname(const char* value);
  inline void set_devname(const char* value, size_t size);
  inline ::std::string* mutable_devname();
  inline ::std::string* release_devname();
  inline void set_allocated_devname(::std::string* devname);

  // optional string ip = 28;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 28;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 mobiletype = 29;
  inline bool has_mobiletype() const;
  inline void clear_mobiletype();
  static const int kMobiletypeFieldNumber = 29;
  inline ::google::protobuf::int32 mobiletype() const;
  inline void set_mobiletype(::google::protobuf::int32 value);

  // optional int32 lasttime = 30;
  inline bool has_lasttime() const;
  inline void clear_lasttime();
  static const int kLasttimeFieldNumber = 30;
  inline ::google::protobuf::int32 lasttime() const;
  inline void set_lasttime(::google::protobuf::int32 value);

  // optional int32 penulttime = 31;
  inline bool has_penulttime() const;
  inline void clear_penulttime();
  static const int kPenulttimeFieldNumber = 31;
  inline ::google::protobuf::int32 penulttime() const;
  inline void set_penulttime(::google::protobuf::int32 value);

  // optional int32 silent = 32;
  inline bool has_silent() const;
  inline void clear_silent();
  static const int kSilentFieldNumber = 32;
  inline ::google::protobuf::int32 silent() const;
  inline void set_silent(::google::protobuf::int32 value);

  // optional int32 isban = 33;
  inline bool has_isban() const;
  inline void clear_isban();
  static const int kIsbanFieldNumber = 33;
  inline ::google::protobuf::int32 isban() const;
  inline void set_isban(::google::protobuf::int32 value);

  // optional string face_1 = 34;
  inline bool has_face_1() const;
  inline void clear_face_1();
  static const int kFace1FieldNumber = 34;
  inline const ::std::string& face_1() const;
  inline void set_face_1(const ::std::string& value);
  inline void set_face_1(const char* value);
  inline void set_face_1(const char* value, size_t size);
  inline ::std::string* mutable_face_1();
  inline ::std::string* release_face_1();
  inline void set_allocated_face_1(::std::string* face_1);

  // optional string face_2 = 35;
  inline bool has_face_2() const;
  inline void clear_face_2();
  static const int kFace2FieldNumber = 35;
  inline const ::std::string& face_2() const;
  inline void set_face_2(const ::std::string& value);
  inline void set_face_2(const char* value);
  inline void set_face_2(const char* value, size_t size);
  inline ::std::string* mutable_face_2();
  inline ::std::string* release_face_2();
  inline void set_allocated_face_2(::std::string* face_2);

  // optional string face_3 = 36;
  inline bool has_face_3() const;
  inline void clear_face_3();
  static const int kFace3FieldNumber = 36;
  inline const ::std::string& face_3() const;
  inline void set_face_3(const ::std::string& value);
  inline void set_face_3(const char* value);
  inline void set_face_3(const char* value, size_t size);
  inline ::std::string* mutable_face_3();
  inline ::std::string* release_face_3();
  inline void set_allocated_face_3(::std::string* face_3);

  // optional string face_4 = 37;
  inline bool has_face_4() const;
  inline void clear_face_4();
  static const int kFace4FieldNumber = 37;
  inline const ::std::string& face_4() const;
  inline void set_face_4(const ::std::string& value);
  inline void set_face_4(const char* value);
  inline void set_face_4(const char* value, size_t size);
  inline ::std::string* mutable_face_4();
  inline ::std::string* release_face_4();
  inline void set_allocated_face_4(::std::string* face_4);

  // optional int32 isrobot = 38;
  inline bool has_isrobot() const;
  inline void clear_isrobot();
  static const int kIsrobotFieldNumber = 38;
  inline ::google::protobuf::int32 isrobot() const;
  inline void set_isrobot(::google::protobuf::int32 value);

  // optional int32 playtype = 39;
  inline bool has_playtype() const;
  inline void clear_playtype();
  static const int kPlaytypeFieldNumber = 39;
  inline ::google::protobuf::int32 playtype() const;
  inline void set_playtype(::google::protobuf::int32 value);

  // optional string description = 40;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 40;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string location = 41;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 41;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional string bankjetton = 42;
  inline bool has_bankjetton() const;
  inline void clear_bankjetton();
  static const int kBankjettonFieldNumber = 42;
  inline const ::std::string& bankjetton() const;
  inline void set_bankjetton(const ::std::string& value);
  inline void set_bankjetton(const char* value);
  inline void set_bankjetton(const char* value, size_t size);
  inline ::std::string* mutable_bankjetton();
  inline ::std::string* release_bankjetton();
  inline void set_allocated_bankjetton(::std::string* bankjetton);

  // optional string title = 43;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 43;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional int32 blacklist = 44;
  inline bool has_blacklist() const;
  inline void clear_blacklist();
  static const int kBlacklistFieldNumber = 44;
  inline ::google::protobuf::int32 blacklist() const;
  inline void set_blacklist(::google::protobuf::int32 value);

  // optional int32 propertyid = 45;
  inline bool has_propertyid() const;
  inline void clear_propertyid();
  static const int kPropertyidFieldNumber = 45;
  inline ::google::protobuf::int32 propertyid() const;
  inline void set_propertyid(::google::protobuf::int32 value);

  // optional int32 ticket = 46;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 46;
  inline ::google::protobuf::int32 ticket() const;
  inline void set_ticket(::google::protobuf::int32 value);

  // optional string location_x = 47;
  inline bool has_location_x() const;
  inline void clear_location_x();
  static const int kLocationXFieldNumber = 47;
  inline const ::std::string& location_x() const;
  inline void set_location_x(const ::std::string& value);
  inline void set_location_x(const char* value);
  inline void set_location_x(const char* value, size_t size);
  inline ::std::string* mutable_location_x();
  inline ::std::string* release_location_x();
  inline void set_allocated_location_x(::std::string* location_x);

  // optional string location_y = 48;
  inline bool has_location_y() const;
  inline void clear_location_y();
  static const int kLocationYFieldNumber = 48;
  inline const ::std::string& location_y() const;
  inline void set_location_y(const ::std::string& value);
  inline void set_location_y(const char* value);
  inline void set_location_y(const char* value, size_t size);
  inline ::std::string* mutable_location_y();
  inline ::std::string* release_location_y();
  inline void set_allocated_location_y(::std::string* location_y);

  // optional string bank_password = 49;
  inline bool has_bank_password() const;
  inline void clear_bank_password();
  static const int kBankPasswordFieldNumber = 49;
  inline const ::std::string& bank_password() const;
  inline void set_bank_password(const ::std::string& value);
  inline void set_bank_password(const char* value);
  inline void set_bank_password(const char* value, size_t size);
  inline ::std::string* mutable_bank_password();
  inline ::std::string* release_bank_password();
  inline void set_allocated_bank_password(::std::string* bank_password);

  // optional string bank_jetton = 50;
  inline bool has_bank_jetton() const;
  inline void clear_bank_jetton();
  static const int kBankJettonFieldNumber = 50;
  inline const ::std::string& bank_jetton() const;
  inline void set_bank_jetton(const ::std::string& value);
  inline void set_bank_jetton(const char* value);
  inline void set_bank_jetton(const char* value, size_t size);
  inline ::std::string* mutable_bank_jetton();
  inline ::std::string* release_bank_jetton();
  inline void set_allocated_bank_jetton(::std::string* bank_jetton);

  // optional int32 agent1 = 51;
  inline bool has_agent1() const;
  inline void clear_agent1();
  static const int kAgent1FieldNumber = 51;
  inline ::google::protobuf::int32 agent1() const;
  inline void set_agent1(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.playerinfo)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_regdate();
  inline void clear_has_regdate();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_age();
  inline void clear_has_age();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_phonenum();
  inline void clear_has_phonenum();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_viplevel();
  inline void clear_has_viplevel();
  inline void set_has_jetton();
  inline void clear_has_jetton();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_province();
  inline void clear_has_province();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_popularity();
  inline void clear_has_popularity();
  inline void set_has_idenstatus();
  inline void clear_has_idenstatus();
  inline void set_has_bindtype();
  inline void clear_has_bindtype();
  inline void set_has_bindnick();
  inline void clear_has_bindnick();
  inline void set_has_platformid();
  inline void clear_has_platformid();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_devname();
  inline void clear_has_devname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mobiletype();
  inline void clear_has_mobiletype();
  inline void set_has_lasttime();
  inline void clear_has_lasttime();
  inline void set_has_penulttime();
  inline void clear_has_penulttime();
  inline void set_has_silent();
  inline void clear_has_silent();
  inline void set_has_isban();
  inline void clear_has_isban();
  inline void set_has_face_1();
  inline void clear_has_face_1();
  inline void set_has_face_2();
  inline void clear_has_face_2();
  inline void set_has_face_3();
  inline void clear_has_face_3();
  inline void set_has_face_4();
  inline void clear_has_face_4();
  inline void set_has_isrobot();
  inline void clear_has_isrobot();
  inline void set_has_playtype();
  inline void clear_has_playtype();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_bankjetton();
  inline void clear_has_bankjetton();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_blacklist();
  inline void clear_has_blacklist();
  inline void set_has_propertyid();
  inline void clear_has_propertyid();
  inline void set_has_ticket();
  inline void clear_has_ticket();
  inline void set_has_location_x();
  inline void clear_has_location_x();
  inline void set_has_location_y();
  inline void clear_has_location_y();
  inline void set_has_bank_password();
  inline void clear_has_bank_password();
  inline void set_has_bank_jetton();
  inline void clear_has_bank_jetton();
  inline void set_has_agent1();
  inline void clear_has_agent1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  ::std::string* account_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 sex_;
  ::std::string* password_;
  ::std::string* nickname_;
  ::std::string* regdate_;
  ::std::string* email_;
  ::google::protobuf::int32 age_;
  ::google::protobuf::int32 exp_;
  ::std::string* phonenum_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 viplevel_;
  ::std::string* jetton_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 money_;
  ::std::string* channel_;
  ::std::string* province_;
  ::std::string* city_;
  ::google::protobuf::int32 popularity_;
  ::google::protobuf::int32 idenstatus_;
  ::std::string* bindnick_;
  ::std::string* platformid_;
  ::std::string* imei_;
  ::google::protobuf::int32 bindtype_;
  ::google::protobuf::int32 mobiletype_;
  ::std::string* devname_;
  ::std::string* ip_;
  ::google::protobuf::int32 lasttime_;
  ::google::protobuf::int32 penulttime_;
  ::google::protobuf::int32 silent_;
  ::google::protobuf::int32 isban_;
  ::std::string* face_1_;
  ::std::string* face_2_;
  ::std::string* face_3_;
  ::std::string* face_4_;
  ::google::protobuf::int32 isrobot_;
  ::google::protobuf::int32 playtype_;
  ::std::string* description_;
  ::std::string* location_;
  ::std::string* bankjetton_;
  ::std::string* title_;
  ::google::protobuf::int32 blacklist_;
  ::google::protobuf::int32 propertyid_;
  ::std::string* location_x_;
  ::std::string* location_y_;
  ::google::protobuf::int32 ticket_;
  ::google::protobuf::int32 agent1_;
  ::std::string* bank_password_;
  ::std::string* bank_jetton_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(50 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static playerinfo* default_instance_;
};
// -------------------------------------------------------------------

class playerstats : public ::google::protobuf::Message {
 public:
  playerstats();
  virtual ~playerstats();

  playerstats(const playerstats& from);

  inline playerstats& operator=(const playerstats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const playerstats& default_instance();

  void Swap(playerstats* other);

  // implements Message ----------------------------------------------

  playerstats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const playerstats& from);
  void MergeFrom(const playerstats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional int32 mdynickamount = 2;
  inline bool has_mdynickamount() const;
  inline void clear_mdynickamount();
  static const int kMdynickamountFieldNumber = 2;
  inline ::google::protobuf::int32 mdynickamount() const;
  inline void set_mdynickamount(::google::protobuf::int32 value);

  // optional int32 loginday = 3;
  inline bool has_loginday() const;
  inline void clear_loginday();
  static const int kLogindayFieldNumber = 3;
  inline ::google::protobuf::int32 loginday() const;
  inline void set_loginday(::google::protobuf::int32 value);

  // optional int32 loginconday = 4;
  inline bool has_loginconday() const;
  inline void clear_loginconday();
  static const int kLogincondayFieldNumber = 4;
  inline ::google::protobuf::int32 loginconday() const;
  inline void set_loginconday(::google::protobuf::int32 value);

  // optional int32 maxloginconday = 5;
  inline bool has_maxloginconday() const;
  inline void clear_maxloginconday();
  static const int kMaxlogincondayFieldNumber = 5;
  inline ::google::protobuf::int32 maxloginconday() const;
  inline void set_maxloginconday(::google::protobuf::int32 value);

  // optional int32 loginamount = 6;
  inline bool has_loginamount() const;
  inline void clear_loginamount();
  static const int kLoginamountFieldNumber = 6;
  inline ::google::protobuf::int32 loginamount() const;
  inline void set_loginamount(::google::protobuf::int32 value);

  // optional int32 onlinetime = 7;
  inline bool has_onlinetime() const;
  inline void clear_onlinetime();
  static const int kOnlinetimeFieldNumber = 7;
  inline ::google::protobuf::int32 onlinetime() const;
  inline void set_onlinetime(::google::protobuf::int32 value);

  // optional string maxjetton = 8;
  inline bool has_maxjetton() const;
  inline void clear_maxjetton();
  static const int kMaxjettonFieldNumber = 8;
  inline const ::std::string& maxjetton() const;
  inline void set_maxjetton(const ::std::string& value);
  inline void set_maxjetton(const char* value);
  inline void set_maxjetton(const char* value, size_t size);
  inline ::std::string* mutable_maxjetton();
  inline ::std::string* release_maxjetton();
  inline void set_allocated_maxjetton(::std::string* maxjetton);

  // optional int32 payrmb = 9;
  inline bool has_payrmb() const;
  inline void clear_payrmb();
  static const int kPayrmbFieldNumber = 9;
  inline ::google::protobuf::int32 payrmb() const;
  inline void set_payrmb(::google::protobuf::int32 value);

  // optional int32 callpayrmb = 10;
  inline bool has_callpayrmb() const;
  inline void clear_callpayrmb();
  static const int kCallpayrmbFieldNumber = 10;
  inline ::google::protobuf::int32 callpayrmb() const;
  inline void set_callpayrmb(::google::protobuf::int32 value);

  // optional int32 paytime = 11;
  inline bool has_paytime() const;
  inline void clear_paytime();
  static const int kPaytimeFieldNumber = 11;
  inline ::google::protobuf::int32 paytime() const;
  inline void set_paytime(::google::protobuf::int32 value);

  // optional int32 callpaytime = 12;
  inline bool has_callpaytime() const;
  inline void clear_callpaytime();
  static const int kCallpaytimeFieldNumber = 12;
  inline ::google::protobuf::int32 callpaytime() const;
  inline void set_callpaytime(::google::protobuf::int32 value);

  // optional int32 maxmoney = 13;
  inline bool has_maxmoney() const;
  inline void clear_maxmoney();
  static const int kMaxmoneyFieldNumber = 13;
  inline ::google::protobuf::int32 maxmoney() const;
  inline void set_maxmoney(::google::protobuf::int32 value);

  // optional int32 dayrmb = 14;
  inline bool has_dayrmb() const;
  inline void clear_dayrmb();
  static const int kDayrmbFieldNumber = 14;
  inline ::google::protobuf::int32 dayrmb() const;
  inline void set_dayrmb(::google::protobuf::int32 value);

  // optional int32 daypaytime = 15;
  inline bool has_daypaytime() const;
  inline void clear_daypaytime();
  static const int kDaypaytimeFieldNumber = 15;
  inline ::google::protobuf::int32 daypaytime() const;
  inline void set_daypaytime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.playerstats)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_mdynickamount();
  inline void clear_has_mdynickamount();
  inline void set_has_loginday();
  inline void clear_has_loginday();
  inline void set_has_loginconday();
  inline void clear_has_loginconday();
  inline void set_has_maxloginconday();
  inline void clear_has_maxloginconday();
  inline void set_has_loginamount();
  inline void clear_has_loginamount();
  inline void set_has_onlinetime();
  inline void clear_has_onlinetime();
  inline void set_has_maxjetton();
  inline void clear_has_maxjetton();
  inline void set_has_payrmb();
  inline void clear_has_payrmb();
  inline void set_has_callpayrmb();
  inline void clear_has_callpayrmb();
  inline void set_has_paytime();
  inline void clear_has_paytime();
  inline void set_has_callpaytime();
  inline void clear_has_callpaytime();
  inline void set_has_maxmoney();
  inline void clear_has_maxmoney();
  inline void set_has_dayrmb();
  inline void clear_has_dayrmb();
  inline void set_has_daypaytime();
  inline void clear_has_daypaytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 mdynickamount_;
  ::google::protobuf::int32 loginday_;
  ::google::protobuf::int32 loginconday_;
  ::google::protobuf::int32 maxloginconday_;
  ::google::protobuf::int32 loginamount_;
  ::std::string* maxjetton_;
  ::google::protobuf::int32 onlinetime_;
  ::google::protobuf::int32 payrmb_;
  ::google::protobuf::int32 callpayrmb_;
  ::google::protobuf::int32 paytime_;
  ::google::protobuf::int32 callpaytime_;
  ::google::protobuf::int32 maxmoney_;
  ::google::protobuf::int32 dayrmb_;
  ::google::protobuf::int32 daypaytime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static playerstats* default_instance_;
};
// -------------------------------------------------------------------

class goodsinfo : public ::google::protobuf::Message {
 public:
  goodsinfo();
  virtual ~goodsinfo();

  goodsinfo(const goodsinfo& from);

  inline goodsinfo& operator=(const goodsinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const goodsinfo& default_instance();

  void Swap(goodsinfo* other);

  // implements Message ----------------------------------------------

  goodsinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const goodsinfo& from);
  void MergeFrom(const goodsinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 itemid = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional int32 goodsid = 3;
  inline bool has_goodsid() const;
  inline void clear_goodsid();
  static const int kGoodsidFieldNumber = 3;
  inline ::google::protobuf::int32 goodsid() const;
  inline void set_goodsid(::google::protobuf::int32 value);

  // optional int32 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::int32 amount() const;
  inline void set_amount(::google::protobuf::int32 value);

  // optional int32 validity = 5;
  inline bool has_validity() const;
  inline void clear_validity();
  static const int kValidityFieldNumber = 5;
  inline ::google::protobuf::int32 validity() const;
  inline void set_validity(::google::protobuf::int32 value);

  // optional string createdate = 6;
  inline bool has_createdate() const;
  inline void clear_createdate();
  static const int kCreatedateFieldNumber = 6;
  inline const ::std::string& createdate() const;
  inline void set_createdate(const ::std::string& value);
  inline void set_createdate(const char* value);
  inline void set_createdate(const char* value, size_t size);
  inline ::std::string* mutable_createdate();
  inline ::std::string* release_createdate();
  inline void set_allocated_createdate(::std::string* createdate);

  // optional int32 iswear = 7;
  inline bool has_iswear() const;
  inline void clear_iswear();
  static const int kIswearFieldNumber = 7;
  inline ::google::protobuf::int32 iswear() const;
  inline void set_iswear(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.goodsinfo)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_goodsid();
  inline void clear_has_goodsid();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_validity();
  inline void clear_has_validity();
  inline void set_has_createdate();
  inline void clear_has_createdate();
  inline void set_has_iswear();
  inline void clear_has_iswear();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 goodsid_;
  ::google::protobuf::int32 amount_;
  ::std::string* createdate_;
  ::google::protobuf::int32 validity_;
  ::google::protobuf::int32 iswear_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static goodsinfo* default_instance_;
};
// -------------------------------------------------------------------

class goodslist : public ::google::protobuf::Message {
 public:
  goodslist();
  virtual ~goodslist();

  goodslist(const goodslist& from);

  inline goodslist& operator=(const goodslist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const goodslist& default_instance();

  void Swap(goodslist* other);

  // implements Message ----------------------------------------------

  goodslist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const goodslist& from);
  void MergeFrom(const goodslist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .progame.goodsinfo glist = 1;
  inline int glist_size() const;
  inline void clear_glist();
  static const int kGlistFieldNumber = 1;
  inline const ::progame::goodsinfo& glist(int index) const;
  inline ::progame::goodsinfo* mutable_glist(int index);
  inline ::progame::goodsinfo* add_glist();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::goodsinfo >&
      glist() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::goodsinfo >*
      mutable_glist();

  // @@protoc_insertion_point(class_scope:progame.goodslist)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::progame::goodsinfo > glist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static goodslist* default_instance_;
};
// -------------------------------------------------------------------

class noticeinfo : public ::google::protobuf::Message {
 public:
  noticeinfo();
  virtual ~noticeinfo();

  noticeinfo(const noticeinfo& from);

  inline noticeinfo& operator=(const noticeinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const noticeinfo& default_instance();

  void Swap(noticeinfo* other);

  // implements Message ----------------------------------------------

  noticeinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const noticeinfo& from);
  void MergeFrom(const noticeinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 noticetype = 1;
  inline bool has_noticetype() const;
  inline void clear_noticetype();
  static const int kNoticetypeFieldNumber = 1;
  inline ::google::protobuf::int32 noticetype() const;
  inline void set_noticetype(::google::protobuf::int32 value);

  // optional int32 amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::int32 amount() const;
  inline void set_amount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.noticeinfo)
 private:
  inline void set_has_noticetype();
  inline void clear_has_noticetype();
  inline void set_has_amount();
  inline void clear_has_amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 noticetype_;
  ::google::protobuf::int32 amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static noticeinfo* default_instance_;
};
// -------------------------------------------------------------------

class playersimpleinfo : public ::google::protobuf::Message {
 public:
  playersimpleinfo();
  virtual ~playersimpleinfo();

  playersimpleinfo(const playersimpleinfo& from);

  inline playersimpleinfo& operator=(const playersimpleinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const playersimpleinfo& default_instance();

  void Swap(playersimpleinfo* other);

  // implements Message ----------------------------------------------

  playersimpleinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const playersimpleinfo& from);
  void MergeFrom(const playersimpleinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional string nickname = 5;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 5;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional int32 sex = 8;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 8;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional int32 level = 13;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 13;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 viplevel = 14;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kViplevelFieldNumber = 14;
  inline ::google::protobuf::int32 viplevel() const;
  inline void set_viplevel(::google::protobuf::int32 value);

  // optional string jetton = 15;
  inline bool has_jetton() const;
  inline void clear_jetton();
  static const int kJettonFieldNumber = 15;
  inline const ::std::string& jetton() const;
  inline void set_jetton(const ::std::string& value);
  inline void set_jetton(const char* value);
  inline void set_jetton(const char* value, size_t size);
  inline ::std::string* mutable_jetton();
  inline ::std::string* release_jetton();
  inline void set_allocated_jetton(::std::string* jetton);

  // optional int32 gold = 16;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 16;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional int32 popularity = 21;
  inline bool has_popularity() const;
  inline void clear_popularity();
  static const int kPopularityFieldNumber = 21;
  inline ::google::protobuf::int32 popularity() const;
  inline void set_popularity(::google::protobuf::int32 value);

  // optional string ip = 31;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 31;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string face_1 = 34;
  inline bool has_face_1() const;
  inline void clear_face_1();
  static const int kFace1FieldNumber = 34;
  inline const ::std::string& face_1() const;
  inline void set_face_1(const ::std::string& value);
  inline void set_face_1(const char* value);
  inline void set_face_1(const char* value, size_t size);
  inline ::std::string* mutable_face_1();
  inline ::std::string* release_face_1();
  inline void set_allocated_face_1(::std::string* face_1);

  // optional string location = 41;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 41;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional int32 propertyid = 45;
  inline bool has_propertyid() const;
  inline void clear_propertyid();
  static const int kPropertyidFieldNumber = 45;
  inline ::google::protobuf::int32 propertyid() const;
  inline void set_propertyid(::google::protobuf::int32 value);

  // optional string jifen = 99;
  inline bool has_jifen() const;
  inline void clear_jifen();
  static const int kJifenFieldNumber = 99;
  inline const ::std::string& jifen() const;
  inline void set_jifen(const ::std::string& value);
  inline void set_jifen(const char* value);
  inline void set_jifen(const char* value, size_t size);
  inline ::std::string* mutable_jifen();
  inline ::std::string* release_jifen();
  inline void set_allocated_jifen(::std::string* jifen);

  // optional string location_x = 47;
  inline bool has_location_x() const;
  inline void clear_location_x();
  static const int kLocationXFieldNumber = 47;
  inline const ::std::string& location_x() const;
  inline void set_location_x(const ::std::string& value);
  inline void set_location_x(const char* value);
  inline void set_location_x(const char* value, size_t size);
  inline ::std::string* mutable_location_x();
  inline ::std::string* release_location_x();
  inline void set_allocated_location_x(::std::string* location_x);

  // optional string location_y = 48;
  inline bool has_location_y() const;
  inline void clear_location_y();
  static const int kLocationYFieldNumber = 48;
  inline const ::std::string& location_y() const;
  inline void set_location_y(const ::std::string& value);
  inline void set_location_y(const char* value);
  inline void set_location_y(const char* value, size_t size);
  inline ::std::string* mutable_location_y();
  inline ::std::string* release_location_y();
  inline void set_allocated_location_y(::std::string* location_y);

  // @@protoc_insertion_point(class_scope:progame.playersimpleinfo)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_viplevel();
  inline void clear_has_viplevel();
  inline void set_has_jetton();
  inline void clear_has_jetton();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_popularity();
  inline void clear_has_popularity();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_face_1();
  inline void clear_has_face_1();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_propertyid();
  inline void clear_has_propertyid();
  inline void set_has_jifen();
  inline void clear_has_jifen();
  inline void set_has_location_x();
  inline void clear_has_location_x();
  inline void set_has_location_y();
  inline void clear_has_location_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nickname_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 viplevel_;
  ::std::string* jetton_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 popularity_;
  ::std::string* ip_;
  ::std::string* face_1_;
  ::std::string* location_;
  ::std::string* jifen_;
  ::std::string* location_x_;
  ::std::string* location_y_;
  ::google::protobuf::int32 propertyid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static playersimpleinfo* default_instance_;
};
// -------------------------------------------------------------------

class broadcastinfo : public ::google::protobuf::Message {
 public:
  broadcastinfo();
  virtual ~broadcastinfo();

  broadcastinfo(const broadcastinfo& from);

  inline broadcastinfo& operator=(const broadcastinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const broadcastinfo& default_instance();

  void Swap(broadcastinfo* other);

  // implements Message ----------------------------------------------

  broadcastinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const broadcastinfo& from);
  void MergeFrom(const broadcastinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 broadtype = 2;
  inline bool has_broadtype() const;
  inline void clear_broadtype();
  static const int kBroadtypeFieldNumber = 2;
  inline ::google::protobuf::int32 broadtype() const;
  inline void set_broadtype(::google::protobuf::int32 value);

  // optional int32 senderid = 3;
  inline bool has_senderid() const;
  inline void clear_senderid();
  static const int kSenderidFieldNumber = 3;
  inline ::google::protobuf::int32 senderid() const;
  inline void set_senderid(::google::protobuf::int32 value);

  // optional string sender = 4;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 4;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // optional string msg = 5;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 5;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional int32 broadtimes = 6;
  inline bool has_broadtimes() const;
  inline void clear_broadtimes();
  static const int kBroadtimesFieldNumber = 6;
  inline ::google::protobuf::int32 broadtimes() const;
  inline void set_broadtimes(::google::protobuf::int32 value);

  // optional int32 validday = 7;
  inline bool has_validday() const;
  inline void clear_validday();
  static const int kValiddayFieldNumber = 7;
  inline ::google::protobuf::int32 validday() const;
  inline void set_validday(::google::protobuf::int32 value);

  // optional string createtime = 8;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreatetimeFieldNumber = 8;
  inline const ::std::string& createtime() const;
  inline void set_createtime(const ::std::string& value);
  inline void set_createtime(const char* value);
  inline void set_createtime(const char* value, size_t size);
  inline ::std::string* mutable_createtime();
  inline ::std::string* release_createtime();
  inline void set_allocated_createtime(::std::string* createtime);

  // optional int32 cycletype = 9;
  inline bool has_cycletype() const;
  inline void clear_cycletype();
  static const int kCycletypeFieldNumber = 9;
  inline ::google::protobuf::int32 cycletype() const;
  inline void set_cycletype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.broadcastinfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_broadtype();
  inline void clear_has_broadtype();
  inline void set_has_senderid();
  inline void clear_has_senderid();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_broadtimes();
  inline void clear_has_broadtimes();
  inline void set_has_validday();
  inline void clear_has_validday();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_cycletype();
  inline void clear_has_cycletype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 broadtype_;
  ::std::string* sender_;
  ::google::protobuf::int32 senderid_;
  ::google::protobuf::int32 broadtimes_;
  ::std::string* msg_;
  ::std::string* createtime_;
  ::google::protobuf::int32 validday_;
  ::google::protobuf::int32 cycletype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static broadcastinfo* default_instance_;
};
// -------------------------------------------------------------------

class mailinfo : public ::google::protobuf::Message {
 public:
  mailinfo();
  virtual ~mailinfo();

  mailinfo(const mailinfo& from);

  inline mailinfo& operator=(const mailinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mailinfo& default_instance();

  void Swap(mailinfo* other);

  // implements Message ----------------------------------------------

  mailinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mailinfo& from);
  void MergeFrom(const mailinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 mailid = 1;
  inline bool has_mailid() const;
  inline void clear_mailid();
  static const int kMailidFieldNumber = 1;
  inline ::google::protobuf::int32 mailid() const;
  inline void set_mailid(::google::protobuf::int32 value);

  // optional int32 senderid = 2;
  inline bool has_senderid() const;
  inline void clear_senderid();
  static const int kSenderidFieldNumber = 2;
  inline ::google::protobuf::int32 senderid() const;
  inline void set_senderid(::google::protobuf::int32 value);

  // optional string sender = 3;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 3;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // optional int32 receiverid = 4;
  inline bool has_receiverid() const;
  inline void clear_receiverid();
  static const int kReceiveridFieldNumber = 4;
  inline ::google::protobuf::int32 receiverid() const;
  inline void set_receiverid(::google::protobuf::int32 value);

  // optional string receiver = 5;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 5;
  inline const ::std::string& receiver() const;
  inline void set_receiver(const ::std::string& value);
  inline void set_receiver(const char* value);
  inline void set_receiver(const char* value, size_t size);
  inline ::std::string* mutable_receiver();
  inline ::std::string* release_receiver();
  inline void set_allocated_receiver(::std::string* receiver);

  // optional int32 mailtype = 6;
  inline bool has_mailtype() const;
  inline void clear_mailtype();
  static const int kMailtypeFieldNumber = 6;
  inline ::google::protobuf::int32 mailtype() const;
  inline void set_mailtype(::google::protobuf::int32 value);

  // optional string title = 7;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 7;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string content = 8;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 8;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string senddate = 9;
  inline bool has_senddate() const;
  inline void clear_senddate();
  static const int kSenddateFieldNumber = 9;
  inline const ::std::string& senddate() const;
  inline void set_senddate(const ::std::string& value);
  inline void set_senddate(const char* value);
  inline void set_senddate(const char* value, size_t size);
  inline ::std::string* mutable_senddate();
  inline ::std::string* release_senddate();
  inline void set_allocated_senddate(::std::string* senddate);

  // optional string markdate = 10;
  inline bool has_markdate() const;
  inline void clear_markdate();
  static const int kMarkdateFieldNumber = 10;
  inline const ::std::string& markdate() const;
  inline void set_markdate(const ::std::string& value);
  inline void set_markdate(const char* value);
  inline void set_markdate(const char* value, size_t size);
  inline ::std::string* mutable_markdate();
  inline ::std::string* release_markdate();
  inline void set_allocated_markdate(::std::string* markdate);

  // optional int32 mailstate = 11;
  inline bool has_mailstate() const;
  inline void clear_mailstate();
  static const int kMailstateFieldNumber = 11;
  inline ::google::protobuf::int32 mailstate() const;
  inline void set_mailstate(::google::protobuf::int32 value);

  // optional string externdata = 12;
  inline bool has_externdata() const;
  inline void clear_externdata();
  static const int kExterndataFieldNumber = 12;
  inline const ::std::string& externdata() const;
  inline void set_externdata(const ::std::string& value);
  inline void set_externdata(const char* value);
  inline void set_externdata(const char* value, size_t size);
  inline ::std::string* mutable_externdata();
  inline ::std::string* release_externdata();
  inline void set_allocated_externdata(::std::string* externdata);

  // optional string remark = 13;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 13;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // optional int32 validity = 14;
  inline bool has_validity() const;
  inline void clear_validity();
  static const int kValidityFieldNumber = 14;
  inline ::google::protobuf::int32 validity() const;
  inline void set_validity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.mailinfo)
 private:
  inline void set_has_mailid();
  inline void clear_has_mailid();
  inline void set_has_senderid();
  inline void clear_has_senderid();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_receiverid();
  inline void clear_has_receiverid();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_mailtype();
  inline void clear_has_mailtype();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_senddate();
  inline void clear_has_senddate();
  inline void set_has_markdate();
  inline void clear_has_markdate();
  inline void set_has_mailstate();
  inline void clear_has_mailstate();
  inline void set_has_externdata();
  inline void clear_has_externdata();
  inline void set_has_remark();
  inline void clear_has_remark();
  inline void set_has_validity();
  inline void clear_has_validity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 mailid_;
  ::google::protobuf::int32 senderid_;
  ::std::string* sender_;
  ::std::string* receiver_;
  ::google::protobuf::int32 receiverid_;
  ::google::protobuf::int32 mailtype_;
  ::std::string* title_;
  ::std::string* content_;
  ::std::string* senddate_;
  ::std::string* markdate_;
  ::std::string* externdata_;
  ::google::protobuf::int32 mailstate_;
  ::google::protobuf::int32 validity_;
  ::std::string* remark_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static mailinfo* default_instance_;
};
// -------------------------------------------------------------------

class maillist : public ::google::protobuf::Message {
 public:
  maillist();
  virtual ~maillist();

  maillist(const maillist& from);

  inline maillist& operator=(const maillist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const maillist& default_instance();

  void Swap(maillist* other);

  // implements Message ----------------------------------------------

  maillist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const maillist& from);
  void MergeFrom(const maillist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .progame.mailinfo mlist = 1;
  inline int mlist_size() const;
  inline void clear_mlist();
  static const int kMlistFieldNumber = 1;
  inline const ::progame::mailinfo& mlist(int index) const;
  inline ::progame::mailinfo* mutable_mlist(int index);
  inline ::progame::mailinfo* add_mlist();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::mailinfo >&
      mlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::mailinfo >*
      mutable_mlist();

  // @@protoc_insertion_point(class_scope:progame.maillist)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::progame::mailinfo > mlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static maillist* default_instance_;
};
// -------------------------------------------------------------------

class inviteinfo : public ::google::protobuf::Message {
 public:
  inviteinfo();
  virtual ~inviteinfo();

  inviteinfo(const inviteinfo& from);

  inline inviteinfo& operator=(const inviteinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const inviteinfo& default_instance();

  void Swap(inviteinfo* other);

  // implements Message ----------------------------------------------

  inviteinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const inviteinfo& from);
  void MergeFrom(const inviteinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional int32 binduserid = 2;
  inline bool has_binduserid() const;
  inline void clear_binduserid();
  static const int kBinduseridFieldNumber = 2;
  inline ::google::protobuf::int32 binduserid() const;
  inline void set_binduserid(::google::protobuf::int32 value);

  // optional string bindnickname = 3;
  inline bool has_bindnickname() const;
  inline void clear_bindnickname();
  static const int kBindnicknameFieldNumber = 3;
  inline const ::std::string& bindnickname() const;
  inline void set_bindnickname(const ::std::string& value);
  inline void set_bindnickname(const char* value);
  inline void set_bindnickname(const char* value, size_t size);
  inline ::std::string* mutable_bindnickname();
  inline ::std::string* release_bindnickname();
  inline void set_allocated_bindnickname(::std::string* bindnickname);

  // optional string bindfaceid = 4;
  inline bool has_bindfaceid() const;
  inline void clear_bindfaceid();
  static const int kBindfaceidFieldNumber = 4;
  inline const ::std::string& bindfaceid() const;
  inline void set_bindfaceid(const ::std::string& value);
  inline void set_bindfaceid(const char* value);
  inline void set_bindfaceid(const char* value, size_t size);
  inline ::std::string* mutable_bindfaceid();
  inline ::std::string* release_bindfaceid();
  inline void set_allocated_bindfaceid(::std::string* bindfaceid);

  // optional string binddate = 5;
  inline bool has_binddate() const;
  inline void clear_binddate();
  static const int kBinddateFieldNumber = 5;
  inline const ::std::string& binddate() const;
  inline void set_binddate(const ::std::string& value);
  inline void set_binddate(const char* value);
  inline void set_binddate(const char* value, size_t size);
  inline ::std::string* mutable_binddate();
  inline ::std::string* release_binddate();
  inline void set_allocated_binddate(::std::string* binddate);

  // @@protoc_insertion_point(class_scope:progame.inviteinfo)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_binduserid();
  inline void clear_has_binduserid();
  inline void set_has_bindnickname();
  inline void clear_has_bindnickname();
  inline void set_has_bindfaceid();
  inline void clear_has_bindfaceid();
  inline void set_has_binddate();
  inline void clear_has_binddate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 binduserid_;
  ::std::string* bindnickname_;
  ::std::string* bindfaceid_;
  ::std::string* binddate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static inviteinfo* default_instance_;
};
// -------------------------------------------------------------------

class agencyinfo : public ::google::protobuf::Message {
 public:
  agencyinfo();
  virtual ~agencyinfo();

  agencyinfo(const agencyinfo& from);

  inline agencyinfo& operator=(const agencyinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const agencyinfo& default_instance();

  void Swap(agencyinfo* other);

  // implements Message ----------------------------------------------

  agencyinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const agencyinfo& from);
  void MergeFrom(const agencyinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional string invitestr = 2;
  inline bool has_invitestr() const;
  inline void clear_invitestr();
  static const int kInvitestrFieldNumber = 2;
  inline const ::std::string& invitestr() const;
  inline void set_invitestr(const ::std::string& value);
  inline void set_invitestr(const char* value);
  inline void set_invitestr(const char* value, size_t size);
  inline ::std::string* mutable_invitestr();
  inline ::std::string* release_invitestr();
  inline void set_allocated_invitestr(::std::string* invitestr);

  // optional int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 soleagent = 4;
  inline bool has_soleagent() const;
  inline void clear_soleagent();
  static const int kSoleagentFieldNumber = 4;
  inline ::google::protobuf::int32 soleagent() const;
  inline void set_soleagent(::google::protobuf::int32 value);

  // optional int32 agent1 = 5;
  inline bool has_agent1() const;
  inline void clear_agent1();
  static const int kAgent1FieldNumber = 5;
  inline ::google::protobuf::int32 agent1() const;
  inline void set_agent1(::google::protobuf::int32 value);

  // optional int32 agent2 = 6;
  inline bool has_agent2() const;
  inline void clear_agent2();
  static const int kAgent2FieldNumber = 6;
  inline ::google::protobuf::int32 agent2() const;
  inline void set_agent2(::google::protobuf::int32 value);

  // optional int32 agent3 = 7;
  inline bool has_agent3() const;
  inline void clear_agent3();
  static const int kAgent3FieldNumber = 7;
  inline ::google::protobuf::int32 agent3() const;
  inline void set_agent3(::google::protobuf::int32 value);

  // optional int32 agent4 = 8;
  inline bool has_agent4() const;
  inline void clear_agent4();
  static const int kAgent4FieldNumber = 8;
  inline ::google::protobuf::int32 agent4() const;
  inline void set_agent4(::google::protobuf::int32 value);

  // repeated .progame.inviteinfo invitelist = 9;
  inline int invitelist_size() const;
  inline void clear_invitelist();
  static const int kInvitelistFieldNumber = 9;
  inline const ::progame::inviteinfo& invitelist(int index) const;
  inline ::progame::inviteinfo* mutable_invitelist(int index);
  inline ::progame::inviteinfo* add_invitelist();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::inviteinfo >&
      invitelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::inviteinfo >*
      mutable_invitelist();

  // optional string qrcodeurl = 10;
  inline bool has_qrcodeurl() const;
  inline void clear_qrcodeurl();
  static const int kQrcodeurlFieldNumber = 10;
  inline const ::std::string& qrcodeurl() const;
  inline void set_qrcodeurl(const ::std::string& value);
  inline void set_qrcodeurl(const char* value);
  inline void set_qrcodeurl(const char* value, size_t size);
  inline ::std::string* mutable_qrcodeurl();
  inline ::std::string* release_qrcodeurl();
  inline void set_allocated_qrcodeurl(::std::string* qrcodeurl);

  // optional string datemark = 11;
  inline bool has_datemark() const;
  inline void clear_datemark();
  static const int kDatemarkFieldNumber = 11;
  inline const ::std::string& datemark() const;
  inline void set_datemark(const ::std::string& value);
  inline void set_datemark(const char* value);
  inline void set_datemark(const char* value, size_t size);
  inline ::std::string* mutable_datemark();
  inline ::std::string* release_datemark();
  inline void set_allocated_datemark(::std::string* datemark);

  // optional int32 moneymark = 12;
  inline bool has_moneymark() const;
  inline void clear_moneymark();
  static const int kMoneymarkFieldNumber = 12;
  inline ::google::protobuf::int32 moneymark() const;
  inline void set_moneymark(::google::protobuf::int32 value);

  // optional int32 weekmoney = 13;
  inline bool has_weekmoney() const;
  inline void clear_weekmoney();
  static const int kWeekmoneyFieldNumber = 13;
  inline ::google::protobuf::int32 weekmoney() const;
  inline void set_weekmoney(::google::protobuf::int32 value);

  // optional string exclusiveurl = 14;
  inline bool has_exclusiveurl() const;
  inline void clear_exclusiveurl();
  static const int kExclusiveurlFieldNumber = 14;
  inline const ::std::string& exclusiveurl() const;
  inline void set_exclusiveurl(const ::std::string& value);
  inline void set_exclusiveurl(const char* value);
  inline void set_exclusiveurl(const char* value, size_t size);
  inline ::std::string* mutable_exclusiveurl();
  inline ::std::string* release_exclusiveurl();
  inline void set_allocated_exclusiveurl(::std::string* exclusiveurl);

  // optional string alipay = 15;
  inline bool has_alipay() const;
  inline void clear_alipay();
  static const int kAlipayFieldNumber = 15;
  inline const ::std::string& alipay() const;
  inline void set_alipay(const ::std::string& value);
  inline void set_alipay(const char* value);
  inline void set_alipay(const char* value, size_t size);
  inline ::std::string* mutable_alipay();
  inline ::std::string* release_alipay();
  inline void set_allocated_alipay(::std::string* alipay);

  // optional string bankaccount = 16;
  inline bool has_bankaccount() const;
  inline void clear_bankaccount();
  static const int kBankaccountFieldNumber = 16;
  inline const ::std::string& bankaccount() const;
  inline void set_bankaccount(const ::std::string& value);
  inline void set_bankaccount(const char* value);
  inline void set_bankaccount(const char* value, size_t size);
  inline ::std::string* mutable_bankaccount();
  inline ::std::string* release_bankaccount();
  inline void set_allocated_bankaccount(::std::string* bankaccount);

  // optional int32 wiringid = 17;
  inline bool has_wiringid() const;
  inline void clear_wiringid();
  static const int kWiringidFieldNumber = 17;
  inline ::google::protobuf::int32 wiringid() const;
  inline void set_wiringid(::google::protobuf::int32 value);

  // optional int32 grade = 18;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 18;
  inline ::google::protobuf::int32 grade() const;
  inline void set_grade(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.agencyinfo)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_invitestr();
  inline void clear_has_invitestr();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_soleagent();
  inline void clear_has_soleagent();
  inline void set_has_agent1();
  inline void clear_has_agent1();
  inline void set_has_agent2();
  inline void clear_has_agent2();
  inline void set_has_agent3();
  inline void clear_has_agent3();
  inline void set_has_agent4();
  inline void clear_has_agent4();
  inline void set_has_qrcodeurl();
  inline void clear_has_qrcodeurl();
  inline void set_has_datemark();
  inline void clear_has_datemark();
  inline void set_has_moneymark();
  inline void clear_has_moneymark();
  inline void set_has_weekmoney();
  inline void clear_has_weekmoney();
  inline void set_has_exclusiveurl();
  inline void clear_has_exclusiveurl();
  inline void set_has_alipay();
  inline void clear_has_alipay();
  inline void set_has_bankaccount();
  inline void clear_has_bankaccount();
  inline void set_has_wiringid();
  inline void clear_has_wiringid();
  inline void set_has_grade();
  inline void clear_has_grade();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* invitestr_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 soleagent_;
  ::google::protobuf::int32 agent1_;
  ::google::protobuf::int32 agent2_;
  ::google::protobuf::int32 agent3_;
  ::google::protobuf::RepeatedPtrField< ::progame::inviteinfo > invitelist_;
  ::std::string* qrcodeurl_;
  ::google::protobuf::int32 agent4_;
  ::google::protobuf::int32 moneymark_;
  ::std::string* datemark_;
  ::std::string* exclusiveurl_;
  ::std::string* alipay_;
  ::google::protobuf::int32 weekmoney_;
  ::google::protobuf::int32 wiringid_;
  ::std::string* bankaccount_;
  ::google::protobuf::int32 grade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static agencyinfo* default_instance_;
};
// -------------------------------------------------------------------

class intlist : public ::google::protobuf::Message {
 public:
  intlist();
  virtual ~intlist();

  intlist(const intlist& from);

  inline intlist& operator=(const intlist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const intlist& default_instance();

  void Swap(intlist* other);

  // implements Message ----------------------------------------------

  intlist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const intlist& from);
  void MergeFrom(const intlist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 ilist = 1;
  inline int ilist_size() const;
  inline void clear_ilist();
  static const int kIlistFieldNumber = 1;
  inline ::google::protobuf::int32 ilist(int index) const;
  inline void set_ilist(int index, ::google::protobuf::int32 value);
  inline void add_ilist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ilist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ilist();

  // @@protoc_insertion_point(class_scope:progame.intlist)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ilist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static intlist* default_instance_;
};
// -------------------------------------------------------------------

class stringlist : public ::google::protobuf::Message {
 public:
  stringlist();
  virtual ~stringlist();

  stringlist(const stringlist& from);

  inline stringlist& operator=(const stringlist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stringlist& default_instance();

  void Swap(stringlist* other);

  // implements Message ----------------------------------------------

  stringlist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stringlist& from);
  void MergeFrom(const stringlist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string slist = 1;
  inline int slist_size() const;
  inline void clear_slist();
  static const int kSlistFieldNumber = 1;
  inline const ::std::string& slist(int index) const;
  inline ::std::string* mutable_slist(int index);
  inline void set_slist(int index, const ::std::string& value);
  inline void set_slist(int index, const char* value);
  inline void set_slist(int index, const char* value, size_t size);
  inline ::std::string* add_slist();
  inline void add_slist(const ::std::string& value);
  inline void add_slist(const char* value);
  inline void add_slist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& slist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_slist();

  // @@protoc_insertion_point(class_scope:progame.stringlist)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> slist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static stringlist* default_instance_;
};
// -------------------------------------------------------------------

class useraward : public ::google::protobuf::Message {
 public:
  useraward();
  virtual ~useraward();

  useraward(const useraward& from);

  inline useraward& operator=(const useraward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const useraward& default_instance();

  void Swap(useraward* other);

  // implements Message ----------------------------------------------

  useraward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const useraward& from);
  void MergeFrom(const useraward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 awardtype = 2;
  inline bool has_awardtype() const;
  inline void clear_awardtype();
  static const int kAwardtypeFieldNumber = 2;
  inline ::google::protobuf::int32 awardtype() const;
  inline void set_awardtype(::google::protobuf::int32 value);

  // optional int32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 timemark = 4;
  inline bool has_timemark() const;
  inline void clear_timemark();
  static const int kTimemarkFieldNumber = 4;
  inline ::google::protobuf::int32 timemark() const;
  inline void set_timemark(::google::protobuf::int32 value);

  // optional int32 state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.useraward)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_awardtype();
  inline void clear_has_awardtype();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_timemark();
  inline void clear_has_timemark();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 awardtype_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 timemark_;
  ::google::protobuf::int32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static useraward* default_instance_;
};
// -------------------------------------------------------------------

class banktransferrecord : public ::google::protobuf::Message {
 public:
  banktransferrecord();
  virtual ~banktransferrecord();

  banktransferrecord(const banktransferrecord& from);

  inline banktransferrecord& operator=(const banktransferrecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const banktransferrecord& default_instance();

  void Swap(banktransferrecord* other);

  // implements Message ----------------------------------------------

  banktransferrecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const banktransferrecord& from);
  void MergeFrom(const banktransferrecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline const ::std::string& amount() const;
  inline void set_amount(const ::std::string& value);
  inline void set_amount(const char* value);
  inline void set_amount(const char* value, size_t size);
  inline ::std::string* mutable_amount();
  inline ::std::string* release_amount();
  inline void set_allocated_amount(::std::string* amount);

  // optional string timemark = 4;
  inline bool has_timemark() const;
  inline void clear_timemark();
  static const int kTimemarkFieldNumber = 4;
  inline const ::std::string& timemark() const;
  inline void set_timemark(const ::std::string& value);
  inline void set_timemark(const char* value);
  inline void set_timemark(const char* value, size_t size);
  inline ::std::string* mutable_timemark();
  inline ::std::string* release_timemark();
  inline void set_allocated_timemark(::std::string* timemark);

  // @@protoc_insertion_point(class_scope:progame.banktransferrecord)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_timemark();
  inline void clear_has_timemark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nickname_;
  ::std::string* amount_;
  ::std::string* timemark_;
  ::google::protobuf::int32 userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static banktransferrecord* default_instance_;
};
// -------------------------------------------------------------------

class specialcardreward : public ::google::protobuf::Message {
 public:
  specialcardreward();
  virtual ~specialcardreward();

  specialcardreward(const specialcardreward& from);

  inline specialcardreward& operator=(const specialcardreward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const specialcardreward& default_instance();

  void Swap(specialcardreward* other);

  // implements Message ----------------------------------------------

  specialcardreward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const specialcardreward& from);
  void MergeFrom(const specialcardreward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional int32 cardtype = 2;
  inline bool has_cardtype() const;
  inline void clear_cardtype();
  static const int kCardtypeFieldNumber = 2;
  inline ::google::protobuf::int32 cardtype() const;
  inline void set_cardtype(::google::protobuf::int32 value);

  // optional int32 reward = 3;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 3;
  inline ::google::protobuf::int32 reward() const;
  inline void set_reward(::google::protobuf::int32 value);

  // optional int32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string createdate = 5;
  inline bool has_createdate() const;
  inline void clear_createdate();
  static const int kCreatedateFieldNumber = 5;
  inline const ::std::string& createdate() const;
  inline void set_createdate(const ::std::string& value);
  inline void set_createdate(const char* value);
  inline void set_createdate(const char* value, size_t size);
  inline ::std::string* mutable_createdate();
  inline ::std::string* release_createdate();
  inline void set_allocated_createdate(::std::string* createdate);

  // @@protoc_insertion_point(class_scope:progame.specialcardreward)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_cardtype();
  inline void clear_has_cardtype();
  inline void set_has_reward();
  inline void clear_has_reward();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_createdate();
  inline void clear_has_createdate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 cardtype_;
  ::google::protobuf::int32 reward_;
  ::google::protobuf::int32 status_;
  ::std::string* createdate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static specialcardreward* default_instance_;
};
// -------------------------------------------------------------------

class specialinfo : public ::google::protobuf::Message {
 public:
  specialinfo();
  virtual ~specialinfo();

  specialinfo(const specialinfo& from);

  inline specialinfo& operator=(const specialinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const specialinfo& default_instance();

  void Swap(specialinfo* other);

  // implements Message ----------------------------------------------

  specialinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const specialinfo& from);
  void MergeFrom(const specialinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional int32 starttime = 2;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 2;
  inline ::google::protobuf::int32 starttime() const;
  inline void set_starttime(::google::protobuf::int32 value);

  // optional int32 endtime = 3;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 3;
  inline ::google::protobuf::int32 endtime() const;
  inline void set_endtime(::google::protobuf::int32 value);

  // optional int32 state = 4;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 rate = 5;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 5;
  inline ::google::protobuf::int32 rate() const;
  inline void set_rate(::google::protobuf::int32 value);

  // optional int32 winall = 6;
  inline bool has_winall() const;
  inline void clear_winall();
  static const int kWinallFieldNumber = 6;
  inline ::google::protobuf::int32 winall() const;
  inline void set_winall(::google::protobuf::int32 value);

  // optional int32 peinum = 7;
  inline bool has_peinum() const;
  inline void clear_peinum();
  static const int kPeinumFieldNumber = 7;
  inline ::google::protobuf::int32 peinum() const;
  inline void set_peinum(::google::protobuf::int32 value);

  // optional int32 marknum = 8;
  inline bool has_marknum() const;
  inline void clear_marknum();
  static const int kMarknumFieldNumber = 8;
  inline ::google::protobuf::int32 marknum() const;
  inline void set_marknum(::google::protobuf::int32 value);

  // repeated int32 gametype = 9;
  inline int gametype_size() const;
  inline void clear_gametype();
  static const int kGametypeFieldNumber = 9;
  inline ::google::protobuf::int32 gametype(int index) const;
  inline void set_gametype(int index, ::google::protobuf::int32 value);
  inline void add_gametype(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      gametype() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_gametype();

  // optional int32 cardtype = 10;
  inline bool has_cardtype() const;
  inline void clear_cardtype();
  static const int kCardtypeFieldNumber = 10;
  inline ::google::protobuf::int32 cardtype() const;
  inline void set_cardtype(::google::protobuf::int32 value);

  // optional int32 iszhuang = 11;
  inline bool has_iszhuang() const;
  inline void clear_iszhuang();
  static const int kIszhuangFieldNumber = 11;
  inline ::google::protobuf::int32 iszhuang() const;
  inline void set_iszhuang(::google::protobuf::int32 value);

  // optional int32 norecord = 12;
  inline bool has_norecord() const;
  inline void clear_norecord();
  static const int kNorecordFieldNumber = 12;
  inline ::google::protobuf::int32 norecord() const;
  inline void set_norecord(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.specialinfo)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_rate();
  inline void clear_has_rate();
  inline void set_has_winall();
  inline void clear_has_winall();
  inline void set_has_peinum();
  inline void clear_has_peinum();
  inline void set_has_marknum();
  inline void clear_has_marknum();
  inline void set_has_cardtype();
  inline void clear_has_cardtype();
  inline void set_has_iszhuang();
  inline void clear_has_iszhuang();
  inline void set_has_norecord();
  inline void clear_has_norecord();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 starttime_;
  ::google::protobuf::int32 endtime_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 rate_;
  ::google::protobuf::int32 winall_;
  ::google::protobuf::int32 peinum_;
  ::google::protobuf::int32 marknum_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > gametype_;
  ::google::protobuf::int32 cardtype_;
  ::google::protobuf::int32 iszhuang_;
  ::google::protobuf::int32 norecord_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_st_5fhuman_2eproto();
  friend void protobuf_AssignDesc_st_5fhuman_2eproto();
  friend void protobuf_ShutdownFile_st_5fhuman_2eproto();

  void InitAsDefaultInstance();
  static specialinfo* default_instance_;
};
// ===================================================================


// ===================================================================

// playerinfo

// optional int32 userid = 1;
inline bool playerinfo::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void playerinfo::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void playerinfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void playerinfo::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 playerinfo::userid() const {
  return userid_;
}
inline void playerinfo::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional string cid = 2;
inline bool playerinfo::has_cid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void playerinfo::set_has_cid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void playerinfo::clear_has_cid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void playerinfo::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& playerinfo::cid() const {
  return *cid_;
}
inline void playerinfo::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void playerinfo::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void playerinfo::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* playerinfo::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 3;
inline bool playerinfo::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void playerinfo::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void playerinfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void playerinfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& playerinfo::account() const {
  return *account_;
}
inline void playerinfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void playerinfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void playerinfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* playerinfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 4;
inline bool playerinfo::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void playerinfo::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void playerinfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void playerinfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& playerinfo::password() const {
  return *password_;
}
inline void playerinfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void playerinfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void playerinfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* playerinfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nickname = 5;
inline bool playerinfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void playerinfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void playerinfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void playerinfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& playerinfo::nickname() const {
  return *nickname_;
}
inline void playerinfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void playerinfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void playerinfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* playerinfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string regdate = 7;
inline bool playerinfo::has_regdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void playerinfo::set_has_regdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void playerinfo::clear_has_regdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void playerinfo::clear_regdate() {
  if (regdate_ != &::google::protobuf::internal::kEmptyString) {
    regdate_->clear();
  }
  clear_has_regdate();
}
inline const ::std::string& playerinfo::regdate() const {
  return *regdate_;
}
inline void playerinfo::set_regdate(const ::std::string& value) {
  set_has_regdate();
  if (regdate_ == &::google::protobuf::internal::kEmptyString) {
    regdate_ = new ::std::string;
  }
  regdate_->assign(value);
}
inline void playerinfo::set_regdate(const char* value) {
  set_has_regdate();
  if (regdate_ == &::google::protobuf::internal::kEmptyString) {
    regdate_ = new ::std::string;
  }
  regdate_->assign(value);
}
inline void playerinfo::set_regdate(const char* value, size_t size) {
  set_has_regdate();
  if (regdate_ == &::google::protobuf::internal::kEmptyString) {
    regdate_ = new ::std::string;
  }
  regdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_regdate() {
  set_has_regdate();
  if (regdate_ == &::google::protobuf::internal::kEmptyString) {
    regdate_ = new ::std::string;
  }
  return regdate_;
}
inline ::std::string* playerinfo::release_regdate() {
  clear_has_regdate();
  if (regdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = regdate_;
    regdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_regdate(::std::string* regdate) {
  if (regdate_ != &::google::protobuf::internal::kEmptyString) {
    delete regdate_;
  }
  if (regdate) {
    set_has_regdate();
    regdate_ = regdate;
  } else {
    clear_has_regdate();
    regdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sex = 8;
inline bool playerinfo::has_sex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void playerinfo::set_has_sex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void playerinfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void playerinfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 playerinfo::sex() const {
  return sex_;
}
inline void playerinfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional int32 age = 9;
inline bool playerinfo::has_age() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void playerinfo::set_has_age() {
  _has_bits_[0] |= 0x00000080u;
}
inline void playerinfo::clear_has_age() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void playerinfo::clear_age() {
  age_ = 0;
  clear_has_age();
}
inline ::google::protobuf::int32 playerinfo::age() const {
  return age_;
}
inline void playerinfo::set_age(::google::protobuf::int32 value) {
  set_has_age();
  age_ = value;
}

// optional string email = 10;
inline bool playerinfo::has_email() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void playerinfo::set_has_email() {
  _has_bits_[0] |= 0x00000100u;
}
inline void playerinfo::clear_has_email() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void playerinfo::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& playerinfo::email() const {
  return *email_;
}
inline void playerinfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void playerinfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void playerinfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* playerinfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phonenum = 11;
inline bool playerinfo::has_phonenum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void playerinfo::set_has_phonenum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void playerinfo::clear_has_phonenum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void playerinfo::clear_phonenum() {
  if (phonenum_ != &::google::protobuf::internal::kEmptyString) {
    phonenum_->clear();
  }
  clear_has_phonenum();
}
inline const ::std::string& playerinfo::phonenum() const {
  return *phonenum_;
}
inline void playerinfo::set_phonenum(const ::std::string& value) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(value);
}
inline void playerinfo::set_phonenum(const char* value) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(value);
}
inline void playerinfo::set_phonenum(const char* value, size_t size) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_phonenum() {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  return phonenum_;
}
inline ::std::string* playerinfo::release_phonenum() {
  clear_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phonenum_;
    phonenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_phonenum(::std::string* phonenum) {
  if (phonenum_ != &::google::protobuf::internal::kEmptyString) {
    delete phonenum_;
  }
  if (phonenum) {
    set_has_phonenum();
    phonenum_ = phonenum;
  } else {
    clear_has_phonenum();
    phonenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exp = 12;
inline bool playerinfo::has_exp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void playerinfo::set_has_exp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void playerinfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void playerinfo::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 playerinfo::exp() const {
  return exp_;
}
inline void playerinfo::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 level = 13;
inline bool playerinfo::has_level() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void playerinfo::set_has_level() {
  _has_bits_[0] |= 0x00000800u;
}
inline void playerinfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void playerinfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 playerinfo::level() const {
  return level_;
}
inline void playerinfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 viplevel = 14;
inline bool playerinfo::has_viplevel() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void playerinfo::set_has_viplevel() {
  _has_bits_[0] |= 0x00001000u;
}
inline void playerinfo::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void playerinfo::clear_viplevel() {
  viplevel_ = 0;
  clear_has_viplevel();
}
inline ::google::protobuf::int32 playerinfo::viplevel() const {
  return viplevel_;
}
inline void playerinfo::set_viplevel(::google::protobuf::int32 value) {
  set_has_viplevel();
  viplevel_ = value;
}

// optional string jetton = 15;
inline bool playerinfo::has_jetton() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void playerinfo::set_has_jetton() {
  _has_bits_[0] |= 0x00002000u;
}
inline void playerinfo::clear_has_jetton() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void playerinfo::clear_jetton() {
  if (jetton_ != &::google::protobuf::internal::kEmptyString) {
    jetton_->clear();
  }
  clear_has_jetton();
}
inline const ::std::string& playerinfo::jetton() const {
  return *jetton_;
}
inline void playerinfo::set_jetton(const ::std::string& value) {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  jetton_->assign(value);
}
inline void playerinfo::set_jetton(const char* value) {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  jetton_->assign(value);
}
inline void playerinfo::set_jetton(const char* value, size_t size) {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  jetton_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_jetton() {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  return jetton_;
}
inline ::std::string* playerinfo::release_jetton() {
  clear_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jetton_;
    jetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_jetton(::std::string* jetton) {
  if (jetton_ != &::google::protobuf::internal::kEmptyString) {
    delete jetton_;
  }
  if (jetton) {
    set_has_jetton();
    jetton_ = jetton;
  } else {
    clear_has_jetton();
    jetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 gold = 16;
inline bool playerinfo::has_gold() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void playerinfo::set_has_gold() {
  _has_bits_[0] |= 0x00004000u;
}
inline void playerinfo::clear_has_gold() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void playerinfo::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 playerinfo::gold() const {
  return gold_;
}
inline void playerinfo::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// optional int32 money = 17;
inline bool playerinfo::has_money() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void playerinfo::set_has_money() {
  _has_bits_[0] |= 0x00008000u;
}
inline void playerinfo::clear_has_money() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void playerinfo::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 playerinfo::money() const {
  return money_;
}
inline void playerinfo::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional string channel = 18;
inline bool playerinfo::has_channel() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void playerinfo::set_has_channel() {
  _has_bits_[0] |= 0x00010000u;
}
inline void playerinfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void playerinfo::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& playerinfo::channel() const {
  return *channel_;
}
inline void playerinfo::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void playerinfo::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void playerinfo::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* playerinfo::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string province = 19;
inline bool playerinfo::has_province() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void playerinfo::set_has_province() {
  _has_bits_[0] |= 0x00020000u;
}
inline void playerinfo::clear_has_province() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void playerinfo::clear_province() {
  if (province_ != &::google::protobuf::internal::kEmptyString) {
    province_->clear();
  }
  clear_has_province();
}
inline const ::std::string& playerinfo::province() const {
  return *province_;
}
inline void playerinfo::set_province(const ::std::string& value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  province_->assign(value);
}
inline void playerinfo::set_province(const char* value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  province_->assign(value);
}
inline void playerinfo::set_province(const char* value, size_t size) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  province_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_province() {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  return province_;
}
inline ::std::string* playerinfo::release_province() {
  clear_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = province_;
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_province(::std::string* province) {
  if (province_ != &::google::protobuf::internal::kEmptyString) {
    delete province_;
  }
  if (province) {
    set_has_province();
    province_ = province;
  } else {
    clear_has_province();
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string city = 20;
inline bool playerinfo::has_city() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void playerinfo::set_has_city() {
  _has_bits_[0] |= 0x00040000u;
}
inline void playerinfo::clear_has_city() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void playerinfo::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& playerinfo::city() const {
  return *city_;
}
inline void playerinfo::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void playerinfo::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void playerinfo::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* playerinfo::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 popularity = 21;
inline bool playerinfo::has_popularity() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void playerinfo::set_has_popularity() {
  _has_bits_[0] |= 0x00080000u;
}
inline void playerinfo::clear_has_popularity() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void playerinfo::clear_popularity() {
  popularity_ = 0;
  clear_has_popularity();
}
inline ::google::protobuf::int32 playerinfo::popularity() const {
  return popularity_;
}
inline void playerinfo::set_popularity(::google::protobuf::int32 value) {
  set_has_popularity();
  popularity_ = value;
}

// optional int32 idenstatus = 22;
inline bool playerinfo::has_idenstatus() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void playerinfo::set_has_idenstatus() {
  _has_bits_[0] |= 0x00100000u;
}
inline void playerinfo::clear_has_idenstatus() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void playerinfo::clear_idenstatus() {
  idenstatus_ = 0;
  clear_has_idenstatus();
}
inline ::google::protobuf::int32 playerinfo::idenstatus() const {
  return idenstatus_;
}
inline void playerinfo::set_idenstatus(::google::protobuf::int32 value) {
  set_has_idenstatus();
  idenstatus_ = value;
}

// optional int32 bindtype = 23;
inline bool playerinfo::has_bindtype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void playerinfo::set_has_bindtype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void playerinfo::clear_has_bindtype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void playerinfo::clear_bindtype() {
  bindtype_ = 0;
  clear_has_bindtype();
}
inline ::google::protobuf::int32 playerinfo::bindtype() const {
  return bindtype_;
}
inline void playerinfo::set_bindtype(::google::protobuf::int32 value) {
  set_has_bindtype();
  bindtype_ = value;
}

// optional string bindnick = 24;
inline bool playerinfo::has_bindnick() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void playerinfo::set_has_bindnick() {
  _has_bits_[0] |= 0x00400000u;
}
inline void playerinfo::clear_has_bindnick() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void playerinfo::clear_bindnick() {
  if (bindnick_ != &::google::protobuf::internal::kEmptyString) {
    bindnick_->clear();
  }
  clear_has_bindnick();
}
inline const ::std::string& playerinfo::bindnick() const {
  return *bindnick_;
}
inline void playerinfo::set_bindnick(const ::std::string& value) {
  set_has_bindnick();
  if (bindnick_ == &::google::protobuf::internal::kEmptyString) {
    bindnick_ = new ::std::string;
  }
  bindnick_->assign(value);
}
inline void playerinfo::set_bindnick(const char* value) {
  set_has_bindnick();
  if (bindnick_ == &::google::protobuf::internal::kEmptyString) {
    bindnick_ = new ::std::string;
  }
  bindnick_->assign(value);
}
inline void playerinfo::set_bindnick(const char* value, size_t size) {
  set_has_bindnick();
  if (bindnick_ == &::google::protobuf::internal::kEmptyString) {
    bindnick_ = new ::std::string;
  }
  bindnick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_bindnick() {
  set_has_bindnick();
  if (bindnick_ == &::google::protobuf::internal::kEmptyString) {
    bindnick_ = new ::std::string;
  }
  return bindnick_;
}
inline ::std::string* playerinfo::release_bindnick() {
  clear_has_bindnick();
  if (bindnick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bindnick_;
    bindnick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_bindnick(::std::string* bindnick) {
  if (bindnick_ != &::google::protobuf::internal::kEmptyString) {
    delete bindnick_;
  }
  if (bindnick) {
    set_has_bindnick();
    bindnick_ = bindnick;
  } else {
    clear_has_bindnick();
    bindnick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string platformid = 25;
inline bool playerinfo::has_platformid() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void playerinfo::set_has_platformid() {
  _has_bits_[0] |= 0x00800000u;
}
inline void playerinfo::clear_has_platformid() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void playerinfo::clear_platformid() {
  if (platformid_ != &::google::protobuf::internal::kEmptyString) {
    platformid_->clear();
  }
  clear_has_platformid();
}
inline const ::std::string& playerinfo::platformid() const {
  return *platformid_;
}
inline void playerinfo::set_platformid(const ::std::string& value) {
  set_has_platformid();
  if (platformid_ == &::google::protobuf::internal::kEmptyString) {
    platformid_ = new ::std::string;
  }
  platformid_->assign(value);
}
inline void playerinfo::set_platformid(const char* value) {
  set_has_platformid();
  if (platformid_ == &::google::protobuf::internal::kEmptyString) {
    platformid_ = new ::std::string;
  }
  platformid_->assign(value);
}
inline void playerinfo::set_platformid(const char* value, size_t size) {
  set_has_platformid();
  if (platformid_ == &::google::protobuf::internal::kEmptyString) {
    platformid_ = new ::std::string;
  }
  platformid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_platformid() {
  set_has_platformid();
  if (platformid_ == &::google::protobuf::internal::kEmptyString) {
    platformid_ = new ::std::string;
  }
  return platformid_;
}
inline ::std::string* playerinfo::release_platformid() {
  clear_has_platformid();
  if (platformid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platformid_;
    platformid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_platformid(::std::string* platformid) {
  if (platformid_ != &::google::protobuf::internal::kEmptyString) {
    delete platformid_;
  }
  if (platformid) {
    set_has_platformid();
    platformid_ = platformid;
  } else {
    clear_has_platformid();
    platformid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string imei = 26;
inline bool playerinfo::has_imei() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void playerinfo::set_has_imei() {
  _has_bits_[0] |= 0x01000000u;
}
inline void playerinfo::clear_has_imei() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void playerinfo::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& playerinfo::imei() const {
  return *imei_;
}
inline void playerinfo::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void playerinfo::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void playerinfo::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* playerinfo::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string devname = 27;
inline bool playerinfo::has_devname() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void playerinfo::set_has_devname() {
  _has_bits_[0] |= 0x02000000u;
}
inline void playerinfo::clear_has_devname() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void playerinfo::clear_devname() {
  if (devname_ != &::google::protobuf::internal::kEmptyString) {
    devname_->clear();
  }
  clear_has_devname();
}
inline const ::std::string& playerinfo::devname() const {
  return *devname_;
}
inline void playerinfo::set_devname(const ::std::string& value) {
  set_has_devname();
  if (devname_ == &::google::protobuf::internal::kEmptyString) {
    devname_ = new ::std::string;
  }
  devname_->assign(value);
}
inline void playerinfo::set_devname(const char* value) {
  set_has_devname();
  if (devname_ == &::google::protobuf::internal::kEmptyString) {
    devname_ = new ::std::string;
  }
  devname_->assign(value);
}
inline void playerinfo::set_devname(const char* value, size_t size) {
  set_has_devname();
  if (devname_ == &::google::protobuf::internal::kEmptyString) {
    devname_ = new ::std::string;
  }
  devname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_devname() {
  set_has_devname();
  if (devname_ == &::google::protobuf::internal::kEmptyString) {
    devname_ = new ::std::string;
  }
  return devname_;
}
inline ::std::string* playerinfo::release_devname() {
  clear_has_devname();
  if (devname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devname_;
    devname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_devname(::std::string* devname) {
  if (devname_ != &::google::protobuf::internal::kEmptyString) {
    delete devname_;
  }
  if (devname) {
    set_has_devname();
    devname_ = devname;
  } else {
    clear_has_devname();
    devname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 28;
inline bool playerinfo::has_ip() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void playerinfo::set_has_ip() {
  _has_bits_[0] |= 0x04000000u;
}
inline void playerinfo::clear_has_ip() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void playerinfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& playerinfo::ip() const {
  return *ip_;
}
inline void playerinfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void playerinfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void playerinfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* playerinfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 mobiletype = 29;
inline bool playerinfo::has_mobiletype() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void playerinfo::set_has_mobiletype() {
  _has_bits_[0] |= 0x08000000u;
}
inline void playerinfo::clear_has_mobiletype() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void playerinfo::clear_mobiletype() {
  mobiletype_ = 0;
  clear_has_mobiletype();
}
inline ::google::protobuf::int32 playerinfo::mobiletype() const {
  return mobiletype_;
}
inline void playerinfo::set_mobiletype(::google::protobuf::int32 value) {
  set_has_mobiletype();
  mobiletype_ = value;
}

// optional int32 lasttime = 30;
inline bool playerinfo::has_lasttime() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void playerinfo::set_has_lasttime() {
  _has_bits_[0] |= 0x10000000u;
}
inline void playerinfo::clear_has_lasttime() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void playerinfo::clear_lasttime() {
  lasttime_ = 0;
  clear_has_lasttime();
}
inline ::google::protobuf::int32 playerinfo::lasttime() const {
  return lasttime_;
}
inline void playerinfo::set_lasttime(::google::protobuf::int32 value) {
  set_has_lasttime();
  lasttime_ = value;
}

// optional int32 penulttime = 31;
inline bool playerinfo::has_penulttime() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void playerinfo::set_has_penulttime() {
  _has_bits_[0] |= 0x20000000u;
}
inline void playerinfo::clear_has_penulttime() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void playerinfo::clear_penulttime() {
  penulttime_ = 0;
  clear_has_penulttime();
}
inline ::google::protobuf::int32 playerinfo::penulttime() const {
  return penulttime_;
}
inline void playerinfo::set_penulttime(::google::protobuf::int32 value) {
  set_has_penulttime();
  penulttime_ = value;
}

// optional int32 silent = 32;
inline bool playerinfo::has_silent() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void playerinfo::set_has_silent() {
  _has_bits_[0] |= 0x40000000u;
}
inline void playerinfo::clear_has_silent() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void playerinfo::clear_silent() {
  silent_ = 0;
  clear_has_silent();
}
inline ::google::protobuf::int32 playerinfo::silent() const {
  return silent_;
}
inline void playerinfo::set_silent(::google::protobuf::int32 value) {
  set_has_silent();
  silent_ = value;
}

// optional int32 isban = 33;
inline bool playerinfo::has_isban() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void playerinfo::set_has_isban() {
  _has_bits_[0] |= 0x80000000u;
}
inline void playerinfo::clear_has_isban() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void playerinfo::clear_isban() {
  isban_ = 0;
  clear_has_isban();
}
inline ::google::protobuf::int32 playerinfo::isban() const {
  return isban_;
}
inline void playerinfo::set_isban(::google::protobuf::int32 value) {
  set_has_isban();
  isban_ = value;
}

// optional string face_1 = 34;
inline bool playerinfo::has_face_1() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void playerinfo::set_has_face_1() {
  _has_bits_[1] |= 0x00000001u;
}
inline void playerinfo::clear_has_face_1() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void playerinfo::clear_face_1() {
  if (face_1_ != &::google::protobuf::internal::kEmptyString) {
    face_1_->clear();
  }
  clear_has_face_1();
}
inline const ::std::string& playerinfo::face_1() const {
  return *face_1_;
}
inline void playerinfo::set_face_1(const ::std::string& value) {
  set_has_face_1();
  if (face_1_ == &::google::protobuf::internal::kEmptyString) {
    face_1_ = new ::std::string;
  }
  face_1_->assign(value);
}
inline void playerinfo::set_face_1(const char* value) {
  set_has_face_1();
  if (face_1_ == &::google::protobuf::internal::kEmptyString) {
    face_1_ = new ::std::string;
  }
  face_1_->assign(value);
}
inline void playerinfo::set_face_1(const char* value, size_t size) {
  set_has_face_1();
  if (face_1_ == &::google::protobuf::internal::kEmptyString) {
    face_1_ = new ::std::string;
  }
  face_1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_face_1() {
  set_has_face_1();
  if (face_1_ == &::google::protobuf::internal::kEmptyString) {
    face_1_ = new ::std::string;
  }
  return face_1_;
}
inline ::std::string* playerinfo::release_face_1() {
  clear_has_face_1();
  if (face_1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = face_1_;
    face_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_face_1(::std::string* face_1) {
  if (face_1_ != &::google::protobuf::internal::kEmptyString) {
    delete face_1_;
  }
  if (face_1) {
    set_has_face_1();
    face_1_ = face_1;
  } else {
    clear_has_face_1();
    face_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string face_2 = 35;
inline bool playerinfo::has_face_2() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void playerinfo::set_has_face_2() {
  _has_bits_[1] |= 0x00000002u;
}
inline void playerinfo::clear_has_face_2() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void playerinfo::clear_face_2() {
  if (face_2_ != &::google::protobuf::internal::kEmptyString) {
    face_2_->clear();
  }
  clear_has_face_2();
}
inline const ::std::string& playerinfo::face_2() const {
  return *face_2_;
}
inline void playerinfo::set_face_2(const ::std::string& value) {
  set_has_face_2();
  if (face_2_ == &::google::protobuf::internal::kEmptyString) {
    face_2_ = new ::std::string;
  }
  face_2_->assign(value);
}
inline void playerinfo::set_face_2(const char* value) {
  set_has_face_2();
  if (face_2_ == &::google::protobuf::internal::kEmptyString) {
    face_2_ = new ::std::string;
  }
  face_2_->assign(value);
}
inline void playerinfo::set_face_2(const char* value, size_t size) {
  set_has_face_2();
  if (face_2_ == &::google::protobuf::internal::kEmptyString) {
    face_2_ = new ::std::string;
  }
  face_2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_face_2() {
  set_has_face_2();
  if (face_2_ == &::google::protobuf::internal::kEmptyString) {
    face_2_ = new ::std::string;
  }
  return face_2_;
}
inline ::std::string* playerinfo::release_face_2() {
  clear_has_face_2();
  if (face_2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = face_2_;
    face_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_face_2(::std::string* face_2) {
  if (face_2_ != &::google::protobuf::internal::kEmptyString) {
    delete face_2_;
  }
  if (face_2) {
    set_has_face_2();
    face_2_ = face_2;
  } else {
    clear_has_face_2();
    face_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string face_3 = 36;
inline bool playerinfo::has_face_3() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void playerinfo::set_has_face_3() {
  _has_bits_[1] |= 0x00000004u;
}
inline void playerinfo::clear_has_face_3() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void playerinfo::clear_face_3() {
  if (face_3_ != &::google::protobuf::internal::kEmptyString) {
    face_3_->clear();
  }
  clear_has_face_3();
}
inline const ::std::string& playerinfo::face_3() const {
  return *face_3_;
}
inline void playerinfo::set_face_3(const ::std::string& value) {
  set_has_face_3();
  if (face_3_ == &::google::protobuf::internal::kEmptyString) {
    face_3_ = new ::std::string;
  }
  face_3_->assign(value);
}
inline void playerinfo::set_face_3(const char* value) {
  set_has_face_3();
  if (face_3_ == &::google::protobuf::internal::kEmptyString) {
    face_3_ = new ::std::string;
  }
  face_3_->assign(value);
}
inline void playerinfo::set_face_3(const char* value, size_t size) {
  set_has_face_3();
  if (face_3_ == &::google::protobuf::internal::kEmptyString) {
    face_3_ = new ::std::string;
  }
  face_3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_face_3() {
  set_has_face_3();
  if (face_3_ == &::google::protobuf::internal::kEmptyString) {
    face_3_ = new ::std::string;
  }
  return face_3_;
}
inline ::std::string* playerinfo::release_face_3() {
  clear_has_face_3();
  if (face_3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = face_3_;
    face_3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_face_3(::std::string* face_3) {
  if (face_3_ != &::google::protobuf::internal::kEmptyString) {
    delete face_3_;
  }
  if (face_3) {
    set_has_face_3();
    face_3_ = face_3;
  } else {
    clear_has_face_3();
    face_3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string face_4 = 37;
inline bool playerinfo::has_face_4() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void playerinfo::set_has_face_4() {
  _has_bits_[1] |= 0x00000008u;
}
inline void playerinfo::clear_has_face_4() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void playerinfo::clear_face_4() {
  if (face_4_ != &::google::protobuf::internal::kEmptyString) {
    face_4_->clear();
  }
  clear_has_face_4();
}
inline const ::std::string& playerinfo::face_4() const {
  return *face_4_;
}
inline void playerinfo::set_face_4(const ::std::string& value) {
  set_has_face_4();
  if (face_4_ == &::google::protobuf::internal::kEmptyString) {
    face_4_ = new ::std::string;
  }
  face_4_->assign(value);
}
inline void playerinfo::set_face_4(const char* value) {
  set_has_face_4();
  if (face_4_ == &::google::protobuf::internal::kEmptyString) {
    face_4_ = new ::std::string;
  }
  face_4_->assign(value);
}
inline void playerinfo::set_face_4(const char* value, size_t size) {
  set_has_face_4();
  if (face_4_ == &::google::protobuf::internal::kEmptyString) {
    face_4_ = new ::std::string;
  }
  face_4_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_face_4() {
  set_has_face_4();
  if (face_4_ == &::google::protobuf::internal::kEmptyString) {
    face_4_ = new ::std::string;
  }
  return face_4_;
}
inline ::std::string* playerinfo::release_face_4() {
  clear_has_face_4();
  if (face_4_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = face_4_;
    face_4_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_face_4(::std::string* face_4) {
  if (face_4_ != &::google::protobuf::internal::kEmptyString) {
    delete face_4_;
  }
  if (face_4) {
    set_has_face_4();
    face_4_ = face_4;
  } else {
    clear_has_face_4();
    face_4_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 isrobot = 38;
inline bool playerinfo::has_isrobot() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void playerinfo::set_has_isrobot() {
  _has_bits_[1] |= 0x00000010u;
}
inline void playerinfo::clear_has_isrobot() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void playerinfo::clear_isrobot() {
  isrobot_ = 0;
  clear_has_isrobot();
}
inline ::google::protobuf::int32 playerinfo::isrobot() const {
  return isrobot_;
}
inline void playerinfo::set_isrobot(::google::protobuf::int32 value) {
  set_has_isrobot();
  isrobot_ = value;
}

// optional int32 playtype = 39;
inline bool playerinfo::has_playtype() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void playerinfo::set_has_playtype() {
  _has_bits_[1] |= 0x00000020u;
}
inline void playerinfo::clear_has_playtype() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void playerinfo::clear_playtype() {
  playtype_ = 0;
  clear_has_playtype();
}
inline ::google::protobuf::int32 playerinfo::playtype() const {
  return playtype_;
}
inline void playerinfo::set_playtype(::google::protobuf::int32 value) {
  set_has_playtype();
  playtype_ = value;
}

// optional string description = 40;
inline bool playerinfo::has_description() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void playerinfo::set_has_description() {
  _has_bits_[1] |= 0x00000040u;
}
inline void playerinfo::clear_has_description() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void playerinfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& playerinfo::description() const {
  return *description_;
}
inline void playerinfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void playerinfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void playerinfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* playerinfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location = 41;
inline bool playerinfo::has_location() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void playerinfo::set_has_location() {
  _has_bits_[1] |= 0x00000080u;
}
inline void playerinfo::clear_has_location() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void playerinfo::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& playerinfo::location() const {
  return *location_;
}
inline void playerinfo::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void playerinfo::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void playerinfo::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* playerinfo::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bankjetton = 42;
inline bool playerinfo::has_bankjetton() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void playerinfo::set_has_bankjetton() {
  _has_bits_[1] |= 0x00000100u;
}
inline void playerinfo::clear_has_bankjetton() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void playerinfo::clear_bankjetton() {
  if (bankjetton_ != &::google::protobuf::internal::kEmptyString) {
    bankjetton_->clear();
  }
  clear_has_bankjetton();
}
inline const ::std::string& playerinfo::bankjetton() const {
  return *bankjetton_;
}
inline void playerinfo::set_bankjetton(const ::std::string& value) {
  set_has_bankjetton();
  if (bankjetton_ == &::google::protobuf::internal::kEmptyString) {
    bankjetton_ = new ::std::string;
  }
  bankjetton_->assign(value);
}
inline void playerinfo::set_bankjetton(const char* value) {
  set_has_bankjetton();
  if (bankjetton_ == &::google::protobuf::internal::kEmptyString) {
    bankjetton_ = new ::std::string;
  }
  bankjetton_->assign(value);
}
inline void playerinfo::set_bankjetton(const char* value, size_t size) {
  set_has_bankjetton();
  if (bankjetton_ == &::google::protobuf::internal::kEmptyString) {
    bankjetton_ = new ::std::string;
  }
  bankjetton_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_bankjetton() {
  set_has_bankjetton();
  if (bankjetton_ == &::google::protobuf::internal::kEmptyString) {
    bankjetton_ = new ::std::string;
  }
  return bankjetton_;
}
inline ::std::string* playerinfo::release_bankjetton() {
  clear_has_bankjetton();
  if (bankjetton_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bankjetton_;
    bankjetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_bankjetton(::std::string* bankjetton) {
  if (bankjetton_ != &::google::protobuf::internal::kEmptyString) {
    delete bankjetton_;
  }
  if (bankjetton) {
    set_has_bankjetton();
    bankjetton_ = bankjetton;
  } else {
    clear_has_bankjetton();
    bankjetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string title = 43;
inline bool playerinfo::has_title() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void playerinfo::set_has_title() {
  _has_bits_[1] |= 0x00000200u;
}
inline void playerinfo::clear_has_title() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void playerinfo::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& playerinfo::title() const {
  return *title_;
}
inline void playerinfo::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void playerinfo::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void playerinfo::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* playerinfo::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 blacklist = 44;
inline bool playerinfo::has_blacklist() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void playerinfo::set_has_blacklist() {
  _has_bits_[1] |= 0x00000400u;
}
inline void playerinfo::clear_has_blacklist() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void playerinfo::clear_blacklist() {
  blacklist_ = 0;
  clear_has_blacklist();
}
inline ::google::protobuf::int32 playerinfo::blacklist() const {
  return blacklist_;
}
inline void playerinfo::set_blacklist(::google::protobuf::int32 value) {
  set_has_blacklist();
  blacklist_ = value;
}

// optional int32 propertyid = 45;
inline bool playerinfo::has_propertyid() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void playerinfo::set_has_propertyid() {
  _has_bits_[1] |= 0x00000800u;
}
inline void playerinfo::clear_has_propertyid() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void playerinfo::clear_propertyid() {
  propertyid_ = 0;
  clear_has_propertyid();
}
inline ::google::protobuf::int32 playerinfo::propertyid() const {
  return propertyid_;
}
inline void playerinfo::set_propertyid(::google::protobuf::int32 value) {
  set_has_propertyid();
  propertyid_ = value;
}

// optional int32 ticket = 46;
inline bool playerinfo::has_ticket() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void playerinfo::set_has_ticket() {
  _has_bits_[1] |= 0x00001000u;
}
inline void playerinfo::clear_has_ticket() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void playerinfo::clear_ticket() {
  ticket_ = 0;
  clear_has_ticket();
}
inline ::google::protobuf::int32 playerinfo::ticket() const {
  return ticket_;
}
inline void playerinfo::set_ticket(::google::protobuf::int32 value) {
  set_has_ticket();
  ticket_ = value;
}

// optional string location_x = 47;
inline bool playerinfo::has_location_x() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void playerinfo::set_has_location_x() {
  _has_bits_[1] |= 0x00002000u;
}
inline void playerinfo::clear_has_location_x() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void playerinfo::clear_location_x() {
  if (location_x_ != &::google::protobuf::internal::kEmptyString) {
    location_x_->clear();
  }
  clear_has_location_x();
}
inline const ::std::string& playerinfo::location_x() const {
  return *location_x_;
}
inline void playerinfo::set_location_x(const ::std::string& value) {
  set_has_location_x();
  if (location_x_ == &::google::protobuf::internal::kEmptyString) {
    location_x_ = new ::std::string;
  }
  location_x_->assign(value);
}
inline void playerinfo::set_location_x(const char* value) {
  set_has_location_x();
  if (location_x_ == &::google::protobuf::internal::kEmptyString) {
    location_x_ = new ::std::string;
  }
  location_x_->assign(value);
}
inline void playerinfo::set_location_x(const char* value, size_t size) {
  set_has_location_x();
  if (location_x_ == &::google::protobuf::internal::kEmptyString) {
    location_x_ = new ::std::string;
  }
  location_x_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_location_x() {
  set_has_location_x();
  if (location_x_ == &::google::protobuf::internal::kEmptyString) {
    location_x_ = new ::std::string;
  }
  return location_x_;
}
inline ::std::string* playerinfo::release_location_x() {
  clear_has_location_x();
  if (location_x_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_x_;
    location_x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_location_x(::std::string* location_x) {
  if (location_x_ != &::google::protobuf::internal::kEmptyString) {
    delete location_x_;
  }
  if (location_x) {
    set_has_location_x();
    location_x_ = location_x;
  } else {
    clear_has_location_x();
    location_x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location_y = 48;
inline bool playerinfo::has_location_y() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void playerinfo::set_has_location_y() {
  _has_bits_[1] |= 0x00004000u;
}
inline void playerinfo::clear_has_location_y() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void playerinfo::clear_location_y() {
  if (location_y_ != &::google::protobuf::internal::kEmptyString) {
    location_y_->clear();
  }
  clear_has_location_y();
}
inline const ::std::string& playerinfo::location_y() const {
  return *location_y_;
}
inline void playerinfo::set_location_y(const ::std::string& value) {
  set_has_location_y();
  if (location_y_ == &::google::protobuf::internal::kEmptyString) {
    location_y_ = new ::std::string;
  }
  location_y_->assign(value);
}
inline void playerinfo::set_location_y(const char* value) {
  set_has_location_y();
  if (location_y_ == &::google::protobuf::internal::kEmptyString) {
    location_y_ = new ::std::string;
  }
  location_y_->assign(value);
}
inline void playerinfo::set_location_y(const char* value, size_t size) {
  set_has_location_y();
  if (location_y_ == &::google::protobuf::internal::kEmptyString) {
    location_y_ = new ::std::string;
  }
  location_y_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_location_y() {
  set_has_location_y();
  if (location_y_ == &::google::protobuf::internal::kEmptyString) {
    location_y_ = new ::std::string;
  }
  return location_y_;
}
inline ::std::string* playerinfo::release_location_y() {
  clear_has_location_y();
  if (location_y_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_y_;
    location_y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_location_y(::std::string* location_y) {
  if (location_y_ != &::google::protobuf::internal::kEmptyString) {
    delete location_y_;
  }
  if (location_y) {
    set_has_location_y();
    location_y_ = location_y;
  } else {
    clear_has_location_y();
    location_y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bank_password = 49;
inline bool playerinfo::has_bank_password() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void playerinfo::set_has_bank_password() {
  _has_bits_[1] |= 0x00008000u;
}
inline void playerinfo::clear_has_bank_password() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void playerinfo::clear_bank_password() {
  if (bank_password_ != &::google::protobuf::internal::kEmptyString) {
    bank_password_->clear();
  }
  clear_has_bank_password();
}
inline const ::std::string& playerinfo::bank_password() const {
  return *bank_password_;
}
inline void playerinfo::set_bank_password(const ::std::string& value) {
  set_has_bank_password();
  if (bank_password_ == &::google::protobuf::internal::kEmptyString) {
    bank_password_ = new ::std::string;
  }
  bank_password_->assign(value);
}
inline void playerinfo::set_bank_password(const char* value) {
  set_has_bank_password();
  if (bank_password_ == &::google::protobuf::internal::kEmptyString) {
    bank_password_ = new ::std::string;
  }
  bank_password_->assign(value);
}
inline void playerinfo::set_bank_password(const char* value, size_t size) {
  set_has_bank_password();
  if (bank_password_ == &::google::protobuf::internal::kEmptyString) {
    bank_password_ = new ::std::string;
  }
  bank_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_bank_password() {
  set_has_bank_password();
  if (bank_password_ == &::google::protobuf::internal::kEmptyString) {
    bank_password_ = new ::std::string;
  }
  return bank_password_;
}
inline ::std::string* playerinfo::release_bank_password() {
  clear_has_bank_password();
  if (bank_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_password_;
    bank_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_bank_password(::std::string* bank_password) {
  if (bank_password_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_password_;
  }
  if (bank_password) {
    set_has_bank_password();
    bank_password_ = bank_password;
  } else {
    clear_has_bank_password();
    bank_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bank_jetton = 50;
inline bool playerinfo::has_bank_jetton() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void playerinfo::set_has_bank_jetton() {
  _has_bits_[1] |= 0x00010000u;
}
inline void playerinfo::clear_has_bank_jetton() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void playerinfo::clear_bank_jetton() {
  if (bank_jetton_ != &::google::protobuf::internal::kEmptyString) {
    bank_jetton_->clear();
  }
  clear_has_bank_jetton();
}
inline const ::std::string& playerinfo::bank_jetton() const {
  return *bank_jetton_;
}
inline void playerinfo::set_bank_jetton(const ::std::string& value) {
  set_has_bank_jetton();
  if (bank_jetton_ == &::google::protobuf::internal::kEmptyString) {
    bank_jetton_ = new ::std::string;
  }
  bank_jetton_->assign(value);
}
inline void playerinfo::set_bank_jetton(const char* value) {
  set_has_bank_jetton();
  if (bank_jetton_ == &::google::protobuf::internal::kEmptyString) {
    bank_jetton_ = new ::std::string;
  }
  bank_jetton_->assign(value);
}
inline void playerinfo::set_bank_jetton(const char* value, size_t size) {
  set_has_bank_jetton();
  if (bank_jetton_ == &::google::protobuf::internal::kEmptyString) {
    bank_jetton_ = new ::std::string;
  }
  bank_jetton_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerinfo::mutable_bank_jetton() {
  set_has_bank_jetton();
  if (bank_jetton_ == &::google::protobuf::internal::kEmptyString) {
    bank_jetton_ = new ::std::string;
  }
  return bank_jetton_;
}
inline ::std::string* playerinfo::release_bank_jetton() {
  clear_has_bank_jetton();
  if (bank_jetton_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_jetton_;
    bank_jetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerinfo::set_allocated_bank_jetton(::std::string* bank_jetton) {
  if (bank_jetton_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_jetton_;
  }
  if (bank_jetton) {
    set_has_bank_jetton();
    bank_jetton_ = bank_jetton;
  } else {
    clear_has_bank_jetton();
    bank_jetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 agent1 = 51;
inline bool playerinfo::has_agent1() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void playerinfo::set_has_agent1() {
  _has_bits_[1] |= 0x00020000u;
}
inline void playerinfo::clear_has_agent1() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void playerinfo::clear_agent1() {
  agent1_ = 0;
  clear_has_agent1();
}
inline ::google::protobuf::int32 playerinfo::agent1() const {
  return agent1_;
}
inline void playerinfo::set_agent1(::google::protobuf::int32 value) {
  set_has_agent1();
  agent1_ = value;
}

// -------------------------------------------------------------------

// playerstats

// optional int32 userid = 1;
inline bool playerstats::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void playerstats::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void playerstats::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void playerstats::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 playerstats::userid() const {
  return userid_;
}
inline void playerstats::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional int32 mdynickamount = 2;
inline bool playerstats::has_mdynickamount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void playerstats::set_has_mdynickamount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void playerstats::clear_has_mdynickamount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void playerstats::clear_mdynickamount() {
  mdynickamount_ = 0;
  clear_has_mdynickamount();
}
inline ::google::protobuf::int32 playerstats::mdynickamount() const {
  return mdynickamount_;
}
inline void playerstats::set_mdynickamount(::google::protobuf::int32 value) {
  set_has_mdynickamount();
  mdynickamount_ = value;
}

// optional int32 loginday = 3;
inline bool playerstats::has_loginday() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void playerstats::set_has_loginday() {
  _has_bits_[0] |= 0x00000004u;
}
inline void playerstats::clear_has_loginday() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void playerstats::clear_loginday() {
  loginday_ = 0;
  clear_has_loginday();
}
inline ::google::protobuf::int32 playerstats::loginday() const {
  return loginday_;
}
inline void playerstats::set_loginday(::google::protobuf::int32 value) {
  set_has_loginday();
  loginday_ = value;
}

// optional int32 loginconday = 4;
inline bool playerstats::has_loginconday() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void playerstats::set_has_loginconday() {
  _has_bits_[0] |= 0x00000008u;
}
inline void playerstats::clear_has_loginconday() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void playerstats::clear_loginconday() {
  loginconday_ = 0;
  clear_has_loginconday();
}
inline ::google::protobuf::int32 playerstats::loginconday() const {
  return loginconday_;
}
inline void playerstats::set_loginconday(::google::protobuf::int32 value) {
  set_has_loginconday();
  loginconday_ = value;
}

// optional int32 maxloginconday = 5;
inline bool playerstats::has_maxloginconday() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void playerstats::set_has_maxloginconday() {
  _has_bits_[0] |= 0x00000010u;
}
inline void playerstats::clear_has_maxloginconday() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void playerstats::clear_maxloginconday() {
  maxloginconday_ = 0;
  clear_has_maxloginconday();
}
inline ::google::protobuf::int32 playerstats::maxloginconday() const {
  return maxloginconday_;
}
inline void playerstats::set_maxloginconday(::google::protobuf::int32 value) {
  set_has_maxloginconday();
  maxloginconday_ = value;
}

// optional int32 loginamount = 6;
inline bool playerstats::has_loginamount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void playerstats::set_has_loginamount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void playerstats::clear_has_loginamount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void playerstats::clear_loginamount() {
  loginamount_ = 0;
  clear_has_loginamount();
}
inline ::google::protobuf::int32 playerstats::loginamount() const {
  return loginamount_;
}
inline void playerstats::set_loginamount(::google::protobuf::int32 value) {
  set_has_loginamount();
  loginamount_ = value;
}

// optional int32 onlinetime = 7;
inline bool playerstats::has_onlinetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void playerstats::set_has_onlinetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void playerstats::clear_has_onlinetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void playerstats::clear_onlinetime() {
  onlinetime_ = 0;
  clear_has_onlinetime();
}
inline ::google::protobuf::int32 playerstats::onlinetime() const {
  return onlinetime_;
}
inline void playerstats::set_onlinetime(::google::protobuf::int32 value) {
  set_has_onlinetime();
  onlinetime_ = value;
}

// optional string maxjetton = 8;
inline bool playerstats::has_maxjetton() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void playerstats::set_has_maxjetton() {
  _has_bits_[0] |= 0x00000080u;
}
inline void playerstats::clear_has_maxjetton() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void playerstats::clear_maxjetton() {
  if (maxjetton_ != &::google::protobuf::internal::kEmptyString) {
    maxjetton_->clear();
  }
  clear_has_maxjetton();
}
inline const ::std::string& playerstats::maxjetton() const {
  return *maxjetton_;
}
inline void playerstats::set_maxjetton(const ::std::string& value) {
  set_has_maxjetton();
  if (maxjetton_ == &::google::protobuf::internal::kEmptyString) {
    maxjetton_ = new ::std::string;
  }
  maxjetton_->assign(value);
}
inline void playerstats::set_maxjetton(const char* value) {
  set_has_maxjetton();
  if (maxjetton_ == &::google::protobuf::internal::kEmptyString) {
    maxjetton_ = new ::std::string;
  }
  maxjetton_->assign(value);
}
inline void playerstats::set_maxjetton(const char* value, size_t size) {
  set_has_maxjetton();
  if (maxjetton_ == &::google::protobuf::internal::kEmptyString) {
    maxjetton_ = new ::std::string;
  }
  maxjetton_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playerstats::mutable_maxjetton() {
  set_has_maxjetton();
  if (maxjetton_ == &::google::protobuf::internal::kEmptyString) {
    maxjetton_ = new ::std::string;
  }
  return maxjetton_;
}
inline ::std::string* playerstats::release_maxjetton() {
  clear_has_maxjetton();
  if (maxjetton_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = maxjetton_;
    maxjetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playerstats::set_allocated_maxjetton(::std::string* maxjetton) {
  if (maxjetton_ != &::google::protobuf::internal::kEmptyString) {
    delete maxjetton_;
  }
  if (maxjetton) {
    set_has_maxjetton();
    maxjetton_ = maxjetton;
  } else {
    clear_has_maxjetton();
    maxjetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 payrmb = 9;
inline bool playerstats::has_payrmb() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void playerstats::set_has_payrmb() {
  _has_bits_[0] |= 0x00000100u;
}
inline void playerstats::clear_has_payrmb() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void playerstats::clear_payrmb() {
  payrmb_ = 0;
  clear_has_payrmb();
}
inline ::google::protobuf::int32 playerstats::payrmb() const {
  return payrmb_;
}
inline void playerstats::set_payrmb(::google::protobuf::int32 value) {
  set_has_payrmb();
  payrmb_ = value;
}

// optional int32 callpayrmb = 10;
inline bool playerstats::has_callpayrmb() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void playerstats::set_has_callpayrmb() {
  _has_bits_[0] |= 0x00000200u;
}
inline void playerstats::clear_has_callpayrmb() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void playerstats::clear_callpayrmb() {
  callpayrmb_ = 0;
  clear_has_callpayrmb();
}
inline ::google::protobuf::int32 playerstats::callpayrmb() const {
  return callpayrmb_;
}
inline void playerstats::set_callpayrmb(::google::protobuf::int32 value) {
  set_has_callpayrmb();
  callpayrmb_ = value;
}

// optional int32 paytime = 11;
inline bool playerstats::has_paytime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void playerstats::set_has_paytime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void playerstats::clear_has_paytime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void playerstats::clear_paytime() {
  paytime_ = 0;
  clear_has_paytime();
}
inline ::google::protobuf::int32 playerstats::paytime() const {
  return paytime_;
}
inline void playerstats::set_paytime(::google::protobuf::int32 value) {
  set_has_paytime();
  paytime_ = value;
}

// optional int32 callpaytime = 12;
inline bool playerstats::has_callpaytime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void playerstats::set_has_callpaytime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void playerstats::clear_has_callpaytime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void playerstats::clear_callpaytime() {
  callpaytime_ = 0;
  clear_has_callpaytime();
}
inline ::google::protobuf::int32 playerstats::callpaytime() const {
  return callpaytime_;
}
inline void playerstats::set_callpaytime(::google::protobuf::int32 value) {
  set_has_callpaytime();
  callpaytime_ = value;
}

// optional int32 maxmoney = 13;
inline bool playerstats::has_maxmoney() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void playerstats::set_has_maxmoney() {
  _has_bits_[0] |= 0x00001000u;
}
inline void playerstats::clear_has_maxmoney() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void playerstats::clear_maxmoney() {
  maxmoney_ = 0;
  clear_has_maxmoney();
}
inline ::google::protobuf::int32 playerstats::maxmoney() const {
  return maxmoney_;
}
inline void playerstats::set_maxmoney(::google::protobuf::int32 value) {
  set_has_maxmoney();
  maxmoney_ = value;
}

// optional int32 dayrmb = 14;
inline bool playerstats::has_dayrmb() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void playerstats::set_has_dayrmb() {
  _has_bits_[0] |= 0x00002000u;
}
inline void playerstats::clear_has_dayrmb() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void playerstats::clear_dayrmb() {
  dayrmb_ = 0;
  clear_has_dayrmb();
}
inline ::google::protobuf::int32 playerstats::dayrmb() const {
  return dayrmb_;
}
inline void playerstats::set_dayrmb(::google::protobuf::int32 value) {
  set_has_dayrmb();
  dayrmb_ = value;
}

// optional int32 daypaytime = 15;
inline bool playerstats::has_daypaytime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void playerstats::set_has_daypaytime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void playerstats::clear_has_daypaytime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void playerstats::clear_daypaytime() {
  daypaytime_ = 0;
  clear_has_daypaytime();
}
inline ::google::protobuf::int32 playerstats::daypaytime() const {
  return daypaytime_;
}
inline void playerstats::set_daypaytime(::google::protobuf::int32 value) {
  set_has_daypaytime();
  daypaytime_ = value;
}

// -------------------------------------------------------------------

// goodsinfo

// optional int32 itemid = 1;
inline bool goodsinfo::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void goodsinfo::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void goodsinfo::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void goodsinfo::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 goodsinfo::itemid() const {
  return itemid_;
}
inline void goodsinfo::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 userid = 2;
inline bool goodsinfo::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void goodsinfo::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void goodsinfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void goodsinfo::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 goodsinfo::userid() const {
  return userid_;
}
inline void goodsinfo::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional int32 goodsid = 3;
inline bool goodsinfo::has_goodsid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void goodsinfo::set_has_goodsid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void goodsinfo::clear_has_goodsid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void goodsinfo::clear_goodsid() {
  goodsid_ = 0;
  clear_has_goodsid();
}
inline ::google::protobuf::int32 goodsinfo::goodsid() const {
  return goodsid_;
}
inline void goodsinfo::set_goodsid(::google::protobuf::int32 value) {
  set_has_goodsid();
  goodsid_ = value;
}

// optional int32 amount = 4;
inline bool goodsinfo::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void goodsinfo::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void goodsinfo::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void goodsinfo::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline ::google::protobuf::int32 goodsinfo::amount() const {
  return amount_;
}
inline void goodsinfo::set_amount(::google::protobuf::int32 value) {
  set_has_amount();
  amount_ = value;
}

// optional int32 validity = 5;
inline bool goodsinfo::has_validity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void goodsinfo::set_has_validity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void goodsinfo::clear_has_validity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void goodsinfo::clear_validity() {
  validity_ = 0;
  clear_has_validity();
}
inline ::google::protobuf::int32 goodsinfo::validity() const {
  return validity_;
}
inline void goodsinfo::set_validity(::google::protobuf::int32 value) {
  set_has_validity();
  validity_ = value;
}

// optional string createdate = 6;
inline bool goodsinfo::has_createdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void goodsinfo::set_has_createdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void goodsinfo::clear_has_createdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void goodsinfo::clear_createdate() {
  if (createdate_ != &::google::protobuf::internal::kEmptyString) {
    createdate_->clear();
  }
  clear_has_createdate();
}
inline const ::std::string& goodsinfo::createdate() const {
  return *createdate_;
}
inline void goodsinfo::set_createdate(const ::std::string& value) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(value);
}
inline void goodsinfo::set_createdate(const char* value) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(value);
}
inline void goodsinfo::set_createdate(const char* value, size_t size) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* goodsinfo::mutable_createdate() {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    createdate_ = new ::std::string;
  }
  return createdate_;
}
inline ::std::string* goodsinfo::release_createdate() {
  clear_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createdate_;
    createdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void goodsinfo::set_allocated_createdate(::std::string* createdate) {
  if (createdate_ != &::google::protobuf::internal::kEmptyString) {
    delete createdate_;
  }
  if (createdate) {
    set_has_createdate();
    createdate_ = createdate;
  } else {
    clear_has_createdate();
    createdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 iswear = 7;
inline bool goodsinfo::has_iswear() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void goodsinfo::set_has_iswear() {
  _has_bits_[0] |= 0x00000040u;
}
inline void goodsinfo::clear_has_iswear() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void goodsinfo::clear_iswear() {
  iswear_ = 0;
  clear_has_iswear();
}
inline ::google::protobuf::int32 goodsinfo::iswear() const {
  return iswear_;
}
inline void goodsinfo::set_iswear(::google::protobuf::int32 value) {
  set_has_iswear();
  iswear_ = value;
}

// -------------------------------------------------------------------

// goodslist

// repeated .progame.goodsinfo glist = 1;
inline int goodslist::glist_size() const {
  return glist_.size();
}
inline void goodslist::clear_glist() {
  glist_.Clear();
}
inline const ::progame::goodsinfo& goodslist::glist(int index) const {
  return glist_.Get(index);
}
inline ::progame::goodsinfo* goodslist::mutable_glist(int index) {
  return glist_.Mutable(index);
}
inline ::progame::goodsinfo* goodslist::add_glist() {
  return glist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::goodsinfo >&
goodslist::glist() const {
  return glist_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::goodsinfo >*
goodslist::mutable_glist() {
  return &glist_;
}

// -------------------------------------------------------------------

// noticeinfo

// optional int32 noticetype = 1;
inline bool noticeinfo::has_noticetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void noticeinfo::set_has_noticetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void noticeinfo::clear_has_noticetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void noticeinfo::clear_noticetype() {
  noticetype_ = 0;
  clear_has_noticetype();
}
inline ::google::protobuf::int32 noticeinfo::noticetype() const {
  return noticetype_;
}
inline void noticeinfo::set_noticetype(::google::protobuf::int32 value) {
  set_has_noticetype();
  noticetype_ = value;
}

// optional int32 amount = 2;
inline bool noticeinfo::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void noticeinfo::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void noticeinfo::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void noticeinfo::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline ::google::protobuf::int32 noticeinfo::amount() const {
  return amount_;
}
inline void noticeinfo::set_amount(::google::protobuf::int32 value) {
  set_has_amount();
  amount_ = value;
}

// -------------------------------------------------------------------

// playersimpleinfo

// optional int32 userid = 1;
inline bool playersimpleinfo::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void playersimpleinfo::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void playersimpleinfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void playersimpleinfo::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 playersimpleinfo::userid() const {
  return userid_;
}
inline void playersimpleinfo::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional string nickname = 5;
inline bool playersimpleinfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void playersimpleinfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void playersimpleinfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void playersimpleinfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& playersimpleinfo::nickname() const {
  return *nickname_;
}
inline void playersimpleinfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void playersimpleinfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void playersimpleinfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playersimpleinfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* playersimpleinfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playersimpleinfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sex = 8;
inline bool playersimpleinfo::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void playersimpleinfo::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void playersimpleinfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void playersimpleinfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 playersimpleinfo::sex() const {
  return sex_;
}
inline void playersimpleinfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional int32 level = 13;
inline bool playersimpleinfo::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void playersimpleinfo::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void playersimpleinfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void playersimpleinfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 playersimpleinfo::level() const {
  return level_;
}
inline void playersimpleinfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 viplevel = 14;
inline bool playersimpleinfo::has_viplevel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void playersimpleinfo::set_has_viplevel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void playersimpleinfo::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void playersimpleinfo::clear_viplevel() {
  viplevel_ = 0;
  clear_has_viplevel();
}
inline ::google::protobuf::int32 playersimpleinfo::viplevel() const {
  return viplevel_;
}
inline void playersimpleinfo::set_viplevel(::google::protobuf::int32 value) {
  set_has_viplevel();
  viplevel_ = value;
}

// optional string jetton = 15;
inline bool playersimpleinfo::has_jetton() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void playersimpleinfo::set_has_jetton() {
  _has_bits_[0] |= 0x00000020u;
}
inline void playersimpleinfo::clear_has_jetton() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void playersimpleinfo::clear_jetton() {
  if (jetton_ != &::google::protobuf::internal::kEmptyString) {
    jetton_->clear();
  }
  clear_has_jetton();
}
inline const ::std::string& playersimpleinfo::jetton() const {
  return *jetton_;
}
inline void playersimpleinfo::set_jetton(const ::std::string& value) {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  jetton_->assign(value);
}
inline void playersimpleinfo::set_jetton(const char* value) {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  jetton_->assign(value);
}
inline void playersimpleinfo::set_jetton(const char* value, size_t size) {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  jetton_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playersimpleinfo::mutable_jetton() {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  return jetton_;
}
inline ::std::string* playersimpleinfo::release_jetton() {
  clear_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jetton_;
    jetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playersimpleinfo::set_allocated_jetton(::std::string* jetton) {
  if (jetton_ != &::google::protobuf::internal::kEmptyString) {
    delete jetton_;
  }
  if (jetton) {
    set_has_jetton();
    jetton_ = jetton;
  } else {
    clear_has_jetton();
    jetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 gold = 16;
inline bool playersimpleinfo::has_gold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void playersimpleinfo::set_has_gold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void playersimpleinfo::clear_has_gold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void playersimpleinfo::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 playersimpleinfo::gold() const {
  return gold_;
}
inline void playersimpleinfo::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// optional int32 popularity = 21;
inline bool playersimpleinfo::has_popularity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void playersimpleinfo::set_has_popularity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void playersimpleinfo::clear_has_popularity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void playersimpleinfo::clear_popularity() {
  popularity_ = 0;
  clear_has_popularity();
}
inline ::google::protobuf::int32 playersimpleinfo::popularity() const {
  return popularity_;
}
inline void playersimpleinfo::set_popularity(::google::protobuf::int32 value) {
  set_has_popularity();
  popularity_ = value;
}

// optional string ip = 31;
inline bool playersimpleinfo::has_ip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void playersimpleinfo::set_has_ip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void playersimpleinfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void playersimpleinfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& playersimpleinfo::ip() const {
  return *ip_;
}
inline void playersimpleinfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void playersimpleinfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void playersimpleinfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playersimpleinfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* playersimpleinfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playersimpleinfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string face_1 = 34;
inline bool playersimpleinfo::has_face_1() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void playersimpleinfo::set_has_face_1() {
  _has_bits_[0] |= 0x00000200u;
}
inline void playersimpleinfo::clear_has_face_1() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void playersimpleinfo::clear_face_1() {
  if (face_1_ != &::google::protobuf::internal::kEmptyString) {
    face_1_->clear();
  }
  clear_has_face_1();
}
inline const ::std::string& playersimpleinfo::face_1() const {
  return *face_1_;
}
inline void playersimpleinfo::set_face_1(const ::std::string& value) {
  set_has_face_1();
  if (face_1_ == &::google::protobuf::internal::kEmptyString) {
    face_1_ = new ::std::string;
  }
  face_1_->assign(value);
}
inline void playersimpleinfo::set_face_1(const char* value) {
  set_has_face_1();
  if (face_1_ == &::google::protobuf::internal::kEmptyString) {
    face_1_ = new ::std::string;
  }
  face_1_->assign(value);
}
inline void playersimpleinfo::set_face_1(const char* value, size_t size) {
  set_has_face_1();
  if (face_1_ == &::google::protobuf::internal::kEmptyString) {
    face_1_ = new ::std::string;
  }
  face_1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playersimpleinfo::mutable_face_1() {
  set_has_face_1();
  if (face_1_ == &::google::protobuf::internal::kEmptyString) {
    face_1_ = new ::std::string;
  }
  return face_1_;
}
inline ::std::string* playersimpleinfo::release_face_1() {
  clear_has_face_1();
  if (face_1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = face_1_;
    face_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playersimpleinfo::set_allocated_face_1(::std::string* face_1) {
  if (face_1_ != &::google::protobuf::internal::kEmptyString) {
    delete face_1_;
  }
  if (face_1) {
    set_has_face_1();
    face_1_ = face_1;
  } else {
    clear_has_face_1();
    face_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location = 41;
inline bool playersimpleinfo::has_location() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void playersimpleinfo::set_has_location() {
  _has_bits_[0] |= 0x00000400u;
}
inline void playersimpleinfo::clear_has_location() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void playersimpleinfo::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& playersimpleinfo::location() const {
  return *location_;
}
inline void playersimpleinfo::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void playersimpleinfo::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void playersimpleinfo::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playersimpleinfo::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* playersimpleinfo::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playersimpleinfo::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 propertyid = 45;
inline bool playersimpleinfo::has_propertyid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void playersimpleinfo::set_has_propertyid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void playersimpleinfo::clear_has_propertyid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void playersimpleinfo::clear_propertyid() {
  propertyid_ = 0;
  clear_has_propertyid();
}
inline ::google::protobuf::int32 playersimpleinfo::propertyid() const {
  return propertyid_;
}
inline void playersimpleinfo::set_propertyid(::google::protobuf::int32 value) {
  set_has_propertyid();
  propertyid_ = value;
}

// optional string jifen = 99;
inline bool playersimpleinfo::has_jifen() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void playersimpleinfo::set_has_jifen() {
  _has_bits_[0] |= 0x00001000u;
}
inline void playersimpleinfo::clear_has_jifen() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void playersimpleinfo::clear_jifen() {
  if (jifen_ != &::google::protobuf::internal::kEmptyString) {
    jifen_->clear();
  }
  clear_has_jifen();
}
inline const ::std::string& playersimpleinfo::jifen() const {
  return *jifen_;
}
inline void playersimpleinfo::set_jifen(const ::std::string& value) {
  set_has_jifen();
  if (jifen_ == &::google::protobuf::internal::kEmptyString) {
    jifen_ = new ::std::string;
  }
  jifen_->assign(value);
}
inline void playersimpleinfo::set_jifen(const char* value) {
  set_has_jifen();
  if (jifen_ == &::google::protobuf::internal::kEmptyString) {
    jifen_ = new ::std::string;
  }
  jifen_->assign(value);
}
inline void playersimpleinfo::set_jifen(const char* value, size_t size) {
  set_has_jifen();
  if (jifen_ == &::google::protobuf::internal::kEmptyString) {
    jifen_ = new ::std::string;
  }
  jifen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playersimpleinfo::mutable_jifen() {
  set_has_jifen();
  if (jifen_ == &::google::protobuf::internal::kEmptyString) {
    jifen_ = new ::std::string;
  }
  return jifen_;
}
inline ::std::string* playersimpleinfo::release_jifen() {
  clear_has_jifen();
  if (jifen_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jifen_;
    jifen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playersimpleinfo::set_allocated_jifen(::std::string* jifen) {
  if (jifen_ != &::google::protobuf::internal::kEmptyString) {
    delete jifen_;
  }
  if (jifen) {
    set_has_jifen();
    jifen_ = jifen;
  } else {
    clear_has_jifen();
    jifen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location_x = 47;
inline bool playersimpleinfo::has_location_x() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void playersimpleinfo::set_has_location_x() {
  _has_bits_[0] |= 0x00002000u;
}
inline void playersimpleinfo::clear_has_location_x() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void playersimpleinfo::clear_location_x() {
  if (location_x_ != &::google::protobuf::internal::kEmptyString) {
    location_x_->clear();
  }
  clear_has_location_x();
}
inline const ::std::string& playersimpleinfo::location_x() const {
  return *location_x_;
}
inline void playersimpleinfo::set_location_x(const ::std::string& value) {
  set_has_location_x();
  if (location_x_ == &::google::protobuf::internal::kEmptyString) {
    location_x_ = new ::std::string;
  }
  location_x_->assign(value);
}
inline void playersimpleinfo::set_location_x(const char* value) {
  set_has_location_x();
  if (location_x_ == &::google::protobuf::internal::kEmptyString) {
    location_x_ = new ::std::string;
  }
  location_x_->assign(value);
}
inline void playersimpleinfo::set_location_x(const char* value, size_t size) {
  set_has_location_x();
  if (location_x_ == &::google::protobuf::internal::kEmptyString) {
    location_x_ = new ::std::string;
  }
  location_x_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playersimpleinfo::mutable_location_x() {
  set_has_location_x();
  if (location_x_ == &::google::protobuf::internal::kEmptyString) {
    location_x_ = new ::std::string;
  }
  return location_x_;
}
inline ::std::string* playersimpleinfo::release_location_x() {
  clear_has_location_x();
  if (location_x_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_x_;
    location_x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playersimpleinfo::set_allocated_location_x(::std::string* location_x) {
  if (location_x_ != &::google::protobuf::internal::kEmptyString) {
    delete location_x_;
  }
  if (location_x) {
    set_has_location_x();
    location_x_ = location_x;
  } else {
    clear_has_location_x();
    location_x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location_y = 48;
inline bool playersimpleinfo::has_location_y() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void playersimpleinfo::set_has_location_y() {
  _has_bits_[0] |= 0x00004000u;
}
inline void playersimpleinfo::clear_has_location_y() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void playersimpleinfo::clear_location_y() {
  if (location_y_ != &::google::protobuf::internal::kEmptyString) {
    location_y_->clear();
  }
  clear_has_location_y();
}
inline const ::std::string& playersimpleinfo::location_y() const {
  return *location_y_;
}
inline void playersimpleinfo::set_location_y(const ::std::string& value) {
  set_has_location_y();
  if (location_y_ == &::google::protobuf::internal::kEmptyString) {
    location_y_ = new ::std::string;
  }
  location_y_->assign(value);
}
inline void playersimpleinfo::set_location_y(const char* value) {
  set_has_location_y();
  if (location_y_ == &::google::protobuf::internal::kEmptyString) {
    location_y_ = new ::std::string;
  }
  location_y_->assign(value);
}
inline void playersimpleinfo::set_location_y(const char* value, size_t size) {
  set_has_location_y();
  if (location_y_ == &::google::protobuf::internal::kEmptyString) {
    location_y_ = new ::std::string;
  }
  location_y_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* playersimpleinfo::mutable_location_y() {
  set_has_location_y();
  if (location_y_ == &::google::protobuf::internal::kEmptyString) {
    location_y_ = new ::std::string;
  }
  return location_y_;
}
inline ::std::string* playersimpleinfo::release_location_y() {
  clear_has_location_y();
  if (location_y_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_y_;
    location_y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void playersimpleinfo::set_allocated_location_y(::std::string* location_y) {
  if (location_y_ != &::google::protobuf::internal::kEmptyString) {
    delete location_y_;
  }
  if (location_y) {
    set_has_location_y();
    location_y_ = location_y;
  } else {
    clear_has_location_y();
    location_y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// broadcastinfo

// optional int32 id = 1;
inline bool broadcastinfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void broadcastinfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void broadcastinfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void broadcastinfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 broadcastinfo::id() const {
  return id_;
}
inline void broadcastinfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 broadtype = 2;
inline bool broadcastinfo::has_broadtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void broadcastinfo::set_has_broadtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void broadcastinfo::clear_has_broadtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void broadcastinfo::clear_broadtype() {
  broadtype_ = 0;
  clear_has_broadtype();
}
inline ::google::protobuf::int32 broadcastinfo::broadtype() const {
  return broadtype_;
}
inline void broadcastinfo::set_broadtype(::google::protobuf::int32 value) {
  set_has_broadtype();
  broadtype_ = value;
}

// optional int32 senderid = 3;
inline bool broadcastinfo::has_senderid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void broadcastinfo::set_has_senderid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void broadcastinfo::clear_has_senderid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void broadcastinfo::clear_senderid() {
  senderid_ = 0;
  clear_has_senderid();
}
inline ::google::protobuf::int32 broadcastinfo::senderid() const {
  return senderid_;
}
inline void broadcastinfo::set_senderid(::google::protobuf::int32 value) {
  set_has_senderid();
  senderid_ = value;
}

// optional string sender = 4;
inline bool broadcastinfo::has_sender() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void broadcastinfo::set_has_sender() {
  _has_bits_[0] |= 0x00000008u;
}
inline void broadcastinfo::clear_has_sender() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void broadcastinfo::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& broadcastinfo::sender() const {
  return *sender_;
}
inline void broadcastinfo::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void broadcastinfo::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void broadcastinfo::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* broadcastinfo::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* broadcastinfo::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void broadcastinfo::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string msg = 5;
inline bool broadcastinfo::has_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void broadcastinfo::set_has_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void broadcastinfo::clear_has_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void broadcastinfo::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& broadcastinfo::msg() const {
  return *msg_;
}
inline void broadcastinfo::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void broadcastinfo::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void broadcastinfo::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* broadcastinfo::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* broadcastinfo::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void broadcastinfo::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 broadtimes = 6;
inline bool broadcastinfo::has_broadtimes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void broadcastinfo::set_has_broadtimes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void broadcastinfo::clear_has_broadtimes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void broadcastinfo::clear_broadtimes() {
  broadtimes_ = 0;
  clear_has_broadtimes();
}
inline ::google::protobuf::int32 broadcastinfo::broadtimes() const {
  return broadtimes_;
}
inline void broadcastinfo::set_broadtimes(::google::protobuf::int32 value) {
  set_has_broadtimes();
  broadtimes_ = value;
}

// optional int32 validday = 7;
inline bool broadcastinfo::has_validday() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void broadcastinfo::set_has_validday() {
  _has_bits_[0] |= 0x00000040u;
}
inline void broadcastinfo::clear_has_validday() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void broadcastinfo::clear_validday() {
  validday_ = 0;
  clear_has_validday();
}
inline ::google::protobuf::int32 broadcastinfo::validday() const {
  return validday_;
}
inline void broadcastinfo::set_validday(::google::protobuf::int32 value) {
  set_has_validday();
  validday_ = value;
}

// optional string createtime = 8;
inline bool broadcastinfo::has_createtime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void broadcastinfo::set_has_createtime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void broadcastinfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void broadcastinfo::clear_createtime() {
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    createtime_->clear();
  }
  clear_has_createtime();
}
inline const ::std::string& broadcastinfo::createtime() const {
  return *createtime_;
}
inline void broadcastinfo::set_createtime(const ::std::string& value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
}
inline void broadcastinfo::set_createtime(const char* value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
}
inline void broadcastinfo::set_createtime(const char* value, size_t size) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* broadcastinfo::mutable_createtime() {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  return createtime_;
}
inline ::std::string* broadcastinfo::release_createtime() {
  clear_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createtime_;
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void broadcastinfo::set_allocated_createtime(::std::string* createtime) {
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    delete createtime_;
  }
  if (createtime) {
    set_has_createtime();
    createtime_ = createtime;
  } else {
    clear_has_createtime();
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 cycletype = 9;
inline bool broadcastinfo::has_cycletype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void broadcastinfo::set_has_cycletype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void broadcastinfo::clear_has_cycletype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void broadcastinfo::clear_cycletype() {
  cycletype_ = 0;
  clear_has_cycletype();
}
inline ::google::protobuf::int32 broadcastinfo::cycletype() const {
  return cycletype_;
}
inline void broadcastinfo::set_cycletype(::google::protobuf::int32 value) {
  set_has_cycletype();
  cycletype_ = value;
}

// -------------------------------------------------------------------

// mailinfo

// optional int32 mailid = 1;
inline bool mailinfo::has_mailid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mailinfo::set_has_mailid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mailinfo::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mailinfo::clear_mailid() {
  mailid_ = 0;
  clear_has_mailid();
}
inline ::google::protobuf::int32 mailinfo::mailid() const {
  return mailid_;
}
inline void mailinfo::set_mailid(::google::protobuf::int32 value) {
  set_has_mailid();
  mailid_ = value;
}

// optional int32 senderid = 2;
inline bool mailinfo::has_senderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mailinfo::set_has_senderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mailinfo::clear_has_senderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mailinfo::clear_senderid() {
  senderid_ = 0;
  clear_has_senderid();
}
inline ::google::protobuf::int32 mailinfo::senderid() const {
  return senderid_;
}
inline void mailinfo::set_senderid(::google::protobuf::int32 value) {
  set_has_senderid();
  senderid_ = value;
}

// optional string sender = 3;
inline bool mailinfo::has_sender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mailinfo::set_has_sender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mailinfo::clear_has_sender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mailinfo::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& mailinfo::sender() const {
  return *sender_;
}
inline void mailinfo::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void mailinfo::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void mailinfo::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mailinfo::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* mailinfo::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mailinfo::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 receiverid = 4;
inline bool mailinfo::has_receiverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mailinfo::set_has_receiverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mailinfo::clear_has_receiverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mailinfo::clear_receiverid() {
  receiverid_ = 0;
  clear_has_receiverid();
}
inline ::google::protobuf::int32 mailinfo::receiverid() const {
  return receiverid_;
}
inline void mailinfo::set_receiverid(::google::protobuf::int32 value) {
  set_has_receiverid();
  receiverid_ = value;
}

// optional string receiver = 5;
inline bool mailinfo::has_receiver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mailinfo::set_has_receiver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mailinfo::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mailinfo::clear_receiver() {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    receiver_->clear();
  }
  clear_has_receiver();
}
inline const ::std::string& mailinfo::receiver() const {
  return *receiver_;
}
inline void mailinfo::set_receiver(const ::std::string& value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void mailinfo::set_receiver(const char* value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void mailinfo::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mailinfo::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  return receiver_;
}
inline ::std::string* mailinfo::release_receiver() {
  clear_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiver_;
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mailinfo::set_allocated_receiver(::std::string* receiver) {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    delete receiver_;
  }
  if (receiver) {
    set_has_receiver();
    receiver_ = receiver;
  } else {
    clear_has_receiver();
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 mailtype = 6;
inline bool mailinfo::has_mailtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mailinfo::set_has_mailtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void mailinfo::clear_has_mailtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void mailinfo::clear_mailtype() {
  mailtype_ = 0;
  clear_has_mailtype();
}
inline ::google::protobuf::int32 mailinfo::mailtype() const {
  return mailtype_;
}
inline void mailinfo::set_mailtype(::google::protobuf::int32 value) {
  set_has_mailtype();
  mailtype_ = value;
}

// optional string title = 7;
inline bool mailinfo::has_title() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void mailinfo::set_has_title() {
  _has_bits_[0] |= 0x00000040u;
}
inline void mailinfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void mailinfo::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& mailinfo::title() const {
  return *title_;
}
inline void mailinfo::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void mailinfo::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void mailinfo::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mailinfo::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* mailinfo::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mailinfo::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 8;
inline bool mailinfo::has_content() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void mailinfo::set_has_content() {
  _has_bits_[0] |= 0x00000080u;
}
inline void mailinfo::clear_has_content() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void mailinfo::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& mailinfo::content() const {
  return *content_;
}
inline void mailinfo::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void mailinfo::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void mailinfo::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mailinfo::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* mailinfo::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mailinfo::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string senddate = 9;
inline bool mailinfo::has_senddate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void mailinfo::set_has_senddate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void mailinfo::clear_has_senddate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void mailinfo::clear_senddate() {
  if (senddate_ != &::google::protobuf::internal::kEmptyString) {
    senddate_->clear();
  }
  clear_has_senddate();
}
inline const ::std::string& mailinfo::senddate() const {
  return *senddate_;
}
inline void mailinfo::set_senddate(const ::std::string& value) {
  set_has_senddate();
  if (senddate_ == &::google::protobuf::internal::kEmptyString) {
    senddate_ = new ::std::string;
  }
  senddate_->assign(value);
}
inline void mailinfo::set_senddate(const char* value) {
  set_has_senddate();
  if (senddate_ == &::google::protobuf::internal::kEmptyString) {
    senddate_ = new ::std::string;
  }
  senddate_->assign(value);
}
inline void mailinfo::set_senddate(const char* value, size_t size) {
  set_has_senddate();
  if (senddate_ == &::google::protobuf::internal::kEmptyString) {
    senddate_ = new ::std::string;
  }
  senddate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mailinfo::mutable_senddate() {
  set_has_senddate();
  if (senddate_ == &::google::protobuf::internal::kEmptyString) {
    senddate_ = new ::std::string;
  }
  return senddate_;
}
inline ::std::string* mailinfo::release_senddate() {
  clear_has_senddate();
  if (senddate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = senddate_;
    senddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mailinfo::set_allocated_senddate(::std::string* senddate) {
  if (senddate_ != &::google::protobuf::internal::kEmptyString) {
    delete senddate_;
  }
  if (senddate) {
    set_has_senddate();
    senddate_ = senddate;
  } else {
    clear_has_senddate();
    senddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string markdate = 10;
inline bool mailinfo::has_markdate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void mailinfo::set_has_markdate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void mailinfo::clear_has_markdate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void mailinfo::clear_markdate() {
  if (markdate_ != &::google::protobuf::internal::kEmptyString) {
    markdate_->clear();
  }
  clear_has_markdate();
}
inline const ::std::string& mailinfo::markdate() const {
  return *markdate_;
}
inline void mailinfo::set_markdate(const ::std::string& value) {
  set_has_markdate();
  if (markdate_ == &::google::protobuf::internal::kEmptyString) {
    markdate_ = new ::std::string;
  }
  markdate_->assign(value);
}
inline void mailinfo::set_markdate(const char* value) {
  set_has_markdate();
  if (markdate_ == &::google::protobuf::internal::kEmptyString) {
    markdate_ = new ::std::string;
  }
  markdate_->assign(value);
}
inline void mailinfo::set_markdate(const char* value, size_t size) {
  set_has_markdate();
  if (markdate_ == &::google::protobuf::internal::kEmptyString) {
    markdate_ = new ::std::string;
  }
  markdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mailinfo::mutable_markdate() {
  set_has_markdate();
  if (markdate_ == &::google::protobuf::internal::kEmptyString) {
    markdate_ = new ::std::string;
  }
  return markdate_;
}
inline ::std::string* mailinfo::release_markdate() {
  clear_has_markdate();
  if (markdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = markdate_;
    markdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mailinfo::set_allocated_markdate(::std::string* markdate) {
  if (markdate_ != &::google::protobuf::internal::kEmptyString) {
    delete markdate_;
  }
  if (markdate) {
    set_has_markdate();
    markdate_ = markdate;
  } else {
    clear_has_markdate();
    markdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 mailstate = 11;
inline bool mailinfo::has_mailstate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void mailinfo::set_has_mailstate() {
  _has_bits_[0] |= 0x00000400u;
}
inline void mailinfo::clear_has_mailstate() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void mailinfo::clear_mailstate() {
  mailstate_ = 0;
  clear_has_mailstate();
}
inline ::google::protobuf::int32 mailinfo::mailstate() const {
  return mailstate_;
}
inline void mailinfo::set_mailstate(::google::protobuf::int32 value) {
  set_has_mailstate();
  mailstate_ = value;
}

// optional string externdata = 12;
inline bool mailinfo::has_externdata() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void mailinfo::set_has_externdata() {
  _has_bits_[0] |= 0x00000800u;
}
inline void mailinfo::clear_has_externdata() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void mailinfo::clear_externdata() {
  if (externdata_ != &::google::protobuf::internal::kEmptyString) {
    externdata_->clear();
  }
  clear_has_externdata();
}
inline const ::std::string& mailinfo::externdata() const {
  return *externdata_;
}
inline void mailinfo::set_externdata(const ::std::string& value) {
  set_has_externdata();
  if (externdata_ == &::google::protobuf::internal::kEmptyString) {
    externdata_ = new ::std::string;
  }
  externdata_->assign(value);
}
inline void mailinfo::set_externdata(const char* value) {
  set_has_externdata();
  if (externdata_ == &::google::protobuf::internal::kEmptyString) {
    externdata_ = new ::std::string;
  }
  externdata_->assign(value);
}
inline void mailinfo::set_externdata(const char* value, size_t size) {
  set_has_externdata();
  if (externdata_ == &::google::protobuf::internal::kEmptyString) {
    externdata_ = new ::std::string;
  }
  externdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mailinfo::mutable_externdata() {
  set_has_externdata();
  if (externdata_ == &::google::protobuf::internal::kEmptyString) {
    externdata_ = new ::std::string;
  }
  return externdata_;
}
inline ::std::string* mailinfo::release_externdata() {
  clear_has_externdata();
  if (externdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = externdata_;
    externdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mailinfo::set_allocated_externdata(::std::string* externdata) {
  if (externdata_ != &::google::protobuf::internal::kEmptyString) {
    delete externdata_;
  }
  if (externdata) {
    set_has_externdata();
    externdata_ = externdata;
  } else {
    clear_has_externdata();
    externdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string remark = 13;
inline bool mailinfo::has_remark() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void mailinfo::set_has_remark() {
  _has_bits_[0] |= 0x00001000u;
}
inline void mailinfo::clear_has_remark() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void mailinfo::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& mailinfo::remark() const {
  return *remark_;
}
inline void mailinfo::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void mailinfo::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void mailinfo::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mailinfo::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* mailinfo::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mailinfo::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 validity = 14;
inline bool mailinfo::has_validity() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void mailinfo::set_has_validity() {
  _has_bits_[0] |= 0x00002000u;
}
inline void mailinfo::clear_has_validity() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void mailinfo::clear_validity() {
  validity_ = 0;
  clear_has_validity();
}
inline ::google::protobuf::int32 mailinfo::validity() const {
  return validity_;
}
inline void mailinfo::set_validity(::google::protobuf::int32 value) {
  set_has_validity();
  validity_ = value;
}

// -------------------------------------------------------------------

// maillist

// repeated .progame.mailinfo mlist = 1;
inline int maillist::mlist_size() const {
  return mlist_.size();
}
inline void maillist::clear_mlist() {
  mlist_.Clear();
}
inline const ::progame::mailinfo& maillist::mlist(int index) const {
  return mlist_.Get(index);
}
inline ::progame::mailinfo* maillist::mutable_mlist(int index) {
  return mlist_.Mutable(index);
}
inline ::progame::mailinfo* maillist::add_mlist() {
  return mlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::mailinfo >&
maillist::mlist() const {
  return mlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::mailinfo >*
maillist::mutable_mlist() {
  return &mlist_;
}

// -------------------------------------------------------------------

// inviteinfo

// optional int32 userid = 1;
inline bool inviteinfo::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void inviteinfo::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void inviteinfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void inviteinfo::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 inviteinfo::userid() const {
  return userid_;
}
inline void inviteinfo::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional int32 binduserid = 2;
inline bool inviteinfo::has_binduserid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void inviteinfo::set_has_binduserid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void inviteinfo::clear_has_binduserid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void inviteinfo::clear_binduserid() {
  binduserid_ = 0;
  clear_has_binduserid();
}
inline ::google::protobuf::int32 inviteinfo::binduserid() const {
  return binduserid_;
}
inline void inviteinfo::set_binduserid(::google::protobuf::int32 value) {
  set_has_binduserid();
  binduserid_ = value;
}

// optional string bindnickname = 3;
inline bool inviteinfo::has_bindnickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void inviteinfo::set_has_bindnickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void inviteinfo::clear_has_bindnickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void inviteinfo::clear_bindnickname() {
  if (bindnickname_ != &::google::protobuf::internal::kEmptyString) {
    bindnickname_->clear();
  }
  clear_has_bindnickname();
}
inline const ::std::string& inviteinfo::bindnickname() const {
  return *bindnickname_;
}
inline void inviteinfo::set_bindnickname(const ::std::string& value) {
  set_has_bindnickname();
  if (bindnickname_ == &::google::protobuf::internal::kEmptyString) {
    bindnickname_ = new ::std::string;
  }
  bindnickname_->assign(value);
}
inline void inviteinfo::set_bindnickname(const char* value) {
  set_has_bindnickname();
  if (bindnickname_ == &::google::protobuf::internal::kEmptyString) {
    bindnickname_ = new ::std::string;
  }
  bindnickname_->assign(value);
}
inline void inviteinfo::set_bindnickname(const char* value, size_t size) {
  set_has_bindnickname();
  if (bindnickname_ == &::google::protobuf::internal::kEmptyString) {
    bindnickname_ = new ::std::string;
  }
  bindnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* inviteinfo::mutable_bindnickname() {
  set_has_bindnickname();
  if (bindnickname_ == &::google::protobuf::internal::kEmptyString) {
    bindnickname_ = new ::std::string;
  }
  return bindnickname_;
}
inline ::std::string* inviteinfo::release_bindnickname() {
  clear_has_bindnickname();
  if (bindnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bindnickname_;
    bindnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void inviteinfo::set_allocated_bindnickname(::std::string* bindnickname) {
  if (bindnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete bindnickname_;
  }
  if (bindnickname) {
    set_has_bindnickname();
    bindnickname_ = bindnickname;
  } else {
    clear_has_bindnickname();
    bindnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bindfaceid = 4;
inline bool inviteinfo::has_bindfaceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void inviteinfo::set_has_bindfaceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void inviteinfo::clear_has_bindfaceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void inviteinfo::clear_bindfaceid() {
  if (bindfaceid_ != &::google::protobuf::internal::kEmptyString) {
    bindfaceid_->clear();
  }
  clear_has_bindfaceid();
}
inline const ::std::string& inviteinfo::bindfaceid() const {
  return *bindfaceid_;
}
inline void inviteinfo::set_bindfaceid(const ::std::string& value) {
  set_has_bindfaceid();
  if (bindfaceid_ == &::google::protobuf::internal::kEmptyString) {
    bindfaceid_ = new ::std::string;
  }
  bindfaceid_->assign(value);
}
inline void inviteinfo::set_bindfaceid(const char* value) {
  set_has_bindfaceid();
  if (bindfaceid_ == &::google::protobuf::internal::kEmptyString) {
    bindfaceid_ = new ::std::string;
  }
  bindfaceid_->assign(value);
}
inline void inviteinfo::set_bindfaceid(const char* value, size_t size) {
  set_has_bindfaceid();
  if (bindfaceid_ == &::google::protobuf::internal::kEmptyString) {
    bindfaceid_ = new ::std::string;
  }
  bindfaceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* inviteinfo::mutable_bindfaceid() {
  set_has_bindfaceid();
  if (bindfaceid_ == &::google::protobuf::internal::kEmptyString) {
    bindfaceid_ = new ::std::string;
  }
  return bindfaceid_;
}
inline ::std::string* inviteinfo::release_bindfaceid() {
  clear_has_bindfaceid();
  if (bindfaceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bindfaceid_;
    bindfaceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void inviteinfo::set_allocated_bindfaceid(::std::string* bindfaceid) {
  if (bindfaceid_ != &::google::protobuf::internal::kEmptyString) {
    delete bindfaceid_;
  }
  if (bindfaceid) {
    set_has_bindfaceid();
    bindfaceid_ = bindfaceid;
  } else {
    clear_has_bindfaceid();
    bindfaceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string binddate = 5;
inline bool inviteinfo::has_binddate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void inviteinfo::set_has_binddate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void inviteinfo::clear_has_binddate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void inviteinfo::clear_binddate() {
  if (binddate_ != &::google::protobuf::internal::kEmptyString) {
    binddate_->clear();
  }
  clear_has_binddate();
}
inline const ::std::string& inviteinfo::binddate() const {
  return *binddate_;
}
inline void inviteinfo::set_binddate(const ::std::string& value) {
  set_has_binddate();
  if (binddate_ == &::google::protobuf::internal::kEmptyString) {
    binddate_ = new ::std::string;
  }
  binddate_->assign(value);
}
inline void inviteinfo::set_binddate(const char* value) {
  set_has_binddate();
  if (binddate_ == &::google::protobuf::internal::kEmptyString) {
    binddate_ = new ::std::string;
  }
  binddate_->assign(value);
}
inline void inviteinfo::set_binddate(const char* value, size_t size) {
  set_has_binddate();
  if (binddate_ == &::google::protobuf::internal::kEmptyString) {
    binddate_ = new ::std::string;
  }
  binddate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* inviteinfo::mutable_binddate() {
  set_has_binddate();
  if (binddate_ == &::google::protobuf::internal::kEmptyString) {
    binddate_ = new ::std::string;
  }
  return binddate_;
}
inline ::std::string* inviteinfo::release_binddate() {
  clear_has_binddate();
  if (binddate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = binddate_;
    binddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void inviteinfo::set_allocated_binddate(::std::string* binddate) {
  if (binddate_ != &::google::protobuf::internal::kEmptyString) {
    delete binddate_;
  }
  if (binddate) {
    set_has_binddate();
    binddate_ = binddate;
  } else {
    clear_has_binddate();
    binddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// agencyinfo

// optional int32 userid = 1;
inline bool agencyinfo::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void agencyinfo::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void agencyinfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void agencyinfo::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 agencyinfo::userid() const {
  return userid_;
}
inline void agencyinfo::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional string invitestr = 2;
inline bool agencyinfo::has_invitestr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void agencyinfo::set_has_invitestr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void agencyinfo::clear_has_invitestr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void agencyinfo::clear_invitestr() {
  if (invitestr_ != &::google::protobuf::internal::kEmptyString) {
    invitestr_->clear();
  }
  clear_has_invitestr();
}
inline const ::std::string& agencyinfo::invitestr() const {
  return *invitestr_;
}
inline void agencyinfo::set_invitestr(const ::std::string& value) {
  set_has_invitestr();
  if (invitestr_ == &::google::protobuf::internal::kEmptyString) {
    invitestr_ = new ::std::string;
  }
  invitestr_->assign(value);
}
inline void agencyinfo::set_invitestr(const char* value) {
  set_has_invitestr();
  if (invitestr_ == &::google::protobuf::internal::kEmptyString) {
    invitestr_ = new ::std::string;
  }
  invitestr_->assign(value);
}
inline void agencyinfo::set_invitestr(const char* value, size_t size) {
  set_has_invitestr();
  if (invitestr_ == &::google::protobuf::internal::kEmptyString) {
    invitestr_ = new ::std::string;
  }
  invitestr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* agencyinfo::mutable_invitestr() {
  set_has_invitestr();
  if (invitestr_ == &::google::protobuf::internal::kEmptyString) {
    invitestr_ = new ::std::string;
  }
  return invitestr_;
}
inline ::std::string* agencyinfo::release_invitestr() {
  clear_has_invitestr();
  if (invitestr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = invitestr_;
    invitestr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void agencyinfo::set_allocated_invitestr(::std::string* invitestr) {
  if (invitestr_ != &::google::protobuf::internal::kEmptyString) {
    delete invitestr_;
  }
  if (invitestr) {
    set_has_invitestr();
    invitestr_ = invitestr;
  } else {
    clear_has_invitestr();
    invitestr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 3;
inline bool agencyinfo::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void agencyinfo::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void agencyinfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void agencyinfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 agencyinfo::level() const {
  return level_;
}
inline void agencyinfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 soleagent = 4;
inline bool agencyinfo::has_soleagent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void agencyinfo::set_has_soleagent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void agencyinfo::clear_has_soleagent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void agencyinfo::clear_soleagent() {
  soleagent_ = 0;
  clear_has_soleagent();
}
inline ::google::protobuf::int32 agencyinfo::soleagent() const {
  return soleagent_;
}
inline void agencyinfo::set_soleagent(::google::protobuf::int32 value) {
  set_has_soleagent();
  soleagent_ = value;
}

// optional int32 agent1 = 5;
inline bool agencyinfo::has_agent1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void agencyinfo::set_has_agent1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void agencyinfo::clear_has_agent1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void agencyinfo::clear_agent1() {
  agent1_ = 0;
  clear_has_agent1();
}
inline ::google::protobuf::int32 agencyinfo::agent1() const {
  return agent1_;
}
inline void agencyinfo::set_agent1(::google::protobuf::int32 value) {
  set_has_agent1();
  agent1_ = value;
}

// optional int32 agent2 = 6;
inline bool agencyinfo::has_agent2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void agencyinfo::set_has_agent2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void agencyinfo::clear_has_agent2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void agencyinfo::clear_agent2() {
  agent2_ = 0;
  clear_has_agent2();
}
inline ::google::protobuf::int32 agencyinfo::agent2() const {
  return agent2_;
}
inline void agencyinfo::set_agent2(::google::protobuf::int32 value) {
  set_has_agent2();
  agent2_ = value;
}

// optional int32 agent3 = 7;
inline bool agencyinfo::has_agent3() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void agencyinfo::set_has_agent3() {
  _has_bits_[0] |= 0x00000040u;
}
inline void agencyinfo::clear_has_agent3() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void agencyinfo::clear_agent3() {
  agent3_ = 0;
  clear_has_agent3();
}
inline ::google::protobuf::int32 agencyinfo::agent3() const {
  return agent3_;
}
inline void agencyinfo::set_agent3(::google::protobuf::int32 value) {
  set_has_agent3();
  agent3_ = value;
}

// optional int32 agent4 = 8;
inline bool agencyinfo::has_agent4() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void agencyinfo::set_has_agent4() {
  _has_bits_[0] |= 0x00000080u;
}
inline void agencyinfo::clear_has_agent4() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void agencyinfo::clear_agent4() {
  agent4_ = 0;
  clear_has_agent4();
}
inline ::google::protobuf::int32 agencyinfo::agent4() const {
  return agent4_;
}
inline void agencyinfo::set_agent4(::google::protobuf::int32 value) {
  set_has_agent4();
  agent4_ = value;
}

// repeated .progame.inviteinfo invitelist = 9;
inline int agencyinfo::invitelist_size() const {
  return invitelist_.size();
}
inline void agencyinfo::clear_invitelist() {
  invitelist_.Clear();
}
inline const ::progame::inviteinfo& agencyinfo::invitelist(int index) const {
  return invitelist_.Get(index);
}
inline ::progame::inviteinfo* agencyinfo::mutable_invitelist(int index) {
  return invitelist_.Mutable(index);
}
inline ::progame::inviteinfo* agencyinfo::add_invitelist() {
  return invitelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::inviteinfo >&
agencyinfo::invitelist() const {
  return invitelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::inviteinfo >*
agencyinfo::mutable_invitelist() {
  return &invitelist_;
}

// optional string qrcodeurl = 10;
inline bool agencyinfo::has_qrcodeurl() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void agencyinfo::set_has_qrcodeurl() {
  _has_bits_[0] |= 0x00000200u;
}
inline void agencyinfo::clear_has_qrcodeurl() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void agencyinfo::clear_qrcodeurl() {
  if (qrcodeurl_ != &::google::protobuf::internal::kEmptyString) {
    qrcodeurl_->clear();
  }
  clear_has_qrcodeurl();
}
inline const ::std::string& agencyinfo::qrcodeurl() const {
  return *qrcodeurl_;
}
inline void agencyinfo::set_qrcodeurl(const ::std::string& value) {
  set_has_qrcodeurl();
  if (qrcodeurl_ == &::google::protobuf::internal::kEmptyString) {
    qrcodeurl_ = new ::std::string;
  }
  qrcodeurl_->assign(value);
}
inline void agencyinfo::set_qrcodeurl(const char* value) {
  set_has_qrcodeurl();
  if (qrcodeurl_ == &::google::protobuf::internal::kEmptyString) {
    qrcodeurl_ = new ::std::string;
  }
  qrcodeurl_->assign(value);
}
inline void agencyinfo::set_qrcodeurl(const char* value, size_t size) {
  set_has_qrcodeurl();
  if (qrcodeurl_ == &::google::protobuf::internal::kEmptyString) {
    qrcodeurl_ = new ::std::string;
  }
  qrcodeurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* agencyinfo::mutable_qrcodeurl() {
  set_has_qrcodeurl();
  if (qrcodeurl_ == &::google::protobuf::internal::kEmptyString) {
    qrcodeurl_ = new ::std::string;
  }
  return qrcodeurl_;
}
inline ::std::string* agencyinfo::release_qrcodeurl() {
  clear_has_qrcodeurl();
  if (qrcodeurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qrcodeurl_;
    qrcodeurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void agencyinfo::set_allocated_qrcodeurl(::std::string* qrcodeurl) {
  if (qrcodeurl_ != &::google::protobuf::internal::kEmptyString) {
    delete qrcodeurl_;
  }
  if (qrcodeurl) {
    set_has_qrcodeurl();
    qrcodeurl_ = qrcodeurl;
  } else {
    clear_has_qrcodeurl();
    qrcodeurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string datemark = 11;
inline bool agencyinfo::has_datemark() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void agencyinfo::set_has_datemark() {
  _has_bits_[0] |= 0x00000400u;
}
inline void agencyinfo::clear_has_datemark() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void agencyinfo::clear_datemark() {
  if (datemark_ != &::google::protobuf::internal::kEmptyString) {
    datemark_->clear();
  }
  clear_has_datemark();
}
inline const ::std::string& agencyinfo::datemark() const {
  return *datemark_;
}
inline void agencyinfo::set_datemark(const ::std::string& value) {
  set_has_datemark();
  if (datemark_ == &::google::protobuf::internal::kEmptyString) {
    datemark_ = new ::std::string;
  }
  datemark_->assign(value);
}
inline void agencyinfo::set_datemark(const char* value) {
  set_has_datemark();
  if (datemark_ == &::google::protobuf::internal::kEmptyString) {
    datemark_ = new ::std::string;
  }
  datemark_->assign(value);
}
inline void agencyinfo::set_datemark(const char* value, size_t size) {
  set_has_datemark();
  if (datemark_ == &::google::protobuf::internal::kEmptyString) {
    datemark_ = new ::std::string;
  }
  datemark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* agencyinfo::mutable_datemark() {
  set_has_datemark();
  if (datemark_ == &::google::protobuf::internal::kEmptyString) {
    datemark_ = new ::std::string;
  }
  return datemark_;
}
inline ::std::string* agencyinfo::release_datemark() {
  clear_has_datemark();
  if (datemark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datemark_;
    datemark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void agencyinfo::set_allocated_datemark(::std::string* datemark) {
  if (datemark_ != &::google::protobuf::internal::kEmptyString) {
    delete datemark_;
  }
  if (datemark) {
    set_has_datemark();
    datemark_ = datemark;
  } else {
    clear_has_datemark();
    datemark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 moneymark = 12;
inline bool agencyinfo::has_moneymark() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void agencyinfo::set_has_moneymark() {
  _has_bits_[0] |= 0x00000800u;
}
inline void agencyinfo::clear_has_moneymark() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void agencyinfo::clear_moneymark() {
  moneymark_ = 0;
  clear_has_moneymark();
}
inline ::google::protobuf::int32 agencyinfo::moneymark() const {
  return moneymark_;
}
inline void agencyinfo::set_moneymark(::google::protobuf::int32 value) {
  set_has_moneymark();
  moneymark_ = value;
}

// optional int32 weekmoney = 13;
inline bool agencyinfo::has_weekmoney() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void agencyinfo::set_has_weekmoney() {
  _has_bits_[0] |= 0x00001000u;
}
inline void agencyinfo::clear_has_weekmoney() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void agencyinfo::clear_weekmoney() {
  weekmoney_ = 0;
  clear_has_weekmoney();
}
inline ::google::protobuf::int32 agencyinfo::weekmoney() const {
  return weekmoney_;
}
inline void agencyinfo::set_weekmoney(::google::protobuf::int32 value) {
  set_has_weekmoney();
  weekmoney_ = value;
}

// optional string exclusiveurl = 14;
inline bool agencyinfo::has_exclusiveurl() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void agencyinfo::set_has_exclusiveurl() {
  _has_bits_[0] |= 0x00002000u;
}
inline void agencyinfo::clear_has_exclusiveurl() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void agencyinfo::clear_exclusiveurl() {
  if (exclusiveurl_ != &::google::protobuf::internal::kEmptyString) {
    exclusiveurl_->clear();
  }
  clear_has_exclusiveurl();
}
inline const ::std::string& agencyinfo::exclusiveurl() const {
  return *exclusiveurl_;
}
inline void agencyinfo::set_exclusiveurl(const ::std::string& value) {
  set_has_exclusiveurl();
  if (exclusiveurl_ == &::google::protobuf::internal::kEmptyString) {
    exclusiveurl_ = new ::std::string;
  }
  exclusiveurl_->assign(value);
}
inline void agencyinfo::set_exclusiveurl(const char* value) {
  set_has_exclusiveurl();
  if (exclusiveurl_ == &::google::protobuf::internal::kEmptyString) {
    exclusiveurl_ = new ::std::string;
  }
  exclusiveurl_->assign(value);
}
inline void agencyinfo::set_exclusiveurl(const char* value, size_t size) {
  set_has_exclusiveurl();
  if (exclusiveurl_ == &::google::protobuf::internal::kEmptyString) {
    exclusiveurl_ = new ::std::string;
  }
  exclusiveurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* agencyinfo::mutable_exclusiveurl() {
  set_has_exclusiveurl();
  if (exclusiveurl_ == &::google::protobuf::internal::kEmptyString) {
    exclusiveurl_ = new ::std::string;
  }
  return exclusiveurl_;
}
inline ::std::string* agencyinfo::release_exclusiveurl() {
  clear_has_exclusiveurl();
  if (exclusiveurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exclusiveurl_;
    exclusiveurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void agencyinfo::set_allocated_exclusiveurl(::std::string* exclusiveurl) {
  if (exclusiveurl_ != &::google::protobuf::internal::kEmptyString) {
    delete exclusiveurl_;
  }
  if (exclusiveurl) {
    set_has_exclusiveurl();
    exclusiveurl_ = exclusiveurl;
  } else {
    clear_has_exclusiveurl();
    exclusiveurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alipay = 15;
inline bool agencyinfo::has_alipay() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void agencyinfo::set_has_alipay() {
  _has_bits_[0] |= 0x00004000u;
}
inline void agencyinfo::clear_has_alipay() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void agencyinfo::clear_alipay() {
  if (alipay_ != &::google::protobuf::internal::kEmptyString) {
    alipay_->clear();
  }
  clear_has_alipay();
}
inline const ::std::string& agencyinfo::alipay() const {
  return *alipay_;
}
inline void agencyinfo::set_alipay(const ::std::string& value) {
  set_has_alipay();
  if (alipay_ == &::google::protobuf::internal::kEmptyString) {
    alipay_ = new ::std::string;
  }
  alipay_->assign(value);
}
inline void agencyinfo::set_alipay(const char* value) {
  set_has_alipay();
  if (alipay_ == &::google::protobuf::internal::kEmptyString) {
    alipay_ = new ::std::string;
  }
  alipay_->assign(value);
}
inline void agencyinfo::set_alipay(const char* value, size_t size) {
  set_has_alipay();
  if (alipay_ == &::google::protobuf::internal::kEmptyString) {
    alipay_ = new ::std::string;
  }
  alipay_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* agencyinfo::mutable_alipay() {
  set_has_alipay();
  if (alipay_ == &::google::protobuf::internal::kEmptyString) {
    alipay_ = new ::std::string;
  }
  return alipay_;
}
inline ::std::string* agencyinfo::release_alipay() {
  clear_has_alipay();
  if (alipay_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alipay_;
    alipay_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void agencyinfo::set_allocated_alipay(::std::string* alipay) {
  if (alipay_ != &::google::protobuf::internal::kEmptyString) {
    delete alipay_;
  }
  if (alipay) {
    set_has_alipay();
    alipay_ = alipay;
  } else {
    clear_has_alipay();
    alipay_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bankaccount = 16;
inline bool agencyinfo::has_bankaccount() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void agencyinfo::set_has_bankaccount() {
  _has_bits_[0] |= 0x00008000u;
}
inline void agencyinfo::clear_has_bankaccount() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void agencyinfo::clear_bankaccount() {
  if (bankaccount_ != &::google::protobuf::internal::kEmptyString) {
    bankaccount_->clear();
  }
  clear_has_bankaccount();
}
inline const ::std::string& agencyinfo::bankaccount() const {
  return *bankaccount_;
}
inline void agencyinfo::set_bankaccount(const ::std::string& value) {
  set_has_bankaccount();
  if (bankaccount_ == &::google::protobuf::internal::kEmptyString) {
    bankaccount_ = new ::std::string;
  }
  bankaccount_->assign(value);
}
inline void agencyinfo::set_bankaccount(const char* value) {
  set_has_bankaccount();
  if (bankaccount_ == &::google::protobuf::internal::kEmptyString) {
    bankaccount_ = new ::std::string;
  }
  bankaccount_->assign(value);
}
inline void agencyinfo::set_bankaccount(const char* value, size_t size) {
  set_has_bankaccount();
  if (bankaccount_ == &::google::protobuf::internal::kEmptyString) {
    bankaccount_ = new ::std::string;
  }
  bankaccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* agencyinfo::mutable_bankaccount() {
  set_has_bankaccount();
  if (bankaccount_ == &::google::protobuf::internal::kEmptyString) {
    bankaccount_ = new ::std::string;
  }
  return bankaccount_;
}
inline ::std::string* agencyinfo::release_bankaccount() {
  clear_has_bankaccount();
  if (bankaccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bankaccount_;
    bankaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void agencyinfo::set_allocated_bankaccount(::std::string* bankaccount) {
  if (bankaccount_ != &::google::protobuf::internal::kEmptyString) {
    delete bankaccount_;
  }
  if (bankaccount) {
    set_has_bankaccount();
    bankaccount_ = bankaccount;
  } else {
    clear_has_bankaccount();
    bankaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 wiringid = 17;
inline bool agencyinfo::has_wiringid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void agencyinfo::set_has_wiringid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void agencyinfo::clear_has_wiringid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void agencyinfo::clear_wiringid() {
  wiringid_ = 0;
  clear_has_wiringid();
}
inline ::google::protobuf::int32 agencyinfo::wiringid() const {
  return wiringid_;
}
inline void agencyinfo::set_wiringid(::google::protobuf::int32 value) {
  set_has_wiringid();
  wiringid_ = value;
}

// optional int32 grade = 18;
inline bool agencyinfo::has_grade() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void agencyinfo::set_has_grade() {
  _has_bits_[0] |= 0x00020000u;
}
inline void agencyinfo::clear_has_grade() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void agencyinfo::clear_grade() {
  grade_ = 0;
  clear_has_grade();
}
inline ::google::protobuf::int32 agencyinfo::grade() const {
  return grade_;
}
inline void agencyinfo::set_grade(::google::protobuf::int32 value) {
  set_has_grade();
  grade_ = value;
}

// -------------------------------------------------------------------

// intlist

// repeated int32 ilist = 1;
inline int intlist::ilist_size() const {
  return ilist_.size();
}
inline void intlist::clear_ilist() {
  ilist_.Clear();
}
inline ::google::protobuf::int32 intlist::ilist(int index) const {
  return ilist_.Get(index);
}
inline void intlist::set_ilist(int index, ::google::protobuf::int32 value) {
  ilist_.Set(index, value);
}
inline void intlist::add_ilist(::google::protobuf::int32 value) {
  ilist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
intlist::ilist() const {
  return ilist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
intlist::mutable_ilist() {
  return &ilist_;
}

// -------------------------------------------------------------------

// stringlist

// repeated string slist = 1;
inline int stringlist::slist_size() const {
  return slist_.size();
}
inline void stringlist::clear_slist() {
  slist_.Clear();
}
inline const ::std::string& stringlist::slist(int index) const {
  return slist_.Get(index);
}
inline ::std::string* stringlist::mutable_slist(int index) {
  return slist_.Mutable(index);
}
inline void stringlist::set_slist(int index, const ::std::string& value) {
  slist_.Mutable(index)->assign(value);
}
inline void stringlist::set_slist(int index, const char* value) {
  slist_.Mutable(index)->assign(value);
}
inline void stringlist::set_slist(int index, const char* value, size_t size) {
  slist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* stringlist::add_slist() {
  return slist_.Add();
}
inline void stringlist::add_slist(const ::std::string& value) {
  slist_.Add()->assign(value);
}
inline void stringlist::add_slist(const char* value) {
  slist_.Add()->assign(value);
}
inline void stringlist::add_slist(const char* value, size_t size) {
  slist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
stringlist::slist() const {
  return slist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
stringlist::mutable_slist() {
  return &slist_;
}

// -------------------------------------------------------------------

// useraward

// optional int32 id = 1;
inline bool useraward::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void useraward::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void useraward::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void useraward::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 useraward::id() const {
  return id_;
}
inline void useraward::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 awardtype = 2;
inline bool useraward::has_awardtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void useraward::set_has_awardtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void useraward::clear_has_awardtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void useraward::clear_awardtype() {
  awardtype_ = 0;
  clear_has_awardtype();
}
inline ::google::protobuf::int32 useraward::awardtype() const {
  return awardtype_;
}
inline void useraward::set_awardtype(::google::protobuf::int32 value) {
  set_has_awardtype();
  awardtype_ = value;
}

// optional int32 count = 3;
inline bool useraward::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void useraward::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void useraward::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void useraward::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 useraward::count() const {
  return count_;
}
inline void useraward::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional int32 timemark = 4;
inline bool useraward::has_timemark() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void useraward::set_has_timemark() {
  _has_bits_[0] |= 0x00000008u;
}
inline void useraward::clear_has_timemark() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void useraward::clear_timemark() {
  timemark_ = 0;
  clear_has_timemark();
}
inline ::google::protobuf::int32 useraward::timemark() const {
  return timemark_;
}
inline void useraward::set_timemark(::google::protobuf::int32 value) {
  set_has_timemark();
  timemark_ = value;
}

// optional int32 state = 5;
inline bool useraward::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void useraward::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void useraward::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void useraward::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 useraward::state() const {
  return state_;
}
inline void useraward::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// banktransferrecord

// optional int32 userid = 1;
inline bool banktransferrecord::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void banktransferrecord::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void banktransferrecord::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void banktransferrecord::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 banktransferrecord::userid() const {
  return userid_;
}
inline void banktransferrecord::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional string nickname = 2;
inline bool banktransferrecord::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void banktransferrecord::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void banktransferrecord::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void banktransferrecord::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& banktransferrecord::nickname() const {
  return *nickname_;
}
inline void banktransferrecord::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void banktransferrecord::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void banktransferrecord::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* banktransferrecord::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* banktransferrecord::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void banktransferrecord::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string amount = 3;
inline bool banktransferrecord::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void banktransferrecord::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void banktransferrecord::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void banktransferrecord::clear_amount() {
  if (amount_ != &::google::protobuf::internal::kEmptyString) {
    amount_->clear();
  }
  clear_has_amount();
}
inline const ::std::string& banktransferrecord::amount() const {
  return *amount_;
}
inline void banktransferrecord::set_amount(const ::std::string& value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
}
inline void banktransferrecord::set_amount(const char* value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
}
inline void banktransferrecord::set_amount(const char* value, size_t size) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  amount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* banktransferrecord::mutable_amount() {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    amount_ = new ::std::string;
  }
  return amount_;
}
inline ::std::string* banktransferrecord::release_amount() {
  clear_has_amount();
  if (amount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = amount_;
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void banktransferrecord::set_allocated_amount(::std::string* amount) {
  if (amount_ != &::google::protobuf::internal::kEmptyString) {
    delete amount_;
  }
  if (amount) {
    set_has_amount();
    amount_ = amount;
  } else {
    clear_has_amount();
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string timemark = 4;
inline bool banktransferrecord::has_timemark() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void banktransferrecord::set_has_timemark() {
  _has_bits_[0] |= 0x00000008u;
}
inline void banktransferrecord::clear_has_timemark() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void banktransferrecord::clear_timemark() {
  if (timemark_ != &::google::protobuf::internal::kEmptyString) {
    timemark_->clear();
  }
  clear_has_timemark();
}
inline const ::std::string& banktransferrecord::timemark() const {
  return *timemark_;
}
inline void banktransferrecord::set_timemark(const ::std::string& value) {
  set_has_timemark();
  if (timemark_ == &::google::protobuf::internal::kEmptyString) {
    timemark_ = new ::std::string;
  }
  timemark_->assign(value);
}
inline void banktransferrecord::set_timemark(const char* value) {
  set_has_timemark();
  if (timemark_ == &::google::protobuf::internal::kEmptyString) {
    timemark_ = new ::std::string;
  }
  timemark_->assign(value);
}
inline void banktransferrecord::set_timemark(const char* value, size_t size) {
  set_has_timemark();
  if (timemark_ == &::google::protobuf::internal::kEmptyString) {
    timemark_ = new ::std::string;
  }
  timemark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* banktransferrecord::mutable_timemark() {
  set_has_timemark();
  if (timemark_ == &::google::protobuf::internal::kEmptyString) {
    timemark_ = new ::std::string;
  }
  return timemark_;
}
inline ::std::string* banktransferrecord::release_timemark() {
  clear_has_timemark();
  if (timemark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timemark_;
    timemark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void banktransferrecord::set_allocated_timemark(::std::string* timemark) {
  if (timemark_ != &::google::protobuf::internal::kEmptyString) {
    delete timemark_;
  }
  if (timemark) {
    set_has_timemark();
    timemark_ = timemark;
  } else {
    clear_has_timemark();
    timemark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// specialcardreward

// optional int32 index = 1;
inline bool specialcardreward::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void specialcardreward::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void specialcardreward::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void specialcardreward::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 specialcardreward::index() const {
  return index_;
}
inline void specialcardreward::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional int32 cardtype = 2;
inline bool specialcardreward::has_cardtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void specialcardreward::set_has_cardtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void specialcardreward::clear_has_cardtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void specialcardreward::clear_cardtype() {
  cardtype_ = 0;
  clear_has_cardtype();
}
inline ::google::protobuf::int32 specialcardreward::cardtype() const {
  return cardtype_;
}
inline void specialcardreward::set_cardtype(::google::protobuf::int32 value) {
  set_has_cardtype();
  cardtype_ = value;
}

// optional int32 reward = 3;
inline bool specialcardreward::has_reward() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void specialcardreward::set_has_reward() {
  _has_bits_[0] |= 0x00000004u;
}
inline void specialcardreward::clear_has_reward() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void specialcardreward::clear_reward() {
  reward_ = 0;
  clear_has_reward();
}
inline ::google::protobuf::int32 specialcardreward::reward() const {
  return reward_;
}
inline void specialcardreward::set_reward(::google::protobuf::int32 value) {
  set_has_reward();
  reward_ = value;
}

// optional int32 status = 4;
inline bool specialcardreward::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void specialcardreward::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void specialcardreward::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void specialcardreward::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 specialcardreward::status() const {
  return status_;
}
inline void specialcardreward::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string createdate = 5;
inline bool specialcardreward::has_createdate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void specialcardreward::set_has_createdate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void specialcardreward::clear_has_createdate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void specialcardreward::clear_createdate() {
  if (createdate_ != &::google::protobuf::internal::kEmptyString) {
    createdate_->clear();
  }
  clear_has_createdate();
}
inline const ::std::string& specialcardreward::createdate() const {
  return *createdate_;
}
inline void specialcardreward::set_createdate(const ::std::string& value) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(value);
}
inline void specialcardreward::set_createdate(const char* value) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(value);
}
inline void specialcardreward::set_createdate(const char* value, size_t size) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* specialcardreward::mutable_createdate() {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    createdate_ = new ::std::string;
  }
  return createdate_;
}
inline ::std::string* specialcardreward::release_createdate() {
  clear_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createdate_;
    createdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void specialcardreward::set_allocated_createdate(::std::string* createdate) {
  if (createdate_ != &::google::protobuf::internal::kEmptyString) {
    delete createdate_;
  }
  if (createdate) {
    set_has_createdate();
    createdate_ = createdate;
  } else {
    clear_has_createdate();
    createdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// specialinfo

// optional int32 userid = 1;
inline bool specialinfo::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void specialinfo::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void specialinfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void specialinfo::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 specialinfo::userid() const {
  return userid_;
}
inline void specialinfo::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional int32 starttime = 2;
inline bool specialinfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void specialinfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void specialinfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void specialinfo::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline ::google::protobuf::int32 specialinfo::starttime() const {
  return starttime_;
}
inline void specialinfo::set_starttime(::google::protobuf::int32 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional int32 endtime = 3;
inline bool specialinfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void specialinfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void specialinfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void specialinfo::clear_endtime() {
  endtime_ = 0;
  clear_has_endtime();
}
inline ::google::protobuf::int32 specialinfo::endtime() const {
  return endtime_;
}
inline void specialinfo::set_endtime(::google::protobuf::int32 value) {
  set_has_endtime();
  endtime_ = value;
}

// optional int32 state = 4;
inline bool specialinfo::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void specialinfo::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void specialinfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void specialinfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 specialinfo::state() const {
  return state_;
}
inline void specialinfo::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional int32 rate = 5;
inline bool specialinfo::has_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void specialinfo::set_has_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void specialinfo::clear_has_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void specialinfo::clear_rate() {
  rate_ = 0;
  clear_has_rate();
}
inline ::google::protobuf::int32 specialinfo::rate() const {
  return rate_;
}
inline void specialinfo::set_rate(::google::protobuf::int32 value) {
  set_has_rate();
  rate_ = value;
}

// optional int32 winall = 6;
inline bool specialinfo::has_winall() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void specialinfo::set_has_winall() {
  _has_bits_[0] |= 0x00000020u;
}
inline void specialinfo::clear_has_winall() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void specialinfo::clear_winall() {
  winall_ = 0;
  clear_has_winall();
}
inline ::google::protobuf::int32 specialinfo::winall() const {
  return winall_;
}
inline void specialinfo::set_winall(::google::protobuf::int32 value) {
  set_has_winall();
  winall_ = value;
}

// optional int32 peinum = 7;
inline bool specialinfo::has_peinum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void specialinfo::set_has_peinum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void specialinfo::clear_has_peinum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void specialinfo::clear_peinum() {
  peinum_ = 0;
  clear_has_peinum();
}
inline ::google::protobuf::int32 specialinfo::peinum() const {
  return peinum_;
}
inline void specialinfo::set_peinum(::google::protobuf::int32 value) {
  set_has_peinum();
  peinum_ = value;
}

// optional int32 marknum = 8;
inline bool specialinfo::has_marknum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void specialinfo::set_has_marknum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void specialinfo::clear_has_marknum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void specialinfo::clear_marknum() {
  marknum_ = 0;
  clear_has_marknum();
}
inline ::google::protobuf::int32 specialinfo::marknum() const {
  return marknum_;
}
inline void specialinfo::set_marknum(::google::protobuf::int32 value) {
  set_has_marknum();
  marknum_ = value;
}

// repeated int32 gametype = 9;
inline int specialinfo::gametype_size() const {
  return gametype_.size();
}
inline void specialinfo::clear_gametype() {
  gametype_.Clear();
}
inline ::google::protobuf::int32 specialinfo::gametype(int index) const {
  return gametype_.Get(index);
}
inline void specialinfo::set_gametype(int index, ::google::protobuf::int32 value) {
  gametype_.Set(index, value);
}
inline void specialinfo::add_gametype(::google::protobuf::int32 value) {
  gametype_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
specialinfo::gametype() const {
  return gametype_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
specialinfo::mutable_gametype() {
  return &gametype_;
}

// optional int32 cardtype = 10;
inline bool specialinfo::has_cardtype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void specialinfo::set_has_cardtype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void specialinfo::clear_has_cardtype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void specialinfo::clear_cardtype() {
  cardtype_ = 0;
  clear_has_cardtype();
}
inline ::google::protobuf::int32 specialinfo::cardtype() const {
  return cardtype_;
}
inline void specialinfo::set_cardtype(::google::protobuf::int32 value) {
  set_has_cardtype();
  cardtype_ = value;
}

// optional int32 iszhuang = 11;
inline bool specialinfo::has_iszhuang() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void specialinfo::set_has_iszhuang() {
  _has_bits_[0] |= 0x00000400u;
}
inline void specialinfo::clear_has_iszhuang() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void specialinfo::clear_iszhuang() {
  iszhuang_ = 0;
  clear_has_iszhuang();
}
inline ::google::protobuf::int32 specialinfo::iszhuang() const {
  return iszhuang_;
}
inline void specialinfo::set_iszhuang(::google::protobuf::int32 value) {
  set_has_iszhuang();
  iszhuang_ = value;
}

// optional int32 norecord = 12;
inline bool specialinfo::has_norecord() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void specialinfo::set_has_norecord() {
  _has_bits_[0] |= 0x00000800u;
}
inline void specialinfo::clear_has_norecord() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void specialinfo::clear_norecord() {
  norecord_ = 0;
  clear_has_norecord();
}
inline ::google::protobuf::int32 specialinfo::norecord() const {
  return norecord_;
}
inline void specialinfo::set_norecord(::google::protobuf::int32 value) {
  set_has_norecord();
  norecord_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace progame

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_st_5fhuman_2eproto__INCLUDED
