// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: st_lhdb.proto

#ifndef PROTOBUF_st_5flhdb_2eproto__INCLUDED
#define PROTOBUF_st_5flhdb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "st_human.pb.h"
// @@protoc_insertion_point(includes)

namespace progame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_st_5flhdb_2eproto();
void protobuf_AssignDesc_st_5flhdb_2eproto();
void protobuf_ShutdownFile_st_5flhdb_2eproto();

class lhdbinfo;
class lhdbpoint;
class lhdbgemcolumn;
class lhdbscoreitem;
class lhdbscorelist;
class lhdbpriavedata;

// ===================================================================

class lhdbinfo : public ::google::protobuf::Message {
 public:
  lhdbinfo();
  virtual ~lhdbinfo();

  lhdbinfo(const lhdbinfo& from);

  inline lhdbinfo& operator=(const lhdbinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lhdbinfo& default_instance();

  void Swap(lhdbinfo* other);

  // implements Message ----------------------------------------------

  lhdbinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lhdbinfo& from);
  void MergeFrom(const lhdbinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 tableid = 1;
  inline bool has_tableid() const;
  inline void clear_tableid();
  static const int kTableidFieldNumber = 1;
  inline ::google::protobuf::int32 tableid() const;
  inline void set_tableid(::google::protobuf::int32 value);

  // optional int32 tabletype = 2;
  inline bool has_tabletype() const;
  inline void clear_tabletype();
  static const int kTabletypeFieldNumber = 2;
  inline ::google::protobuf::int32 tabletype() const;
  inline void set_tabletype(::google::protobuf::int32 value);

  // optional int32 state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 timemark = 4;
  inline bool has_timemark() const;
  inline void clear_timemark();
  static const int kTimemarkFieldNumber = 4;
  inline ::google::protobuf::int32 timemark() const;
  inline void set_timemark(::google::protobuf::int32 value);

  // repeated int32 useridlist = 5;
  inline int useridlist_size() const;
  inline void clear_useridlist();
  static const int kUseridlistFieldNumber = 5;
  inline ::google::protobuf::int32 useridlist(int index) const;
  inline void set_useridlist(int index, ::google::protobuf::int32 value);
  inline void add_useridlist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      useridlist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_useridlist();

  // optional string minjetton = 6;
  inline bool has_minjetton() const;
  inline void clear_minjetton();
  static const int kMinjettonFieldNumber = 6;
  inline const ::std::string& minjetton() const;
  inline void set_minjetton(const ::std::string& value);
  inline void set_minjetton(const char* value);
  inline void set_minjetton(const char* value, size_t size);
  inline ::std::string* mutable_minjetton();
  inline ::std::string* release_minjetton();
  inline void set_allocated_minjetton(::std::string* minjetton);

  // optional int32 bankerid = 8;
  inline bool has_bankerid() const;
  inline void clear_bankerid();
  static const int kBankeridFieldNumber = 8;
  inline ::google::protobuf::int32 bankerid() const;
  inline void set_bankerid(::google::protobuf::int32 value);

  // optional string bankerjetton = 9;
  inline bool has_bankerjetton() const;
  inline void clear_bankerjetton();
  static const int kBankerjettonFieldNumber = 9;
  inline const ::std::string& bankerjetton() const;
  inline void set_bankerjetton(const ::std::string& value);
  inline void set_bankerjetton(const char* value);
  inline void set_bankerjetton(const char* value, size_t size);
  inline ::std::string* mutable_bankerjetton();
  inline ::std::string* release_bankerjetton();
  inline void set_allocated_bankerjetton(::std::string* bankerjetton);

  // optional string bankername = 10;
  inline bool has_bankername() const;
  inline void clear_bankername();
  static const int kBankernameFieldNumber = 10;
  inline const ::std::string& bankername() const;
  inline void set_bankername(const ::std::string& value);
  inline void set_bankername(const char* value);
  inline void set_bankername(const char* value, size_t size);
  inline ::std::string* mutable_bankername();
  inline ::std::string* release_bankername();
  inline void set_allocated_bankername(::std::string* bankername);

  // optional string bankerfaceid = 11;
  inline bool has_bankerfaceid() const;
  inline void clear_bankerfaceid();
  static const int kBankerfaceidFieldNumber = 11;
  inline const ::std::string& bankerfaceid() const;
  inline void set_bankerfaceid(const ::std::string& value);
  inline void set_bankerfaceid(const char* value);
  inline void set_bankerfaceid(const char* value, size_t size);
  inline ::std::string* mutable_bankerfaceid();
  inline ::std::string* release_bankerfaceid();
  inline void set_allocated_bankerfaceid(::std::string* bankerfaceid);

  // optional string bankerlimit = 12;
  inline bool has_bankerlimit() const;
  inline void clear_bankerlimit();
  static const int kBankerlimitFieldNumber = 12;
  inline const ::std::string& bankerlimit() const;
  inline void set_bankerlimit(const ::std::string& value);
  inline void set_bankerlimit(const char* value);
  inline void set_bankerlimit(const char* value, size_t size);
  inline ::std::string* mutable_bankerlimit();
  inline ::std::string* release_bankerlimit();
  inline void set_allocated_bankerlimit(::std::string* bankerlimit);

  // optional int32 dropbanker = 13;
  inline bool has_dropbanker() const;
  inline void clear_dropbanker();
  static const int kDropbankerFieldNumber = 13;
  inline ::google::protobuf::int32 dropbanker() const;
  inline void set_dropbanker(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.lhdbinfo)
 private:
  inline void set_has_tableid();
  inline void clear_has_tableid();
  inline void set_has_tabletype();
  inline void clear_has_tabletype();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_timemark();
  inline void clear_has_timemark();
  inline void set_has_minjetton();
  inline void clear_has_minjetton();
  inline void set_has_bankerid();
  inline void clear_has_bankerid();
  inline void set_has_bankerjetton();
  inline void clear_has_bankerjetton();
  inline void set_has_bankername();
  inline void clear_has_bankername();
  inline void set_has_bankerfaceid();
  inline void clear_has_bankerfaceid();
  inline void set_has_bankerlimit();
  inline void clear_has_bankerlimit();
  inline void set_has_dropbanker();
  inline void clear_has_dropbanker();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tableid_;
  ::google::protobuf::int32 tabletype_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 timemark_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > useridlist_;
  ::std::string* minjetton_;
  ::std::string* bankerjetton_;
  ::std::string* bankername_;
  ::google::protobuf::int32 bankerid_;
  ::google::protobuf::int32 dropbanker_;
  ::std::string* bankerfaceid_;
  ::std::string* bankerlimit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flhdb_2eproto();
  friend void protobuf_AssignDesc_st_5flhdb_2eproto();
  friend void protobuf_ShutdownFile_st_5flhdb_2eproto();

  void InitAsDefaultInstance();
  static lhdbinfo* default_instance_;
};
// -------------------------------------------------------------------

class lhdbpoint : public ::google::protobuf::Message {
 public:
  lhdbpoint();
  virtual ~lhdbpoint();

  lhdbpoint(const lhdbpoint& from);

  inline lhdbpoint& operator=(const lhdbpoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lhdbpoint& default_instance();

  void Swap(lhdbpoint* other);

  // implements Message ----------------------------------------------

  lhdbpoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lhdbpoint& from);
  void MergeFrom(const lhdbpoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.lhdbpoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flhdb_2eproto();
  friend void protobuf_AssignDesc_st_5flhdb_2eproto();
  friend void protobuf_ShutdownFile_st_5flhdb_2eproto();

  void InitAsDefaultInstance();
  static lhdbpoint* default_instance_;
};
// -------------------------------------------------------------------

class lhdbgemcolumn : public ::google::protobuf::Message {
 public:
  lhdbgemcolumn();
  virtual ~lhdbgemcolumn();

  lhdbgemcolumn(const lhdbgemcolumn& from);

  inline lhdbgemcolumn& operator=(const lhdbgemcolumn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lhdbgemcolumn& default_instance();

  void Swap(lhdbgemcolumn* other);

  // implements Message ----------------------------------------------

  lhdbgemcolumn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lhdbgemcolumn& from);
  void MergeFrom(const lhdbgemcolumn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline ::google::protobuf::int32 list(int index) const;
  inline void set_list(int index, ::google::protobuf::int32 value);
  inline void add_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:progame.lhdbgemcolumn)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flhdb_2eproto();
  friend void protobuf_AssignDesc_st_5flhdb_2eproto();
  friend void protobuf_ShutdownFile_st_5flhdb_2eproto();

  void InitAsDefaultInstance();
  static lhdbgemcolumn* default_instance_;
};
// -------------------------------------------------------------------

class lhdbscoreitem : public ::google::protobuf::Message {
 public:
  lhdbscoreitem();
  virtual ~lhdbscoreitem();

  lhdbscoreitem(const lhdbscoreitem& from);

  inline lhdbscoreitem& operator=(const lhdbscoreitem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lhdbscoreitem& default_instance();

  void Swap(lhdbscoreitem* other);

  // implements Message ----------------------------------------------

  lhdbscoreitem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lhdbscoreitem& from);
  void MergeFrom(const lhdbscoreitem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 gem = 1;
  inline bool has_gem() const;
  inline void clear_gem();
  static const int kGemFieldNumber = 1;
  inline ::google::protobuf::int32 gem() const;
  inline void set_gem(::google::protobuf::int32 value);

  // repeated string scorelist = 2;
  inline int scorelist_size() const;
  inline void clear_scorelist();
  static const int kScorelistFieldNumber = 2;
  inline const ::std::string& scorelist(int index) const;
  inline ::std::string* mutable_scorelist(int index);
  inline void set_scorelist(int index, const ::std::string& value);
  inline void set_scorelist(int index, const char* value);
  inline void set_scorelist(int index, const char* value, size_t size);
  inline ::std::string* add_scorelist();
  inline void add_scorelist(const ::std::string& value);
  inline void add_scorelist(const char* value);
  inline void add_scorelist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& scorelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_scorelist();

  // repeated .progame.lhdbpoint pointlist = 3;
  inline int pointlist_size() const;
  inline void clear_pointlist();
  static const int kPointlistFieldNumber = 3;
  inline const ::progame::lhdbpoint& pointlist(int index) const;
  inline ::progame::lhdbpoint* mutable_pointlist(int index);
  inline ::progame::lhdbpoint* add_pointlist();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::lhdbpoint >&
      pointlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::lhdbpoint >*
      mutable_pointlist();

  // @@protoc_insertion_point(class_scope:progame.lhdbscoreitem)
 private:
  inline void set_has_gem();
  inline void clear_has_gem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> scorelist_;
  ::google::protobuf::RepeatedPtrField< ::progame::lhdbpoint > pointlist_;
  ::google::protobuf::int32 gem_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flhdb_2eproto();
  friend void protobuf_AssignDesc_st_5flhdb_2eproto();
  friend void protobuf_ShutdownFile_st_5flhdb_2eproto();

  void InitAsDefaultInstance();
  static lhdbscoreitem* default_instance_;
};
// -------------------------------------------------------------------

class lhdbscorelist : public ::google::protobuf::Message {
 public:
  lhdbscorelist();
  virtual ~lhdbscorelist();

  lhdbscorelist(const lhdbscorelist& from);

  inline lhdbscorelist& operator=(const lhdbscorelist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lhdbscorelist& default_instance();

  void Swap(lhdbscorelist* other);

  // implements Message ----------------------------------------------

  lhdbscorelist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lhdbscorelist& from);
  void MergeFrom(const lhdbscorelist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .progame.lhdbscoreitem list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::progame::lhdbscoreitem& list(int index) const;
  inline ::progame::lhdbscoreitem* mutable_list(int index);
  inline ::progame::lhdbscoreitem* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::lhdbscoreitem >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::lhdbscoreitem >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:progame.lhdbscorelist)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::progame::lhdbscoreitem > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flhdb_2eproto();
  friend void protobuf_AssignDesc_st_5flhdb_2eproto();
  friend void protobuf_ShutdownFile_st_5flhdb_2eproto();

  void InitAsDefaultInstance();
  static lhdbscorelist* default_instance_;
};
// -------------------------------------------------------------------

class lhdbpriavedata : public ::google::protobuf::Message {
 public:
  lhdbpriavedata();
  virtual ~lhdbpriavedata();

  lhdbpriavedata(const lhdbpriavedata& from);

  inline lhdbpriavedata& operator=(const lhdbpriavedata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lhdbpriavedata& default_instance();

  void Swap(lhdbpriavedata* other);

  // implements Message ----------------------------------------------

  lhdbpriavedata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lhdbpriavedata& from);
  void MergeFrom(const lhdbpriavedata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string totalscore = 1;
  inline bool has_totalscore() const;
  inline void clear_totalscore();
  static const int kTotalscoreFieldNumber = 1;
  inline const ::std::string& totalscore() const;
  inline void set_totalscore(const ::std::string& value);
  inline void set_totalscore(const char* value);
  inline void set_totalscore(const char* value, size_t size);
  inline ::std::string* mutable_totalscore();
  inline ::std::string* release_totalscore();
  inline void set_allocated_totalscore(::std::string* totalscore);

  // optional int32 round = 2;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 2;
  inline ::google::protobuf::int32 round() const;
  inline void set_round(::google::protobuf::int32 value);

  // optional int32 boardlength = 3;
  inline bool has_boardlength() const;
  inline void clear_boardlength();
  static const int kBoardlengthFieldNumber = 3;
  inline ::google::protobuf::int32 boardlength() const;
  inline void set_boardlength(::google::protobuf::int32 value);

  // repeated .progame.lhdbgemcolumn gemmap = 4;
  inline int gemmap_size() const;
  inline void clear_gemmap();
  static const int kGemmapFieldNumber = 4;
  inline const ::progame::lhdbgemcolumn& gemmap(int index) const;
  inline ::progame::lhdbgemcolumn* mutable_gemmap(int index);
  inline ::progame::lhdbgemcolumn* add_gemmap();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::lhdbgemcolumn >&
      gemmap() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::lhdbgemcolumn >*
      mutable_gemmap();

  // repeated .progame.lhdbgemcolumn reservegemmap = 5;
  inline int reservegemmap_size() const;
  inline void clear_reservegemmap();
  static const int kReservegemmapFieldNumber = 5;
  inline const ::progame::lhdbgemcolumn& reservegemmap(int index) const;
  inline ::progame::lhdbgemcolumn* mutable_reservegemmap(int index);
  inline ::progame::lhdbgemcolumn* add_reservegemmap();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::lhdbgemcolumn >&
      reservegemmap() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::lhdbgemcolumn >*
      mutable_reservegemmap();

  // repeated string pourjettonlist = 6;
  inline int pourjettonlist_size() const;
  inline void clear_pourjettonlist();
  static const int kPourjettonlistFieldNumber = 6;
  inline const ::std::string& pourjettonlist(int index) const;
  inline ::std::string* mutable_pourjettonlist(int index);
  inline void set_pourjettonlist(int index, const ::std::string& value);
  inline void set_pourjettonlist(int index, const char* value);
  inline void set_pourjettonlist(int index, const char* value, size_t size);
  inline ::std::string* add_pourjettonlist();
  inline void add_pourjettonlist(const ::std::string& value);
  inline void add_pourjettonlist(const char* value);
  inline void add_pourjettonlist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pourjettonlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pourjettonlist();

  // optional int64 timemark = 7;
  inline bool has_timemark() const;
  inline void clear_timemark();
  static const int kTimemarkFieldNumber = 7;
  inline ::google::protobuf::int64 timemark() const;
  inline void set_timemark(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:progame.lhdbpriavedata)
 private:
  inline void set_has_totalscore();
  inline void clear_has_totalscore();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_boardlength();
  inline void clear_has_boardlength();
  inline void set_has_timemark();
  inline void clear_has_timemark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* totalscore_;
  ::google::protobuf::int32 round_;
  ::google::protobuf::int32 boardlength_;
  ::google::protobuf::RepeatedPtrField< ::progame::lhdbgemcolumn > gemmap_;
  ::google::protobuf::RepeatedPtrField< ::progame::lhdbgemcolumn > reservegemmap_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pourjettonlist_;
  ::google::protobuf::int64 timemark_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flhdb_2eproto();
  friend void protobuf_AssignDesc_st_5flhdb_2eproto();
  friend void protobuf_ShutdownFile_st_5flhdb_2eproto();

  void InitAsDefaultInstance();
  static lhdbpriavedata* default_instance_;
};
// ===================================================================


// ===================================================================

// lhdbinfo

// optional int32 tableid = 1;
inline bool lhdbinfo::has_tableid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lhdbinfo::set_has_tableid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lhdbinfo::clear_has_tableid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lhdbinfo::clear_tableid() {
  tableid_ = 0;
  clear_has_tableid();
}
inline ::google::protobuf::int32 lhdbinfo::tableid() const {
  return tableid_;
}
inline void lhdbinfo::set_tableid(::google::protobuf::int32 value) {
  set_has_tableid();
  tableid_ = value;
}

// optional int32 tabletype = 2;
inline bool lhdbinfo::has_tabletype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lhdbinfo::set_has_tabletype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lhdbinfo::clear_has_tabletype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lhdbinfo::clear_tabletype() {
  tabletype_ = 0;
  clear_has_tabletype();
}
inline ::google::protobuf::int32 lhdbinfo::tabletype() const {
  return tabletype_;
}
inline void lhdbinfo::set_tabletype(::google::protobuf::int32 value) {
  set_has_tabletype();
  tabletype_ = value;
}

// optional int32 state = 3;
inline bool lhdbinfo::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lhdbinfo::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lhdbinfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lhdbinfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 lhdbinfo::state() const {
  return state_;
}
inline void lhdbinfo::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional int32 timemark = 4;
inline bool lhdbinfo::has_timemark() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lhdbinfo::set_has_timemark() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lhdbinfo::clear_has_timemark() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lhdbinfo::clear_timemark() {
  timemark_ = 0;
  clear_has_timemark();
}
inline ::google::protobuf::int32 lhdbinfo::timemark() const {
  return timemark_;
}
inline void lhdbinfo::set_timemark(::google::protobuf::int32 value) {
  set_has_timemark();
  timemark_ = value;
}

// repeated int32 useridlist = 5;
inline int lhdbinfo::useridlist_size() const {
  return useridlist_.size();
}
inline void lhdbinfo::clear_useridlist() {
  useridlist_.Clear();
}
inline ::google::protobuf::int32 lhdbinfo::useridlist(int index) const {
  return useridlist_.Get(index);
}
inline void lhdbinfo::set_useridlist(int index, ::google::protobuf::int32 value) {
  useridlist_.Set(index, value);
}
inline void lhdbinfo::add_useridlist(::google::protobuf::int32 value) {
  useridlist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
lhdbinfo::useridlist() const {
  return useridlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
lhdbinfo::mutable_useridlist() {
  return &useridlist_;
}

// optional string minjetton = 6;
inline bool lhdbinfo::has_minjetton() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void lhdbinfo::set_has_minjetton() {
  _has_bits_[0] |= 0x00000020u;
}
inline void lhdbinfo::clear_has_minjetton() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void lhdbinfo::clear_minjetton() {
  if (minjetton_ != &::google::protobuf::internal::kEmptyString) {
    minjetton_->clear();
  }
  clear_has_minjetton();
}
inline const ::std::string& lhdbinfo::minjetton() const {
  return *minjetton_;
}
inline void lhdbinfo::set_minjetton(const ::std::string& value) {
  set_has_minjetton();
  if (minjetton_ == &::google::protobuf::internal::kEmptyString) {
    minjetton_ = new ::std::string;
  }
  minjetton_->assign(value);
}
inline void lhdbinfo::set_minjetton(const char* value) {
  set_has_minjetton();
  if (minjetton_ == &::google::protobuf::internal::kEmptyString) {
    minjetton_ = new ::std::string;
  }
  minjetton_->assign(value);
}
inline void lhdbinfo::set_minjetton(const char* value, size_t size) {
  set_has_minjetton();
  if (minjetton_ == &::google::protobuf::internal::kEmptyString) {
    minjetton_ = new ::std::string;
  }
  minjetton_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lhdbinfo::mutable_minjetton() {
  set_has_minjetton();
  if (minjetton_ == &::google::protobuf::internal::kEmptyString) {
    minjetton_ = new ::std::string;
  }
  return minjetton_;
}
inline ::std::string* lhdbinfo::release_minjetton() {
  clear_has_minjetton();
  if (minjetton_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = minjetton_;
    minjetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lhdbinfo::set_allocated_minjetton(::std::string* minjetton) {
  if (minjetton_ != &::google::protobuf::internal::kEmptyString) {
    delete minjetton_;
  }
  if (minjetton) {
    set_has_minjetton();
    minjetton_ = minjetton;
  } else {
    clear_has_minjetton();
    minjetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 bankerid = 8;
inline bool lhdbinfo::has_bankerid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void lhdbinfo::set_has_bankerid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void lhdbinfo::clear_has_bankerid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void lhdbinfo::clear_bankerid() {
  bankerid_ = 0;
  clear_has_bankerid();
}
inline ::google::protobuf::int32 lhdbinfo::bankerid() const {
  return bankerid_;
}
inline void lhdbinfo::set_bankerid(::google::protobuf::int32 value) {
  set_has_bankerid();
  bankerid_ = value;
}

// optional string bankerjetton = 9;
inline bool lhdbinfo::has_bankerjetton() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void lhdbinfo::set_has_bankerjetton() {
  _has_bits_[0] |= 0x00000080u;
}
inline void lhdbinfo::clear_has_bankerjetton() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void lhdbinfo::clear_bankerjetton() {
  if (bankerjetton_ != &::google::protobuf::internal::kEmptyString) {
    bankerjetton_->clear();
  }
  clear_has_bankerjetton();
}
inline const ::std::string& lhdbinfo::bankerjetton() const {
  return *bankerjetton_;
}
inline void lhdbinfo::set_bankerjetton(const ::std::string& value) {
  set_has_bankerjetton();
  if (bankerjetton_ == &::google::protobuf::internal::kEmptyString) {
    bankerjetton_ = new ::std::string;
  }
  bankerjetton_->assign(value);
}
inline void lhdbinfo::set_bankerjetton(const char* value) {
  set_has_bankerjetton();
  if (bankerjetton_ == &::google::protobuf::internal::kEmptyString) {
    bankerjetton_ = new ::std::string;
  }
  bankerjetton_->assign(value);
}
inline void lhdbinfo::set_bankerjetton(const char* value, size_t size) {
  set_has_bankerjetton();
  if (bankerjetton_ == &::google::protobuf::internal::kEmptyString) {
    bankerjetton_ = new ::std::string;
  }
  bankerjetton_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lhdbinfo::mutable_bankerjetton() {
  set_has_bankerjetton();
  if (bankerjetton_ == &::google::protobuf::internal::kEmptyString) {
    bankerjetton_ = new ::std::string;
  }
  return bankerjetton_;
}
inline ::std::string* lhdbinfo::release_bankerjetton() {
  clear_has_bankerjetton();
  if (bankerjetton_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bankerjetton_;
    bankerjetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lhdbinfo::set_allocated_bankerjetton(::std::string* bankerjetton) {
  if (bankerjetton_ != &::google::protobuf::internal::kEmptyString) {
    delete bankerjetton_;
  }
  if (bankerjetton) {
    set_has_bankerjetton();
    bankerjetton_ = bankerjetton;
  } else {
    clear_has_bankerjetton();
    bankerjetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bankername = 10;
inline bool lhdbinfo::has_bankername() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void lhdbinfo::set_has_bankername() {
  _has_bits_[0] |= 0x00000100u;
}
inline void lhdbinfo::clear_has_bankername() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void lhdbinfo::clear_bankername() {
  if (bankername_ != &::google::protobuf::internal::kEmptyString) {
    bankername_->clear();
  }
  clear_has_bankername();
}
inline const ::std::string& lhdbinfo::bankername() const {
  return *bankername_;
}
inline void lhdbinfo::set_bankername(const ::std::string& value) {
  set_has_bankername();
  if (bankername_ == &::google::protobuf::internal::kEmptyString) {
    bankername_ = new ::std::string;
  }
  bankername_->assign(value);
}
inline void lhdbinfo::set_bankername(const char* value) {
  set_has_bankername();
  if (bankername_ == &::google::protobuf::internal::kEmptyString) {
    bankername_ = new ::std::string;
  }
  bankername_->assign(value);
}
inline void lhdbinfo::set_bankername(const char* value, size_t size) {
  set_has_bankername();
  if (bankername_ == &::google::protobuf::internal::kEmptyString) {
    bankername_ = new ::std::string;
  }
  bankername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lhdbinfo::mutable_bankername() {
  set_has_bankername();
  if (bankername_ == &::google::protobuf::internal::kEmptyString) {
    bankername_ = new ::std::string;
  }
  return bankername_;
}
inline ::std::string* lhdbinfo::release_bankername() {
  clear_has_bankername();
  if (bankername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bankername_;
    bankername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lhdbinfo::set_allocated_bankername(::std::string* bankername) {
  if (bankername_ != &::google::protobuf::internal::kEmptyString) {
    delete bankername_;
  }
  if (bankername) {
    set_has_bankername();
    bankername_ = bankername;
  } else {
    clear_has_bankername();
    bankername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bankerfaceid = 11;
inline bool lhdbinfo::has_bankerfaceid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void lhdbinfo::set_has_bankerfaceid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void lhdbinfo::clear_has_bankerfaceid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void lhdbinfo::clear_bankerfaceid() {
  if (bankerfaceid_ != &::google::protobuf::internal::kEmptyString) {
    bankerfaceid_->clear();
  }
  clear_has_bankerfaceid();
}
inline const ::std::string& lhdbinfo::bankerfaceid() const {
  return *bankerfaceid_;
}
inline void lhdbinfo::set_bankerfaceid(const ::std::string& value) {
  set_has_bankerfaceid();
  if (bankerfaceid_ == &::google::protobuf::internal::kEmptyString) {
    bankerfaceid_ = new ::std::string;
  }
  bankerfaceid_->assign(value);
}
inline void lhdbinfo::set_bankerfaceid(const char* value) {
  set_has_bankerfaceid();
  if (bankerfaceid_ == &::google::protobuf::internal::kEmptyString) {
    bankerfaceid_ = new ::std::string;
  }
  bankerfaceid_->assign(value);
}
inline void lhdbinfo::set_bankerfaceid(const char* value, size_t size) {
  set_has_bankerfaceid();
  if (bankerfaceid_ == &::google::protobuf::internal::kEmptyString) {
    bankerfaceid_ = new ::std::string;
  }
  bankerfaceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lhdbinfo::mutable_bankerfaceid() {
  set_has_bankerfaceid();
  if (bankerfaceid_ == &::google::protobuf::internal::kEmptyString) {
    bankerfaceid_ = new ::std::string;
  }
  return bankerfaceid_;
}
inline ::std::string* lhdbinfo::release_bankerfaceid() {
  clear_has_bankerfaceid();
  if (bankerfaceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bankerfaceid_;
    bankerfaceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lhdbinfo::set_allocated_bankerfaceid(::std::string* bankerfaceid) {
  if (bankerfaceid_ != &::google::protobuf::internal::kEmptyString) {
    delete bankerfaceid_;
  }
  if (bankerfaceid) {
    set_has_bankerfaceid();
    bankerfaceid_ = bankerfaceid;
  } else {
    clear_has_bankerfaceid();
    bankerfaceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bankerlimit = 12;
inline bool lhdbinfo::has_bankerlimit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void lhdbinfo::set_has_bankerlimit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void lhdbinfo::clear_has_bankerlimit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void lhdbinfo::clear_bankerlimit() {
  if (bankerlimit_ != &::google::protobuf::internal::kEmptyString) {
    bankerlimit_->clear();
  }
  clear_has_bankerlimit();
}
inline const ::std::string& lhdbinfo::bankerlimit() const {
  return *bankerlimit_;
}
inline void lhdbinfo::set_bankerlimit(const ::std::string& value) {
  set_has_bankerlimit();
  if (bankerlimit_ == &::google::protobuf::internal::kEmptyString) {
    bankerlimit_ = new ::std::string;
  }
  bankerlimit_->assign(value);
}
inline void lhdbinfo::set_bankerlimit(const char* value) {
  set_has_bankerlimit();
  if (bankerlimit_ == &::google::protobuf::internal::kEmptyString) {
    bankerlimit_ = new ::std::string;
  }
  bankerlimit_->assign(value);
}
inline void lhdbinfo::set_bankerlimit(const char* value, size_t size) {
  set_has_bankerlimit();
  if (bankerlimit_ == &::google::protobuf::internal::kEmptyString) {
    bankerlimit_ = new ::std::string;
  }
  bankerlimit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lhdbinfo::mutable_bankerlimit() {
  set_has_bankerlimit();
  if (bankerlimit_ == &::google::protobuf::internal::kEmptyString) {
    bankerlimit_ = new ::std::string;
  }
  return bankerlimit_;
}
inline ::std::string* lhdbinfo::release_bankerlimit() {
  clear_has_bankerlimit();
  if (bankerlimit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bankerlimit_;
    bankerlimit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lhdbinfo::set_allocated_bankerlimit(::std::string* bankerlimit) {
  if (bankerlimit_ != &::google::protobuf::internal::kEmptyString) {
    delete bankerlimit_;
  }
  if (bankerlimit) {
    set_has_bankerlimit();
    bankerlimit_ = bankerlimit;
  } else {
    clear_has_bankerlimit();
    bankerlimit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dropbanker = 13;
inline bool lhdbinfo::has_dropbanker() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void lhdbinfo::set_has_dropbanker() {
  _has_bits_[0] |= 0x00000800u;
}
inline void lhdbinfo::clear_has_dropbanker() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void lhdbinfo::clear_dropbanker() {
  dropbanker_ = 0;
  clear_has_dropbanker();
}
inline ::google::protobuf::int32 lhdbinfo::dropbanker() const {
  return dropbanker_;
}
inline void lhdbinfo::set_dropbanker(::google::protobuf::int32 value) {
  set_has_dropbanker();
  dropbanker_ = value;
}

// -------------------------------------------------------------------

// lhdbpoint

// optional int32 x = 1;
inline bool lhdbpoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lhdbpoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lhdbpoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lhdbpoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 lhdbpoint::x() const {
  return x_;
}
inline void lhdbpoint::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 2;
inline bool lhdbpoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lhdbpoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lhdbpoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lhdbpoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 lhdbpoint::y() const {
  return y_;
}
inline void lhdbpoint::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// lhdbgemcolumn

// repeated int32 list = 1;
inline int lhdbgemcolumn::list_size() const {
  return list_.size();
}
inline void lhdbgemcolumn::clear_list() {
  list_.Clear();
}
inline ::google::protobuf::int32 lhdbgemcolumn::list(int index) const {
  return list_.Get(index);
}
inline void lhdbgemcolumn::set_list(int index, ::google::protobuf::int32 value) {
  list_.Set(index, value);
}
inline void lhdbgemcolumn::add_list(::google::protobuf::int32 value) {
  list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
lhdbgemcolumn::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
lhdbgemcolumn::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// lhdbscoreitem

// optional int32 gem = 1;
inline bool lhdbscoreitem::has_gem() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lhdbscoreitem::set_has_gem() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lhdbscoreitem::clear_has_gem() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lhdbscoreitem::clear_gem() {
  gem_ = 0;
  clear_has_gem();
}
inline ::google::protobuf::int32 lhdbscoreitem::gem() const {
  return gem_;
}
inline void lhdbscoreitem::set_gem(::google::protobuf::int32 value) {
  set_has_gem();
  gem_ = value;
}

// repeated string scorelist = 2;
inline int lhdbscoreitem::scorelist_size() const {
  return scorelist_.size();
}
inline void lhdbscoreitem::clear_scorelist() {
  scorelist_.Clear();
}
inline const ::std::string& lhdbscoreitem::scorelist(int index) const {
  return scorelist_.Get(index);
}
inline ::std::string* lhdbscoreitem::mutable_scorelist(int index) {
  return scorelist_.Mutable(index);
}
inline void lhdbscoreitem::set_scorelist(int index, const ::std::string& value) {
  scorelist_.Mutable(index)->assign(value);
}
inline void lhdbscoreitem::set_scorelist(int index, const char* value) {
  scorelist_.Mutable(index)->assign(value);
}
inline void lhdbscoreitem::set_scorelist(int index, const char* value, size_t size) {
  scorelist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lhdbscoreitem::add_scorelist() {
  return scorelist_.Add();
}
inline void lhdbscoreitem::add_scorelist(const ::std::string& value) {
  scorelist_.Add()->assign(value);
}
inline void lhdbscoreitem::add_scorelist(const char* value) {
  scorelist_.Add()->assign(value);
}
inline void lhdbscoreitem::add_scorelist(const char* value, size_t size) {
  scorelist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
lhdbscoreitem::scorelist() const {
  return scorelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
lhdbscoreitem::mutable_scorelist() {
  return &scorelist_;
}

// repeated .progame.lhdbpoint pointlist = 3;
inline int lhdbscoreitem::pointlist_size() const {
  return pointlist_.size();
}
inline void lhdbscoreitem::clear_pointlist() {
  pointlist_.Clear();
}
inline const ::progame::lhdbpoint& lhdbscoreitem::pointlist(int index) const {
  return pointlist_.Get(index);
}
inline ::progame::lhdbpoint* lhdbscoreitem::mutable_pointlist(int index) {
  return pointlist_.Mutable(index);
}
inline ::progame::lhdbpoint* lhdbscoreitem::add_pointlist() {
  return pointlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::lhdbpoint >&
lhdbscoreitem::pointlist() const {
  return pointlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::lhdbpoint >*
lhdbscoreitem::mutable_pointlist() {
  return &pointlist_;
}

// -------------------------------------------------------------------

// lhdbscorelist

// repeated .progame.lhdbscoreitem list = 1;
inline int lhdbscorelist::list_size() const {
  return list_.size();
}
inline void lhdbscorelist::clear_list() {
  list_.Clear();
}
inline const ::progame::lhdbscoreitem& lhdbscorelist::list(int index) const {
  return list_.Get(index);
}
inline ::progame::lhdbscoreitem* lhdbscorelist::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::progame::lhdbscoreitem* lhdbscorelist::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::lhdbscoreitem >&
lhdbscorelist::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::lhdbscoreitem >*
lhdbscorelist::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// lhdbpriavedata

// optional string totalscore = 1;
inline bool lhdbpriavedata::has_totalscore() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lhdbpriavedata::set_has_totalscore() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lhdbpriavedata::clear_has_totalscore() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lhdbpriavedata::clear_totalscore() {
  if (totalscore_ != &::google::protobuf::internal::kEmptyString) {
    totalscore_->clear();
  }
  clear_has_totalscore();
}
inline const ::std::string& lhdbpriavedata::totalscore() const {
  return *totalscore_;
}
inline void lhdbpriavedata::set_totalscore(const ::std::string& value) {
  set_has_totalscore();
  if (totalscore_ == &::google::protobuf::internal::kEmptyString) {
    totalscore_ = new ::std::string;
  }
  totalscore_->assign(value);
}
inline void lhdbpriavedata::set_totalscore(const char* value) {
  set_has_totalscore();
  if (totalscore_ == &::google::protobuf::internal::kEmptyString) {
    totalscore_ = new ::std::string;
  }
  totalscore_->assign(value);
}
inline void lhdbpriavedata::set_totalscore(const char* value, size_t size) {
  set_has_totalscore();
  if (totalscore_ == &::google::protobuf::internal::kEmptyString) {
    totalscore_ = new ::std::string;
  }
  totalscore_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lhdbpriavedata::mutable_totalscore() {
  set_has_totalscore();
  if (totalscore_ == &::google::protobuf::internal::kEmptyString) {
    totalscore_ = new ::std::string;
  }
  return totalscore_;
}
inline ::std::string* lhdbpriavedata::release_totalscore() {
  clear_has_totalscore();
  if (totalscore_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = totalscore_;
    totalscore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lhdbpriavedata::set_allocated_totalscore(::std::string* totalscore) {
  if (totalscore_ != &::google::protobuf::internal::kEmptyString) {
    delete totalscore_;
  }
  if (totalscore) {
    set_has_totalscore();
    totalscore_ = totalscore;
  } else {
    clear_has_totalscore();
    totalscore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 round = 2;
inline bool lhdbpriavedata::has_round() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lhdbpriavedata::set_has_round() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lhdbpriavedata::clear_has_round() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lhdbpriavedata::clear_round() {
  round_ = 0;
  clear_has_round();
}
inline ::google::protobuf::int32 lhdbpriavedata::round() const {
  return round_;
}
inline void lhdbpriavedata::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
}

// optional int32 boardlength = 3;
inline bool lhdbpriavedata::has_boardlength() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lhdbpriavedata::set_has_boardlength() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lhdbpriavedata::clear_has_boardlength() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lhdbpriavedata::clear_boardlength() {
  boardlength_ = 0;
  clear_has_boardlength();
}
inline ::google::protobuf::int32 lhdbpriavedata::boardlength() const {
  return boardlength_;
}
inline void lhdbpriavedata::set_boardlength(::google::protobuf::int32 value) {
  set_has_boardlength();
  boardlength_ = value;
}

// repeated .progame.lhdbgemcolumn gemmap = 4;
inline int lhdbpriavedata::gemmap_size() const {
  return gemmap_.size();
}
inline void lhdbpriavedata::clear_gemmap() {
  gemmap_.Clear();
}
inline const ::progame::lhdbgemcolumn& lhdbpriavedata::gemmap(int index) const {
  return gemmap_.Get(index);
}
inline ::progame::lhdbgemcolumn* lhdbpriavedata::mutable_gemmap(int index) {
  return gemmap_.Mutable(index);
}
inline ::progame::lhdbgemcolumn* lhdbpriavedata::add_gemmap() {
  return gemmap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::lhdbgemcolumn >&
lhdbpriavedata::gemmap() const {
  return gemmap_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::lhdbgemcolumn >*
lhdbpriavedata::mutable_gemmap() {
  return &gemmap_;
}

// repeated .progame.lhdbgemcolumn reservegemmap = 5;
inline int lhdbpriavedata::reservegemmap_size() const {
  return reservegemmap_.size();
}
inline void lhdbpriavedata::clear_reservegemmap() {
  reservegemmap_.Clear();
}
inline const ::progame::lhdbgemcolumn& lhdbpriavedata::reservegemmap(int index) const {
  return reservegemmap_.Get(index);
}
inline ::progame::lhdbgemcolumn* lhdbpriavedata::mutable_reservegemmap(int index) {
  return reservegemmap_.Mutable(index);
}
inline ::progame::lhdbgemcolumn* lhdbpriavedata::add_reservegemmap() {
  return reservegemmap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::lhdbgemcolumn >&
lhdbpriavedata::reservegemmap() const {
  return reservegemmap_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::lhdbgemcolumn >*
lhdbpriavedata::mutable_reservegemmap() {
  return &reservegemmap_;
}

// repeated string pourjettonlist = 6;
inline int lhdbpriavedata::pourjettonlist_size() const {
  return pourjettonlist_.size();
}
inline void lhdbpriavedata::clear_pourjettonlist() {
  pourjettonlist_.Clear();
}
inline const ::std::string& lhdbpriavedata::pourjettonlist(int index) const {
  return pourjettonlist_.Get(index);
}
inline ::std::string* lhdbpriavedata::mutable_pourjettonlist(int index) {
  return pourjettonlist_.Mutable(index);
}
inline void lhdbpriavedata::set_pourjettonlist(int index, const ::std::string& value) {
  pourjettonlist_.Mutable(index)->assign(value);
}
inline void lhdbpriavedata::set_pourjettonlist(int index, const char* value) {
  pourjettonlist_.Mutable(index)->assign(value);
}
inline void lhdbpriavedata::set_pourjettonlist(int index, const char* value, size_t size) {
  pourjettonlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lhdbpriavedata::add_pourjettonlist() {
  return pourjettonlist_.Add();
}
inline void lhdbpriavedata::add_pourjettonlist(const ::std::string& value) {
  pourjettonlist_.Add()->assign(value);
}
inline void lhdbpriavedata::add_pourjettonlist(const char* value) {
  pourjettonlist_.Add()->assign(value);
}
inline void lhdbpriavedata::add_pourjettonlist(const char* value, size_t size) {
  pourjettonlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
lhdbpriavedata::pourjettonlist() const {
  return pourjettonlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
lhdbpriavedata::mutable_pourjettonlist() {
  return &pourjettonlist_;
}

// optional int64 timemark = 7;
inline bool lhdbpriavedata::has_timemark() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void lhdbpriavedata::set_has_timemark() {
  _has_bits_[0] |= 0x00000040u;
}
inline void lhdbpriavedata::clear_has_timemark() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void lhdbpriavedata::clear_timemark() {
  timemark_ = GOOGLE_LONGLONG(0);
  clear_has_timemark();
}
inline ::google::protobuf::int64 lhdbpriavedata::timemark() const {
  return timemark_;
}
inline void lhdbpriavedata::set_timemark(::google::protobuf::int64 value) {
  set_has_timemark();
  timemark_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace progame

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_st_5flhdb_2eproto__INCLUDED
