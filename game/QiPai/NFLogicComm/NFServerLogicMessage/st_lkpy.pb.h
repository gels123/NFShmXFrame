// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: st_lkpy.proto

#ifndef PROTOBUF_st_5flkpy_2eproto__INCLUDED
#define PROTOBUF_st_5flkpy_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "st_human.pb.h"
// @@protoc_insertion_point(includes)

namespace progame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_st_5flkpy_2eproto();
void protobuf_AssignDesc_st_5flkpy_2eproto();
void protobuf_ShutdownFile_st_5flkpy_2eproto();

class lkpyconffish;
class lkpyconfcannon;
class lkpyconfitem;
class lkpygameconf;
class lkpycreatefish;
class lkpycreatebullet;
class lkpyitem;
class lkpyuser;
class lkpyuseitem;
class lkpyinfo;
class lkpycatchfish;

// ===================================================================

class lkpyconffish : public ::google::protobuf::Message {
 public:
  lkpyconffish();
  virtual ~lkpyconffish();

  lkpyconffish(const lkpyconffish& from);

  inline lkpyconffish& operator=(const lkpyconffish& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lkpyconffish& default_instance();

  void Swap(lkpyconffish* other);

  // implements Message ----------------------------------------------

  lkpyconffish* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lkpyconffish& from);
  void MergeFrom(const lkpyconffish& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 enable = 2;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 2;
  inline ::google::protobuf::int32 enable() const;
  inline void set_enable(::google::protobuf::int32 value);

  // optional int32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int32 height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 pathtype = 5;
  inline bool has_pathtype() const;
  inline void clear_pathtype();
  static const int kPathtypeFieldNumber = 5;
  inline ::google::protobuf::int32 pathtype() const;
  inline void set_pathtype(::google::protobuf::int32 value);

  // optional int32 scoretype = 6;
  inline bool has_scoretype() const;
  inline void clear_scoretype();
  static const int kScoretypeFieldNumber = 6;
  inline ::google::protobuf::int32 scoretype() const;
  inline void set_scoretype(::google::protobuf::int32 value);

  // optional string score = 7;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 7;
  inline const ::std::string& score() const;
  inline void set_score(const ::std::string& value);
  inline void set_score(const char* value);
  inline void set_score(const char* value, size_t size);
  inline ::std::string* mutable_score();
  inline ::std::string* release_score();
  inline void set_allocated_score(::std::string* score);

  // @@protoc_insertion_point(class_scope:progame.lkpyconffish)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_pathtype();
  inline void clear_has_pathtype();
  inline void set_has_scoretype();
  inline void clear_has_scoretype();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 enable_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 pathtype_;
  ::google::protobuf::int32 scoretype_;
  ::std::string* score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flkpy_2eproto();
  friend void protobuf_AssignDesc_st_5flkpy_2eproto();
  friend void protobuf_ShutdownFile_st_5flkpy_2eproto();

  void InitAsDefaultInstance();
  static lkpyconffish* default_instance_;
};
// -------------------------------------------------------------------

class lkpyconfcannon : public ::google::protobuf::Message {
 public:
  lkpyconfcannon();
  virtual ~lkpyconfcannon();

  lkpyconfcannon(const lkpyconfcannon& from);

  inline lkpyconfcannon& operator=(const lkpyconfcannon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lkpyconfcannon& default_instance();

  void Swap(lkpyconfcannon* other);

  // implements Message ----------------------------------------------

  lkpyconfcannon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lkpyconfcannon& from);
  void MergeFrom(const lkpyconfcannon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int32 height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional float speed = 4;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 4;
  inline float speed() const;
  inline void set_speed(float value);

  // optional int32 tubenum = 5;
  inline bool has_tubenum() const;
  inline void clear_tubenum();
  static const int kTubenumFieldNumber = 5;
  inline ::google::protobuf::int32 tubenum() const;
  inline void set_tubenum(::google::protobuf::int32 value);

  // optional string jetton = 6;
  inline bool has_jetton() const;
  inline void clear_jetton();
  static const int kJettonFieldNumber = 6;
  inline const ::std::string& jetton() const;
  inline void set_jetton(const ::std::string& value);
  inline void set_jetton(const char* value);
  inline void set_jetton(const char* value, size_t size);
  inline ::std::string* mutable_jetton();
  inline ::std::string* release_jetton();
  inline void set_allocated_jetton(::std::string* jetton);

  // optional int32 money = 7;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 7;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 givejetton = 8;
  inline bool has_givejetton() const;
  inline void clear_givejetton();
  static const int kGivejettonFieldNumber = 8;
  inline ::google::protobuf::int32 givejetton() const;
  inline void set_givejetton(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.lkpyconfcannon)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_tubenum();
  inline void clear_has_tubenum();
  inline void set_has_jetton();
  inline void clear_has_jetton();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_givejetton();
  inline void clear_has_givejetton();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  float speed_;
  ::std::string* jetton_;
  ::google::protobuf::int32 tubenum_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 givejetton_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flkpy_2eproto();
  friend void protobuf_AssignDesc_st_5flkpy_2eproto();
  friend void protobuf_ShutdownFile_st_5flkpy_2eproto();

  void InitAsDefaultInstance();
  static lkpyconfcannon* default_instance_;
};
// -------------------------------------------------------------------

class lkpyconfitem : public ::google::protobuf::Message {
 public:
  lkpyconfitem();
  virtual ~lkpyconfitem();

  lkpyconfitem(const lkpyconfitem& from);

  inline lkpyconfitem& operator=(const lkpyconfitem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lkpyconfitem& default_instance();

  void Swap(lkpyconfitem* other);

  // implements Message ----------------------------------------------

  lkpyconfitem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lkpyconfitem& from);
  void MergeFrom(const lkpyconfitem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 consumetype = 3;
  inline bool has_consumetype() const;
  inline void clear_consumetype();
  static const int kConsumetypeFieldNumber = 3;
  inline ::google::protobuf::int32 consumetype() const;
  inline void set_consumetype(::google::protobuf::int32 value);

  // optional int32 consume = 4;
  inline bool has_consume() const;
  inline void clear_consume();
  static const int kConsumeFieldNumber = 4;
  inline ::google::protobuf::int32 consume() const;
  inline void set_consume(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.lkpyconfitem)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_consumetype();
  inline void clear_has_consumetype();
  inline void set_has_consume();
  inline void clear_has_consume();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 consumetype_;
  ::google::protobuf::int32 consume_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flkpy_2eproto();
  friend void protobuf_AssignDesc_st_5flkpy_2eproto();
  friend void protobuf_ShutdownFile_st_5flkpy_2eproto();

  void InitAsDefaultInstance();
  static lkpyconfitem* default_instance_;
};
// -------------------------------------------------------------------

class lkpygameconf : public ::google::protobuf::Message {
 public:
  lkpygameconf();
  virtual ~lkpygameconf();

  lkpygameconf(const lkpygameconf& from);

  inline lkpygameconf& operator=(const lkpygameconf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lkpygameconf& default_instance();

  void Swap(lkpygameconf* other);

  // implements Message ----------------------------------------------

  lkpygameconf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lkpygameconf& from);
  void MergeFrom(const lkpygameconf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .progame.lkpyconffish fishlist = 1;
  inline int fishlist_size() const;
  inline void clear_fishlist();
  static const int kFishlistFieldNumber = 1;
  inline const ::progame::lkpyconffish& fishlist(int index) const;
  inline ::progame::lkpyconffish* mutable_fishlist(int index);
  inline ::progame::lkpyconffish* add_fishlist();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpyconffish >&
      fishlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::lkpyconffish >*
      mutable_fishlist();

  // repeated .progame.lkpyconfcannon cannonlist = 2;
  inline int cannonlist_size() const;
  inline void clear_cannonlist();
  static const int kCannonlistFieldNumber = 2;
  inline const ::progame::lkpyconfcannon& cannonlist(int index) const;
  inline ::progame::lkpyconfcannon* mutable_cannonlist(int index);
  inline ::progame::lkpyconfcannon* add_cannonlist();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpyconfcannon >&
      cannonlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::lkpyconfcannon >*
      mutable_cannonlist();

  // optional float fireinterval = 3;
  inline bool has_fireinterval() const;
  inline void clear_fireinterval();
  static const int kFireintervalFieldNumber = 3;
  inline float fireinterval() const;
  inline void set_fireinterval(float value);

  // optional int32 ionneedpower = 4;
  inline bool has_ionneedpower() const;
  inline void clear_ionneedpower();
  static const int kIonneedpowerFieldNumber = 4;
  inline ::google::protobuf::int32 ionneedpower() const;
  inline void set_ionneedpower(::google::protobuf::int32 value);

  // optional int32 rangebombradius = 5;
  inline bool has_rangebombradius() const;
  inline void clear_rangebombradius();
  static const int kRangebombradiusFieldNumber = 5;
  inline ::google::protobuf::int32 rangebombradius() const;
  inline void set_rangebombradius(::google::protobuf::int32 value);

  // optional float freezetime = 6;
  inline bool has_freezetime() const;
  inline void clear_freezetime();
  static const int kFreezetimeFieldNumber = 6;
  inline float freezetime() const;
  inline void set_freezetime(float value);

  // repeated .progame.lkpyconfitem itemlist = 7;
  inline int itemlist_size() const;
  inline void clear_itemlist();
  static const int kItemlistFieldNumber = 7;
  inline const ::progame::lkpyconfitem& itemlist(int index) const;
  inline ::progame::lkpyconfitem* mutable_itemlist(int index);
  inline ::progame::lkpyconfitem* add_itemlist();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpyconfitem >&
      itemlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::lkpyconfitem >*
      mutable_itemlist();

  // optional float freezecooldown = 8;
  inline bool has_freezecooldown() const;
  inline void clear_freezecooldown();
  static const int kFreezecooldownFieldNumber = 8;
  inline float freezecooldown() const;
  inline void set_freezecooldown(float value);

  // optional float locktime = 9;
  inline bool has_locktime() const;
  inline void clear_locktime();
  static const int kLocktimeFieldNumber = 9;
  inline float locktime() const;
  inline void set_locktime(float value);

  // optional float lockcooldown = 10;
  inline bool has_lockcooldown() const;
  inline void clear_lockcooldown();
  static const int kLockcooldownFieldNumber = 10;
  inline float lockcooldown() const;
  inline void set_lockcooldown(float value);

  // @@protoc_insertion_point(class_scope:progame.lkpygameconf)
 private:
  inline void set_has_fireinterval();
  inline void clear_has_fireinterval();
  inline void set_has_ionneedpower();
  inline void clear_has_ionneedpower();
  inline void set_has_rangebombradius();
  inline void clear_has_rangebombradius();
  inline void set_has_freezetime();
  inline void clear_has_freezetime();
  inline void set_has_freezecooldown();
  inline void clear_has_freezecooldown();
  inline void set_has_locktime();
  inline void clear_has_locktime();
  inline void set_has_lockcooldown();
  inline void clear_has_lockcooldown();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::progame::lkpyconffish > fishlist_;
  ::google::protobuf::RepeatedPtrField< ::progame::lkpyconfcannon > cannonlist_;
  float fireinterval_;
  ::google::protobuf::int32 ionneedpower_;
  ::google::protobuf::int32 rangebombradius_;
  float freezetime_;
  ::google::protobuf::RepeatedPtrField< ::progame::lkpyconfitem > itemlist_;
  float freezecooldown_;
  float locktime_;
  float lockcooldown_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flkpy_2eproto();
  friend void protobuf_AssignDesc_st_5flkpy_2eproto();
  friend void protobuf_ShutdownFile_st_5flkpy_2eproto();

  void InitAsDefaultInstance();
  static lkpygameconf* default_instance_;
};
// -------------------------------------------------------------------

class lkpycreatefish : public ::google::protobuf::Message {
 public:
  lkpycreatefish();
  virtual ~lkpycreatefish();

  lkpycreatefish(const lkpycreatefish& from);

  inline lkpycreatefish& operator=(const lkpycreatefish& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lkpycreatefish& default_instance();

  void Swap(lkpycreatefish* other);

  // implements Message ----------------------------------------------

  lkpycreatefish* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lkpycreatefish& from);
  void MergeFrom(const lkpycreatefish& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 pathid = 3;
  inline bool has_pathid() const;
  inline void clear_pathid();
  static const int kPathidFieldNumber = 3;
  inline ::google::protobuf::int32 pathid() const;
  inline void set_pathid(::google::protobuf::int32 value);

  // optional int32 pathtype = 4;
  inline bool has_pathtype() const;
  inline void clear_pathtype();
  static const int kPathtypeFieldNumber = 4;
  inline ::google::protobuf::int32 pathtype() const;
  inline void set_pathtype(::google::protobuf::int32 value);

  // optional int32 width = 5;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 5;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int32 height = 6;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 6;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional float offsetx = 7;
  inline bool has_offsetx() const;
  inline void clear_offsetx();
  static const int kOffsetxFieldNumber = 7;
  inline float offsetx() const;
  inline void set_offsetx(float value);

  // optional float offsety = 8;
  inline bool has_offsety() const;
  inline void clear_offsety();
  static const int kOffsetyFieldNumber = 8;
  inline float offsety() const;
  inline void set_offsety(float value);

  // optional float delay = 9;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 9;
  inline float delay() const;
  inline void set_delay(float value);

  // optional float elaspe = 10;
  inline bool has_elaspe() const;
  inline void clear_elaspe();
  static const int kElaspeFieldNumber = 10;
  inline float elaspe() const;
  inline void set_elaspe(float value);

  // optional float speed = 11;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 11;
  inline float speed() const;
  inline void set_speed(float value);

  // optional double borntime = 12;
  inline bool has_borntime() const;
  inline void clear_borntime();
  static const int kBorntimeFieldNumber = 12;
  inline double borntime() const;
  inline void set_borntime(double value);

  // optional int32 data = 13;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 13;
  inline ::google::protobuf::int32 data() const;
  inline void set_data(::google::protobuf::int32 value);

  // optional int32 score = 14;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 14;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 attrid = 15;
  inline bool has_attrid() const;
  inline void clear_attrid();
  static const int kAttridFieldNumber = 15;
  inline ::google::protobuf::int32 attrid() const;
  inline void set_attrid(::google::protobuf::int32 value);

  // optional int32 chairid = 16;
  inline bool has_chairid() const;
  inline void clear_chairid();
  static const int kChairidFieldNumber = 16;
  inline ::google::protobuf::int32 chairid() const;
  inline void set_chairid(::google::protobuf::int32 value);

  // optional float lifecycle = 17;
  inline bool has_lifecycle() const;
  inline void clear_lifecycle();
  static const int kLifecycleFieldNumber = 17;
  inline float lifecycle() const;
  inline void set_lifecycle(float value);

  // @@protoc_insertion_point(class_scope:progame.lkpycreatefish)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pathid();
  inline void clear_has_pathid();
  inline void set_has_pathtype();
  inline void clear_has_pathtype();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_offsetx();
  inline void clear_has_offsetx();
  inline void set_has_offsety();
  inline void clear_has_offsety();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_elaspe();
  inline void clear_has_elaspe();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_borntime();
  inline void clear_has_borntime();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_attrid();
  inline void clear_has_attrid();
  inline void set_has_chairid();
  inline void clear_has_chairid();
  inline void set_has_lifecycle();
  inline void clear_has_lifecycle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 pathid_;
  ::google::protobuf::int32 pathtype_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  float offsetx_;
  float offsety_;
  float delay_;
  float elaspe_;
  double borntime_;
  float speed_;
  ::google::protobuf::int32 data_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 attrid_;
  ::google::protobuf::int32 chairid_;
  float lifecycle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flkpy_2eproto();
  friend void protobuf_AssignDesc_st_5flkpy_2eproto();
  friend void protobuf_ShutdownFile_st_5flkpy_2eproto();

  void InitAsDefaultInstance();
  static lkpycreatefish* default_instance_;
};
// -------------------------------------------------------------------

class lkpycreatebullet : public ::google::protobuf::Message {
 public:
  lkpycreatebullet();
  virtual ~lkpycreatebullet();

  lkpycreatebullet(const lkpycreatebullet& from);

  inline lkpycreatebullet& operator=(const lkpycreatebullet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lkpycreatebullet& default_instance();

  void Swap(lkpycreatebullet* other);

  // implements Message ----------------------------------------------

  lkpycreatebullet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lkpycreatebullet& from);
  void MergeFrom(const lkpycreatebullet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 cannontype = 1;
  inline bool has_cannontype() const;
  inline void clear_cannontype();
  static const int kCannontypeFieldNumber = 1;
  inline ::google::protobuf::int32 cannontype() const;
  inline void set_cannontype(::google::protobuf::int32 value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional float speed = 3;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 3;
  inline float speed() const;
  inline void set_speed(float value);

  // optional float posx = 4;
  inline bool has_posx() const;
  inline void clear_posx();
  static const int kPosxFieldNumber = 4;
  inline float posx() const;
  inline void set_posx(float value);

  // optional float posy = 5;
  inline bool has_posy() const;
  inline void clear_posy();
  static const int kPosyFieldNumber = 5;
  inline float posy() const;
  inline void set_posy(float value);

  // optional float direction = 6;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 6;
  inline float direction() const;
  inline void set_direction(float value);

  // optional int32 elaspe = 7;
  inline bool has_elaspe() const;
  inline void clear_elaspe();
  static const int kElaspeFieldNumber = 7;
  inline ::google::protobuf::int32 elaspe() const;
  inline void set_elaspe(::google::protobuf::int32 value);

  // optional int32 itemid = 8;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 8;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 fishid = 9;
  inline bool has_fishid() const;
  inline void clear_fishid();
  static const int kFishidFieldNumber = 9;
  inline ::google::protobuf::int32 fishid() const;
  inline void set_fishid(::google::protobuf::int32 value);

  // optional int32 mul = 10;
  inline bool has_mul() const;
  inline void clear_mul();
  static const int kMulFieldNumber = 10;
  inline ::google::protobuf::int32 mul() const;
  inline void set_mul(::google::protobuf::int32 value);

  // optional int32 new = 11;
  inline bool has_new_() const;
  inline void clear_new_();
  static const int kNewFieldNumber = 11;
  inline ::google::protobuf::int32 new_() const;
  inline void set_new_(::google::protobuf::int32 value);

  // optional int32 tubenum = 12;
  inline bool has_tubenum() const;
  inline void clear_tubenum();
  static const int kTubenumFieldNumber = 12;
  inline ::google::protobuf::int32 tubenum() const;
  inline void set_tubenum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.lkpycreatebullet)
 private:
  inline void set_has_cannontype();
  inline void clear_has_cannontype();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_posx();
  inline void clear_has_posx();
  inline void set_has_posy();
  inline void clear_has_posy();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_elaspe();
  inline void clear_has_elaspe();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_fishid();
  inline void clear_has_fishid();
  inline void set_has_mul();
  inline void clear_has_mul();
  inline void set_has_new_();
  inline void clear_has_new_();
  inline void set_has_tubenum();
  inline void clear_has_tubenum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 cannontype_;
  ::google::protobuf::int32 id_;
  float speed_;
  float posx_;
  float posy_;
  float direction_;
  ::google::protobuf::int32 elaspe_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 fishid_;
  ::google::protobuf::int32 mul_;
  ::google::protobuf::int32 new__;
  ::google::protobuf::int32 tubenum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flkpy_2eproto();
  friend void protobuf_AssignDesc_st_5flkpy_2eproto();
  friend void protobuf_ShutdownFile_st_5flkpy_2eproto();

  void InitAsDefaultInstance();
  static lkpycreatebullet* default_instance_;
};
// -------------------------------------------------------------------

class lkpyitem : public ::google::protobuf::Message {
 public:
  lkpyitem();
  virtual ~lkpyitem();

  lkpyitem(const lkpyitem& from);

  inline lkpyitem& operator=(const lkpyitem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lkpyitem& default_instance();

  void Swap(lkpyitem* other);

  // implements Message ----------------------------------------------

  lkpyitem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lkpyitem& from);
  void MergeFrom(const lkpyitem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 itemid = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 slotid = 2;
  inline bool has_slotid() const;
  inline void clear_slotid();
  static const int kSlotidFieldNumber = 2;
  inline ::google::protobuf::int32 slotid() const;
  inline void set_slotid(::google::protobuf::int32 value);

  // optional int32 itemnum = 3;
  inline bool has_itemnum() const;
  inline void clear_itemnum();
  static const int kItemnumFieldNumber = 3;
  inline ::google::protobuf::int32 itemnum() const;
  inline void set_itemnum(::google::protobuf::int32 value);

  // optional int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.lkpyitem)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_slotid();
  inline void clear_has_slotid();
  inline void set_has_itemnum();
  inline void clear_has_itemnum();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 slotid_;
  ::google::protobuf::int32 itemnum_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flkpy_2eproto();
  friend void protobuf_AssignDesc_st_5flkpy_2eproto();
  friend void protobuf_ShutdownFile_st_5flkpy_2eproto();

  void InitAsDefaultInstance();
  static lkpyitem* default_instance_;
};
// -------------------------------------------------------------------

class lkpyuser : public ::google::protobuf::Message {
 public:
  lkpyuser();
  virtual ~lkpyuser();

  lkpyuser(const lkpyuser& from);

  inline lkpyuser& operator=(const lkpyuser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lkpyuser& default_instance();

  void Swap(lkpyuser* other);

  // implements Message ----------------------------------------------

  lkpyuser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lkpyuser& from);
  void MergeFrom(const lkpyuser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional int32 chairid = 2;
  inline bool has_chairid() const;
  inline void clear_chairid();
  static const int kChairidFieldNumber = 2;
  inline ::google::protobuf::int32 chairid() const;
  inline void set_chairid(::google::protobuf::int32 value);

  // optional string nickname = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string faceid = 4;
  inline bool has_faceid() const;
  inline void clear_faceid();
  static const int kFaceidFieldNumber = 4;
  inline const ::std::string& faceid() const;
  inline void set_faceid(const ::std::string& value);
  inline void set_faceid(const char* value);
  inline void set_faceid(const char* value, size_t size);
  inline ::std::string* mutable_faceid();
  inline ::std::string* release_faceid();
  inline void set_allocated_faceid(::std::string* faceid);

  // optional int32 sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional string jetton = 6;
  inline bool has_jetton() const;
  inline void clear_jetton();
  static const int kJettonFieldNumber = 6;
  inline const ::std::string& jetton() const;
  inline void set_jetton(const ::std::string& value);
  inline void set_jetton(const char* value);
  inline void set_jetton(const char* value, size_t size);
  inline ::std::string* mutable_jetton();
  inline ::std::string* release_jetton();
  inline void set_allocated_jetton(::std::string* jetton);

  // optional string money = 7;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 7;
  inline const ::std::string& money() const;
  inline void set_money(const ::std::string& value);
  inline void set_money(const char* value);
  inline void set_money(const char* value, size_t size);
  inline ::std::string* mutable_money();
  inline ::std::string* release_money();
  inline void set_allocated_money(::std::string* money);

  // optional int32 isrobot = 8;
  inline bool has_isrobot() const;
  inline void clear_isrobot();
  static const int kIsrobotFieldNumber = 8;
  inline ::google::protobuf::int32 isrobot() const;
  inline void set_isrobot(::google::protobuf::int32 value);

  // optional int32 cannontype = 9;
  inline bool has_cannontype() const;
  inline void clear_cannontype();
  static const int kCannontypeFieldNumber = 9;
  inline ::google::protobuf::int32 cannontype() const;
  inline void set_cannontype(::google::protobuf::int32 value);

  // optional int32 cannonlv = 10;
  inline bool has_cannonlv() const;
  inline void clear_cannonlv();
  static const int kCannonlvFieldNumber = 10;
  inline ::google::protobuf::int32 cannonlv() const;
  inline void set_cannonlv(::google::protobuf::int32 value);

  // optional string bank_jetton = 11;
  inline bool has_bank_jetton() const;
  inline void clear_bank_jetton();
  static const int kBankJettonFieldNumber = 11;
  inline const ::std::string& bank_jetton() const;
  inline void set_bank_jetton(const ::std::string& value);
  inline void set_bank_jetton(const char* value);
  inline void set_bank_jetton(const char* value, size_t size);
  inline ::std::string* mutable_bank_jetton();
  inline ::std::string* release_bank_jetton();
  inline void set_allocated_bank_jetton(::std::string* bank_jetton);

  // optional int32 state = 12;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 12;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // repeated int32 cannonlist = 13;
  inline int cannonlist_size() const;
  inline void clear_cannonlist();
  static const int kCannonlistFieldNumber = 13;
  inline ::google::protobuf::int32 cannonlist(int index) const;
  inline void set_cannonlist(int index, ::google::protobuf::int32 value);
  inline void add_cannonlist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      cannonlist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_cannonlist();

  // repeated .progame.lkpycreatebullet createbulletlist = 14;
  inline int createbulletlist_size() const;
  inline void clear_createbulletlist();
  static const int kCreatebulletlistFieldNumber = 14;
  inline const ::progame::lkpycreatebullet& createbulletlist(int index) const;
  inline ::progame::lkpycreatebullet* mutable_createbulletlist(int index);
  inline ::progame::lkpycreatebullet* add_createbulletlist();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpycreatebullet >&
      createbulletlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::lkpycreatebullet >*
      mutable_createbulletlist();

  // repeated .progame.lkpyitem backpack = 15;
  inline int backpack_size() const;
  inline void clear_backpack();
  static const int kBackpackFieldNumber = 15;
  inline const ::progame::lkpyitem& backpack(int index) const;
  inline ::progame::lkpyitem* mutable_backpack(int index);
  inline ::progame::lkpyitem* add_backpack();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpyitem >&
      backpack() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::lkpyitem >*
      mutable_backpack();

  // optional int32 tubenum = 16;
  inline bool has_tubenum() const;
  inline void clear_tubenum();
  static const int kTubenumFieldNumber = 16;
  inline ::google::protobuf::int32 tubenum() const;
  inline void set_tubenum(::google::protobuf::int32 value);

  // optional int32 cannonmul = 17;
  inline bool has_cannonmul() const;
  inline void clear_cannonmul();
  static const int kCannonmulFieldNumber = 17;
  inline ::google::protobuf::int32 cannonmul() const;
  inline void set_cannonmul(::google::protobuf::int32 value);

  // optional double lastfiretime = 18;
  inline bool has_lastfiretime() const;
  inline void clear_lastfiretime();
  static const int kLastfiretimeFieldNumber = 18;
  inline double lastfiretime() const;
  inline void set_lastfiretime(double value);

  // @@protoc_insertion_point(class_scope:progame.lkpyuser)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_chairid();
  inline void clear_has_chairid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_faceid();
  inline void clear_has_faceid();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_jetton();
  inline void clear_has_jetton();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_isrobot();
  inline void clear_has_isrobot();
  inline void set_has_cannontype();
  inline void clear_has_cannontype();
  inline void set_has_cannonlv();
  inline void clear_has_cannonlv();
  inline void set_has_bank_jetton();
  inline void clear_has_bank_jetton();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_tubenum();
  inline void clear_has_tubenum();
  inline void set_has_cannonmul();
  inline void clear_has_cannonmul();
  inline void set_has_lastfiretime();
  inline void clear_has_lastfiretime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 chairid_;
  ::std::string* nickname_;
  ::std::string* faceid_;
  ::std::string* jetton_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 isrobot_;
  ::std::string* money_;
  ::google::protobuf::int32 cannontype_;
  ::google::protobuf::int32 cannonlv_;
  ::std::string* bank_jetton_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > cannonlist_;
  ::google::protobuf::RepeatedPtrField< ::progame::lkpycreatebullet > createbulletlist_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 tubenum_;
  ::google::protobuf::RepeatedPtrField< ::progame::lkpyitem > backpack_;
  double lastfiretime_;
  ::google::protobuf::int32 cannonmul_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flkpy_2eproto();
  friend void protobuf_AssignDesc_st_5flkpy_2eproto();
  friend void protobuf_ShutdownFile_st_5flkpy_2eproto();

  void InitAsDefaultInstance();
  static lkpyuser* default_instance_;
};
// -------------------------------------------------------------------

class lkpyuseitem : public ::google::protobuf::Message {
 public:
  lkpyuseitem();
  virtual ~lkpyuseitem();

  lkpyuseitem(const lkpyuseitem& from);

  inline lkpyuseitem& operator=(const lkpyuseitem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lkpyuseitem& default_instance();

  void Swap(lkpyuseitem* other);

  // implements Message ----------------------------------------------

  lkpyuseitem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lkpyuseitem& from);
  void MergeFrom(const lkpyuseitem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional double time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline double time() const;
  inline void set_time(double value);

  // @@protoc_insertion_point(class_scope:progame.lkpyuseitem)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 type_;
  double time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flkpy_2eproto();
  friend void protobuf_AssignDesc_st_5flkpy_2eproto();
  friend void protobuf_ShutdownFile_st_5flkpy_2eproto();

  void InitAsDefaultInstance();
  static lkpyuseitem* default_instance_;
};
// -------------------------------------------------------------------

class lkpyinfo : public ::google::protobuf::Message {
 public:
  lkpyinfo();
  virtual ~lkpyinfo();

  lkpyinfo(const lkpyinfo& from);

  inline lkpyinfo& operator=(const lkpyinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lkpyinfo& default_instance();

  void Swap(lkpyinfo* other);

  // implements Message ----------------------------------------------

  lkpyinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lkpyinfo& from);
  void MergeFrom(const lkpyinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 tableid = 1;
  inline bool has_tableid() const;
  inline void clear_tableid();
  static const int kTableidFieldNumber = 1;
  inline ::google::protobuf::int32 tableid() const;
  inline void set_tableid(::google::protobuf::int32 value);

  // optional int32 tabletype = 2;
  inline bool has_tabletype() const;
  inline void clear_tabletype();
  static const int kTabletypeFieldNumber = 2;
  inline ::google::protobuf::int32 tabletype() const;
  inline void set_tabletype(::google::protobuf::int32 value);

  // optional int32 state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 timemark = 4;
  inline bool has_timemark() const;
  inline void clear_timemark();
  static const int kTimemarkFieldNumber = 4;
  inline ::google::protobuf::int32 timemark() const;
  inline void set_timemark(::google::protobuf::int32 value);

  // optional string minenter = 5;
  inline bool has_minenter() const;
  inline void clear_minenter();
  static const int kMinenterFieldNumber = 5;
  inline const ::std::string& minenter() const;
  inline void set_minenter(const ::std::string& value);
  inline void set_minenter(const char* value);
  inline void set_minenter(const char* value, size_t size);
  inline ::std::string* mutable_minenter();
  inline ::std::string* release_minenter();
  inline void set_allocated_minenter(::std::string* minenter);

  // optional string maxenter = 6;
  inline bool has_maxenter() const;
  inline void clear_maxenter();
  static const int kMaxenterFieldNumber = 6;
  inline const ::std::string& maxenter() const;
  inline void set_maxenter(const ::std::string& value);
  inline void set_maxenter(const char* value);
  inline void set_maxenter(const char* value, size_t size);
  inline ::std::string* mutable_maxenter();
  inline ::std::string* release_maxenter();
  inline void set_allocated_maxenter(::std::string* maxenter);

  // optional int32 maxuser = 13;
  inline bool has_maxuser() const;
  inline void clear_maxuser();
  static const int kMaxuserFieldNumber = 13;
  inline ::google::protobuf::int32 maxuser() const;
  inline void set_maxuser(::google::protobuf::int32 value);

  // repeated .progame.lkpyuser situser = 14;
  inline int situser_size() const;
  inline void clear_situser();
  static const int kSituserFieldNumber = 14;
  inline const ::progame::lkpyuser& situser(int index) const;
  inline ::progame::lkpyuser* mutable_situser(int index);
  inline ::progame::lkpyuser* add_situser();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpyuser >&
      situser() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::lkpyuser >*
      mutable_situser();

  // repeated int32 standuser = 15;
  inline int standuser_size() const;
  inline void clear_standuser();
  static const int kStanduserFieldNumber = 15;
  inline ::google::protobuf::int32 standuser(int index) const;
  inline void set_standuser(int index, ::google::protobuf::int32 value);
  inline void add_standuser(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      standuser() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_standuser();

  // repeated .progame.lkpycreatefish createfishlist = 16;
  inline int createfishlist_size() const;
  inline void clear_createfishlist();
  static const int kCreatefishlistFieldNumber = 16;
  inline const ::progame::lkpycreatefish& createfishlist(int index) const;
  inline ::progame::lkpycreatefish* mutable_createfishlist(int index);
  inline ::progame::lkpycreatefish* add_createfishlist();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpycreatefish >&
      createfishlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::lkpycreatefish >*
      mutable_createfishlist();

  // optional int32 cursceneid = 17;
  inline bool has_cursceneid() const;
  inline void clear_cursceneid();
  static const int kCursceneidFieldNumber = 17;
  inline ::google::protobuf::int32 cursceneid() const;
  inline void set_cursceneid(::google::protobuf::int32 value);

  // optional int32 presceneid = 18;
  inline bool has_presceneid() const;
  inline void clear_presceneid();
  static const int kPresceneidFieldNumber = 18;
  inline ::google::protobuf::int32 presceneid() const;
  inline void set_presceneid(::google::protobuf::int32 value);

  // optional int32 nextfishid = 19;
  inline bool has_nextfishid() const;
  inline void clear_nextfishid();
  static const int kNextfishidFieldNumber = 19;
  inline ::google::protobuf::int32 nextfishid() const;
  inline void set_nextfishid(::google::protobuf::int32 value);

  // repeated .progame.lkpyuseitem useitemlist = 20;
  inline int useitemlist_size() const;
  inline void clear_useitemlist();
  static const int kUseitemlistFieldNumber = 20;
  inline const ::progame::lkpyuseitem& useitemlist(int index) const;
  inline ::progame::lkpyuseitem* mutable_useitemlist(int index);
  inline ::progame::lkpyuseitem* add_useitemlist();
  inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpyuseitem >&
      useitemlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::progame::lkpyuseitem >*
      mutable_useitemlist();

  // optional int32 shoalpathtype = 21;
  inline bool has_shoalpathtype() const;
  inline void clear_shoalpathtype();
  static const int kShoalpathtypeFieldNumber = 21;
  inline ::google::protobuf::int32 shoalpathtype() const;
  inline void set_shoalpathtype(::google::protobuf::int32 value);

  // optional double systime = 22;
  inline bool has_systime() const;
  inline void clear_systime();
  static const int kSystimeFieldNumber = 22;
  inline double systime() const;
  inline void set_systime(double value);

  // @@protoc_insertion_point(class_scope:progame.lkpyinfo)
 private:
  inline void set_has_tableid();
  inline void clear_has_tableid();
  inline void set_has_tabletype();
  inline void clear_has_tabletype();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_timemark();
  inline void clear_has_timemark();
  inline void set_has_minenter();
  inline void clear_has_minenter();
  inline void set_has_maxenter();
  inline void clear_has_maxenter();
  inline void set_has_maxuser();
  inline void clear_has_maxuser();
  inline void set_has_cursceneid();
  inline void clear_has_cursceneid();
  inline void set_has_presceneid();
  inline void clear_has_presceneid();
  inline void set_has_nextfishid();
  inline void clear_has_nextfishid();
  inline void set_has_shoalpathtype();
  inline void clear_has_shoalpathtype();
  inline void set_has_systime();
  inline void clear_has_systime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tableid_;
  ::google::protobuf::int32 tabletype_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 timemark_;
  ::std::string* minenter_;
  ::std::string* maxenter_;
  ::google::protobuf::RepeatedPtrField< ::progame::lkpyuser > situser_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > standuser_;
  ::google::protobuf::int32 maxuser_;
  ::google::protobuf::int32 cursceneid_;
  ::google::protobuf::RepeatedPtrField< ::progame::lkpycreatefish > createfishlist_;
  ::google::protobuf::int32 presceneid_;
  ::google::protobuf::int32 nextfishid_;
  ::google::protobuf::RepeatedPtrField< ::progame::lkpyuseitem > useitemlist_;
  double systime_;
  ::google::protobuf::int32 shoalpathtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flkpy_2eproto();
  friend void protobuf_AssignDesc_st_5flkpy_2eproto();
  friend void protobuf_ShutdownFile_st_5flkpy_2eproto();

  void InitAsDefaultInstance();
  static lkpyinfo* default_instance_;
};
// -------------------------------------------------------------------

class lkpycatchfish : public ::google::protobuf::Message {
 public:
  lkpycatchfish();
  virtual ~lkpycatchfish();

  lkpycatchfish(const lkpycatchfish& from);

  inline lkpycatchfish& operator=(const lkpycatchfish& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lkpycatchfish& default_instance();

  void Swap(lkpycatchfish* other);

  // implements Message ----------------------------------------------

  lkpycatchfish* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lkpycatchfish& from);
  void MergeFrom(const lkpycatchfish& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 scoretype = 2;
  inline bool has_scoretype() const;
  inline void clear_scoretype();
  static const int kScoretypeFieldNumber = 2;
  inline ::google::protobuf::int32 scoretype() const;
  inline void set_scoretype(::google::protobuf::int32 value);

  // optional int32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 scoremul = 4;
  inline bool has_scoremul() const;
  inline void clear_scoremul();
  static const int kScoremulFieldNumber = 4;
  inline ::google::protobuf::int32 scoremul() const;
  inline void set_scoremul(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.lkpycatchfish)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_scoretype();
  inline void clear_has_scoretype();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_scoremul();
  inline void clear_has_scoremul();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 scoretype_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 scoremul_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_st_5flkpy_2eproto();
  friend void protobuf_AssignDesc_st_5flkpy_2eproto();
  friend void protobuf_ShutdownFile_st_5flkpy_2eproto();

  void InitAsDefaultInstance();
  static lkpycatchfish* default_instance_;
};
// ===================================================================


// ===================================================================

// lkpyconffish

// optional int32 type = 1;
inline bool lkpyconffish::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lkpyconffish::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lkpyconffish::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lkpyconffish::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 lkpyconffish::type() const {
  return type_;
}
inline void lkpyconffish::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 enable = 2;
inline bool lkpyconffish::has_enable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lkpyconffish::set_has_enable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lkpyconffish::clear_has_enable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lkpyconffish::clear_enable() {
  enable_ = 0;
  clear_has_enable();
}
inline ::google::protobuf::int32 lkpyconffish::enable() const {
  return enable_;
}
inline void lkpyconffish::set_enable(::google::protobuf::int32 value) {
  set_has_enable();
  enable_ = value;
}

// optional int32 width = 3;
inline bool lkpyconffish::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lkpyconffish::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lkpyconffish::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lkpyconffish::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 lkpyconffish::width() const {
  return width_;
}
inline void lkpyconffish::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 4;
inline bool lkpyconffish::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lkpyconffish::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lkpyconffish::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lkpyconffish::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 lkpyconffish::height() const {
  return height_;
}
inline void lkpyconffish::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 pathtype = 5;
inline bool lkpyconffish::has_pathtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void lkpyconffish::set_has_pathtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void lkpyconffish::clear_has_pathtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void lkpyconffish::clear_pathtype() {
  pathtype_ = 0;
  clear_has_pathtype();
}
inline ::google::protobuf::int32 lkpyconffish::pathtype() const {
  return pathtype_;
}
inline void lkpyconffish::set_pathtype(::google::protobuf::int32 value) {
  set_has_pathtype();
  pathtype_ = value;
}

// optional int32 scoretype = 6;
inline bool lkpyconffish::has_scoretype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void lkpyconffish::set_has_scoretype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void lkpyconffish::clear_has_scoretype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void lkpyconffish::clear_scoretype() {
  scoretype_ = 0;
  clear_has_scoretype();
}
inline ::google::protobuf::int32 lkpyconffish::scoretype() const {
  return scoretype_;
}
inline void lkpyconffish::set_scoretype(::google::protobuf::int32 value) {
  set_has_scoretype();
  scoretype_ = value;
}

// optional string score = 7;
inline bool lkpyconffish::has_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void lkpyconffish::set_has_score() {
  _has_bits_[0] |= 0x00000040u;
}
inline void lkpyconffish::clear_has_score() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void lkpyconffish::clear_score() {
  if (score_ != &::google::protobuf::internal::kEmptyString) {
    score_->clear();
  }
  clear_has_score();
}
inline const ::std::string& lkpyconffish::score() const {
  return *score_;
}
inline void lkpyconffish::set_score(const ::std::string& value) {
  set_has_score();
  if (score_ == &::google::protobuf::internal::kEmptyString) {
    score_ = new ::std::string;
  }
  score_->assign(value);
}
inline void lkpyconffish::set_score(const char* value) {
  set_has_score();
  if (score_ == &::google::protobuf::internal::kEmptyString) {
    score_ = new ::std::string;
  }
  score_->assign(value);
}
inline void lkpyconffish::set_score(const char* value, size_t size) {
  set_has_score();
  if (score_ == &::google::protobuf::internal::kEmptyString) {
    score_ = new ::std::string;
  }
  score_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lkpyconffish::mutable_score() {
  set_has_score();
  if (score_ == &::google::protobuf::internal::kEmptyString) {
    score_ = new ::std::string;
  }
  return score_;
}
inline ::std::string* lkpyconffish::release_score() {
  clear_has_score();
  if (score_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = score_;
    score_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lkpyconffish::set_allocated_score(::std::string* score) {
  if (score_ != &::google::protobuf::internal::kEmptyString) {
    delete score_;
  }
  if (score) {
    set_has_score();
    score_ = score;
  } else {
    clear_has_score();
    score_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// lkpyconfcannon

// optional int32 type = 1;
inline bool lkpyconfcannon::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lkpyconfcannon::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lkpyconfcannon::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lkpyconfcannon::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 lkpyconfcannon::type() const {
  return type_;
}
inline void lkpyconfcannon::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 width = 2;
inline bool lkpyconfcannon::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lkpyconfcannon::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lkpyconfcannon::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lkpyconfcannon::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 lkpyconfcannon::width() const {
  return width_;
}
inline void lkpyconfcannon::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 3;
inline bool lkpyconfcannon::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lkpyconfcannon::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lkpyconfcannon::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lkpyconfcannon::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 lkpyconfcannon::height() const {
  return height_;
}
inline void lkpyconfcannon::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional float speed = 4;
inline bool lkpyconfcannon::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lkpyconfcannon::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lkpyconfcannon::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lkpyconfcannon::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float lkpyconfcannon::speed() const {
  return speed_;
}
inline void lkpyconfcannon::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// optional int32 tubenum = 5;
inline bool lkpyconfcannon::has_tubenum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void lkpyconfcannon::set_has_tubenum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void lkpyconfcannon::clear_has_tubenum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void lkpyconfcannon::clear_tubenum() {
  tubenum_ = 0;
  clear_has_tubenum();
}
inline ::google::protobuf::int32 lkpyconfcannon::tubenum() const {
  return tubenum_;
}
inline void lkpyconfcannon::set_tubenum(::google::protobuf::int32 value) {
  set_has_tubenum();
  tubenum_ = value;
}

// optional string jetton = 6;
inline bool lkpyconfcannon::has_jetton() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void lkpyconfcannon::set_has_jetton() {
  _has_bits_[0] |= 0x00000020u;
}
inline void lkpyconfcannon::clear_has_jetton() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void lkpyconfcannon::clear_jetton() {
  if (jetton_ != &::google::protobuf::internal::kEmptyString) {
    jetton_->clear();
  }
  clear_has_jetton();
}
inline const ::std::string& lkpyconfcannon::jetton() const {
  return *jetton_;
}
inline void lkpyconfcannon::set_jetton(const ::std::string& value) {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  jetton_->assign(value);
}
inline void lkpyconfcannon::set_jetton(const char* value) {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  jetton_->assign(value);
}
inline void lkpyconfcannon::set_jetton(const char* value, size_t size) {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  jetton_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lkpyconfcannon::mutable_jetton() {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  return jetton_;
}
inline ::std::string* lkpyconfcannon::release_jetton() {
  clear_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jetton_;
    jetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lkpyconfcannon::set_allocated_jetton(::std::string* jetton) {
  if (jetton_ != &::google::protobuf::internal::kEmptyString) {
    delete jetton_;
  }
  if (jetton) {
    set_has_jetton();
    jetton_ = jetton;
  } else {
    clear_has_jetton();
    jetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 money = 7;
inline bool lkpyconfcannon::has_money() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void lkpyconfcannon::set_has_money() {
  _has_bits_[0] |= 0x00000040u;
}
inline void lkpyconfcannon::clear_has_money() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void lkpyconfcannon::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 lkpyconfcannon::money() const {
  return money_;
}
inline void lkpyconfcannon::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 givejetton = 8;
inline bool lkpyconfcannon::has_givejetton() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void lkpyconfcannon::set_has_givejetton() {
  _has_bits_[0] |= 0x00000080u;
}
inline void lkpyconfcannon::clear_has_givejetton() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void lkpyconfcannon::clear_givejetton() {
  givejetton_ = 0;
  clear_has_givejetton();
}
inline ::google::protobuf::int32 lkpyconfcannon::givejetton() const {
  return givejetton_;
}
inline void lkpyconfcannon::set_givejetton(::google::protobuf::int32 value) {
  set_has_givejetton();
  givejetton_ = value;
}

// -------------------------------------------------------------------

// lkpyconfitem

// optional int32 type = 1;
inline bool lkpyconfitem::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lkpyconfitem::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lkpyconfitem::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lkpyconfitem::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 lkpyconfitem::type() const {
  return type_;
}
inline void lkpyconfitem::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string name = 2;
inline bool lkpyconfitem::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lkpyconfitem::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lkpyconfitem::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lkpyconfitem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& lkpyconfitem::name() const {
  return *name_;
}
inline void lkpyconfitem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void lkpyconfitem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void lkpyconfitem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lkpyconfitem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* lkpyconfitem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lkpyconfitem::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 consumetype = 3;
inline bool lkpyconfitem::has_consumetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lkpyconfitem::set_has_consumetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lkpyconfitem::clear_has_consumetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lkpyconfitem::clear_consumetype() {
  consumetype_ = 0;
  clear_has_consumetype();
}
inline ::google::protobuf::int32 lkpyconfitem::consumetype() const {
  return consumetype_;
}
inline void lkpyconfitem::set_consumetype(::google::protobuf::int32 value) {
  set_has_consumetype();
  consumetype_ = value;
}

// optional int32 consume = 4;
inline bool lkpyconfitem::has_consume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lkpyconfitem::set_has_consume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lkpyconfitem::clear_has_consume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lkpyconfitem::clear_consume() {
  consume_ = 0;
  clear_has_consume();
}
inline ::google::protobuf::int32 lkpyconfitem::consume() const {
  return consume_;
}
inline void lkpyconfitem::set_consume(::google::protobuf::int32 value) {
  set_has_consume();
  consume_ = value;
}

// -------------------------------------------------------------------

// lkpygameconf

// repeated .progame.lkpyconffish fishlist = 1;
inline int lkpygameconf::fishlist_size() const {
  return fishlist_.size();
}
inline void lkpygameconf::clear_fishlist() {
  fishlist_.Clear();
}
inline const ::progame::lkpyconffish& lkpygameconf::fishlist(int index) const {
  return fishlist_.Get(index);
}
inline ::progame::lkpyconffish* lkpygameconf::mutable_fishlist(int index) {
  return fishlist_.Mutable(index);
}
inline ::progame::lkpyconffish* lkpygameconf::add_fishlist() {
  return fishlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpyconffish >&
lkpygameconf::fishlist() const {
  return fishlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::lkpyconffish >*
lkpygameconf::mutable_fishlist() {
  return &fishlist_;
}

// repeated .progame.lkpyconfcannon cannonlist = 2;
inline int lkpygameconf::cannonlist_size() const {
  return cannonlist_.size();
}
inline void lkpygameconf::clear_cannonlist() {
  cannonlist_.Clear();
}
inline const ::progame::lkpyconfcannon& lkpygameconf::cannonlist(int index) const {
  return cannonlist_.Get(index);
}
inline ::progame::lkpyconfcannon* lkpygameconf::mutable_cannonlist(int index) {
  return cannonlist_.Mutable(index);
}
inline ::progame::lkpyconfcannon* lkpygameconf::add_cannonlist() {
  return cannonlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpyconfcannon >&
lkpygameconf::cannonlist() const {
  return cannonlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::lkpyconfcannon >*
lkpygameconf::mutable_cannonlist() {
  return &cannonlist_;
}

// optional float fireinterval = 3;
inline bool lkpygameconf::has_fireinterval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lkpygameconf::set_has_fireinterval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lkpygameconf::clear_has_fireinterval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lkpygameconf::clear_fireinterval() {
  fireinterval_ = 0;
  clear_has_fireinterval();
}
inline float lkpygameconf::fireinterval() const {
  return fireinterval_;
}
inline void lkpygameconf::set_fireinterval(float value) {
  set_has_fireinterval();
  fireinterval_ = value;
}

// optional int32 ionneedpower = 4;
inline bool lkpygameconf::has_ionneedpower() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lkpygameconf::set_has_ionneedpower() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lkpygameconf::clear_has_ionneedpower() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lkpygameconf::clear_ionneedpower() {
  ionneedpower_ = 0;
  clear_has_ionneedpower();
}
inline ::google::protobuf::int32 lkpygameconf::ionneedpower() const {
  return ionneedpower_;
}
inline void lkpygameconf::set_ionneedpower(::google::protobuf::int32 value) {
  set_has_ionneedpower();
  ionneedpower_ = value;
}

// optional int32 rangebombradius = 5;
inline bool lkpygameconf::has_rangebombradius() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void lkpygameconf::set_has_rangebombradius() {
  _has_bits_[0] |= 0x00000010u;
}
inline void lkpygameconf::clear_has_rangebombradius() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void lkpygameconf::clear_rangebombradius() {
  rangebombradius_ = 0;
  clear_has_rangebombradius();
}
inline ::google::protobuf::int32 lkpygameconf::rangebombradius() const {
  return rangebombradius_;
}
inline void lkpygameconf::set_rangebombradius(::google::protobuf::int32 value) {
  set_has_rangebombradius();
  rangebombradius_ = value;
}

// optional float freezetime = 6;
inline bool lkpygameconf::has_freezetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void lkpygameconf::set_has_freezetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void lkpygameconf::clear_has_freezetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void lkpygameconf::clear_freezetime() {
  freezetime_ = 0;
  clear_has_freezetime();
}
inline float lkpygameconf::freezetime() const {
  return freezetime_;
}
inline void lkpygameconf::set_freezetime(float value) {
  set_has_freezetime();
  freezetime_ = value;
}

// repeated .progame.lkpyconfitem itemlist = 7;
inline int lkpygameconf::itemlist_size() const {
  return itemlist_.size();
}
inline void lkpygameconf::clear_itemlist() {
  itemlist_.Clear();
}
inline const ::progame::lkpyconfitem& lkpygameconf::itemlist(int index) const {
  return itemlist_.Get(index);
}
inline ::progame::lkpyconfitem* lkpygameconf::mutable_itemlist(int index) {
  return itemlist_.Mutable(index);
}
inline ::progame::lkpyconfitem* lkpygameconf::add_itemlist() {
  return itemlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpyconfitem >&
lkpygameconf::itemlist() const {
  return itemlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::lkpyconfitem >*
lkpygameconf::mutable_itemlist() {
  return &itemlist_;
}

// optional float freezecooldown = 8;
inline bool lkpygameconf::has_freezecooldown() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void lkpygameconf::set_has_freezecooldown() {
  _has_bits_[0] |= 0x00000080u;
}
inline void lkpygameconf::clear_has_freezecooldown() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void lkpygameconf::clear_freezecooldown() {
  freezecooldown_ = 0;
  clear_has_freezecooldown();
}
inline float lkpygameconf::freezecooldown() const {
  return freezecooldown_;
}
inline void lkpygameconf::set_freezecooldown(float value) {
  set_has_freezecooldown();
  freezecooldown_ = value;
}

// optional float locktime = 9;
inline bool lkpygameconf::has_locktime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void lkpygameconf::set_has_locktime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void lkpygameconf::clear_has_locktime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void lkpygameconf::clear_locktime() {
  locktime_ = 0;
  clear_has_locktime();
}
inline float lkpygameconf::locktime() const {
  return locktime_;
}
inline void lkpygameconf::set_locktime(float value) {
  set_has_locktime();
  locktime_ = value;
}

// optional float lockcooldown = 10;
inline bool lkpygameconf::has_lockcooldown() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void lkpygameconf::set_has_lockcooldown() {
  _has_bits_[0] |= 0x00000200u;
}
inline void lkpygameconf::clear_has_lockcooldown() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void lkpygameconf::clear_lockcooldown() {
  lockcooldown_ = 0;
  clear_has_lockcooldown();
}
inline float lkpygameconf::lockcooldown() const {
  return lockcooldown_;
}
inline void lkpygameconf::set_lockcooldown(float value) {
  set_has_lockcooldown();
  lockcooldown_ = value;
}

// -------------------------------------------------------------------

// lkpycreatefish

// optional int32 type = 1;
inline bool lkpycreatefish::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lkpycreatefish::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lkpycreatefish::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lkpycreatefish::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 lkpycreatefish::type() const {
  return type_;
}
inline void lkpycreatefish::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 id = 2;
inline bool lkpycreatefish::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lkpycreatefish::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lkpycreatefish::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lkpycreatefish::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 lkpycreatefish::id() const {
  return id_;
}
inline void lkpycreatefish::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 pathid = 3;
inline bool lkpycreatefish::has_pathid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lkpycreatefish::set_has_pathid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lkpycreatefish::clear_has_pathid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lkpycreatefish::clear_pathid() {
  pathid_ = 0;
  clear_has_pathid();
}
inline ::google::protobuf::int32 lkpycreatefish::pathid() const {
  return pathid_;
}
inline void lkpycreatefish::set_pathid(::google::protobuf::int32 value) {
  set_has_pathid();
  pathid_ = value;
}

// optional int32 pathtype = 4;
inline bool lkpycreatefish::has_pathtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lkpycreatefish::set_has_pathtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lkpycreatefish::clear_has_pathtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lkpycreatefish::clear_pathtype() {
  pathtype_ = 0;
  clear_has_pathtype();
}
inline ::google::protobuf::int32 lkpycreatefish::pathtype() const {
  return pathtype_;
}
inline void lkpycreatefish::set_pathtype(::google::protobuf::int32 value) {
  set_has_pathtype();
  pathtype_ = value;
}

// optional int32 width = 5;
inline bool lkpycreatefish::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void lkpycreatefish::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void lkpycreatefish::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void lkpycreatefish::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 lkpycreatefish::width() const {
  return width_;
}
inline void lkpycreatefish::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 6;
inline bool lkpycreatefish::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void lkpycreatefish::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void lkpycreatefish::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void lkpycreatefish::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 lkpycreatefish::height() const {
  return height_;
}
inline void lkpycreatefish::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional float offsetx = 7;
inline bool lkpycreatefish::has_offsetx() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void lkpycreatefish::set_has_offsetx() {
  _has_bits_[0] |= 0x00000040u;
}
inline void lkpycreatefish::clear_has_offsetx() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void lkpycreatefish::clear_offsetx() {
  offsetx_ = 0;
  clear_has_offsetx();
}
inline float lkpycreatefish::offsetx() const {
  return offsetx_;
}
inline void lkpycreatefish::set_offsetx(float value) {
  set_has_offsetx();
  offsetx_ = value;
}

// optional float offsety = 8;
inline bool lkpycreatefish::has_offsety() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void lkpycreatefish::set_has_offsety() {
  _has_bits_[0] |= 0x00000080u;
}
inline void lkpycreatefish::clear_has_offsety() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void lkpycreatefish::clear_offsety() {
  offsety_ = 0;
  clear_has_offsety();
}
inline float lkpycreatefish::offsety() const {
  return offsety_;
}
inline void lkpycreatefish::set_offsety(float value) {
  set_has_offsety();
  offsety_ = value;
}

// optional float delay = 9;
inline bool lkpycreatefish::has_delay() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void lkpycreatefish::set_has_delay() {
  _has_bits_[0] |= 0x00000100u;
}
inline void lkpycreatefish::clear_has_delay() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void lkpycreatefish::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline float lkpycreatefish::delay() const {
  return delay_;
}
inline void lkpycreatefish::set_delay(float value) {
  set_has_delay();
  delay_ = value;
}

// optional float elaspe = 10;
inline bool lkpycreatefish::has_elaspe() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void lkpycreatefish::set_has_elaspe() {
  _has_bits_[0] |= 0x00000200u;
}
inline void lkpycreatefish::clear_has_elaspe() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void lkpycreatefish::clear_elaspe() {
  elaspe_ = 0;
  clear_has_elaspe();
}
inline float lkpycreatefish::elaspe() const {
  return elaspe_;
}
inline void lkpycreatefish::set_elaspe(float value) {
  set_has_elaspe();
  elaspe_ = value;
}

// optional float speed = 11;
inline bool lkpycreatefish::has_speed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void lkpycreatefish::set_has_speed() {
  _has_bits_[0] |= 0x00000400u;
}
inline void lkpycreatefish::clear_has_speed() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void lkpycreatefish::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float lkpycreatefish::speed() const {
  return speed_;
}
inline void lkpycreatefish::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// optional double borntime = 12;
inline bool lkpycreatefish::has_borntime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void lkpycreatefish::set_has_borntime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void lkpycreatefish::clear_has_borntime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void lkpycreatefish::clear_borntime() {
  borntime_ = 0;
  clear_has_borntime();
}
inline double lkpycreatefish::borntime() const {
  return borntime_;
}
inline void lkpycreatefish::set_borntime(double value) {
  set_has_borntime();
  borntime_ = value;
}

// optional int32 data = 13;
inline bool lkpycreatefish::has_data() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void lkpycreatefish::set_has_data() {
  _has_bits_[0] |= 0x00001000u;
}
inline void lkpycreatefish::clear_has_data() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void lkpycreatefish::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline ::google::protobuf::int32 lkpycreatefish::data() const {
  return data_;
}
inline void lkpycreatefish::set_data(::google::protobuf::int32 value) {
  set_has_data();
  data_ = value;
}

// optional int32 score = 14;
inline bool lkpycreatefish::has_score() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void lkpycreatefish::set_has_score() {
  _has_bits_[0] |= 0x00002000u;
}
inline void lkpycreatefish::clear_has_score() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void lkpycreatefish::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 lkpycreatefish::score() const {
  return score_;
}
inline void lkpycreatefish::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 attrid = 15;
inline bool lkpycreatefish::has_attrid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void lkpycreatefish::set_has_attrid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void lkpycreatefish::clear_has_attrid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void lkpycreatefish::clear_attrid() {
  attrid_ = 0;
  clear_has_attrid();
}
inline ::google::protobuf::int32 lkpycreatefish::attrid() const {
  return attrid_;
}
inline void lkpycreatefish::set_attrid(::google::protobuf::int32 value) {
  set_has_attrid();
  attrid_ = value;
}

// optional int32 chairid = 16;
inline bool lkpycreatefish::has_chairid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void lkpycreatefish::set_has_chairid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void lkpycreatefish::clear_has_chairid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void lkpycreatefish::clear_chairid() {
  chairid_ = 0;
  clear_has_chairid();
}
inline ::google::protobuf::int32 lkpycreatefish::chairid() const {
  return chairid_;
}
inline void lkpycreatefish::set_chairid(::google::protobuf::int32 value) {
  set_has_chairid();
  chairid_ = value;
}

// optional float lifecycle = 17;
inline bool lkpycreatefish::has_lifecycle() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void lkpycreatefish::set_has_lifecycle() {
  _has_bits_[0] |= 0x00010000u;
}
inline void lkpycreatefish::clear_has_lifecycle() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void lkpycreatefish::clear_lifecycle() {
  lifecycle_ = 0;
  clear_has_lifecycle();
}
inline float lkpycreatefish::lifecycle() const {
  return lifecycle_;
}
inline void lkpycreatefish::set_lifecycle(float value) {
  set_has_lifecycle();
  lifecycle_ = value;
}

// -------------------------------------------------------------------

// lkpycreatebullet

// optional int32 cannontype = 1;
inline bool lkpycreatebullet::has_cannontype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lkpycreatebullet::set_has_cannontype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lkpycreatebullet::clear_has_cannontype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lkpycreatebullet::clear_cannontype() {
  cannontype_ = 0;
  clear_has_cannontype();
}
inline ::google::protobuf::int32 lkpycreatebullet::cannontype() const {
  return cannontype_;
}
inline void lkpycreatebullet::set_cannontype(::google::protobuf::int32 value) {
  set_has_cannontype();
  cannontype_ = value;
}

// optional int32 id = 2;
inline bool lkpycreatebullet::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lkpycreatebullet::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lkpycreatebullet::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lkpycreatebullet::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 lkpycreatebullet::id() const {
  return id_;
}
inline void lkpycreatebullet::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional float speed = 3;
inline bool lkpycreatebullet::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lkpycreatebullet::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lkpycreatebullet::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lkpycreatebullet::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float lkpycreatebullet::speed() const {
  return speed_;
}
inline void lkpycreatebullet::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// optional float posx = 4;
inline bool lkpycreatebullet::has_posx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lkpycreatebullet::set_has_posx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lkpycreatebullet::clear_has_posx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lkpycreatebullet::clear_posx() {
  posx_ = 0;
  clear_has_posx();
}
inline float lkpycreatebullet::posx() const {
  return posx_;
}
inline void lkpycreatebullet::set_posx(float value) {
  set_has_posx();
  posx_ = value;
}

// optional float posy = 5;
inline bool lkpycreatebullet::has_posy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void lkpycreatebullet::set_has_posy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void lkpycreatebullet::clear_has_posy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void lkpycreatebullet::clear_posy() {
  posy_ = 0;
  clear_has_posy();
}
inline float lkpycreatebullet::posy() const {
  return posy_;
}
inline void lkpycreatebullet::set_posy(float value) {
  set_has_posy();
  posy_ = value;
}

// optional float direction = 6;
inline bool lkpycreatebullet::has_direction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void lkpycreatebullet::set_has_direction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void lkpycreatebullet::clear_has_direction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void lkpycreatebullet::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline float lkpycreatebullet::direction() const {
  return direction_;
}
inline void lkpycreatebullet::set_direction(float value) {
  set_has_direction();
  direction_ = value;
}

// optional int32 elaspe = 7;
inline bool lkpycreatebullet::has_elaspe() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void lkpycreatebullet::set_has_elaspe() {
  _has_bits_[0] |= 0x00000040u;
}
inline void lkpycreatebullet::clear_has_elaspe() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void lkpycreatebullet::clear_elaspe() {
  elaspe_ = 0;
  clear_has_elaspe();
}
inline ::google::protobuf::int32 lkpycreatebullet::elaspe() const {
  return elaspe_;
}
inline void lkpycreatebullet::set_elaspe(::google::protobuf::int32 value) {
  set_has_elaspe();
  elaspe_ = value;
}

// optional int32 itemid = 8;
inline bool lkpycreatebullet::has_itemid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void lkpycreatebullet::set_has_itemid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void lkpycreatebullet::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void lkpycreatebullet::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 lkpycreatebullet::itemid() const {
  return itemid_;
}
inline void lkpycreatebullet::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 fishid = 9;
inline bool lkpycreatebullet::has_fishid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void lkpycreatebullet::set_has_fishid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void lkpycreatebullet::clear_has_fishid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void lkpycreatebullet::clear_fishid() {
  fishid_ = 0;
  clear_has_fishid();
}
inline ::google::protobuf::int32 lkpycreatebullet::fishid() const {
  return fishid_;
}
inline void lkpycreatebullet::set_fishid(::google::protobuf::int32 value) {
  set_has_fishid();
  fishid_ = value;
}

// optional int32 mul = 10;
inline bool lkpycreatebullet::has_mul() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void lkpycreatebullet::set_has_mul() {
  _has_bits_[0] |= 0x00000200u;
}
inline void lkpycreatebullet::clear_has_mul() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void lkpycreatebullet::clear_mul() {
  mul_ = 0;
  clear_has_mul();
}
inline ::google::protobuf::int32 lkpycreatebullet::mul() const {
  return mul_;
}
inline void lkpycreatebullet::set_mul(::google::protobuf::int32 value) {
  set_has_mul();
  mul_ = value;
}

// optional int32 new = 11;
inline bool lkpycreatebullet::has_new_() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void lkpycreatebullet::set_has_new_() {
  _has_bits_[0] |= 0x00000400u;
}
inline void lkpycreatebullet::clear_has_new_() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void lkpycreatebullet::clear_new_() {
  new__ = 0;
  clear_has_new_();
}
inline ::google::protobuf::int32 lkpycreatebullet::new_() const {
  return new__;
}
inline void lkpycreatebullet::set_new_(::google::protobuf::int32 value) {
  set_has_new_();
  new__ = value;
}

// optional int32 tubenum = 12;
inline bool lkpycreatebullet::has_tubenum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void lkpycreatebullet::set_has_tubenum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void lkpycreatebullet::clear_has_tubenum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void lkpycreatebullet::clear_tubenum() {
  tubenum_ = 0;
  clear_has_tubenum();
}
inline ::google::protobuf::int32 lkpycreatebullet::tubenum() const {
  return tubenum_;
}
inline void lkpycreatebullet::set_tubenum(::google::protobuf::int32 value) {
  set_has_tubenum();
  tubenum_ = value;
}

// -------------------------------------------------------------------

// lkpyitem

// optional int32 itemid = 1;
inline bool lkpyitem::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lkpyitem::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lkpyitem::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lkpyitem::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 lkpyitem::itemid() const {
  return itemid_;
}
inline void lkpyitem::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 slotid = 2;
inline bool lkpyitem::has_slotid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lkpyitem::set_has_slotid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lkpyitem::clear_has_slotid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lkpyitem::clear_slotid() {
  slotid_ = 0;
  clear_has_slotid();
}
inline ::google::protobuf::int32 lkpyitem::slotid() const {
  return slotid_;
}
inline void lkpyitem::set_slotid(::google::protobuf::int32 value) {
  set_has_slotid();
  slotid_ = value;
}

// optional int32 itemnum = 3;
inline bool lkpyitem::has_itemnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lkpyitem::set_has_itemnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lkpyitem::clear_has_itemnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lkpyitem::clear_itemnum() {
  itemnum_ = 0;
  clear_has_itemnum();
}
inline ::google::protobuf::int32 lkpyitem::itemnum() const {
  return itemnum_;
}
inline void lkpyitem::set_itemnum(::google::protobuf::int32 value) {
  set_has_itemnum();
  itemnum_ = value;
}

// optional int32 type = 4;
inline bool lkpyitem::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lkpyitem::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lkpyitem::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lkpyitem::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 lkpyitem::type() const {
  return type_;
}
inline void lkpyitem::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// lkpyuser

// optional int32 userid = 1;
inline bool lkpyuser::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lkpyuser::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lkpyuser::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lkpyuser::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 lkpyuser::userid() const {
  return userid_;
}
inline void lkpyuser::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional int32 chairid = 2;
inline bool lkpyuser::has_chairid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lkpyuser::set_has_chairid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lkpyuser::clear_has_chairid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lkpyuser::clear_chairid() {
  chairid_ = 0;
  clear_has_chairid();
}
inline ::google::protobuf::int32 lkpyuser::chairid() const {
  return chairid_;
}
inline void lkpyuser::set_chairid(::google::protobuf::int32 value) {
  set_has_chairid();
  chairid_ = value;
}

// optional string nickname = 3;
inline bool lkpyuser::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lkpyuser::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lkpyuser::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lkpyuser::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& lkpyuser::nickname() const {
  return *nickname_;
}
inline void lkpyuser::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void lkpyuser::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void lkpyuser::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lkpyuser::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* lkpyuser::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lkpyuser::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string faceid = 4;
inline bool lkpyuser::has_faceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lkpyuser::set_has_faceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lkpyuser::clear_has_faceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lkpyuser::clear_faceid() {
  if (faceid_ != &::google::protobuf::internal::kEmptyString) {
    faceid_->clear();
  }
  clear_has_faceid();
}
inline const ::std::string& lkpyuser::faceid() const {
  return *faceid_;
}
inline void lkpyuser::set_faceid(const ::std::string& value) {
  set_has_faceid();
  if (faceid_ == &::google::protobuf::internal::kEmptyString) {
    faceid_ = new ::std::string;
  }
  faceid_->assign(value);
}
inline void lkpyuser::set_faceid(const char* value) {
  set_has_faceid();
  if (faceid_ == &::google::protobuf::internal::kEmptyString) {
    faceid_ = new ::std::string;
  }
  faceid_->assign(value);
}
inline void lkpyuser::set_faceid(const char* value, size_t size) {
  set_has_faceid();
  if (faceid_ == &::google::protobuf::internal::kEmptyString) {
    faceid_ = new ::std::string;
  }
  faceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lkpyuser::mutable_faceid() {
  set_has_faceid();
  if (faceid_ == &::google::protobuf::internal::kEmptyString) {
    faceid_ = new ::std::string;
  }
  return faceid_;
}
inline ::std::string* lkpyuser::release_faceid() {
  clear_has_faceid();
  if (faceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = faceid_;
    faceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lkpyuser::set_allocated_faceid(::std::string* faceid) {
  if (faceid_ != &::google::protobuf::internal::kEmptyString) {
    delete faceid_;
  }
  if (faceid) {
    set_has_faceid();
    faceid_ = faceid;
  } else {
    clear_has_faceid();
    faceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sex = 5;
inline bool lkpyuser::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void lkpyuser::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void lkpyuser::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void lkpyuser::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 lkpyuser::sex() const {
  return sex_;
}
inline void lkpyuser::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional string jetton = 6;
inline bool lkpyuser::has_jetton() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void lkpyuser::set_has_jetton() {
  _has_bits_[0] |= 0x00000020u;
}
inline void lkpyuser::clear_has_jetton() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void lkpyuser::clear_jetton() {
  if (jetton_ != &::google::protobuf::internal::kEmptyString) {
    jetton_->clear();
  }
  clear_has_jetton();
}
inline const ::std::string& lkpyuser::jetton() const {
  return *jetton_;
}
inline void lkpyuser::set_jetton(const ::std::string& value) {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  jetton_->assign(value);
}
inline void lkpyuser::set_jetton(const char* value) {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  jetton_->assign(value);
}
inline void lkpyuser::set_jetton(const char* value, size_t size) {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  jetton_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lkpyuser::mutable_jetton() {
  set_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    jetton_ = new ::std::string;
  }
  return jetton_;
}
inline ::std::string* lkpyuser::release_jetton() {
  clear_has_jetton();
  if (jetton_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jetton_;
    jetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lkpyuser::set_allocated_jetton(::std::string* jetton) {
  if (jetton_ != &::google::protobuf::internal::kEmptyString) {
    delete jetton_;
  }
  if (jetton) {
    set_has_jetton();
    jetton_ = jetton;
  } else {
    clear_has_jetton();
    jetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string money = 7;
inline bool lkpyuser::has_money() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void lkpyuser::set_has_money() {
  _has_bits_[0] |= 0x00000040u;
}
inline void lkpyuser::clear_has_money() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void lkpyuser::clear_money() {
  if (money_ != &::google::protobuf::internal::kEmptyString) {
    money_->clear();
  }
  clear_has_money();
}
inline const ::std::string& lkpyuser::money() const {
  return *money_;
}
inline void lkpyuser::set_money(const ::std::string& value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void lkpyuser::set_money(const char* value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void lkpyuser::set_money(const char* value, size_t size) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lkpyuser::mutable_money() {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  return money_;
}
inline ::std::string* lkpyuser::release_money() {
  clear_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = money_;
    money_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lkpyuser::set_allocated_money(::std::string* money) {
  if (money_ != &::google::protobuf::internal::kEmptyString) {
    delete money_;
  }
  if (money) {
    set_has_money();
    money_ = money;
  } else {
    clear_has_money();
    money_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 isrobot = 8;
inline bool lkpyuser::has_isrobot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void lkpyuser::set_has_isrobot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void lkpyuser::clear_has_isrobot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void lkpyuser::clear_isrobot() {
  isrobot_ = 0;
  clear_has_isrobot();
}
inline ::google::protobuf::int32 lkpyuser::isrobot() const {
  return isrobot_;
}
inline void lkpyuser::set_isrobot(::google::protobuf::int32 value) {
  set_has_isrobot();
  isrobot_ = value;
}

// optional int32 cannontype = 9;
inline bool lkpyuser::has_cannontype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void lkpyuser::set_has_cannontype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void lkpyuser::clear_has_cannontype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void lkpyuser::clear_cannontype() {
  cannontype_ = 0;
  clear_has_cannontype();
}
inline ::google::protobuf::int32 lkpyuser::cannontype() const {
  return cannontype_;
}
inline void lkpyuser::set_cannontype(::google::protobuf::int32 value) {
  set_has_cannontype();
  cannontype_ = value;
}

// optional int32 cannonlv = 10;
inline bool lkpyuser::has_cannonlv() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void lkpyuser::set_has_cannonlv() {
  _has_bits_[0] |= 0x00000200u;
}
inline void lkpyuser::clear_has_cannonlv() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void lkpyuser::clear_cannonlv() {
  cannonlv_ = 0;
  clear_has_cannonlv();
}
inline ::google::protobuf::int32 lkpyuser::cannonlv() const {
  return cannonlv_;
}
inline void lkpyuser::set_cannonlv(::google::protobuf::int32 value) {
  set_has_cannonlv();
  cannonlv_ = value;
}

// optional string bank_jetton = 11;
inline bool lkpyuser::has_bank_jetton() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void lkpyuser::set_has_bank_jetton() {
  _has_bits_[0] |= 0x00000400u;
}
inline void lkpyuser::clear_has_bank_jetton() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void lkpyuser::clear_bank_jetton() {
  if (bank_jetton_ != &::google::protobuf::internal::kEmptyString) {
    bank_jetton_->clear();
  }
  clear_has_bank_jetton();
}
inline const ::std::string& lkpyuser::bank_jetton() const {
  return *bank_jetton_;
}
inline void lkpyuser::set_bank_jetton(const ::std::string& value) {
  set_has_bank_jetton();
  if (bank_jetton_ == &::google::protobuf::internal::kEmptyString) {
    bank_jetton_ = new ::std::string;
  }
  bank_jetton_->assign(value);
}
inline void lkpyuser::set_bank_jetton(const char* value) {
  set_has_bank_jetton();
  if (bank_jetton_ == &::google::protobuf::internal::kEmptyString) {
    bank_jetton_ = new ::std::string;
  }
  bank_jetton_->assign(value);
}
inline void lkpyuser::set_bank_jetton(const char* value, size_t size) {
  set_has_bank_jetton();
  if (bank_jetton_ == &::google::protobuf::internal::kEmptyString) {
    bank_jetton_ = new ::std::string;
  }
  bank_jetton_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lkpyuser::mutable_bank_jetton() {
  set_has_bank_jetton();
  if (bank_jetton_ == &::google::protobuf::internal::kEmptyString) {
    bank_jetton_ = new ::std::string;
  }
  return bank_jetton_;
}
inline ::std::string* lkpyuser::release_bank_jetton() {
  clear_has_bank_jetton();
  if (bank_jetton_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bank_jetton_;
    bank_jetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lkpyuser::set_allocated_bank_jetton(::std::string* bank_jetton) {
  if (bank_jetton_ != &::google::protobuf::internal::kEmptyString) {
    delete bank_jetton_;
  }
  if (bank_jetton) {
    set_has_bank_jetton();
    bank_jetton_ = bank_jetton;
  } else {
    clear_has_bank_jetton();
    bank_jetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 state = 12;
inline bool lkpyuser::has_state() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void lkpyuser::set_has_state() {
  _has_bits_[0] |= 0x00000800u;
}
inline void lkpyuser::clear_has_state() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void lkpyuser::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 lkpyuser::state() const {
  return state_;
}
inline void lkpyuser::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// repeated int32 cannonlist = 13;
inline int lkpyuser::cannonlist_size() const {
  return cannonlist_.size();
}
inline void lkpyuser::clear_cannonlist() {
  cannonlist_.Clear();
}
inline ::google::protobuf::int32 lkpyuser::cannonlist(int index) const {
  return cannonlist_.Get(index);
}
inline void lkpyuser::set_cannonlist(int index, ::google::protobuf::int32 value) {
  cannonlist_.Set(index, value);
}
inline void lkpyuser::add_cannonlist(::google::protobuf::int32 value) {
  cannonlist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
lkpyuser::cannonlist() const {
  return cannonlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
lkpyuser::mutable_cannonlist() {
  return &cannonlist_;
}

// repeated .progame.lkpycreatebullet createbulletlist = 14;
inline int lkpyuser::createbulletlist_size() const {
  return createbulletlist_.size();
}
inline void lkpyuser::clear_createbulletlist() {
  createbulletlist_.Clear();
}
inline const ::progame::lkpycreatebullet& lkpyuser::createbulletlist(int index) const {
  return createbulletlist_.Get(index);
}
inline ::progame::lkpycreatebullet* lkpyuser::mutable_createbulletlist(int index) {
  return createbulletlist_.Mutable(index);
}
inline ::progame::lkpycreatebullet* lkpyuser::add_createbulletlist() {
  return createbulletlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpycreatebullet >&
lkpyuser::createbulletlist() const {
  return createbulletlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::lkpycreatebullet >*
lkpyuser::mutable_createbulletlist() {
  return &createbulletlist_;
}

// repeated .progame.lkpyitem backpack = 15;
inline int lkpyuser::backpack_size() const {
  return backpack_.size();
}
inline void lkpyuser::clear_backpack() {
  backpack_.Clear();
}
inline const ::progame::lkpyitem& lkpyuser::backpack(int index) const {
  return backpack_.Get(index);
}
inline ::progame::lkpyitem* lkpyuser::mutable_backpack(int index) {
  return backpack_.Mutable(index);
}
inline ::progame::lkpyitem* lkpyuser::add_backpack() {
  return backpack_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpyitem >&
lkpyuser::backpack() const {
  return backpack_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::lkpyitem >*
lkpyuser::mutable_backpack() {
  return &backpack_;
}

// optional int32 tubenum = 16;
inline bool lkpyuser::has_tubenum() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void lkpyuser::set_has_tubenum() {
  _has_bits_[0] |= 0x00008000u;
}
inline void lkpyuser::clear_has_tubenum() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void lkpyuser::clear_tubenum() {
  tubenum_ = 0;
  clear_has_tubenum();
}
inline ::google::protobuf::int32 lkpyuser::tubenum() const {
  return tubenum_;
}
inline void lkpyuser::set_tubenum(::google::protobuf::int32 value) {
  set_has_tubenum();
  tubenum_ = value;
}

// optional int32 cannonmul = 17;
inline bool lkpyuser::has_cannonmul() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void lkpyuser::set_has_cannonmul() {
  _has_bits_[0] |= 0x00010000u;
}
inline void lkpyuser::clear_has_cannonmul() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void lkpyuser::clear_cannonmul() {
  cannonmul_ = 0;
  clear_has_cannonmul();
}
inline ::google::protobuf::int32 lkpyuser::cannonmul() const {
  return cannonmul_;
}
inline void lkpyuser::set_cannonmul(::google::protobuf::int32 value) {
  set_has_cannonmul();
  cannonmul_ = value;
}

// optional double lastfiretime = 18;
inline bool lkpyuser::has_lastfiretime() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void lkpyuser::set_has_lastfiretime() {
  _has_bits_[0] |= 0x00020000u;
}
inline void lkpyuser::clear_has_lastfiretime() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void lkpyuser::clear_lastfiretime() {
  lastfiretime_ = 0;
  clear_has_lastfiretime();
}
inline double lkpyuser::lastfiretime() const {
  return lastfiretime_;
}
inline void lkpyuser::set_lastfiretime(double value) {
  set_has_lastfiretime();
  lastfiretime_ = value;
}

// -------------------------------------------------------------------

// lkpyuseitem

// optional int32 userid = 1;
inline bool lkpyuseitem::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lkpyuseitem::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lkpyuseitem::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lkpyuseitem::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 lkpyuseitem::userid() const {
  return userid_;
}
inline void lkpyuseitem::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional int32 type = 2;
inline bool lkpyuseitem::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lkpyuseitem::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lkpyuseitem::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lkpyuseitem::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 lkpyuseitem::type() const {
  return type_;
}
inline void lkpyuseitem::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional double time = 3;
inline bool lkpyuseitem::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lkpyuseitem::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lkpyuseitem::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lkpyuseitem::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double lkpyuseitem::time() const {
  return time_;
}
inline void lkpyuseitem::set_time(double value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// lkpyinfo

// optional int32 tableid = 1;
inline bool lkpyinfo::has_tableid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lkpyinfo::set_has_tableid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lkpyinfo::clear_has_tableid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lkpyinfo::clear_tableid() {
  tableid_ = 0;
  clear_has_tableid();
}
inline ::google::protobuf::int32 lkpyinfo::tableid() const {
  return tableid_;
}
inline void lkpyinfo::set_tableid(::google::protobuf::int32 value) {
  set_has_tableid();
  tableid_ = value;
}

// optional int32 tabletype = 2;
inline bool lkpyinfo::has_tabletype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lkpyinfo::set_has_tabletype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lkpyinfo::clear_has_tabletype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lkpyinfo::clear_tabletype() {
  tabletype_ = 0;
  clear_has_tabletype();
}
inline ::google::protobuf::int32 lkpyinfo::tabletype() const {
  return tabletype_;
}
inline void lkpyinfo::set_tabletype(::google::protobuf::int32 value) {
  set_has_tabletype();
  tabletype_ = value;
}

// optional int32 state = 3;
inline bool lkpyinfo::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lkpyinfo::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lkpyinfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lkpyinfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 lkpyinfo::state() const {
  return state_;
}
inline void lkpyinfo::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional int32 timemark = 4;
inline bool lkpyinfo::has_timemark() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lkpyinfo::set_has_timemark() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lkpyinfo::clear_has_timemark() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lkpyinfo::clear_timemark() {
  timemark_ = 0;
  clear_has_timemark();
}
inline ::google::protobuf::int32 lkpyinfo::timemark() const {
  return timemark_;
}
inline void lkpyinfo::set_timemark(::google::protobuf::int32 value) {
  set_has_timemark();
  timemark_ = value;
}

// optional string minenter = 5;
inline bool lkpyinfo::has_minenter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void lkpyinfo::set_has_minenter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void lkpyinfo::clear_has_minenter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void lkpyinfo::clear_minenter() {
  if (minenter_ != &::google::protobuf::internal::kEmptyString) {
    minenter_->clear();
  }
  clear_has_minenter();
}
inline const ::std::string& lkpyinfo::minenter() const {
  return *minenter_;
}
inline void lkpyinfo::set_minenter(const ::std::string& value) {
  set_has_minenter();
  if (minenter_ == &::google::protobuf::internal::kEmptyString) {
    minenter_ = new ::std::string;
  }
  minenter_->assign(value);
}
inline void lkpyinfo::set_minenter(const char* value) {
  set_has_minenter();
  if (minenter_ == &::google::protobuf::internal::kEmptyString) {
    minenter_ = new ::std::string;
  }
  minenter_->assign(value);
}
inline void lkpyinfo::set_minenter(const char* value, size_t size) {
  set_has_minenter();
  if (minenter_ == &::google::protobuf::internal::kEmptyString) {
    minenter_ = new ::std::string;
  }
  minenter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lkpyinfo::mutable_minenter() {
  set_has_minenter();
  if (minenter_ == &::google::protobuf::internal::kEmptyString) {
    minenter_ = new ::std::string;
  }
  return minenter_;
}
inline ::std::string* lkpyinfo::release_minenter() {
  clear_has_minenter();
  if (minenter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = minenter_;
    minenter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lkpyinfo::set_allocated_minenter(::std::string* minenter) {
  if (minenter_ != &::google::protobuf::internal::kEmptyString) {
    delete minenter_;
  }
  if (minenter) {
    set_has_minenter();
    minenter_ = minenter;
  } else {
    clear_has_minenter();
    minenter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string maxenter = 6;
inline bool lkpyinfo::has_maxenter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void lkpyinfo::set_has_maxenter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void lkpyinfo::clear_has_maxenter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void lkpyinfo::clear_maxenter() {
  if (maxenter_ != &::google::protobuf::internal::kEmptyString) {
    maxenter_->clear();
  }
  clear_has_maxenter();
}
inline const ::std::string& lkpyinfo::maxenter() const {
  return *maxenter_;
}
inline void lkpyinfo::set_maxenter(const ::std::string& value) {
  set_has_maxenter();
  if (maxenter_ == &::google::protobuf::internal::kEmptyString) {
    maxenter_ = new ::std::string;
  }
  maxenter_->assign(value);
}
inline void lkpyinfo::set_maxenter(const char* value) {
  set_has_maxenter();
  if (maxenter_ == &::google::protobuf::internal::kEmptyString) {
    maxenter_ = new ::std::string;
  }
  maxenter_->assign(value);
}
inline void lkpyinfo::set_maxenter(const char* value, size_t size) {
  set_has_maxenter();
  if (maxenter_ == &::google::protobuf::internal::kEmptyString) {
    maxenter_ = new ::std::string;
  }
  maxenter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lkpyinfo::mutable_maxenter() {
  set_has_maxenter();
  if (maxenter_ == &::google::protobuf::internal::kEmptyString) {
    maxenter_ = new ::std::string;
  }
  return maxenter_;
}
inline ::std::string* lkpyinfo::release_maxenter() {
  clear_has_maxenter();
  if (maxenter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = maxenter_;
    maxenter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lkpyinfo::set_allocated_maxenter(::std::string* maxenter) {
  if (maxenter_ != &::google::protobuf::internal::kEmptyString) {
    delete maxenter_;
  }
  if (maxenter) {
    set_has_maxenter();
    maxenter_ = maxenter;
  } else {
    clear_has_maxenter();
    maxenter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 maxuser = 13;
inline bool lkpyinfo::has_maxuser() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void lkpyinfo::set_has_maxuser() {
  _has_bits_[0] |= 0x00000040u;
}
inline void lkpyinfo::clear_has_maxuser() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void lkpyinfo::clear_maxuser() {
  maxuser_ = 0;
  clear_has_maxuser();
}
inline ::google::protobuf::int32 lkpyinfo::maxuser() const {
  return maxuser_;
}
inline void lkpyinfo::set_maxuser(::google::protobuf::int32 value) {
  set_has_maxuser();
  maxuser_ = value;
}

// repeated .progame.lkpyuser situser = 14;
inline int lkpyinfo::situser_size() const {
  return situser_.size();
}
inline void lkpyinfo::clear_situser() {
  situser_.Clear();
}
inline const ::progame::lkpyuser& lkpyinfo::situser(int index) const {
  return situser_.Get(index);
}
inline ::progame::lkpyuser* lkpyinfo::mutable_situser(int index) {
  return situser_.Mutable(index);
}
inline ::progame::lkpyuser* lkpyinfo::add_situser() {
  return situser_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpyuser >&
lkpyinfo::situser() const {
  return situser_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::lkpyuser >*
lkpyinfo::mutable_situser() {
  return &situser_;
}

// repeated int32 standuser = 15;
inline int lkpyinfo::standuser_size() const {
  return standuser_.size();
}
inline void lkpyinfo::clear_standuser() {
  standuser_.Clear();
}
inline ::google::protobuf::int32 lkpyinfo::standuser(int index) const {
  return standuser_.Get(index);
}
inline void lkpyinfo::set_standuser(int index, ::google::protobuf::int32 value) {
  standuser_.Set(index, value);
}
inline void lkpyinfo::add_standuser(::google::protobuf::int32 value) {
  standuser_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
lkpyinfo::standuser() const {
  return standuser_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
lkpyinfo::mutable_standuser() {
  return &standuser_;
}

// repeated .progame.lkpycreatefish createfishlist = 16;
inline int lkpyinfo::createfishlist_size() const {
  return createfishlist_.size();
}
inline void lkpyinfo::clear_createfishlist() {
  createfishlist_.Clear();
}
inline const ::progame::lkpycreatefish& lkpyinfo::createfishlist(int index) const {
  return createfishlist_.Get(index);
}
inline ::progame::lkpycreatefish* lkpyinfo::mutable_createfishlist(int index) {
  return createfishlist_.Mutable(index);
}
inline ::progame::lkpycreatefish* lkpyinfo::add_createfishlist() {
  return createfishlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpycreatefish >&
lkpyinfo::createfishlist() const {
  return createfishlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::lkpycreatefish >*
lkpyinfo::mutable_createfishlist() {
  return &createfishlist_;
}

// optional int32 cursceneid = 17;
inline bool lkpyinfo::has_cursceneid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void lkpyinfo::set_has_cursceneid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void lkpyinfo::clear_has_cursceneid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void lkpyinfo::clear_cursceneid() {
  cursceneid_ = 0;
  clear_has_cursceneid();
}
inline ::google::protobuf::int32 lkpyinfo::cursceneid() const {
  return cursceneid_;
}
inline void lkpyinfo::set_cursceneid(::google::protobuf::int32 value) {
  set_has_cursceneid();
  cursceneid_ = value;
}

// optional int32 presceneid = 18;
inline bool lkpyinfo::has_presceneid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void lkpyinfo::set_has_presceneid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void lkpyinfo::clear_has_presceneid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void lkpyinfo::clear_presceneid() {
  presceneid_ = 0;
  clear_has_presceneid();
}
inline ::google::protobuf::int32 lkpyinfo::presceneid() const {
  return presceneid_;
}
inline void lkpyinfo::set_presceneid(::google::protobuf::int32 value) {
  set_has_presceneid();
  presceneid_ = value;
}

// optional int32 nextfishid = 19;
inline bool lkpyinfo::has_nextfishid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void lkpyinfo::set_has_nextfishid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void lkpyinfo::clear_has_nextfishid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void lkpyinfo::clear_nextfishid() {
  nextfishid_ = 0;
  clear_has_nextfishid();
}
inline ::google::protobuf::int32 lkpyinfo::nextfishid() const {
  return nextfishid_;
}
inline void lkpyinfo::set_nextfishid(::google::protobuf::int32 value) {
  set_has_nextfishid();
  nextfishid_ = value;
}

// repeated .progame.lkpyuseitem useitemlist = 20;
inline int lkpyinfo::useitemlist_size() const {
  return useitemlist_.size();
}
inline void lkpyinfo::clear_useitemlist() {
  useitemlist_.Clear();
}
inline const ::progame::lkpyuseitem& lkpyinfo::useitemlist(int index) const {
  return useitemlist_.Get(index);
}
inline ::progame::lkpyuseitem* lkpyinfo::mutable_useitemlist(int index) {
  return useitemlist_.Mutable(index);
}
inline ::progame::lkpyuseitem* lkpyinfo::add_useitemlist() {
  return useitemlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::progame::lkpyuseitem >&
lkpyinfo::useitemlist() const {
  return useitemlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::progame::lkpyuseitem >*
lkpyinfo::mutable_useitemlist() {
  return &useitemlist_;
}

// optional int32 shoalpathtype = 21;
inline bool lkpyinfo::has_shoalpathtype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void lkpyinfo::set_has_shoalpathtype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void lkpyinfo::clear_has_shoalpathtype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void lkpyinfo::clear_shoalpathtype() {
  shoalpathtype_ = 0;
  clear_has_shoalpathtype();
}
inline ::google::protobuf::int32 lkpyinfo::shoalpathtype() const {
  return shoalpathtype_;
}
inline void lkpyinfo::set_shoalpathtype(::google::protobuf::int32 value) {
  set_has_shoalpathtype();
  shoalpathtype_ = value;
}

// optional double systime = 22;
inline bool lkpyinfo::has_systime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void lkpyinfo::set_has_systime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void lkpyinfo::clear_has_systime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void lkpyinfo::clear_systime() {
  systime_ = 0;
  clear_has_systime();
}
inline double lkpyinfo::systime() const {
  return systime_;
}
inline void lkpyinfo::set_systime(double value) {
  set_has_systime();
  systime_ = value;
}

// -------------------------------------------------------------------

// lkpycatchfish

// optional int32 id = 1;
inline bool lkpycatchfish::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lkpycatchfish::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lkpycatchfish::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lkpycatchfish::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 lkpycatchfish::id() const {
  return id_;
}
inline void lkpycatchfish::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 scoretype = 2;
inline bool lkpycatchfish::has_scoretype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lkpycatchfish::set_has_scoretype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lkpycatchfish::clear_has_scoretype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lkpycatchfish::clear_scoretype() {
  scoretype_ = 0;
  clear_has_scoretype();
}
inline ::google::protobuf::int32 lkpycatchfish::scoretype() const {
  return scoretype_;
}
inline void lkpycatchfish::set_scoretype(::google::protobuf::int32 value) {
  set_has_scoretype();
  scoretype_ = value;
}

// optional int32 score = 3;
inline bool lkpycatchfish::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lkpycatchfish::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lkpycatchfish::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lkpycatchfish::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 lkpycatchfish::score() const {
  return score_;
}
inline void lkpycatchfish::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 scoremul = 4;
inline bool lkpycatchfish::has_scoremul() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lkpycatchfish::set_has_scoremul() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lkpycatchfish::clear_has_scoremul() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lkpycatchfish::clear_scoremul() {
  scoremul_ = 0;
  clear_has_scoremul();
}
inline ::google::protobuf::int32 lkpycatchfish::scoremul() const {
  return scoremul_;
}
inline void lkpycatchfish::set_scoremul(::google::protobuf::int32 value) {
  set_has_scoremul();
  scoremul_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace progame

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_st_5flkpy_2eproto__INCLUDED
