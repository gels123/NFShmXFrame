// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: st_utils_pond.proto

#ifndef PROTOBUF_st_5futils_5fpond_2eproto__INCLUDED
#define PROTOBUF_st_5futils_5fpond_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace progame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_st_5futils_5fpond_2eproto();
void protobuf_AssignDesc_st_5futils_5fpond_2eproto();
void protobuf_ShutdownFile_st_5futils_5fpond_2eproto();

class pondinfo;
class legalinfo;

// ===================================================================

class pondinfo : public ::google::protobuf::Message {
 public:
  pondinfo();
  virtual ~pondinfo();

  pondinfo(const pondinfo& from);

  inline pondinfo& operator=(const pondinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pondinfo& default_instance();

  void Swap(pondinfo* other);

  // implements Message ----------------------------------------------

  pondinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pondinfo& from);
  void MergeFrom(const pondinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pondid = 1;
  inline bool has_pondid() const;
  inline void clear_pondid();
  static const int kPondidFieldNumber = 1;
  inline ::google::protobuf::int32 pondid() const;
  inline void set_pondid(::google::protobuf::int32 value);

  // optional int32 gametype = 2;
  inline bool has_gametype() const;
  inline void clear_gametype();
  static const int kGametypeFieldNumber = 2;
  inline ::google::protobuf::int32 gametype() const;
  inline void set_gametype(::google::protobuf::int32 value);

  // optional string jiangjetton = 3;
  inline bool has_jiangjetton() const;
  inline void clear_jiangjetton();
  static const int kJiangjettonFieldNumber = 3;
  inline const ::std::string& jiangjetton() const;
  inline void set_jiangjetton(const ::std::string& value);
  inline void set_jiangjetton(const char* value);
  inline void set_jiangjetton(const char* value, size_t size);
  inline ::std::string* mutable_jiangjetton();
  inline ::std::string* release_jiangjetton();
  inline void set_allocated_jiangjetton(::std::string* jiangjetton);

  // optional string caijetton = 4;
  inline bool has_caijetton() const;
  inline void clear_caijetton();
  static const int kCaijettonFieldNumber = 4;
  inline const ::std::string& caijetton() const;
  inline void set_caijetton(const ::std::string& value);
  inline void set_caijetton(const char* value);
  inline void set_caijetton(const char* value, size_t size);
  inline ::std::string* mutable_caijetton();
  inline ::std::string* release_caijetton();
  inline void set_allocated_caijetton(::std::string* caijetton);

  // optional int32 tabletype = 5;
  inline bool has_tabletype() const;
  inline void clear_tabletype();
  static const int kTabletypeFieldNumber = 5;
  inline ::google::protobuf::int32 tabletype() const;
  inline void set_tabletype(::google::protobuf::int32 value);

  // optional int32 level_1 = 10;
  inline bool has_level_1() const;
  inline void clear_level_1();
  static const int kLevel1FieldNumber = 10;
  inline ::google::protobuf::int32 level_1() const;
  inline void set_level_1(::google::protobuf::int32 value);

  // optional int32 rate_1 = 11;
  inline bool has_rate_1() const;
  inline void clear_rate_1();
  static const int kRate1FieldNumber = 11;
  inline ::google::protobuf::int32 rate_1() const;
  inline void set_rate_1(::google::protobuf::int32 value);

  // optional int32 level_2 = 12;
  inline bool has_level_2() const;
  inline void clear_level_2();
  static const int kLevel2FieldNumber = 12;
  inline ::google::protobuf::int32 level_2() const;
  inline void set_level_2(::google::protobuf::int32 value);

  // optional int32 rate_2 = 13;
  inline bool has_rate_2() const;
  inline void clear_rate_2();
  static const int kRate2FieldNumber = 13;
  inline ::google::protobuf::int32 rate_2() const;
  inline void set_rate_2(::google::protobuf::int32 value);

  // optional int32 level_3 = 14;
  inline bool has_level_3() const;
  inline void clear_level_3();
  static const int kLevel3FieldNumber = 14;
  inline ::google::protobuf::int32 level_3() const;
  inline void set_level_3(::google::protobuf::int32 value);

  // optional int32 rate_3 = 15;
  inline bool has_rate_3() const;
  inline void clear_rate_3();
  static const int kRate3FieldNumber = 15;
  inline ::google::protobuf::int32 rate_3() const;
  inline void set_rate_3(::google::protobuf::int32 value);

  // optional int32 level_4 = 16;
  inline bool has_level_4() const;
  inline void clear_level_4();
  static const int kLevel4FieldNumber = 16;
  inline ::google::protobuf::int32 level_4() const;
  inline void set_level_4(::google::protobuf::int32 value);

  // optional int32 rate_4 = 17;
  inline bool has_rate_4() const;
  inline void clear_rate_4();
  static const int kRate4FieldNumber = 17;
  inline ::google::protobuf::int32 rate_4() const;
  inline void set_rate_4(::google::protobuf::int32 value);

  // optional int32 taxrate = 18;
  inline bool has_taxrate() const;
  inline void clear_taxrate();
  static const int kTaxrateFieldNumber = 18;
  inline ::google::protobuf::int32 taxrate() const;
  inline void set_taxrate(::google::protobuf::int32 value);

  // optional string taxnum = 19;
  inline bool has_taxnum() const;
  inline void clear_taxnum();
  static const int kTaxnumFieldNumber = 19;
  inline const ::std::string& taxnum() const;
  inline void set_taxnum(const ::std::string& value);
  inline void set_taxnum(const char* value);
  inline void set_taxnum(const char* value, size_t size);
  inline ::std::string* mutable_taxnum();
  inline ::std::string* release_taxnum();
  inline void set_allocated_taxnum(::std::string* taxnum);

  // optional int32 gradetype = 20;
  inline bool has_gradetype() const;
  inline void clear_gradetype();
  static const int kGradetypeFieldNumber = 20;
  inline ::google::protobuf::int32 gradetype() const;
  inline void set_gradetype(::google::protobuf::int32 value);

  // optional string historywinpour = 21;
  inline bool has_historywinpour() const;
  inline void clear_historywinpour();
  static const int kHistorywinpourFieldNumber = 21;
  inline const ::std::string& historywinpour() const;
  inline void set_historywinpour(const ::std::string& value);
  inline void set_historywinpour(const char* value);
  inline void set_historywinpour(const char* value, size_t size);
  inline ::std::string* mutable_historywinpour();
  inline ::std::string* release_historywinpour();
  inline void set_allocated_historywinpour(::std::string* historywinpour);

  // optional string todaywinpour = 22;
  inline bool has_todaywinpour() const;
  inline void clear_todaywinpour();
  static const int kTodaywinpourFieldNumber = 22;
  inline const ::std::string& todaywinpour() const;
  inline void set_todaywinpour(const ::std::string& value);
  inline void set_todaywinpour(const char* value);
  inline void set_todaywinpour(const char* value, size_t size);
  inline ::std::string* mutable_todaywinpour();
  inline ::std::string* release_todaywinpour();
  inline void set_allocated_todaywinpour(::std::string* todaywinpour);

  // optional string historytotalpour = 23;
  inline bool has_historytotalpour() const;
  inline void clear_historytotalpour();
  static const int kHistorytotalpourFieldNumber = 23;
  inline const ::std::string& historytotalpour() const;
  inline void set_historytotalpour(const ::std::string& value);
  inline void set_historytotalpour(const char* value);
  inline void set_historytotalpour(const char* value, size_t size);
  inline ::std::string* mutable_historytotalpour();
  inline ::std::string* release_historytotalpour();
  inline void set_allocated_historytotalpour(::std::string* historytotalpour);

  // optional string todaytotalpour = 24;
  inline bool has_todaytotalpour() const;
  inline void clear_todaytotalpour();
  static const int kTodaytotalpourFieldNumber = 24;
  inline const ::std::string& todaytotalpour() const;
  inline void set_todaytotalpour(const ::std::string& value);
  inline void set_todaytotalpour(const char* value);
  inline void set_todaytotalpour(const char* value, size_t size);
  inline ::std::string* mutable_todaytotalpour();
  inline ::std::string* release_todaytotalpour();
  inline void set_allocated_todaytotalpour(::std::string* todaytotalpour);

  // optional int32 historywinrate = 25;
  inline bool has_historywinrate() const;
  inline void clear_historywinrate();
  static const int kHistorywinrateFieldNumber = 25;
  inline ::google::protobuf::int32 historywinrate() const;
  inline void set_historywinrate(::google::protobuf::int32 value);

  // optional int32 todaywinrate = 26;
  inline bool has_todaywinrate() const;
  inline void clear_todaywinrate();
  static const int kTodaywinrateFieldNumber = 26;
  inline ::google::protobuf::int32 todaywinrate() const;
  inline void set_todaywinrate(::google::protobuf::int32 value);

  // optional int32 huan_0 = 27;
  inline bool has_huan_0() const;
  inline void clear_huan_0();
  static const int kHuan0FieldNumber = 27;
  inline ::google::protobuf::int32 huan_0() const;
  inline void set_huan_0(::google::protobuf::int32 value);

  // optional int32 huan_1 = 28;
  inline bool has_huan_1() const;
  inline void clear_huan_1();
  static const int kHuan1FieldNumber = 28;
  inline ::google::protobuf::int32 huan_1() const;
  inline void set_huan_1(::google::protobuf::int32 value);

  // optional int32 huan_2 = 29;
  inline bool has_huan_2() const;
  inline void clear_huan_2();
  static const int kHuan2FieldNumber = 29;
  inline ::google::protobuf::int32 huan_2() const;
  inline void set_huan_2(::google::protobuf::int32 value);

  // optional int32 huan_3 = 30;
  inline bool has_huan_3() const;
  inline void clear_huan_3();
  static const int kHuan3FieldNumber = 30;
  inline ::google::protobuf::int32 huan_3() const;
  inline void set_huan_3(::google::protobuf::int32 value);

  // optional int32 huan_4 = 31;
  inline bool has_huan_4() const;
  inline void clear_huan_4();
  static const int kHuan4FieldNumber = 31;
  inline ::google::protobuf::int32 huan_4() const;
  inline void set_huan_4(::google::protobuf::int32 value);

  // optional int32 cur_level = 32;
  inline bool has_cur_level() const;
  inline void clear_cur_level();
  static const int kCurLevelFieldNumber = 32;
  inline ::google::protobuf::int32 cur_level() const;
  inline void set_cur_level(::google::protobuf::int32 value);

  // optional int32 cur_lun_count = 33;
  inline bool has_cur_lun_count() const;
  inline void clear_cur_lun_count();
  static const int kCurLunCountFieldNumber = 33;
  inline ::google::protobuf::int32 cur_lun_count() const;
  inline void set_cur_lun_count(::google::protobuf::int32 value);

  // optional int32 cur_bi_huan = 34;
  inline bool has_cur_bi_huan() const;
  inline void clear_cur_bi_huan();
  static const int kCurBiHuanFieldNumber = 34;
  inline ::google::protobuf::int32 cur_bi_huan() const;
  inline void set_cur_bi_huan(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:progame.pondinfo)
 private:
  inline void set_has_pondid();
  inline void clear_has_pondid();
  inline void set_has_gametype();
  inline void clear_has_gametype();
  inline void set_has_jiangjetton();
  inline void clear_has_jiangjetton();
  inline void set_has_caijetton();
  inline void clear_has_caijetton();
  inline void set_has_tabletype();
  inline void clear_has_tabletype();
  inline void set_has_level_1();
  inline void clear_has_level_1();
  inline void set_has_rate_1();
  inline void clear_has_rate_1();
  inline void set_has_level_2();
  inline void clear_has_level_2();
  inline void set_has_rate_2();
  inline void clear_has_rate_2();
  inline void set_has_level_3();
  inline void clear_has_level_3();
  inline void set_has_rate_3();
  inline void clear_has_rate_3();
  inline void set_has_level_4();
  inline void clear_has_level_4();
  inline void set_has_rate_4();
  inline void clear_has_rate_4();
  inline void set_has_taxrate();
  inline void clear_has_taxrate();
  inline void set_has_taxnum();
  inline void clear_has_taxnum();
  inline void set_has_gradetype();
  inline void clear_has_gradetype();
  inline void set_has_historywinpour();
  inline void clear_has_historywinpour();
  inline void set_has_todaywinpour();
  inline void clear_has_todaywinpour();
  inline void set_has_historytotalpour();
  inline void clear_has_historytotalpour();
  inline void set_has_todaytotalpour();
  inline void clear_has_todaytotalpour();
  inline void set_has_historywinrate();
  inline void clear_has_historywinrate();
  inline void set_has_todaywinrate();
  inline void clear_has_todaywinrate();
  inline void set_has_huan_0();
  inline void clear_has_huan_0();
  inline void set_has_huan_1();
  inline void clear_has_huan_1();
  inline void set_has_huan_2();
  inline void clear_has_huan_2();
  inline void set_has_huan_3();
  inline void clear_has_huan_3();
  inline void set_has_huan_4();
  inline void clear_has_huan_4();
  inline void set_has_cur_level();
  inline void clear_has_cur_level();
  inline void set_has_cur_lun_count();
  inline void clear_has_cur_lun_count();
  inline void set_has_cur_bi_huan();
  inline void clear_has_cur_bi_huan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 pondid_;
  ::google::protobuf::int32 gametype_;
  ::std::string* jiangjetton_;
  ::std::string* caijetton_;
  ::google::protobuf::int32 tabletype_;
  ::google::protobuf::int32 level_1_;
  ::google::protobuf::int32 rate_1_;
  ::google::protobuf::int32 level_2_;
  ::google::protobuf::int32 rate_2_;
  ::google::protobuf::int32 level_3_;
  ::google::protobuf::int32 rate_3_;
  ::google::protobuf::int32 level_4_;
  ::google::protobuf::int32 rate_4_;
  ::google::protobuf::int32 taxrate_;
  ::std::string* taxnum_;
  ::std::string* historywinpour_;
  ::std::string* todaywinpour_;
  ::google::protobuf::int32 gradetype_;
  ::google::protobuf::int32 historywinrate_;
  ::std::string* historytotalpour_;
  ::std::string* todaytotalpour_;
  ::google::protobuf::int32 todaywinrate_;
  ::google::protobuf::int32 huan_0_;
  ::google::protobuf::int32 huan_1_;
  ::google::protobuf::int32 huan_2_;
  ::google::protobuf::int32 huan_3_;
  ::google::protobuf::int32 huan_4_;
  ::google::protobuf::int32 cur_level_;
  ::google::protobuf::int32 cur_lun_count_;
  ::google::protobuf::int32 cur_bi_huan_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];

  friend void  protobuf_AddDesc_st_5futils_5fpond_2eproto();
  friend void protobuf_AssignDesc_st_5futils_5fpond_2eproto();
  friend void protobuf_ShutdownFile_st_5futils_5fpond_2eproto();

  void InitAsDefaultInstance();
  static pondinfo* default_instance_;
};
// -------------------------------------------------------------------

class legalinfo : public ::google::protobuf::Message {
 public:
  legalinfo();
  virtual ~legalinfo();

  legalinfo(const legalinfo& from);

  inline legalinfo& operator=(const legalinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const legalinfo& default_instance();

  void Swap(legalinfo* other);

  // implements Message ----------------------------------------------

  legalinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const legalinfo& from);
  void MergeFrom(const legalinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string legalkey = 2;
  inline bool has_legalkey() const;
  inline void clear_legalkey();
  static const int kLegalkeyFieldNumber = 2;
  inline const ::std::string& legalkey() const;
  inline void set_legalkey(const ::std::string& value);
  inline void set_legalkey(const char* value);
  inline void set_legalkey(const char* value, size_t size);
  inline ::std::string* mutable_legalkey();
  inline ::std::string* release_legalkey();
  inline void set_allocated_legalkey(::std::string* legalkey);

  // optional string param1 = 3;
  inline bool has_param1() const;
  inline void clear_param1();
  static const int kParam1FieldNumber = 3;
  inline const ::std::string& param1() const;
  inline void set_param1(const ::std::string& value);
  inline void set_param1(const char* value);
  inline void set_param1(const char* value, size_t size);
  inline ::std::string* mutable_param1();
  inline ::std::string* release_param1();
  inline void set_allocated_param1(::std::string* param1);

  // optional string param2 = 4;
  inline bool has_param2() const;
  inline void clear_param2();
  static const int kParam2FieldNumber = 4;
  inline const ::std::string& param2() const;
  inline void set_param2(const ::std::string& value);
  inline void set_param2(const char* value);
  inline void set_param2(const char* value, size_t size);
  inline ::std::string* mutable_param2();
  inline ::std::string* release_param2();
  inline void set_allocated_param2(::std::string* param2);

  // optional string param3 = 5;
  inline bool has_param3() const;
  inline void clear_param3();
  static const int kParam3FieldNumber = 5;
  inline const ::std::string& param3() const;
  inline void set_param3(const ::std::string& value);
  inline void set_param3(const char* value);
  inline void set_param3(const char* value, size_t size);
  inline ::std::string* mutable_param3();
  inline ::std::string* release_param3();
  inline void set_allocated_param3(::std::string* param3);

  // optional string param4 = 6;
  inline bool has_param4() const;
  inline void clear_param4();
  static const int kParam4FieldNumber = 6;
  inline const ::std::string& param4() const;
  inline void set_param4(const ::std::string& value);
  inline void set_param4(const char* value);
  inline void set_param4(const char* value, size_t size);
  inline ::std::string* mutable_param4();
  inline ::std::string* release_param4();
  inline void set_allocated_param4(::std::string* param4);

  // optional string legalsign = 7;
  inline bool has_legalsign() const;
  inline void clear_legalsign();
  static const int kLegalsignFieldNumber = 7;
  inline const ::std::string& legalsign() const;
  inline void set_legalsign(const ::std::string& value);
  inline void set_legalsign(const char* value);
  inline void set_legalsign(const char* value, size_t size);
  inline ::std::string* mutable_legalsign();
  inline ::std::string* release_legalsign();
  inline void set_allocated_legalsign(::std::string* legalsign);

  // optional string state = 8;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 8;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional string cardlist = 9;
  inline bool has_cardlist() const;
  inline void clear_cardlist();
  static const int kCardlistFieldNumber = 9;
  inline const ::std::string& cardlist() const;
  inline void set_cardlist(const ::std::string& value);
  inline void set_cardlist(const char* value);
  inline void set_cardlist(const char* value, size_t size);
  inline ::std::string* mutable_cardlist();
  inline ::std::string* release_cardlist();
  inline void set_allocated_cardlist(::std::string* cardlist);

  // @@protoc_insertion_point(class_scope:progame.legalinfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_legalkey();
  inline void clear_has_legalkey();
  inline void set_has_param1();
  inline void clear_has_param1();
  inline void set_has_param2();
  inline void clear_has_param2();
  inline void set_has_param3();
  inline void clear_has_param3();
  inline void set_has_param4();
  inline void clear_has_param4();
  inline void set_has_legalsign();
  inline void clear_has_legalsign();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_cardlist();
  inline void clear_has_cardlist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* legalkey_;
  ::std::string* param1_;
  ::std::string* param2_;
  ::std::string* param3_;
  ::std::string* param4_;
  ::std::string* legalsign_;
  ::std::string* state_;
  ::std::string* cardlist_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_st_5futils_5fpond_2eproto();
  friend void protobuf_AssignDesc_st_5futils_5fpond_2eproto();
  friend void protobuf_ShutdownFile_st_5futils_5fpond_2eproto();

  void InitAsDefaultInstance();
  static legalinfo* default_instance_;
};
// ===================================================================


// ===================================================================

// pondinfo

// optional int32 pondid = 1;
inline bool pondinfo::has_pondid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pondinfo::set_has_pondid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pondinfo::clear_has_pondid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pondinfo::clear_pondid() {
  pondid_ = 0;
  clear_has_pondid();
}
inline ::google::protobuf::int32 pondinfo::pondid() const {
  return pondid_;
}
inline void pondinfo::set_pondid(::google::protobuf::int32 value) {
  set_has_pondid();
  pondid_ = value;
}

// optional int32 gametype = 2;
inline bool pondinfo::has_gametype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pondinfo::set_has_gametype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pondinfo::clear_has_gametype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pondinfo::clear_gametype() {
  gametype_ = 0;
  clear_has_gametype();
}
inline ::google::protobuf::int32 pondinfo::gametype() const {
  return gametype_;
}
inline void pondinfo::set_gametype(::google::protobuf::int32 value) {
  set_has_gametype();
  gametype_ = value;
}

// optional string jiangjetton = 3;
inline bool pondinfo::has_jiangjetton() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pondinfo::set_has_jiangjetton() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pondinfo::clear_has_jiangjetton() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pondinfo::clear_jiangjetton() {
  if (jiangjetton_ != &::google::protobuf::internal::kEmptyString) {
    jiangjetton_->clear();
  }
  clear_has_jiangjetton();
}
inline const ::std::string& pondinfo::jiangjetton() const {
  return *jiangjetton_;
}
inline void pondinfo::set_jiangjetton(const ::std::string& value) {
  set_has_jiangjetton();
  if (jiangjetton_ == &::google::protobuf::internal::kEmptyString) {
    jiangjetton_ = new ::std::string;
  }
  jiangjetton_->assign(value);
}
inline void pondinfo::set_jiangjetton(const char* value) {
  set_has_jiangjetton();
  if (jiangjetton_ == &::google::protobuf::internal::kEmptyString) {
    jiangjetton_ = new ::std::string;
  }
  jiangjetton_->assign(value);
}
inline void pondinfo::set_jiangjetton(const char* value, size_t size) {
  set_has_jiangjetton();
  if (jiangjetton_ == &::google::protobuf::internal::kEmptyString) {
    jiangjetton_ = new ::std::string;
  }
  jiangjetton_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pondinfo::mutable_jiangjetton() {
  set_has_jiangjetton();
  if (jiangjetton_ == &::google::protobuf::internal::kEmptyString) {
    jiangjetton_ = new ::std::string;
  }
  return jiangjetton_;
}
inline ::std::string* pondinfo::release_jiangjetton() {
  clear_has_jiangjetton();
  if (jiangjetton_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jiangjetton_;
    jiangjetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pondinfo::set_allocated_jiangjetton(::std::string* jiangjetton) {
  if (jiangjetton_ != &::google::protobuf::internal::kEmptyString) {
    delete jiangjetton_;
  }
  if (jiangjetton) {
    set_has_jiangjetton();
    jiangjetton_ = jiangjetton;
  } else {
    clear_has_jiangjetton();
    jiangjetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string caijetton = 4;
inline bool pondinfo::has_caijetton() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pondinfo::set_has_caijetton() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pondinfo::clear_has_caijetton() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pondinfo::clear_caijetton() {
  if (caijetton_ != &::google::protobuf::internal::kEmptyString) {
    caijetton_->clear();
  }
  clear_has_caijetton();
}
inline const ::std::string& pondinfo::caijetton() const {
  return *caijetton_;
}
inline void pondinfo::set_caijetton(const ::std::string& value) {
  set_has_caijetton();
  if (caijetton_ == &::google::protobuf::internal::kEmptyString) {
    caijetton_ = new ::std::string;
  }
  caijetton_->assign(value);
}
inline void pondinfo::set_caijetton(const char* value) {
  set_has_caijetton();
  if (caijetton_ == &::google::protobuf::internal::kEmptyString) {
    caijetton_ = new ::std::string;
  }
  caijetton_->assign(value);
}
inline void pondinfo::set_caijetton(const char* value, size_t size) {
  set_has_caijetton();
  if (caijetton_ == &::google::protobuf::internal::kEmptyString) {
    caijetton_ = new ::std::string;
  }
  caijetton_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pondinfo::mutable_caijetton() {
  set_has_caijetton();
  if (caijetton_ == &::google::protobuf::internal::kEmptyString) {
    caijetton_ = new ::std::string;
  }
  return caijetton_;
}
inline ::std::string* pondinfo::release_caijetton() {
  clear_has_caijetton();
  if (caijetton_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caijetton_;
    caijetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pondinfo::set_allocated_caijetton(::std::string* caijetton) {
  if (caijetton_ != &::google::protobuf::internal::kEmptyString) {
    delete caijetton_;
  }
  if (caijetton) {
    set_has_caijetton();
    caijetton_ = caijetton;
  } else {
    clear_has_caijetton();
    caijetton_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 tabletype = 5;
inline bool pondinfo::has_tabletype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pondinfo::set_has_tabletype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pondinfo::clear_has_tabletype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pondinfo::clear_tabletype() {
  tabletype_ = 0;
  clear_has_tabletype();
}
inline ::google::protobuf::int32 pondinfo::tabletype() const {
  return tabletype_;
}
inline void pondinfo::set_tabletype(::google::protobuf::int32 value) {
  set_has_tabletype();
  tabletype_ = value;
}

// optional int32 level_1 = 10;
inline bool pondinfo::has_level_1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pondinfo::set_has_level_1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pondinfo::clear_has_level_1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pondinfo::clear_level_1() {
  level_1_ = 0;
  clear_has_level_1();
}
inline ::google::protobuf::int32 pondinfo::level_1() const {
  return level_1_;
}
inline void pondinfo::set_level_1(::google::protobuf::int32 value) {
  set_has_level_1();
  level_1_ = value;
}

// optional int32 rate_1 = 11;
inline bool pondinfo::has_rate_1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pondinfo::set_has_rate_1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pondinfo::clear_has_rate_1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pondinfo::clear_rate_1() {
  rate_1_ = 0;
  clear_has_rate_1();
}
inline ::google::protobuf::int32 pondinfo::rate_1() const {
  return rate_1_;
}
inline void pondinfo::set_rate_1(::google::protobuf::int32 value) {
  set_has_rate_1();
  rate_1_ = value;
}

// optional int32 level_2 = 12;
inline bool pondinfo::has_level_2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pondinfo::set_has_level_2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pondinfo::clear_has_level_2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pondinfo::clear_level_2() {
  level_2_ = 0;
  clear_has_level_2();
}
inline ::google::protobuf::int32 pondinfo::level_2() const {
  return level_2_;
}
inline void pondinfo::set_level_2(::google::protobuf::int32 value) {
  set_has_level_2();
  level_2_ = value;
}

// optional int32 rate_2 = 13;
inline bool pondinfo::has_rate_2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pondinfo::set_has_rate_2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pondinfo::clear_has_rate_2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pondinfo::clear_rate_2() {
  rate_2_ = 0;
  clear_has_rate_2();
}
inline ::google::protobuf::int32 pondinfo::rate_2() const {
  return rate_2_;
}
inline void pondinfo::set_rate_2(::google::protobuf::int32 value) {
  set_has_rate_2();
  rate_2_ = value;
}

// optional int32 level_3 = 14;
inline bool pondinfo::has_level_3() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pondinfo::set_has_level_3() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pondinfo::clear_has_level_3() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pondinfo::clear_level_3() {
  level_3_ = 0;
  clear_has_level_3();
}
inline ::google::protobuf::int32 pondinfo::level_3() const {
  return level_3_;
}
inline void pondinfo::set_level_3(::google::protobuf::int32 value) {
  set_has_level_3();
  level_3_ = value;
}

// optional int32 rate_3 = 15;
inline bool pondinfo::has_rate_3() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void pondinfo::set_has_rate_3() {
  _has_bits_[0] |= 0x00000400u;
}
inline void pondinfo::clear_has_rate_3() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void pondinfo::clear_rate_3() {
  rate_3_ = 0;
  clear_has_rate_3();
}
inline ::google::protobuf::int32 pondinfo::rate_3() const {
  return rate_3_;
}
inline void pondinfo::set_rate_3(::google::protobuf::int32 value) {
  set_has_rate_3();
  rate_3_ = value;
}

// optional int32 level_4 = 16;
inline bool pondinfo::has_level_4() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void pondinfo::set_has_level_4() {
  _has_bits_[0] |= 0x00000800u;
}
inline void pondinfo::clear_has_level_4() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void pondinfo::clear_level_4() {
  level_4_ = 0;
  clear_has_level_4();
}
inline ::google::protobuf::int32 pondinfo::level_4() const {
  return level_4_;
}
inline void pondinfo::set_level_4(::google::protobuf::int32 value) {
  set_has_level_4();
  level_4_ = value;
}

// optional int32 rate_4 = 17;
inline bool pondinfo::has_rate_4() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void pondinfo::set_has_rate_4() {
  _has_bits_[0] |= 0x00001000u;
}
inline void pondinfo::clear_has_rate_4() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void pondinfo::clear_rate_4() {
  rate_4_ = 0;
  clear_has_rate_4();
}
inline ::google::protobuf::int32 pondinfo::rate_4() const {
  return rate_4_;
}
inline void pondinfo::set_rate_4(::google::protobuf::int32 value) {
  set_has_rate_4();
  rate_4_ = value;
}

// optional int32 taxrate = 18;
inline bool pondinfo::has_taxrate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void pondinfo::set_has_taxrate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void pondinfo::clear_has_taxrate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void pondinfo::clear_taxrate() {
  taxrate_ = 0;
  clear_has_taxrate();
}
inline ::google::protobuf::int32 pondinfo::taxrate() const {
  return taxrate_;
}
inline void pondinfo::set_taxrate(::google::protobuf::int32 value) {
  set_has_taxrate();
  taxrate_ = value;
}

// optional string taxnum = 19;
inline bool pondinfo::has_taxnum() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void pondinfo::set_has_taxnum() {
  _has_bits_[0] |= 0x00004000u;
}
inline void pondinfo::clear_has_taxnum() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void pondinfo::clear_taxnum() {
  if (taxnum_ != &::google::protobuf::internal::kEmptyString) {
    taxnum_->clear();
  }
  clear_has_taxnum();
}
inline const ::std::string& pondinfo::taxnum() const {
  return *taxnum_;
}
inline void pondinfo::set_taxnum(const ::std::string& value) {
  set_has_taxnum();
  if (taxnum_ == &::google::protobuf::internal::kEmptyString) {
    taxnum_ = new ::std::string;
  }
  taxnum_->assign(value);
}
inline void pondinfo::set_taxnum(const char* value) {
  set_has_taxnum();
  if (taxnum_ == &::google::protobuf::internal::kEmptyString) {
    taxnum_ = new ::std::string;
  }
  taxnum_->assign(value);
}
inline void pondinfo::set_taxnum(const char* value, size_t size) {
  set_has_taxnum();
  if (taxnum_ == &::google::protobuf::internal::kEmptyString) {
    taxnum_ = new ::std::string;
  }
  taxnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pondinfo::mutable_taxnum() {
  set_has_taxnum();
  if (taxnum_ == &::google::protobuf::internal::kEmptyString) {
    taxnum_ = new ::std::string;
  }
  return taxnum_;
}
inline ::std::string* pondinfo::release_taxnum() {
  clear_has_taxnum();
  if (taxnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taxnum_;
    taxnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pondinfo::set_allocated_taxnum(::std::string* taxnum) {
  if (taxnum_ != &::google::protobuf::internal::kEmptyString) {
    delete taxnum_;
  }
  if (taxnum) {
    set_has_taxnum();
    taxnum_ = taxnum;
  } else {
    clear_has_taxnum();
    taxnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 gradetype = 20;
inline bool pondinfo::has_gradetype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void pondinfo::set_has_gradetype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void pondinfo::clear_has_gradetype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void pondinfo::clear_gradetype() {
  gradetype_ = 0;
  clear_has_gradetype();
}
inline ::google::protobuf::int32 pondinfo::gradetype() const {
  return gradetype_;
}
inline void pondinfo::set_gradetype(::google::protobuf::int32 value) {
  set_has_gradetype();
  gradetype_ = value;
}

// optional string historywinpour = 21;
inline bool pondinfo::has_historywinpour() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void pondinfo::set_has_historywinpour() {
  _has_bits_[0] |= 0x00010000u;
}
inline void pondinfo::clear_has_historywinpour() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void pondinfo::clear_historywinpour() {
  if (historywinpour_ != &::google::protobuf::internal::kEmptyString) {
    historywinpour_->clear();
  }
  clear_has_historywinpour();
}
inline const ::std::string& pondinfo::historywinpour() const {
  return *historywinpour_;
}
inline void pondinfo::set_historywinpour(const ::std::string& value) {
  set_has_historywinpour();
  if (historywinpour_ == &::google::protobuf::internal::kEmptyString) {
    historywinpour_ = new ::std::string;
  }
  historywinpour_->assign(value);
}
inline void pondinfo::set_historywinpour(const char* value) {
  set_has_historywinpour();
  if (historywinpour_ == &::google::protobuf::internal::kEmptyString) {
    historywinpour_ = new ::std::string;
  }
  historywinpour_->assign(value);
}
inline void pondinfo::set_historywinpour(const char* value, size_t size) {
  set_has_historywinpour();
  if (historywinpour_ == &::google::protobuf::internal::kEmptyString) {
    historywinpour_ = new ::std::string;
  }
  historywinpour_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pondinfo::mutable_historywinpour() {
  set_has_historywinpour();
  if (historywinpour_ == &::google::protobuf::internal::kEmptyString) {
    historywinpour_ = new ::std::string;
  }
  return historywinpour_;
}
inline ::std::string* pondinfo::release_historywinpour() {
  clear_has_historywinpour();
  if (historywinpour_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = historywinpour_;
    historywinpour_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pondinfo::set_allocated_historywinpour(::std::string* historywinpour) {
  if (historywinpour_ != &::google::protobuf::internal::kEmptyString) {
    delete historywinpour_;
  }
  if (historywinpour) {
    set_has_historywinpour();
    historywinpour_ = historywinpour;
  } else {
    clear_has_historywinpour();
    historywinpour_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string todaywinpour = 22;
inline bool pondinfo::has_todaywinpour() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void pondinfo::set_has_todaywinpour() {
  _has_bits_[0] |= 0x00020000u;
}
inline void pondinfo::clear_has_todaywinpour() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void pondinfo::clear_todaywinpour() {
  if (todaywinpour_ != &::google::protobuf::internal::kEmptyString) {
    todaywinpour_->clear();
  }
  clear_has_todaywinpour();
}
inline const ::std::string& pondinfo::todaywinpour() const {
  return *todaywinpour_;
}
inline void pondinfo::set_todaywinpour(const ::std::string& value) {
  set_has_todaywinpour();
  if (todaywinpour_ == &::google::protobuf::internal::kEmptyString) {
    todaywinpour_ = new ::std::string;
  }
  todaywinpour_->assign(value);
}
inline void pondinfo::set_todaywinpour(const char* value) {
  set_has_todaywinpour();
  if (todaywinpour_ == &::google::protobuf::internal::kEmptyString) {
    todaywinpour_ = new ::std::string;
  }
  todaywinpour_->assign(value);
}
inline void pondinfo::set_todaywinpour(const char* value, size_t size) {
  set_has_todaywinpour();
  if (todaywinpour_ == &::google::protobuf::internal::kEmptyString) {
    todaywinpour_ = new ::std::string;
  }
  todaywinpour_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pondinfo::mutable_todaywinpour() {
  set_has_todaywinpour();
  if (todaywinpour_ == &::google::protobuf::internal::kEmptyString) {
    todaywinpour_ = new ::std::string;
  }
  return todaywinpour_;
}
inline ::std::string* pondinfo::release_todaywinpour() {
  clear_has_todaywinpour();
  if (todaywinpour_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = todaywinpour_;
    todaywinpour_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pondinfo::set_allocated_todaywinpour(::std::string* todaywinpour) {
  if (todaywinpour_ != &::google::protobuf::internal::kEmptyString) {
    delete todaywinpour_;
  }
  if (todaywinpour) {
    set_has_todaywinpour();
    todaywinpour_ = todaywinpour;
  } else {
    clear_has_todaywinpour();
    todaywinpour_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string historytotalpour = 23;
inline bool pondinfo::has_historytotalpour() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void pondinfo::set_has_historytotalpour() {
  _has_bits_[0] |= 0x00040000u;
}
inline void pondinfo::clear_has_historytotalpour() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void pondinfo::clear_historytotalpour() {
  if (historytotalpour_ != &::google::protobuf::internal::kEmptyString) {
    historytotalpour_->clear();
  }
  clear_has_historytotalpour();
}
inline const ::std::string& pondinfo::historytotalpour() const {
  return *historytotalpour_;
}
inline void pondinfo::set_historytotalpour(const ::std::string& value) {
  set_has_historytotalpour();
  if (historytotalpour_ == &::google::protobuf::internal::kEmptyString) {
    historytotalpour_ = new ::std::string;
  }
  historytotalpour_->assign(value);
}
inline void pondinfo::set_historytotalpour(const char* value) {
  set_has_historytotalpour();
  if (historytotalpour_ == &::google::protobuf::internal::kEmptyString) {
    historytotalpour_ = new ::std::string;
  }
  historytotalpour_->assign(value);
}
inline void pondinfo::set_historytotalpour(const char* value, size_t size) {
  set_has_historytotalpour();
  if (historytotalpour_ == &::google::protobuf::internal::kEmptyString) {
    historytotalpour_ = new ::std::string;
  }
  historytotalpour_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pondinfo::mutable_historytotalpour() {
  set_has_historytotalpour();
  if (historytotalpour_ == &::google::protobuf::internal::kEmptyString) {
    historytotalpour_ = new ::std::string;
  }
  return historytotalpour_;
}
inline ::std::string* pondinfo::release_historytotalpour() {
  clear_has_historytotalpour();
  if (historytotalpour_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = historytotalpour_;
    historytotalpour_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pondinfo::set_allocated_historytotalpour(::std::string* historytotalpour) {
  if (historytotalpour_ != &::google::protobuf::internal::kEmptyString) {
    delete historytotalpour_;
  }
  if (historytotalpour) {
    set_has_historytotalpour();
    historytotalpour_ = historytotalpour;
  } else {
    clear_has_historytotalpour();
    historytotalpour_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string todaytotalpour = 24;
inline bool pondinfo::has_todaytotalpour() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void pondinfo::set_has_todaytotalpour() {
  _has_bits_[0] |= 0x00080000u;
}
inline void pondinfo::clear_has_todaytotalpour() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void pondinfo::clear_todaytotalpour() {
  if (todaytotalpour_ != &::google::protobuf::internal::kEmptyString) {
    todaytotalpour_->clear();
  }
  clear_has_todaytotalpour();
}
inline const ::std::string& pondinfo::todaytotalpour() const {
  return *todaytotalpour_;
}
inline void pondinfo::set_todaytotalpour(const ::std::string& value) {
  set_has_todaytotalpour();
  if (todaytotalpour_ == &::google::protobuf::internal::kEmptyString) {
    todaytotalpour_ = new ::std::string;
  }
  todaytotalpour_->assign(value);
}
inline void pondinfo::set_todaytotalpour(const char* value) {
  set_has_todaytotalpour();
  if (todaytotalpour_ == &::google::protobuf::internal::kEmptyString) {
    todaytotalpour_ = new ::std::string;
  }
  todaytotalpour_->assign(value);
}
inline void pondinfo::set_todaytotalpour(const char* value, size_t size) {
  set_has_todaytotalpour();
  if (todaytotalpour_ == &::google::protobuf::internal::kEmptyString) {
    todaytotalpour_ = new ::std::string;
  }
  todaytotalpour_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pondinfo::mutable_todaytotalpour() {
  set_has_todaytotalpour();
  if (todaytotalpour_ == &::google::protobuf::internal::kEmptyString) {
    todaytotalpour_ = new ::std::string;
  }
  return todaytotalpour_;
}
inline ::std::string* pondinfo::release_todaytotalpour() {
  clear_has_todaytotalpour();
  if (todaytotalpour_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = todaytotalpour_;
    todaytotalpour_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pondinfo::set_allocated_todaytotalpour(::std::string* todaytotalpour) {
  if (todaytotalpour_ != &::google::protobuf::internal::kEmptyString) {
    delete todaytotalpour_;
  }
  if (todaytotalpour) {
    set_has_todaytotalpour();
    todaytotalpour_ = todaytotalpour;
  } else {
    clear_has_todaytotalpour();
    todaytotalpour_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 historywinrate = 25;
inline bool pondinfo::has_historywinrate() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void pondinfo::set_has_historywinrate() {
  _has_bits_[0] |= 0x00100000u;
}
inline void pondinfo::clear_has_historywinrate() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void pondinfo::clear_historywinrate() {
  historywinrate_ = 0;
  clear_has_historywinrate();
}
inline ::google::protobuf::int32 pondinfo::historywinrate() const {
  return historywinrate_;
}
inline void pondinfo::set_historywinrate(::google::protobuf::int32 value) {
  set_has_historywinrate();
  historywinrate_ = value;
}

// optional int32 todaywinrate = 26;
inline bool pondinfo::has_todaywinrate() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void pondinfo::set_has_todaywinrate() {
  _has_bits_[0] |= 0x00200000u;
}
inline void pondinfo::clear_has_todaywinrate() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void pondinfo::clear_todaywinrate() {
  todaywinrate_ = 0;
  clear_has_todaywinrate();
}
inline ::google::protobuf::int32 pondinfo::todaywinrate() const {
  return todaywinrate_;
}
inline void pondinfo::set_todaywinrate(::google::protobuf::int32 value) {
  set_has_todaywinrate();
  todaywinrate_ = value;
}

// optional int32 huan_0 = 27;
inline bool pondinfo::has_huan_0() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void pondinfo::set_has_huan_0() {
  _has_bits_[0] |= 0x00400000u;
}
inline void pondinfo::clear_has_huan_0() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void pondinfo::clear_huan_0() {
  huan_0_ = 0;
  clear_has_huan_0();
}
inline ::google::protobuf::int32 pondinfo::huan_0() const {
  return huan_0_;
}
inline void pondinfo::set_huan_0(::google::protobuf::int32 value) {
  set_has_huan_0();
  huan_0_ = value;
}

// optional int32 huan_1 = 28;
inline bool pondinfo::has_huan_1() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void pondinfo::set_has_huan_1() {
  _has_bits_[0] |= 0x00800000u;
}
inline void pondinfo::clear_has_huan_1() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void pondinfo::clear_huan_1() {
  huan_1_ = 0;
  clear_has_huan_1();
}
inline ::google::protobuf::int32 pondinfo::huan_1() const {
  return huan_1_;
}
inline void pondinfo::set_huan_1(::google::protobuf::int32 value) {
  set_has_huan_1();
  huan_1_ = value;
}

// optional int32 huan_2 = 29;
inline bool pondinfo::has_huan_2() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void pondinfo::set_has_huan_2() {
  _has_bits_[0] |= 0x01000000u;
}
inline void pondinfo::clear_has_huan_2() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void pondinfo::clear_huan_2() {
  huan_2_ = 0;
  clear_has_huan_2();
}
inline ::google::protobuf::int32 pondinfo::huan_2() const {
  return huan_2_;
}
inline void pondinfo::set_huan_2(::google::protobuf::int32 value) {
  set_has_huan_2();
  huan_2_ = value;
}

// optional int32 huan_3 = 30;
inline bool pondinfo::has_huan_3() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void pondinfo::set_has_huan_3() {
  _has_bits_[0] |= 0x02000000u;
}
inline void pondinfo::clear_has_huan_3() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void pondinfo::clear_huan_3() {
  huan_3_ = 0;
  clear_has_huan_3();
}
inline ::google::protobuf::int32 pondinfo::huan_3() const {
  return huan_3_;
}
inline void pondinfo::set_huan_3(::google::protobuf::int32 value) {
  set_has_huan_3();
  huan_3_ = value;
}

// optional int32 huan_4 = 31;
inline bool pondinfo::has_huan_4() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void pondinfo::set_has_huan_4() {
  _has_bits_[0] |= 0x04000000u;
}
inline void pondinfo::clear_has_huan_4() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void pondinfo::clear_huan_4() {
  huan_4_ = 0;
  clear_has_huan_4();
}
inline ::google::protobuf::int32 pondinfo::huan_4() const {
  return huan_4_;
}
inline void pondinfo::set_huan_4(::google::protobuf::int32 value) {
  set_has_huan_4();
  huan_4_ = value;
}

// optional int32 cur_level = 32;
inline bool pondinfo::has_cur_level() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void pondinfo::set_has_cur_level() {
  _has_bits_[0] |= 0x08000000u;
}
inline void pondinfo::clear_has_cur_level() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void pondinfo::clear_cur_level() {
  cur_level_ = 0;
  clear_has_cur_level();
}
inline ::google::protobuf::int32 pondinfo::cur_level() const {
  return cur_level_;
}
inline void pondinfo::set_cur_level(::google::protobuf::int32 value) {
  set_has_cur_level();
  cur_level_ = value;
}

// optional int32 cur_lun_count = 33;
inline bool pondinfo::has_cur_lun_count() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void pondinfo::set_has_cur_lun_count() {
  _has_bits_[0] |= 0x10000000u;
}
inline void pondinfo::clear_has_cur_lun_count() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void pondinfo::clear_cur_lun_count() {
  cur_lun_count_ = 0;
  clear_has_cur_lun_count();
}
inline ::google::protobuf::int32 pondinfo::cur_lun_count() const {
  return cur_lun_count_;
}
inline void pondinfo::set_cur_lun_count(::google::protobuf::int32 value) {
  set_has_cur_lun_count();
  cur_lun_count_ = value;
}

// optional int32 cur_bi_huan = 34;
inline bool pondinfo::has_cur_bi_huan() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void pondinfo::set_has_cur_bi_huan() {
  _has_bits_[0] |= 0x20000000u;
}
inline void pondinfo::clear_has_cur_bi_huan() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void pondinfo::clear_cur_bi_huan() {
  cur_bi_huan_ = 0;
  clear_has_cur_bi_huan();
}
inline ::google::protobuf::int32 pondinfo::cur_bi_huan() const {
  return cur_bi_huan_;
}
inline void pondinfo::set_cur_bi_huan(::google::protobuf::int32 value) {
  set_has_cur_bi_huan();
  cur_bi_huan_ = value;
}

// -------------------------------------------------------------------

// legalinfo

// optional int32 id = 1;
inline bool legalinfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void legalinfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void legalinfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void legalinfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 legalinfo::id() const {
  return id_;
}
inline void legalinfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string legalkey = 2;
inline bool legalinfo::has_legalkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void legalinfo::set_has_legalkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void legalinfo::clear_has_legalkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void legalinfo::clear_legalkey() {
  if (legalkey_ != &::google::protobuf::internal::kEmptyString) {
    legalkey_->clear();
  }
  clear_has_legalkey();
}
inline const ::std::string& legalinfo::legalkey() const {
  return *legalkey_;
}
inline void legalinfo::set_legalkey(const ::std::string& value) {
  set_has_legalkey();
  if (legalkey_ == &::google::protobuf::internal::kEmptyString) {
    legalkey_ = new ::std::string;
  }
  legalkey_->assign(value);
}
inline void legalinfo::set_legalkey(const char* value) {
  set_has_legalkey();
  if (legalkey_ == &::google::protobuf::internal::kEmptyString) {
    legalkey_ = new ::std::string;
  }
  legalkey_->assign(value);
}
inline void legalinfo::set_legalkey(const char* value, size_t size) {
  set_has_legalkey();
  if (legalkey_ == &::google::protobuf::internal::kEmptyString) {
    legalkey_ = new ::std::string;
  }
  legalkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* legalinfo::mutable_legalkey() {
  set_has_legalkey();
  if (legalkey_ == &::google::protobuf::internal::kEmptyString) {
    legalkey_ = new ::std::string;
  }
  return legalkey_;
}
inline ::std::string* legalinfo::release_legalkey() {
  clear_has_legalkey();
  if (legalkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legalkey_;
    legalkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void legalinfo::set_allocated_legalkey(::std::string* legalkey) {
  if (legalkey_ != &::google::protobuf::internal::kEmptyString) {
    delete legalkey_;
  }
  if (legalkey) {
    set_has_legalkey();
    legalkey_ = legalkey;
  } else {
    clear_has_legalkey();
    legalkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string param1 = 3;
inline bool legalinfo::has_param1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void legalinfo::set_has_param1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void legalinfo::clear_has_param1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void legalinfo::clear_param1() {
  if (param1_ != &::google::protobuf::internal::kEmptyString) {
    param1_->clear();
  }
  clear_has_param1();
}
inline const ::std::string& legalinfo::param1() const {
  return *param1_;
}
inline void legalinfo::set_param1(const ::std::string& value) {
  set_has_param1();
  if (param1_ == &::google::protobuf::internal::kEmptyString) {
    param1_ = new ::std::string;
  }
  param1_->assign(value);
}
inline void legalinfo::set_param1(const char* value) {
  set_has_param1();
  if (param1_ == &::google::protobuf::internal::kEmptyString) {
    param1_ = new ::std::string;
  }
  param1_->assign(value);
}
inline void legalinfo::set_param1(const char* value, size_t size) {
  set_has_param1();
  if (param1_ == &::google::protobuf::internal::kEmptyString) {
    param1_ = new ::std::string;
  }
  param1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* legalinfo::mutable_param1() {
  set_has_param1();
  if (param1_ == &::google::protobuf::internal::kEmptyString) {
    param1_ = new ::std::string;
  }
  return param1_;
}
inline ::std::string* legalinfo::release_param1() {
  clear_has_param1();
  if (param1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param1_;
    param1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void legalinfo::set_allocated_param1(::std::string* param1) {
  if (param1_ != &::google::protobuf::internal::kEmptyString) {
    delete param1_;
  }
  if (param1) {
    set_has_param1();
    param1_ = param1;
  } else {
    clear_has_param1();
    param1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string param2 = 4;
inline bool legalinfo::has_param2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void legalinfo::set_has_param2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void legalinfo::clear_has_param2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void legalinfo::clear_param2() {
  if (param2_ != &::google::protobuf::internal::kEmptyString) {
    param2_->clear();
  }
  clear_has_param2();
}
inline const ::std::string& legalinfo::param2() const {
  return *param2_;
}
inline void legalinfo::set_param2(const ::std::string& value) {
  set_has_param2();
  if (param2_ == &::google::protobuf::internal::kEmptyString) {
    param2_ = new ::std::string;
  }
  param2_->assign(value);
}
inline void legalinfo::set_param2(const char* value) {
  set_has_param2();
  if (param2_ == &::google::protobuf::internal::kEmptyString) {
    param2_ = new ::std::string;
  }
  param2_->assign(value);
}
inline void legalinfo::set_param2(const char* value, size_t size) {
  set_has_param2();
  if (param2_ == &::google::protobuf::internal::kEmptyString) {
    param2_ = new ::std::string;
  }
  param2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* legalinfo::mutable_param2() {
  set_has_param2();
  if (param2_ == &::google::protobuf::internal::kEmptyString) {
    param2_ = new ::std::string;
  }
  return param2_;
}
inline ::std::string* legalinfo::release_param2() {
  clear_has_param2();
  if (param2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param2_;
    param2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void legalinfo::set_allocated_param2(::std::string* param2) {
  if (param2_ != &::google::protobuf::internal::kEmptyString) {
    delete param2_;
  }
  if (param2) {
    set_has_param2();
    param2_ = param2;
  } else {
    clear_has_param2();
    param2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string param3 = 5;
inline bool legalinfo::has_param3() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void legalinfo::set_has_param3() {
  _has_bits_[0] |= 0x00000010u;
}
inline void legalinfo::clear_has_param3() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void legalinfo::clear_param3() {
  if (param3_ != &::google::protobuf::internal::kEmptyString) {
    param3_->clear();
  }
  clear_has_param3();
}
inline const ::std::string& legalinfo::param3() const {
  return *param3_;
}
inline void legalinfo::set_param3(const ::std::string& value) {
  set_has_param3();
  if (param3_ == &::google::protobuf::internal::kEmptyString) {
    param3_ = new ::std::string;
  }
  param3_->assign(value);
}
inline void legalinfo::set_param3(const char* value) {
  set_has_param3();
  if (param3_ == &::google::protobuf::internal::kEmptyString) {
    param3_ = new ::std::string;
  }
  param3_->assign(value);
}
inline void legalinfo::set_param3(const char* value, size_t size) {
  set_has_param3();
  if (param3_ == &::google::protobuf::internal::kEmptyString) {
    param3_ = new ::std::string;
  }
  param3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* legalinfo::mutable_param3() {
  set_has_param3();
  if (param3_ == &::google::protobuf::internal::kEmptyString) {
    param3_ = new ::std::string;
  }
  return param3_;
}
inline ::std::string* legalinfo::release_param3() {
  clear_has_param3();
  if (param3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param3_;
    param3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void legalinfo::set_allocated_param3(::std::string* param3) {
  if (param3_ != &::google::protobuf::internal::kEmptyString) {
    delete param3_;
  }
  if (param3) {
    set_has_param3();
    param3_ = param3;
  } else {
    clear_has_param3();
    param3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string param4 = 6;
inline bool legalinfo::has_param4() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void legalinfo::set_has_param4() {
  _has_bits_[0] |= 0x00000020u;
}
inline void legalinfo::clear_has_param4() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void legalinfo::clear_param4() {
  if (param4_ != &::google::protobuf::internal::kEmptyString) {
    param4_->clear();
  }
  clear_has_param4();
}
inline const ::std::string& legalinfo::param4() const {
  return *param4_;
}
inline void legalinfo::set_param4(const ::std::string& value) {
  set_has_param4();
  if (param4_ == &::google::protobuf::internal::kEmptyString) {
    param4_ = new ::std::string;
  }
  param4_->assign(value);
}
inline void legalinfo::set_param4(const char* value) {
  set_has_param4();
  if (param4_ == &::google::protobuf::internal::kEmptyString) {
    param4_ = new ::std::string;
  }
  param4_->assign(value);
}
inline void legalinfo::set_param4(const char* value, size_t size) {
  set_has_param4();
  if (param4_ == &::google::protobuf::internal::kEmptyString) {
    param4_ = new ::std::string;
  }
  param4_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* legalinfo::mutable_param4() {
  set_has_param4();
  if (param4_ == &::google::protobuf::internal::kEmptyString) {
    param4_ = new ::std::string;
  }
  return param4_;
}
inline ::std::string* legalinfo::release_param4() {
  clear_has_param4();
  if (param4_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param4_;
    param4_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void legalinfo::set_allocated_param4(::std::string* param4) {
  if (param4_ != &::google::protobuf::internal::kEmptyString) {
    delete param4_;
  }
  if (param4) {
    set_has_param4();
    param4_ = param4;
  } else {
    clear_has_param4();
    param4_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string legalsign = 7;
inline bool legalinfo::has_legalsign() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void legalinfo::set_has_legalsign() {
  _has_bits_[0] |= 0x00000040u;
}
inline void legalinfo::clear_has_legalsign() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void legalinfo::clear_legalsign() {
  if (legalsign_ != &::google::protobuf::internal::kEmptyString) {
    legalsign_->clear();
  }
  clear_has_legalsign();
}
inline const ::std::string& legalinfo::legalsign() const {
  return *legalsign_;
}
inline void legalinfo::set_legalsign(const ::std::string& value) {
  set_has_legalsign();
  if (legalsign_ == &::google::protobuf::internal::kEmptyString) {
    legalsign_ = new ::std::string;
  }
  legalsign_->assign(value);
}
inline void legalinfo::set_legalsign(const char* value) {
  set_has_legalsign();
  if (legalsign_ == &::google::protobuf::internal::kEmptyString) {
    legalsign_ = new ::std::string;
  }
  legalsign_->assign(value);
}
inline void legalinfo::set_legalsign(const char* value, size_t size) {
  set_has_legalsign();
  if (legalsign_ == &::google::protobuf::internal::kEmptyString) {
    legalsign_ = new ::std::string;
  }
  legalsign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* legalinfo::mutable_legalsign() {
  set_has_legalsign();
  if (legalsign_ == &::google::protobuf::internal::kEmptyString) {
    legalsign_ = new ::std::string;
  }
  return legalsign_;
}
inline ::std::string* legalinfo::release_legalsign() {
  clear_has_legalsign();
  if (legalsign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legalsign_;
    legalsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void legalinfo::set_allocated_legalsign(::std::string* legalsign) {
  if (legalsign_ != &::google::protobuf::internal::kEmptyString) {
    delete legalsign_;
  }
  if (legalsign) {
    set_has_legalsign();
    legalsign_ = legalsign;
  } else {
    clear_has_legalsign();
    legalsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state = 8;
inline bool legalinfo::has_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void legalinfo::set_has_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void legalinfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void legalinfo::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& legalinfo::state() const {
  return *state_;
}
inline void legalinfo::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void legalinfo::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void legalinfo::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* legalinfo::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* legalinfo::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void legalinfo::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cardlist = 9;
inline bool legalinfo::has_cardlist() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void legalinfo::set_has_cardlist() {
  _has_bits_[0] |= 0x00000100u;
}
inline void legalinfo::clear_has_cardlist() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void legalinfo::clear_cardlist() {
  if (cardlist_ != &::google::protobuf::internal::kEmptyString) {
    cardlist_->clear();
  }
  clear_has_cardlist();
}
inline const ::std::string& legalinfo::cardlist() const {
  return *cardlist_;
}
inline void legalinfo::set_cardlist(const ::std::string& value) {
  set_has_cardlist();
  if (cardlist_ == &::google::protobuf::internal::kEmptyString) {
    cardlist_ = new ::std::string;
  }
  cardlist_->assign(value);
}
inline void legalinfo::set_cardlist(const char* value) {
  set_has_cardlist();
  if (cardlist_ == &::google::protobuf::internal::kEmptyString) {
    cardlist_ = new ::std::string;
  }
  cardlist_->assign(value);
}
inline void legalinfo::set_cardlist(const char* value, size_t size) {
  set_has_cardlist();
  if (cardlist_ == &::google::protobuf::internal::kEmptyString) {
    cardlist_ = new ::std::string;
  }
  cardlist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* legalinfo::mutable_cardlist() {
  set_has_cardlist();
  if (cardlist_ == &::google::protobuf::internal::kEmptyString) {
    cardlist_ = new ::std::string;
  }
  return cardlist_;
}
inline ::std::string* legalinfo::release_cardlist() {
  clear_has_cardlist();
  if (cardlist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cardlist_;
    cardlist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void legalinfo::set_allocated_cardlist(::std::string* cardlist) {
  if (cardlist_ != &::google::protobuf::internal::kEmptyString) {
    delete cardlist_;
  }
  if (cardlist) {
    set_has_cardlist();
    cardlist_ = cardlist;
  } else {
    clear_has_cardlist();
    cardlist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace progame

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_st_5futils_5fpond_2eproto__INCLUDED
