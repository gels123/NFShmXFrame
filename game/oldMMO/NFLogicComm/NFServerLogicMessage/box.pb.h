// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: box.proto

#ifndef PROTOBUF_box_2eproto__INCLUDED
#define PROTOBUF_box_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "yd_fieldoptions.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_box_2eproto();
void protobuf_AssignDesc_box_2eproto();
void protobuf_ShutdownFile_box_2eproto();

class boxboxequipDesc;
class boxboxitemDesc;
class boxbox;
class Sheet_boxbox;

// ===================================================================

class boxboxequipDesc : public ::google::protobuf::Message {
 public:
  boxboxequipDesc();
  virtual ~boxboxequipDesc();

  boxboxequipDesc(const boxboxequipDesc& from);

  inline boxboxequipDesc& operator=(const boxboxequipDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const boxboxequipDesc& default_instance();

  void Swap(boxboxequipDesc* other);

  // implements Message ----------------------------------------------

  boxboxequipDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const boxboxequipDesc& from);
  void MergeFrom(const boxboxequipDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 rand = 1;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 1;
  inline ::google::protobuf::int32 rand() const;
  inline void set_rand(::google::protobuf::int32 value);

  // optional int32 minNum = 2;
  inline bool has_minnum() const;
  inline void clear_minnum();
  static const int kMinNumFieldNumber = 2;
  inline ::google::protobuf::int32 minnum() const;
  inline void set_minnum(::google::protobuf::int32 value);

  // optional int32 isbind = 3;
  inline bool has_isbind() const;
  inline void clear_isbind();
  static const int kIsbindFieldNumber = 3;
  inline ::google::protobuf::int32 isbind() const;
  inline void set_isbind(::google::protobuf::int32 value);

  // optional int32 maxNum = 4;
  inline bool has_maxnum() const;
  inline void clear_maxnum();
  static const int kMaxNumFieldNumber = 4;
  inline ::google::protobuf::int32 maxnum() const;
  inline void set_maxnum(::google::protobuf::int32 value);

  // optional string id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:proto_ff.boxboxequipDesc)
 private:
  inline void set_has_rand();
  inline void clear_has_rand();
  inline void set_has_minnum();
  inline void clear_has_minnum();
  inline void set_has_isbind();
  inline void clear_has_isbind();
  inline void set_has_maxnum();
  inline void clear_has_maxnum();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 rand_;
  ::google::protobuf::int32 minnum_;
  ::google::protobuf::int32 isbind_;
  ::google::protobuf::int32 maxnum_;
  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_box_2eproto();
  friend void protobuf_AssignDesc_box_2eproto();
  friend void protobuf_ShutdownFile_box_2eproto();

  void InitAsDefaultInstance();
  static boxboxequipDesc* default_instance_;
};
// -------------------------------------------------------------------

class boxboxitemDesc : public ::google::protobuf::Message {
 public:
  boxboxitemDesc();
  virtual ~boxboxitemDesc();

  boxboxitemDesc(const boxboxitemDesc& from);

  inline boxboxitemDesc& operator=(const boxboxitemDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const boxboxitemDesc& default_instance();

  void Swap(boxboxitemDesc* other);

  // implements Message ----------------------------------------------

  boxboxitemDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const boxboxitemDesc& from);
  void MergeFrom(const boxboxitemDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string rand = 1;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 1;
  inline const ::std::string& rand() const;
  inline void set_rand(const ::std::string& value);
  inline void set_rand(const char* value);
  inline void set_rand(const char* value, size_t size);
  inline ::std::string* mutable_rand();
  inline ::std::string* release_rand();
  inline void set_allocated_rand(::std::string* rand);

  // optional int32 maxNum = 2;
  inline bool has_maxnum() const;
  inline void clear_maxnum();
  static const int kMaxNumFieldNumber = 2;
  inline ::google::protobuf::int32 maxnum() const;
  inline void set_maxnum(::google::protobuf::int32 value);

  // optional int32 rarerand = 3;
  inline bool has_rarerand() const;
  inline void clear_rarerand();
  static const int kRarerandFieldNumber = 3;
  inline ::google::protobuf::int32 rarerand() const;
  inline void set_rarerand(::google::protobuf::int32 value);

  // optional int32 minNum = 4;
  inline bool has_minnum() const;
  inline void clear_minnum();
  static const int kMinNumFieldNumber = 4;
  inline ::google::protobuf::int32 minnum() const;
  inline void set_minnum(::google::protobuf::int32 value);

  // optional string isbind = 5;
  inline bool has_isbind() const;
  inline void clear_isbind();
  static const int kIsbindFieldNumber = 5;
  inline const ::std::string& isbind() const;
  inline void set_isbind(const ::std::string& value);
  inline void set_isbind(const char* value);
  inline void set_isbind(const char* value, size_t size);
  inline ::std::string* mutable_isbind();
  inline ::std::string* release_isbind();
  inline void set_allocated_isbind(::std::string* isbind);

  // optional string id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:proto_ff.boxboxitemDesc)
 private:
  inline void set_has_rand();
  inline void clear_has_rand();
  inline void set_has_maxnum();
  inline void clear_has_maxnum();
  inline void set_has_rarerand();
  inline void clear_has_rarerand();
  inline void set_has_minnum();
  inline void clear_has_minnum();
  inline void set_has_isbind();
  inline void clear_has_isbind();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* rand_;
  ::google::protobuf::int32 maxnum_;
  ::google::protobuf::int32 rarerand_;
  ::std::string* isbind_;
  ::std::string* id_;
  ::google::protobuf::int32 minnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_box_2eproto();
  friend void protobuf_AssignDesc_box_2eproto();
  friend void protobuf_ShutdownFile_box_2eproto();

  void InitAsDefaultInstance();
  static boxboxitemDesc* default_instance_;
};
// -------------------------------------------------------------------

class boxbox : public ::google::protobuf::Message {
 public:
  boxbox();
  virtual ~boxbox();

  boxbox(const boxbox& from);

  inline boxbox& operator=(const boxbox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const boxbox& default_instance();

  void Swap(boxbox* other);

  // implements Message ----------------------------------------------

  boxbox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const boxbox& from);
  void MergeFrom(const boxbox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional int32 drop_type = 2;
  inline bool has_drop_type() const;
  inline void clear_drop_type();
  static const int kDropTypeFieldNumber = 2;
  inline ::google::protobuf::int32 drop_type() const;
  inline void set_drop_type(::google::protobuf::int32 value);

  // optional int32 goldminNum = 3;
  inline bool has_goldminnum() const;
  inline void clear_goldminnum();
  static const int kGoldminNumFieldNumber = 3;
  inline ::google::protobuf::int32 goldminnum() const;
  inline void set_goldminnum(::google::protobuf::int32 value);

  // optional int32 goldmaxNum = 4;
  inline bool has_goldmaxnum() const;
  inline void clear_goldmaxnum();
  static const int kGoldmaxNumFieldNumber = 4;
  inline ::google::protobuf::int32 goldmaxnum() const;
  inline void set_goldmaxnum(::google::protobuf::int32 value);

  // optional int32 goldrand = 5;
  inline bool has_goldrand() const;
  inline void clear_goldrand();
  static const int kGoldrandFieldNumber = 5;
  inline ::google::protobuf::int32 goldrand() const;
  inline void set_goldrand(::google::protobuf::int32 value);

  // optional int32 bindjewelminNum = 6;
  inline bool has_bindjewelminnum() const;
  inline void clear_bindjewelminnum();
  static const int kBindjewelminNumFieldNumber = 6;
  inline ::google::protobuf::int32 bindjewelminnum() const;
  inline void set_bindjewelminnum(::google::protobuf::int32 value);

  // optional int32 bindjewelmaxNum = 7;
  inline bool has_bindjewelmaxnum() const;
  inline void clear_bindjewelmaxnum();
  static const int kBindjewelmaxNumFieldNumber = 7;
  inline ::google::protobuf::int32 bindjewelmaxnum() const;
  inline void set_bindjewelmaxnum(::google::protobuf::int32 value);

  // optional int32 bindjewelrand = 8;
  inline bool has_bindjewelrand() const;
  inline void clear_bindjewelrand();
  static const int kBindjewelrandFieldNumber = 8;
  inline ::google::protobuf::int32 bindjewelrand() const;
  inline void set_bindjewelrand(::google::protobuf::int32 value);

  // optional int32 jewelminNum = 9;
  inline bool has_jewelminnum() const;
  inline void clear_jewelminnum();
  static const int kJewelminNumFieldNumber = 9;
  inline ::google::protobuf::int32 jewelminnum() const;
  inline void set_jewelminnum(::google::protobuf::int32 value);

  // optional int32 jewelmaxNum = 10;
  inline bool has_jewelmaxnum() const;
  inline void clear_jewelmaxnum();
  static const int kJewelmaxNumFieldNumber = 10;
  inline ::google::protobuf::int32 jewelmaxnum() const;
  inline void set_jewelmaxnum(::google::protobuf::int32 value);

  // optional int32 jewelrand = 11;
  inline bool has_jewelrand() const;
  inline void clear_jewelrand();
  static const int kJewelrandFieldNumber = 11;
  inline ::google::protobuf::int32 jewelrand() const;
  inline void set_jewelrand(::google::protobuf::int32 value);

  // optional int32 godjewelminNum = 12;
  inline bool has_godjewelminnum() const;
  inline void clear_godjewelminnum();
  static const int kGodjewelminNumFieldNumber = 12;
  inline ::google::protobuf::int32 godjewelminnum() const;
  inline void set_godjewelminnum(::google::protobuf::int32 value);

  // optional int32 godjewelmaxNum = 13;
  inline bool has_godjewelmaxnum() const;
  inline void clear_godjewelmaxnum();
  static const int kGodjewelmaxNumFieldNumber = 13;
  inline ::google::protobuf::int32 godjewelmaxnum() const;
  inline void set_godjewelmaxnum(::google::protobuf::int32 value);

  // optional int32 godjewelrand = 14;
  inline bool has_godjewelrand() const;
  inline void clear_godjewelrand();
  static const int kGodjewelrandFieldNumber = 14;
  inline ::google::protobuf::int32 godjewelrand() const;
  inline void set_godjewelrand(::google::protobuf::int32 value);

  // optional string eq_profession = 15;
  inline bool has_eq_profession() const;
  inline void clear_eq_profession();
  static const int kEqProfessionFieldNumber = 15;
  inline const ::std::string& eq_profession() const;
  inline void set_eq_profession(const ::std::string& value);
  inline void set_eq_profession(const char* value);
  inline void set_eq_profession(const char* value, size_t size);
  inline ::std::string* mutable_eq_profession();
  inline ::std::string* release_eq_profession();
  inline void set_allocated_eq_profession(::std::string* eq_profession);

  // repeated .proto_ff.boxboxequipDesc equip = 16;
  inline int equip_size() const;
  inline void clear_equip();
  static const int kEquipFieldNumber = 16;
  inline const ::proto_ff::boxboxequipDesc& equip(int index) const;
  inline ::proto_ff::boxboxequipDesc* mutable_equip(int index);
  inline ::proto_ff::boxboxequipDesc* add_equip();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxequipDesc >&
      equip() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxequipDesc >*
      mutable_equip();

  // repeated .proto_ff.boxboxitemDesc item = 17;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 17;
  inline const ::proto_ff::boxboxitemDesc& item(int index) const;
  inline ::proto_ff::boxboxitemDesc* mutable_item(int index);
  inline ::proto_ff::boxboxitemDesc* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxitemDesc >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxitemDesc >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:proto_ff.boxbox)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_drop_type();
  inline void clear_has_drop_type();
  inline void set_has_goldminnum();
  inline void clear_has_goldminnum();
  inline void set_has_goldmaxnum();
  inline void clear_has_goldmaxnum();
  inline void set_has_goldrand();
  inline void clear_has_goldrand();
  inline void set_has_bindjewelminnum();
  inline void clear_has_bindjewelminnum();
  inline void set_has_bindjewelmaxnum();
  inline void clear_has_bindjewelmaxnum();
  inline void set_has_bindjewelrand();
  inline void clear_has_bindjewelrand();
  inline void set_has_jewelminnum();
  inline void clear_has_jewelminnum();
  inline void set_has_jewelmaxnum();
  inline void clear_has_jewelmaxnum();
  inline void set_has_jewelrand();
  inline void clear_has_jewelrand();
  inline void set_has_godjewelminnum();
  inline void clear_has_godjewelminnum();
  inline void set_has_godjewelmaxnum();
  inline void clear_has_godjewelmaxnum();
  inline void set_has_godjewelrand();
  inline void clear_has_godjewelrand();
  inline void set_has_eq_profession();
  inline void clear_has_eq_profession();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 drop_type_;
  ::google::protobuf::int32 goldminnum_;
  ::google::protobuf::int32 goldmaxnum_;
  ::google::protobuf::int32 goldrand_;
  ::google::protobuf::int32 bindjewelminnum_;
  ::google::protobuf::int32 bindjewelmaxnum_;
  ::google::protobuf::int32 bindjewelrand_;
  ::google::protobuf::int32 jewelminnum_;
  ::google::protobuf::int32 jewelmaxnum_;
  ::google::protobuf::int32 jewelrand_;
  ::google::protobuf::int32 godjewelminnum_;
  ::google::protobuf::int32 godjewelmaxnum_;
  ::std::string* eq_profession_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxequipDesc > equip_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxitemDesc > item_;
  ::google::protobuf::int32 godjewelrand_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_box_2eproto();
  friend void protobuf_AssignDesc_box_2eproto();
  friend void protobuf_ShutdownFile_box_2eproto();

  void InitAsDefaultInstance();
  static boxbox* default_instance_;
};
// -------------------------------------------------------------------

class Sheet_boxbox : public ::google::protobuf::Message {
 public:
  Sheet_boxbox();
  virtual ~Sheet_boxbox();

  Sheet_boxbox(const Sheet_boxbox& from);

  inline Sheet_boxbox& operator=(const Sheet_boxbox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sheet_boxbox& default_instance();

  void Swap(Sheet_boxbox* other);

  // implements Message ----------------------------------------------

  Sheet_boxbox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sheet_boxbox& from);
  void MergeFrom(const Sheet_boxbox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto_ff.boxbox boxbox_List = 1;
  inline int boxbox_list_size() const;
  inline void clear_boxbox_list();
  static const int kBoxboxListFieldNumber = 1;
  inline const ::proto_ff::boxbox& boxbox_list(int index) const;
  inline ::proto_ff::boxbox* mutable_boxbox_list(int index);
  inline ::proto_ff::boxbox* add_boxbox_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxbox >&
      boxbox_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxbox >*
      mutable_boxbox_list();

  // @@protoc_insertion_point(class_scope:proto_ff.Sheet_boxbox)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::boxbox > boxbox_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_box_2eproto();
  friend void protobuf_AssignDesc_box_2eproto();
  friend void protobuf_ShutdownFile_box_2eproto();

  void InitAsDefaultInstance();
  static Sheet_boxbox* default_instance_;
};
// ===================================================================


// ===================================================================

// boxboxequipDesc

// optional int32 rand = 1;
inline bool boxboxequipDesc::has_rand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void boxboxequipDesc::set_has_rand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void boxboxequipDesc::clear_has_rand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void boxboxequipDesc::clear_rand() {
  rand_ = 0;
  clear_has_rand();
}
inline ::google::protobuf::int32 boxboxequipDesc::rand() const {
  return rand_;
}
inline void boxboxequipDesc::set_rand(::google::protobuf::int32 value) {
  set_has_rand();
  rand_ = value;
}

// optional int32 minNum = 2;
inline bool boxboxequipDesc::has_minnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void boxboxequipDesc::set_has_minnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void boxboxequipDesc::clear_has_minnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void boxboxequipDesc::clear_minnum() {
  minnum_ = 0;
  clear_has_minnum();
}
inline ::google::protobuf::int32 boxboxequipDesc::minnum() const {
  return minnum_;
}
inline void boxboxequipDesc::set_minnum(::google::protobuf::int32 value) {
  set_has_minnum();
  minnum_ = value;
}

// optional int32 isbind = 3;
inline bool boxboxequipDesc::has_isbind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void boxboxequipDesc::set_has_isbind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void boxboxequipDesc::clear_has_isbind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void boxboxequipDesc::clear_isbind() {
  isbind_ = 0;
  clear_has_isbind();
}
inline ::google::protobuf::int32 boxboxequipDesc::isbind() const {
  return isbind_;
}
inline void boxboxequipDesc::set_isbind(::google::protobuf::int32 value) {
  set_has_isbind();
  isbind_ = value;
}

// optional int32 maxNum = 4;
inline bool boxboxequipDesc::has_maxnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void boxboxequipDesc::set_has_maxnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void boxboxequipDesc::clear_has_maxnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void boxboxequipDesc::clear_maxnum() {
  maxnum_ = 0;
  clear_has_maxnum();
}
inline ::google::protobuf::int32 boxboxequipDesc::maxnum() const {
  return maxnum_;
}
inline void boxboxequipDesc::set_maxnum(::google::protobuf::int32 value) {
  set_has_maxnum();
  maxnum_ = value;
}

// optional string id = 5;
inline bool boxboxequipDesc::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void boxboxequipDesc::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void boxboxequipDesc::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void boxboxequipDesc::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& boxboxequipDesc::id() const {
  return *id_;
}
inline void boxboxequipDesc::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void boxboxequipDesc::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void boxboxequipDesc::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* boxboxequipDesc::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* boxboxequipDesc::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void boxboxequipDesc::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// boxboxitemDesc

// optional string rand = 1;
inline bool boxboxitemDesc::has_rand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void boxboxitemDesc::set_has_rand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void boxboxitemDesc::clear_has_rand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void boxboxitemDesc::clear_rand() {
  if (rand_ != &::google::protobuf::internal::kEmptyString) {
    rand_->clear();
  }
  clear_has_rand();
}
inline const ::std::string& boxboxitemDesc::rand() const {
  return *rand_;
}
inline void boxboxitemDesc::set_rand(const ::std::string& value) {
  set_has_rand();
  if (rand_ == &::google::protobuf::internal::kEmptyString) {
    rand_ = new ::std::string;
  }
  rand_->assign(value);
}
inline void boxboxitemDesc::set_rand(const char* value) {
  set_has_rand();
  if (rand_ == &::google::protobuf::internal::kEmptyString) {
    rand_ = new ::std::string;
  }
  rand_->assign(value);
}
inline void boxboxitemDesc::set_rand(const char* value, size_t size) {
  set_has_rand();
  if (rand_ == &::google::protobuf::internal::kEmptyString) {
    rand_ = new ::std::string;
  }
  rand_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* boxboxitemDesc::mutable_rand() {
  set_has_rand();
  if (rand_ == &::google::protobuf::internal::kEmptyString) {
    rand_ = new ::std::string;
  }
  return rand_;
}
inline ::std::string* boxboxitemDesc::release_rand() {
  clear_has_rand();
  if (rand_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rand_;
    rand_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void boxboxitemDesc::set_allocated_rand(::std::string* rand) {
  if (rand_ != &::google::protobuf::internal::kEmptyString) {
    delete rand_;
  }
  if (rand) {
    set_has_rand();
    rand_ = rand;
  } else {
    clear_has_rand();
    rand_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 maxNum = 2;
inline bool boxboxitemDesc::has_maxnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void boxboxitemDesc::set_has_maxnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void boxboxitemDesc::clear_has_maxnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void boxboxitemDesc::clear_maxnum() {
  maxnum_ = 0;
  clear_has_maxnum();
}
inline ::google::protobuf::int32 boxboxitemDesc::maxnum() const {
  return maxnum_;
}
inline void boxboxitemDesc::set_maxnum(::google::protobuf::int32 value) {
  set_has_maxnum();
  maxnum_ = value;
}

// optional int32 rarerand = 3;
inline bool boxboxitemDesc::has_rarerand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void boxboxitemDesc::set_has_rarerand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void boxboxitemDesc::clear_has_rarerand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void boxboxitemDesc::clear_rarerand() {
  rarerand_ = 0;
  clear_has_rarerand();
}
inline ::google::protobuf::int32 boxboxitemDesc::rarerand() const {
  return rarerand_;
}
inline void boxboxitemDesc::set_rarerand(::google::protobuf::int32 value) {
  set_has_rarerand();
  rarerand_ = value;
}

// optional int32 minNum = 4;
inline bool boxboxitemDesc::has_minnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void boxboxitemDesc::set_has_minnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void boxboxitemDesc::clear_has_minnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void boxboxitemDesc::clear_minnum() {
  minnum_ = 0;
  clear_has_minnum();
}
inline ::google::protobuf::int32 boxboxitemDesc::minnum() const {
  return minnum_;
}
inline void boxboxitemDesc::set_minnum(::google::protobuf::int32 value) {
  set_has_minnum();
  minnum_ = value;
}

// optional string isbind = 5;
inline bool boxboxitemDesc::has_isbind() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void boxboxitemDesc::set_has_isbind() {
  _has_bits_[0] |= 0x00000010u;
}
inline void boxboxitemDesc::clear_has_isbind() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void boxboxitemDesc::clear_isbind() {
  if (isbind_ != &::google::protobuf::internal::kEmptyString) {
    isbind_->clear();
  }
  clear_has_isbind();
}
inline const ::std::string& boxboxitemDesc::isbind() const {
  return *isbind_;
}
inline void boxboxitemDesc::set_isbind(const ::std::string& value) {
  set_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    isbind_ = new ::std::string;
  }
  isbind_->assign(value);
}
inline void boxboxitemDesc::set_isbind(const char* value) {
  set_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    isbind_ = new ::std::string;
  }
  isbind_->assign(value);
}
inline void boxboxitemDesc::set_isbind(const char* value, size_t size) {
  set_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    isbind_ = new ::std::string;
  }
  isbind_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* boxboxitemDesc::mutable_isbind() {
  set_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    isbind_ = new ::std::string;
  }
  return isbind_;
}
inline ::std::string* boxboxitemDesc::release_isbind() {
  clear_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isbind_;
    isbind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void boxboxitemDesc::set_allocated_isbind(::std::string* isbind) {
  if (isbind_ != &::google::protobuf::internal::kEmptyString) {
    delete isbind_;
  }
  if (isbind) {
    set_has_isbind();
    isbind_ = isbind;
  } else {
    clear_has_isbind();
    isbind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id = 6;
inline bool boxboxitemDesc::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void boxboxitemDesc::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void boxboxitemDesc::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void boxboxitemDesc::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& boxboxitemDesc::id() const {
  return *id_;
}
inline void boxboxitemDesc::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void boxboxitemDesc::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void boxboxitemDesc::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* boxboxitemDesc::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* boxboxitemDesc::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void boxboxitemDesc::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// boxbox

// optional int64 id = 1;
inline bool boxbox::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void boxbox::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void boxbox::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void boxbox::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 boxbox::id() const {
  return id_;
}
inline void boxbox::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional int32 drop_type = 2;
inline bool boxbox::has_drop_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void boxbox::set_has_drop_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void boxbox::clear_has_drop_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void boxbox::clear_drop_type() {
  drop_type_ = 0;
  clear_has_drop_type();
}
inline ::google::protobuf::int32 boxbox::drop_type() const {
  return drop_type_;
}
inline void boxbox::set_drop_type(::google::protobuf::int32 value) {
  set_has_drop_type();
  drop_type_ = value;
}

// optional int32 goldminNum = 3;
inline bool boxbox::has_goldminnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void boxbox::set_has_goldminnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void boxbox::clear_has_goldminnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void boxbox::clear_goldminnum() {
  goldminnum_ = 0;
  clear_has_goldminnum();
}
inline ::google::protobuf::int32 boxbox::goldminnum() const {
  return goldminnum_;
}
inline void boxbox::set_goldminnum(::google::protobuf::int32 value) {
  set_has_goldminnum();
  goldminnum_ = value;
}

// optional int32 goldmaxNum = 4;
inline bool boxbox::has_goldmaxnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void boxbox::set_has_goldmaxnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void boxbox::clear_has_goldmaxnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void boxbox::clear_goldmaxnum() {
  goldmaxnum_ = 0;
  clear_has_goldmaxnum();
}
inline ::google::protobuf::int32 boxbox::goldmaxnum() const {
  return goldmaxnum_;
}
inline void boxbox::set_goldmaxnum(::google::protobuf::int32 value) {
  set_has_goldmaxnum();
  goldmaxnum_ = value;
}

// optional int32 goldrand = 5;
inline bool boxbox::has_goldrand() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void boxbox::set_has_goldrand() {
  _has_bits_[0] |= 0x00000010u;
}
inline void boxbox::clear_has_goldrand() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void boxbox::clear_goldrand() {
  goldrand_ = 0;
  clear_has_goldrand();
}
inline ::google::protobuf::int32 boxbox::goldrand() const {
  return goldrand_;
}
inline void boxbox::set_goldrand(::google::protobuf::int32 value) {
  set_has_goldrand();
  goldrand_ = value;
}

// optional int32 bindjewelminNum = 6;
inline bool boxbox::has_bindjewelminnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void boxbox::set_has_bindjewelminnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void boxbox::clear_has_bindjewelminnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void boxbox::clear_bindjewelminnum() {
  bindjewelminnum_ = 0;
  clear_has_bindjewelminnum();
}
inline ::google::protobuf::int32 boxbox::bindjewelminnum() const {
  return bindjewelminnum_;
}
inline void boxbox::set_bindjewelminnum(::google::protobuf::int32 value) {
  set_has_bindjewelminnum();
  bindjewelminnum_ = value;
}

// optional int32 bindjewelmaxNum = 7;
inline bool boxbox::has_bindjewelmaxnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void boxbox::set_has_bindjewelmaxnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void boxbox::clear_has_bindjewelmaxnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void boxbox::clear_bindjewelmaxnum() {
  bindjewelmaxnum_ = 0;
  clear_has_bindjewelmaxnum();
}
inline ::google::protobuf::int32 boxbox::bindjewelmaxnum() const {
  return bindjewelmaxnum_;
}
inline void boxbox::set_bindjewelmaxnum(::google::protobuf::int32 value) {
  set_has_bindjewelmaxnum();
  bindjewelmaxnum_ = value;
}

// optional int32 bindjewelrand = 8;
inline bool boxbox::has_bindjewelrand() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void boxbox::set_has_bindjewelrand() {
  _has_bits_[0] |= 0x00000080u;
}
inline void boxbox::clear_has_bindjewelrand() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void boxbox::clear_bindjewelrand() {
  bindjewelrand_ = 0;
  clear_has_bindjewelrand();
}
inline ::google::protobuf::int32 boxbox::bindjewelrand() const {
  return bindjewelrand_;
}
inline void boxbox::set_bindjewelrand(::google::protobuf::int32 value) {
  set_has_bindjewelrand();
  bindjewelrand_ = value;
}

// optional int32 jewelminNum = 9;
inline bool boxbox::has_jewelminnum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void boxbox::set_has_jewelminnum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void boxbox::clear_has_jewelminnum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void boxbox::clear_jewelminnum() {
  jewelminnum_ = 0;
  clear_has_jewelminnum();
}
inline ::google::protobuf::int32 boxbox::jewelminnum() const {
  return jewelminnum_;
}
inline void boxbox::set_jewelminnum(::google::protobuf::int32 value) {
  set_has_jewelminnum();
  jewelminnum_ = value;
}

// optional int32 jewelmaxNum = 10;
inline bool boxbox::has_jewelmaxnum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void boxbox::set_has_jewelmaxnum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void boxbox::clear_has_jewelmaxnum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void boxbox::clear_jewelmaxnum() {
  jewelmaxnum_ = 0;
  clear_has_jewelmaxnum();
}
inline ::google::protobuf::int32 boxbox::jewelmaxnum() const {
  return jewelmaxnum_;
}
inline void boxbox::set_jewelmaxnum(::google::protobuf::int32 value) {
  set_has_jewelmaxnum();
  jewelmaxnum_ = value;
}

// optional int32 jewelrand = 11;
inline bool boxbox::has_jewelrand() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void boxbox::set_has_jewelrand() {
  _has_bits_[0] |= 0x00000400u;
}
inline void boxbox::clear_has_jewelrand() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void boxbox::clear_jewelrand() {
  jewelrand_ = 0;
  clear_has_jewelrand();
}
inline ::google::protobuf::int32 boxbox::jewelrand() const {
  return jewelrand_;
}
inline void boxbox::set_jewelrand(::google::protobuf::int32 value) {
  set_has_jewelrand();
  jewelrand_ = value;
}

// optional int32 godjewelminNum = 12;
inline bool boxbox::has_godjewelminnum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void boxbox::set_has_godjewelminnum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void boxbox::clear_has_godjewelminnum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void boxbox::clear_godjewelminnum() {
  godjewelminnum_ = 0;
  clear_has_godjewelminnum();
}
inline ::google::protobuf::int32 boxbox::godjewelminnum() const {
  return godjewelminnum_;
}
inline void boxbox::set_godjewelminnum(::google::protobuf::int32 value) {
  set_has_godjewelminnum();
  godjewelminnum_ = value;
}

// optional int32 godjewelmaxNum = 13;
inline bool boxbox::has_godjewelmaxnum() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void boxbox::set_has_godjewelmaxnum() {
  _has_bits_[0] |= 0x00001000u;
}
inline void boxbox::clear_has_godjewelmaxnum() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void boxbox::clear_godjewelmaxnum() {
  godjewelmaxnum_ = 0;
  clear_has_godjewelmaxnum();
}
inline ::google::protobuf::int32 boxbox::godjewelmaxnum() const {
  return godjewelmaxnum_;
}
inline void boxbox::set_godjewelmaxnum(::google::protobuf::int32 value) {
  set_has_godjewelmaxnum();
  godjewelmaxnum_ = value;
}

// optional int32 godjewelrand = 14;
inline bool boxbox::has_godjewelrand() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void boxbox::set_has_godjewelrand() {
  _has_bits_[0] |= 0x00002000u;
}
inline void boxbox::clear_has_godjewelrand() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void boxbox::clear_godjewelrand() {
  godjewelrand_ = 0;
  clear_has_godjewelrand();
}
inline ::google::protobuf::int32 boxbox::godjewelrand() const {
  return godjewelrand_;
}
inline void boxbox::set_godjewelrand(::google::protobuf::int32 value) {
  set_has_godjewelrand();
  godjewelrand_ = value;
}

// optional string eq_profession = 15;
inline bool boxbox::has_eq_profession() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void boxbox::set_has_eq_profession() {
  _has_bits_[0] |= 0x00004000u;
}
inline void boxbox::clear_has_eq_profession() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void boxbox::clear_eq_profession() {
  if (eq_profession_ != &::google::protobuf::internal::kEmptyString) {
    eq_profession_->clear();
  }
  clear_has_eq_profession();
}
inline const ::std::string& boxbox::eq_profession() const {
  return *eq_profession_;
}
inline void boxbox::set_eq_profession(const ::std::string& value) {
  set_has_eq_profession();
  if (eq_profession_ == &::google::protobuf::internal::kEmptyString) {
    eq_profession_ = new ::std::string;
  }
  eq_profession_->assign(value);
}
inline void boxbox::set_eq_profession(const char* value) {
  set_has_eq_profession();
  if (eq_profession_ == &::google::protobuf::internal::kEmptyString) {
    eq_profession_ = new ::std::string;
  }
  eq_profession_->assign(value);
}
inline void boxbox::set_eq_profession(const char* value, size_t size) {
  set_has_eq_profession();
  if (eq_profession_ == &::google::protobuf::internal::kEmptyString) {
    eq_profession_ = new ::std::string;
  }
  eq_profession_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* boxbox::mutable_eq_profession() {
  set_has_eq_profession();
  if (eq_profession_ == &::google::protobuf::internal::kEmptyString) {
    eq_profession_ = new ::std::string;
  }
  return eq_profession_;
}
inline ::std::string* boxbox::release_eq_profession() {
  clear_has_eq_profession();
  if (eq_profession_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eq_profession_;
    eq_profession_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void boxbox::set_allocated_eq_profession(::std::string* eq_profession) {
  if (eq_profession_ != &::google::protobuf::internal::kEmptyString) {
    delete eq_profession_;
  }
  if (eq_profession) {
    set_has_eq_profession();
    eq_profession_ = eq_profession;
  } else {
    clear_has_eq_profession();
    eq_profession_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto_ff.boxboxequipDesc equip = 16;
inline int boxbox::equip_size() const {
  return equip_.size();
}
inline void boxbox::clear_equip() {
  equip_.Clear();
}
inline const ::proto_ff::boxboxequipDesc& boxbox::equip(int index) const {
  return equip_.Get(index);
}
inline ::proto_ff::boxboxequipDesc* boxbox::mutable_equip(int index) {
  return equip_.Mutable(index);
}
inline ::proto_ff::boxboxequipDesc* boxbox::add_equip() {
  return equip_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxequipDesc >&
boxbox::equip() const {
  return equip_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxequipDesc >*
boxbox::mutable_equip() {
  return &equip_;
}

// repeated .proto_ff.boxboxitemDesc item = 17;
inline int boxbox::item_size() const {
  return item_.size();
}
inline void boxbox::clear_item() {
  item_.Clear();
}
inline const ::proto_ff::boxboxitemDesc& boxbox::item(int index) const {
  return item_.Get(index);
}
inline ::proto_ff::boxboxitemDesc* boxbox::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::proto_ff::boxboxitemDesc* boxbox::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxitemDesc >&
boxbox::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxitemDesc >*
boxbox::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// Sheet_boxbox

// repeated .proto_ff.boxbox boxbox_List = 1;
inline int Sheet_boxbox::boxbox_list_size() const {
  return boxbox_list_.size();
}
inline void Sheet_boxbox::clear_boxbox_list() {
  boxbox_list_.Clear();
}
inline const ::proto_ff::boxbox& Sheet_boxbox::boxbox_list(int index) const {
  return boxbox_list_.Get(index);
}
inline ::proto_ff::boxbox* Sheet_boxbox::mutable_boxbox_list(int index) {
  return boxbox_list_.Mutable(index);
}
inline ::proto_ff::boxbox* Sheet_boxbox::add_boxbox_list() {
  return boxbox_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxbox >&
Sheet_boxbox::boxbox_list() const {
  return boxbox_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxbox >*
Sheet_boxbox::mutable_boxbox_list() {
  return &boxbox_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_box_2eproto__INCLUDED
