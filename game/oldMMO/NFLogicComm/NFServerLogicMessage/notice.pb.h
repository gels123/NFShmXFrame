// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: notice.proto

#ifndef PROTOBUF_notice_2eproto__INCLUDED
#define PROTOBUF_notice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "yd_fieldoptions.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_notice_2eproto();
void protobuf_AssignDesc_notice_2eproto();
void protobuf_ShutdownFile_notice_2eproto();

class noticenotice;
class Sheet_noticenotice;

// ===================================================================

class noticenotice : public ::google::protobuf::Message {
 public:
  noticenotice();
  virtual ~noticenotice();

  noticenotice(const noticenotice& from);

  inline noticenotice& operator=(const noticenotice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const noticenotice& default_instance();

  void Swap(noticenotice* other);

  // implements Message ----------------------------------------------

  noticenotice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const noticenotice& from);
  void MergeFrom(const noticenotice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 noticeId = 1;
  inline bool has_noticeid() const;
  inline void clear_noticeid();
  static const int kNoticeIdFieldNumber = 1;
  inline ::google::protobuf::int32 noticeid() const;
  inline void set_noticeid(::google::protobuf::int32 value);

  // optional int32 noitceOnoff = 2;
  inline bool has_noitceonoff() const;
  inline void clear_noitceonoff();
  static const int kNoitceOnoffFieldNumber = 2;
  inline ::google::protobuf::int32 noitceonoff() const;
  inline void set_noitceonoff(::google::protobuf::int32 value);

  // optional int32 noticeType = 3;
  inline bool has_noticetype() const;
  inline void clear_noticetype();
  static const int kNoticeTypeFieldNumber = 3;
  inline ::google::protobuf::int32 noticetype() const;
  inline void set_noticetype(::google::protobuf::int32 value);

  // optional string openCycle = 4;
  inline bool has_opencycle() const;
  inline void clear_opencycle();
  static const int kOpenCycleFieldNumber = 4;
  inline const ::std::string& opencycle() const;
  inline void set_opencycle(const ::std::string& value);
  inline void set_opencycle(const char* value);
  inline void set_opencycle(const char* value, size_t size);
  inline ::std::string* mutable_opencycle();
  inline ::std::string* release_opencycle();
  inline void set_allocated_opencycle(::std::string* opencycle);

  // optional string time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional int32 levelRequire = 6;
  inline bool has_levelrequire() const;
  inline void clear_levelrequire();
  static const int kLevelRequireFieldNumber = 6;
  inline ::google::protobuf::int32 levelrequire() const;
  inline void set_levelrequire(::google::protobuf::int32 value);

  // optional string endDay = 7;
  inline bool has_endday() const;
  inline void clear_endday();
  static const int kEndDayFieldNumber = 7;
  inline const ::std::string& endday() const;
  inline void set_endday(const ::std::string& value);
  inline void set_endday(const char* value);
  inline void set_endday(const char* value, size_t size);
  inline ::std::string* mutable_endday();
  inline ::std::string* release_endday();
  inline void set_allocated_endday(::std::string* endday);

  // optional string startDay = 8;
  inline bool has_startday() const;
  inline void clear_startday();
  static const int kStartDayFieldNumber = 8;
  inline const ::std::string& startday() const;
  inline void set_startday(const ::std::string& value);
  inline void set_startday(const char* value);
  inline void set_startday(const char* value, size_t size);
  inline ::std::string* mutable_startday();
  inline ::std::string* release_startday();
  inline void set_allocated_startday(::std::string* startday);

  // optional string noticeTitle = 9;
  inline bool has_noticetitle() const;
  inline void clear_noticetitle();
  static const int kNoticeTitleFieldNumber = 9;
  inline const ::std::string& noticetitle() const;
  inline void set_noticetitle(const ::std::string& value);
  inline void set_noticetitle(const char* value);
  inline void set_noticetitle(const char* value, size_t size);
  inline ::std::string* mutable_noticetitle();
  inline ::std::string* release_noticetitle();
  inline void set_allocated_noticetitle(::std::string* noticetitle);

  // optional string noticeContent = 10;
  inline bool has_noticecontent() const;
  inline void clear_noticecontent();
  static const int kNoticeContentFieldNumber = 10;
  inline const ::std::string& noticecontent() const;
  inline void set_noticecontent(const ::std::string& value);
  inline void set_noticecontent(const char* value);
  inline void set_noticecontent(const char* value, size_t size);
  inline ::std::string* mutable_noticecontent();
  inline ::std::string* release_noticecontent();
  inline void set_allocated_noticecontent(::std::string* noticecontent);

  // @@protoc_insertion_point(class_scope:proto_ff.noticenotice)
 private:
  inline void set_has_noticeid();
  inline void clear_has_noticeid();
  inline void set_has_noitceonoff();
  inline void clear_has_noitceonoff();
  inline void set_has_noticetype();
  inline void clear_has_noticetype();
  inline void set_has_opencycle();
  inline void clear_has_opencycle();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_levelrequire();
  inline void clear_has_levelrequire();
  inline void set_has_endday();
  inline void clear_has_endday();
  inline void set_has_startday();
  inline void clear_has_startday();
  inline void set_has_noticetitle();
  inline void clear_has_noticetitle();
  inline void set_has_noticecontent();
  inline void clear_has_noticecontent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 noticeid_;
  ::google::protobuf::int32 noitceonoff_;
  ::std::string* opencycle_;
  ::google::protobuf::int32 noticetype_;
  ::google::protobuf::int32 levelrequire_;
  ::std::string* time_;
  ::std::string* endday_;
  ::std::string* startday_;
  ::std::string* noticetitle_;
  ::std::string* noticecontent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_notice_2eproto();
  friend void protobuf_AssignDesc_notice_2eproto();
  friend void protobuf_ShutdownFile_notice_2eproto();

  void InitAsDefaultInstance();
  static noticenotice* default_instance_;
};
// -------------------------------------------------------------------

class Sheet_noticenotice : public ::google::protobuf::Message {
 public:
  Sheet_noticenotice();
  virtual ~Sheet_noticenotice();

  Sheet_noticenotice(const Sheet_noticenotice& from);

  inline Sheet_noticenotice& operator=(const Sheet_noticenotice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sheet_noticenotice& default_instance();

  void Swap(Sheet_noticenotice* other);

  // implements Message ----------------------------------------------

  Sheet_noticenotice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sheet_noticenotice& from);
  void MergeFrom(const Sheet_noticenotice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto_ff.noticenotice noticenotice_List = 1;
  inline int noticenotice_list_size() const;
  inline void clear_noticenotice_list();
  static const int kNoticenoticeListFieldNumber = 1;
  inline const ::proto_ff::noticenotice& noticenotice_list(int index) const;
  inline ::proto_ff::noticenotice* mutable_noticenotice_list(int index);
  inline ::proto_ff::noticenotice* add_noticenotice_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::noticenotice >&
      noticenotice_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::noticenotice >*
      mutable_noticenotice_list();

  // @@protoc_insertion_point(class_scope:proto_ff.Sheet_noticenotice)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::noticenotice > noticenotice_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_notice_2eproto();
  friend void protobuf_AssignDesc_notice_2eproto();
  friend void protobuf_ShutdownFile_notice_2eproto();

  void InitAsDefaultInstance();
  static Sheet_noticenotice* default_instance_;
};
// ===================================================================


// ===================================================================

// noticenotice

// optional int32 noticeId = 1;
inline bool noticenotice::has_noticeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void noticenotice::set_has_noticeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void noticenotice::clear_has_noticeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void noticenotice::clear_noticeid() {
  noticeid_ = 0;
  clear_has_noticeid();
}
inline ::google::protobuf::int32 noticenotice::noticeid() const {
  return noticeid_;
}
inline void noticenotice::set_noticeid(::google::protobuf::int32 value) {
  set_has_noticeid();
  noticeid_ = value;
}

// optional int32 noitceOnoff = 2;
inline bool noticenotice::has_noitceonoff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void noticenotice::set_has_noitceonoff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void noticenotice::clear_has_noitceonoff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void noticenotice::clear_noitceonoff() {
  noitceonoff_ = 0;
  clear_has_noitceonoff();
}
inline ::google::protobuf::int32 noticenotice::noitceonoff() const {
  return noitceonoff_;
}
inline void noticenotice::set_noitceonoff(::google::protobuf::int32 value) {
  set_has_noitceonoff();
  noitceonoff_ = value;
}

// optional int32 noticeType = 3;
inline bool noticenotice::has_noticetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void noticenotice::set_has_noticetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void noticenotice::clear_has_noticetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void noticenotice::clear_noticetype() {
  noticetype_ = 0;
  clear_has_noticetype();
}
inline ::google::protobuf::int32 noticenotice::noticetype() const {
  return noticetype_;
}
inline void noticenotice::set_noticetype(::google::protobuf::int32 value) {
  set_has_noticetype();
  noticetype_ = value;
}

// optional string openCycle = 4;
inline bool noticenotice::has_opencycle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void noticenotice::set_has_opencycle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void noticenotice::clear_has_opencycle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void noticenotice::clear_opencycle() {
  if (opencycle_ != &::google::protobuf::internal::kEmptyString) {
    opencycle_->clear();
  }
  clear_has_opencycle();
}
inline const ::std::string& noticenotice::opencycle() const {
  return *opencycle_;
}
inline void noticenotice::set_opencycle(const ::std::string& value) {
  set_has_opencycle();
  if (opencycle_ == &::google::protobuf::internal::kEmptyString) {
    opencycle_ = new ::std::string;
  }
  opencycle_->assign(value);
}
inline void noticenotice::set_opencycle(const char* value) {
  set_has_opencycle();
  if (opencycle_ == &::google::protobuf::internal::kEmptyString) {
    opencycle_ = new ::std::string;
  }
  opencycle_->assign(value);
}
inline void noticenotice::set_opencycle(const char* value, size_t size) {
  set_has_opencycle();
  if (opencycle_ == &::google::protobuf::internal::kEmptyString) {
    opencycle_ = new ::std::string;
  }
  opencycle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* noticenotice::mutable_opencycle() {
  set_has_opencycle();
  if (opencycle_ == &::google::protobuf::internal::kEmptyString) {
    opencycle_ = new ::std::string;
  }
  return opencycle_;
}
inline ::std::string* noticenotice::release_opencycle() {
  clear_has_opencycle();
  if (opencycle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opencycle_;
    opencycle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void noticenotice::set_allocated_opencycle(::std::string* opencycle) {
  if (opencycle_ != &::google::protobuf::internal::kEmptyString) {
    delete opencycle_;
  }
  if (opencycle) {
    set_has_opencycle();
    opencycle_ = opencycle;
  } else {
    clear_has_opencycle();
    opencycle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 5;
inline bool noticenotice::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void noticenotice::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void noticenotice::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void noticenotice::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& noticenotice::time() const {
  return *time_;
}
inline void noticenotice::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void noticenotice::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void noticenotice::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* noticenotice::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* noticenotice::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void noticenotice::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 levelRequire = 6;
inline bool noticenotice::has_levelrequire() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void noticenotice::set_has_levelrequire() {
  _has_bits_[0] |= 0x00000020u;
}
inline void noticenotice::clear_has_levelrequire() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void noticenotice::clear_levelrequire() {
  levelrequire_ = 0;
  clear_has_levelrequire();
}
inline ::google::protobuf::int32 noticenotice::levelrequire() const {
  return levelrequire_;
}
inline void noticenotice::set_levelrequire(::google::protobuf::int32 value) {
  set_has_levelrequire();
  levelrequire_ = value;
}

// optional string endDay = 7;
inline bool noticenotice::has_endday() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void noticenotice::set_has_endday() {
  _has_bits_[0] |= 0x00000040u;
}
inline void noticenotice::clear_has_endday() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void noticenotice::clear_endday() {
  if (endday_ != &::google::protobuf::internal::kEmptyString) {
    endday_->clear();
  }
  clear_has_endday();
}
inline const ::std::string& noticenotice::endday() const {
  return *endday_;
}
inline void noticenotice::set_endday(const ::std::string& value) {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  endday_->assign(value);
}
inline void noticenotice::set_endday(const char* value) {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  endday_->assign(value);
}
inline void noticenotice::set_endday(const char* value, size_t size) {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  endday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* noticenotice::mutable_endday() {
  set_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    endday_ = new ::std::string;
  }
  return endday_;
}
inline ::std::string* noticenotice::release_endday() {
  clear_has_endday();
  if (endday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endday_;
    endday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void noticenotice::set_allocated_endday(::std::string* endday) {
  if (endday_ != &::google::protobuf::internal::kEmptyString) {
    delete endday_;
  }
  if (endday) {
    set_has_endday();
    endday_ = endday;
  } else {
    clear_has_endday();
    endday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string startDay = 8;
inline bool noticenotice::has_startday() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void noticenotice::set_has_startday() {
  _has_bits_[0] |= 0x00000080u;
}
inline void noticenotice::clear_has_startday() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void noticenotice::clear_startday() {
  if (startday_ != &::google::protobuf::internal::kEmptyString) {
    startday_->clear();
  }
  clear_has_startday();
}
inline const ::std::string& noticenotice::startday() const {
  return *startday_;
}
inline void noticenotice::set_startday(const ::std::string& value) {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  startday_->assign(value);
}
inline void noticenotice::set_startday(const char* value) {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  startday_->assign(value);
}
inline void noticenotice::set_startday(const char* value, size_t size) {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  startday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* noticenotice::mutable_startday() {
  set_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    startday_ = new ::std::string;
  }
  return startday_;
}
inline ::std::string* noticenotice::release_startday() {
  clear_has_startday();
  if (startday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startday_;
    startday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void noticenotice::set_allocated_startday(::std::string* startday) {
  if (startday_ != &::google::protobuf::internal::kEmptyString) {
    delete startday_;
  }
  if (startday) {
    set_has_startday();
    startday_ = startday;
  } else {
    clear_has_startday();
    startday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string noticeTitle = 9;
inline bool noticenotice::has_noticetitle() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void noticenotice::set_has_noticetitle() {
  _has_bits_[0] |= 0x00000100u;
}
inline void noticenotice::clear_has_noticetitle() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void noticenotice::clear_noticetitle() {
  if (noticetitle_ != &::google::protobuf::internal::kEmptyString) {
    noticetitle_->clear();
  }
  clear_has_noticetitle();
}
inline const ::std::string& noticenotice::noticetitle() const {
  return *noticetitle_;
}
inline void noticenotice::set_noticetitle(const ::std::string& value) {
  set_has_noticetitle();
  if (noticetitle_ == &::google::protobuf::internal::kEmptyString) {
    noticetitle_ = new ::std::string;
  }
  noticetitle_->assign(value);
}
inline void noticenotice::set_noticetitle(const char* value) {
  set_has_noticetitle();
  if (noticetitle_ == &::google::protobuf::internal::kEmptyString) {
    noticetitle_ = new ::std::string;
  }
  noticetitle_->assign(value);
}
inline void noticenotice::set_noticetitle(const char* value, size_t size) {
  set_has_noticetitle();
  if (noticetitle_ == &::google::protobuf::internal::kEmptyString) {
    noticetitle_ = new ::std::string;
  }
  noticetitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* noticenotice::mutable_noticetitle() {
  set_has_noticetitle();
  if (noticetitle_ == &::google::protobuf::internal::kEmptyString) {
    noticetitle_ = new ::std::string;
  }
  return noticetitle_;
}
inline ::std::string* noticenotice::release_noticetitle() {
  clear_has_noticetitle();
  if (noticetitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = noticetitle_;
    noticetitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void noticenotice::set_allocated_noticetitle(::std::string* noticetitle) {
  if (noticetitle_ != &::google::protobuf::internal::kEmptyString) {
    delete noticetitle_;
  }
  if (noticetitle) {
    set_has_noticetitle();
    noticetitle_ = noticetitle;
  } else {
    clear_has_noticetitle();
    noticetitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string noticeContent = 10;
inline bool noticenotice::has_noticecontent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void noticenotice::set_has_noticecontent() {
  _has_bits_[0] |= 0x00000200u;
}
inline void noticenotice::clear_has_noticecontent() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void noticenotice::clear_noticecontent() {
  if (noticecontent_ != &::google::protobuf::internal::kEmptyString) {
    noticecontent_->clear();
  }
  clear_has_noticecontent();
}
inline const ::std::string& noticenotice::noticecontent() const {
  return *noticecontent_;
}
inline void noticenotice::set_noticecontent(const ::std::string& value) {
  set_has_noticecontent();
  if (noticecontent_ == &::google::protobuf::internal::kEmptyString) {
    noticecontent_ = new ::std::string;
  }
  noticecontent_->assign(value);
}
inline void noticenotice::set_noticecontent(const char* value) {
  set_has_noticecontent();
  if (noticecontent_ == &::google::protobuf::internal::kEmptyString) {
    noticecontent_ = new ::std::string;
  }
  noticecontent_->assign(value);
}
inline void noticenotice::set_noticecontent(const char* value, size_t size) {
  set_has_noticecontent();
  if (noticecontent_ == &::google::protobuf::internal::kEmptyString) {
    noticecontent_ = new ::std::string;
  }
  noticecontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* noticenotice::mutable_noticecontent() {
  set_has_noticecontent();
  if (noticecontent_ == &::google::protobuf::internal::kEmptyString) {
    noticecontent_ = new ::std::string;
  }
  return noticecontent_;
}
inline ::std::string* noticenotice::release_noticecontent() {
  clear_has_noticecontent();
  if (noticecontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = noticecontent_;
    noticecontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void noticenotice::set_allocated_noticecontent(::std::string* noticecontent) {
  if (noticecontent_ != &::google::protobuf::internal::kEmptyString) {
    delete noticecontent_;
  }
  if (noticecontent) {
    set_has_noticecontent();
    noticecontent_ = noticecontent;
  } else {
    clear_has_noticecontent();
    noticecontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Sheet_noticenotice

// repeated .proto_ff.noticenotice noticenotice_List = 1;
inline int Sheet_noticenotice::noticenotice_list_size() const {
  return noticenotice_list_.size();
}
inline void Sheet_noticenotice::clear_noticenotice_list() {
  noticenotice_list_.Clear();
}
inline const ::proto_ff::noticenotice& Sheet_noticenotice::noticenotice_list(int index) const {
  return noticenotice_list_.Get(index);
}
inline ::proto_ff::noticenotice* Sheet_noticenotice::mutable_noticenotice_list(int index) {
  return noticenotice_list_.Mutable(index);
}
inline ::proto_ff::noticenotice* Sheet_noticenotice::add_noticenotice_list() {
  return noticenotice_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::noticenotice >&
Sheet_noticenotice::noticenotice_list() const {
  return noticenotice_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::noticenotice >*
Sheet_noticenotice::mutable_noticenotice_list() {
  return &noticenotice_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_notice_2eproto__INCLUDED
