// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: skill.proto

#ifndef PROTOBUF_skill_2eproto__INCLUDED
#define PROTOBUF_skill_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "yd_fieldoptions.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_skill_2eproto();
void protobuf_AssignDesc_skill_2eproto();
void protobuf_ShutdownFile_skill_2eproto();

class skillskillstateBagDesc;
class skillskill;
class Sheet_skillskill;
class skillbuffeffectDesc;
class skillbuff;
class Sheet_skillbuff;

// ===================================================================

class skillskillstateBagDesc : public ::google::protobuf::Message {
 public:
  skillskillstateBagDesc();
  virtual ~skillskillstateBagDesc();

  skillskillstateBagDesc(const skillskillstateBagDesc& from);

  inline skillskillstateBagDesc& operator=(const skillskillstateBagDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const skillskillstateBagDesc& default_instance();

  void Swap(skillskillstateBagDesc* other);

  // implements Message ----------------------------------------------

  skillskillstateBagDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const skillskillstateBagDesc& from);
  void MergeFrom(const skillskillstateBagDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 Target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline ::google::protobuf::int32 target() const;
  inline void set_target(::google::protobuf::int32 value);

  // optional int32 Point = 2;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 2;
  inline ::google::protobuf::int32 point() const;
  inline void set_point(::google::protobuf::int32 value);

  // optional string Parameter = 3;
  inline bool has_parameter() const;
  inline void clear_parameter();
  static const int kParameterFieldNumber = 3;
  inline const ::std::string& parameter() const;
  inline void set_parameter(const ::std::string& value);
  inline void set_parameter(const char* value);
  inline void set_parameter(const char* value, size_t size);
  inline ::std::string* mutable_parameter();
  inline ::std::string* release_parameter();
  inline void set_allocated_parameter(::std::string* parameter);

  // optional string Rate = 4;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 4;
  inline const ::std::string& rate() const;
  inline void set_rate(const ::std::string& value);
  inline void set_rate(const char* value);
  inline void set_rate(const char* value, size_t size);
  inline ::std::string* mutable_rate();
  inline ::std::string* release_rate();
  inline void set_allocated_rate(::std::string* rate);

  // optional string Time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional int32 Type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int64 ID = 7;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 7;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.skillskillstateBagDesc)
 private:
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_parameter();
  inline void clear_has_parameter();
  inline void set_has_rate();
  inline void clear_has_rate();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 target_;
  ::google::protobuf::int32 point_;
  ::std::string* parameter_;
  ::std::string* rate_;
  ::std::string* time_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_skill_2eproto();
  friend void protobuf_AssignDesc_skill_2eproto();
  friend void protobuf_ShutdownFile_skill_2eproto();

  void InitAsDefaultInstance();
  static skillskillstateBagDesc* default_instance_;
};
// -------------------------------------------------------------------

class skillskill : public ::google::protobuf::Message {
 public:
  skillskill();
  virtual ~skillskill();

  skillskill(const skillskill& from);

  inline skillskill& operator=(const skillskill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const skillskill& default_instance();

  void Swap(skillskill* other);

  // implements Message ----------------------------------------------

  skillskill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const skillskill& from);
  void MergeFrom(const skillskill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 skillID = 1;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIDFieldNumber = 1;
  inline ::google::protobuf::int64 skillid() const;
  inline void set_skillid(::google::protobuf::int64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 skillType = 3;
  inline bool has_skilltype() const;
  inline void clear_skilltype();
  static const int kSkillTypeFieldNumber = 3;
  inline ::google::protobuf::int32 skilltype() const;
  inline void set_skilltype(::google::protobuf::int32 value);

  // optional int32 specialSkill = 4;
  inline bool has_specialskill() const;
  inline void clear_specialskill();
  static const int kSpecialSkillFieldNumber = 4;
  inline ::google::protobuf::int32 specialskill() const;
  inline void set_specialskill(::google::protobuf::int32 value);

  // optional int32 cdSkill = 5;
  inline bool has_cdskill() const;
  inline void clear_cdskill();
  static const int kCdSkillFieldNumber = 5;
  inline ::google::protobuf::int32 cdskill() const;
  inline void set_cdskill(::google::protobuf::int32 value);

  // optional int64 Relation = 6;
  inline bool has_relation() const;
  inline void clear_relation();
  static const int kRelationFieldNumber = 6;
  inline ::google::protobuf::int64 relation() const;
  inline void set_relation(::google::protobuf::int64 value);

  // optional int64 AddSkill = 7;
  inline bool has_addskill() const;
  inline void clear_addskill();
  static const int kAddSkillFieldNumber = 7;
  inline ::google::protobuf::int64 addskill() const;
  inline void set_addskill(::google::protobuf::int64 value);

  // optional int32 AddSkillTime = 8;
  inline bool has_addskilltime() const;
  inline void clear_addskilltime();
  static const int kAddSkillTimeFieldNumber = 8;
  inline ::google::protobuf::int32 addskilltime() const;
  inline void set_addskilltime(::google::protobuf::int32 value);

  // optional int32 unlockLevel = 9;
  inline bool has_unlocklevel() const;
  inline void clear_unlocklevel();
  static const int kUnlockLevelFieldNumber = 9;
  inline ::google::protobuf::int32 unlocklevel() const;
  inline void set_unlocklevel(::google::protobuf::int32 value);

  // optional int32 type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 cd = 11;
  inline bool has_cd() const;
  inline void clear_cd();
  static const int kCdFieldNumber = 11;
  inline ::google::protobuf::int32 cd() const;
  inline void set_cd(::google::protobuf::int32 value);

  // optional int32 priority = 12;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 12;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // optional string fighting = 13;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 13;
  inline const ::std::string& fighting() const;
  inline void set_fighting(const ::std::string& value);
  inline void set_fighting(const char* value);
  inline void set_fighting(const char* value, size_t size);
  inline ::std::string* mutable_fighting();
  inline ::std::string* release_fighting();
  inline void set_allocated_fighting(::std::string* fighting);

  // optional int32 releaseType = 14;
  inline bool has_releasetype() const;
  inline void clear_releasetype();
  static const int kReleaseTypeFieldNumber = 14;
  inline ::google::protobuf::int32 releasetype() const;
  inline void set_releasetype(::google::protobuf::int32 value);

  // optional int32 processTypes = 15;
  inline bool has_processtypes() const;
  inline void clear_processtypes();
  static const int kProcessTypesFieldNumber = 15;
  inline ::google::protobuf::int32 processtypes() const;
  inline void set_processtypes(::google::protobuf::int32 value);

  // optional int32 flySpeed = 16;
  inline bool has_flyspeed() const;
  inline void clear_flyspeed();
  static const int kFlySpeedFieldNumber = 16;
  inline ::google::protobuf::int32 flyspeed() const;
  inline void set_flyspeed(::google::protobuf::int32 value);

  // optional int32 readyTime = 17;
  inline bool has_readytime() const;
  inline void clear_readytime();
  static const int kReadyTimeFieldNumber = 17;
  inline ::google::protobuf::int32 readytime() const;
  inline void set_readytime(::google::protobuf::int32 value);

  // optional int32 attackTime = 18;
  inline bool has_attacktime() const;
  inline void clear_attacktime();
  static const int kAttackTimeFieldNumber = 18;
  inline ::google::protobuf::int32 attacktime() const;
  inline void set_attacktime(::google::protobuf::int32 value);

  // optional string damageTime = 19;
  inline bool has_damagetime() const;
  inline void clear_damagetime();
  static const int kDamageTimeFieldNumber = 19;
  inline const ::std::string& damagetime() const;
  inline void set_damagetime(const ::std::string& value);
  inline void set_damagetime(const char* value);
  inline void set_damagetime(const char* value, size_t size);
  inline ::std::string* mutable_damagetime();
  inline ::std::string* release_damagetime();
  inline void set_allocated_damagetime(::std::string* damagetime);

  // optional int32 displaceTime = 20;
  inline bool has_displacetime() const;
  inline void clear_displacetime();
  static const int kDisplaceTimeFieldNumber = 20;
  inline ::google::protobuf::int32 displacetime() const;
  inline void set_displacetime(::google::protobuf::int32 value);

  // optional int32 displaceSign = 21;
  inline bool has_displacesign() const;
  inline void clear_displacesign();
  static const int kDisplaceSignFieldNumber = 21;
  inline ::google::protobuf::int32 displacesign() const;
  inline void set_displacesign(::google::protobuf::int32 value);

  // optional string displaceSpeed = 22;
  inline bool has_displacespeed() const;
  inline void clear_displacespeed();
  static const int kDisplaceSpeedFieldNumber = 22;
  inline const ::std::string& displacespeed() const;
  inline void set_displacespeed(const ::std::string& value);
  inline void set_displacespeed(const char* value);
  inline void set_displacespeed(const char* value, size_t size);
  inline ::std::string* mutable_displacespeed();
  inline ::std::string* release_displacespeed();
  inline void set_allocated_displacespeed(::std::string* displacespeed);

  // optional string disTimes = 23;
  inline bool has_distimes() const;
  inline void clear_distimes();
  static const int kDisTimesFieldNumber = 23;
  inline const ::std::string& distimes() const;
  inline void set_distimes(const ::std::string& value);
  inline void set_distimes(const char* value);
  inline void set_distimes(const char* value, size_t size);
  inline ::std::string* mutable_distimes();
  inline ::std::string* release_distimes();
  inline void set_allocated_distimes(::std::string* distimes);

  // optional int32 attackDistance = 24;
  inline bool has_attackdistance() const;
  inline void clear_attackdistance();
  static const int kAttackDistanceFieldNumber = 24;
  inline ::google::protobuf::int32 attackdistance() const;
  inline void set_attackdistance(::google::protobuf::int32 value);

  // optional int32 rangeType = 25;
  inline bool has_rangetype() const;
  inline void clear_rangetype();
  static const int kRangeTypeFieldNumber = 25;
  inline ::google::protobuf::int32 rangetype() const;
  inline void set_rangetype(::google::protobuf::int32 value);

  // optional string rangeTypeValue = 26;
  inline bool has_rangetypevalue() const;
  inline void clear_rangetypevalue();
  static const int kRangeTypeValueFieldNumber = 26;
  inline const ::std::string& rangetypevalue() const;
  inline void set_rangetypevalue(const ::std::string& value);
  inline void set_rangetypevalue(const char* value);
  inline void set_rangetypevalue(const char* value, size_t size);
  inline ::std::string* mutable_rangetypevalue();
  inline ::std::string* release_rangetypevalue();
  inline void set_allocated_rangetypevalue(::std::string* rangetypevalue);

  // optional int32 warn = 27;
  inline bool has_warn() const;
  inline void clear_warn();
  static const int kWarnFieldNumber = 27;
  inline ::google::protobuf::int32 warn() const;
  inline void set_warn(::google::protobuf::int32 value);

  // optional int32 dazeTime = 28;
  inline bool has_dazetime() const;
  inline void clear_dazetime();
  static const int kDazeTimeFieldNumber = 28;
  inline ::google::protobuf::int32 dazetime() const;
  inline void set_dazetime(::google::protobuf::int32 value);

  // optional int32 warnTime = 29;
  inline bool has_warntime() const;
  inline void clear_warntime();
  static const int kWarnTimeFieldNumber = 29;
  inline ::google::protobuf::int32 warntime() const;
  inline void set_warntime(::google::protobuf::int32 value);

  // optional string infomationId = 30;
  inline bool has_infomationid() const;
  inline void clear_infomationid();
  static const int kInfomationIdFieldNumber = 30;
  inline const ::std::string& infomationid() const;
  inline void set_infomationid(const ::std::string& value);
  inline void set_infomationid(const char* value);
  inline void set_infomationid(const char* value, size_t size);
  inline ::std::string* mutable_infomationid();
  inline ::std::string* release_infomationid();
  inline void set_allocated_infomationid(::std::string* infomationid);

  // optional int32 summonType = 31;
  inline bool has_summontype() const;
  inline void clear_summontype();
  static const int kSummonTypeFieldNumber = 31;
  inline ::google::protobuf::int32 summontype() const;
  inline void set_summontype(::google::protobuf::int32 value);

  // optional string summonValue = 32;
  inline bool has_summonvalue() const;
  inline void clear_summonvalue();
  static const int kSummonValueFieldNumber = 32;
  inline const ::std::string& summonvalue() const;
  inline void set_summonvalue(const ::std::string& value);
  inline void set_summonvalue(const char* value);
  inline void set_summonvalue(const char* value, size_t size);
  inline ::std::string* mutable_summonvalue();
  inline ::std::string* release_summonvalue();
  inline void set_allocated_summonvalue(::std::string* summonvalue);

  // optional int32 attackMinDistance = 33;
  inline bool has_attackmindistance() const;
  inline void clear_attackmindistance();
  static const int kAttackMinDistanceFieldNumber = 33;
  inline ::google::protobuf::int32 attackmindistance() const;
  inline void set_attackmindistance(::google::protobuf::int32 value);

  // optional int32 goalMaxNum = 34;
  inline bool has_goalmaxnum() const;
  inline void clear_goalmaxnum();
  static const int kGoalMaxNumFieldNumber = 34;
  inline ::google::protobuf::int32 goalmaxnum() const;
  inline void set_goalmaxnum(::google::protobuf::int32 value);

  // optional int32 damageType = 35;
  inline bool has_damagetype() const;
  inline void clear_damagetype();
  static const int kDamageTypeFieldNumber = 35;
  inline ::google::protobuf::int32 damagetype() const;
  inline void set_damagetype(::google::protobuf::int32 value);

  // optional string attackValue = 36;
  inline bool has_attackvalue() const;
  inline void clear_attackvalue();
  static const int kAttackValueFieldNumber = 36;
  inline const ::std::string& attackvalue() const;
  inline void set_attackvalue(const ::std::string& value);
  inline void set_attackvalue(const char* value);
  inline void set_attackvalue(const char* value, size_t size);
  inline ::std::string* mutable_attackvalue();
  inline ::std::string* release_attackvalue();
  inline void set_allocated_attackvalue(::std::string* attackvalue);

  // optional string attackRate = 37;
  inline bool has_attackrate() const;
  inline void clear_attackrate();
  static const int kAttackRateFieldNumber = 37;
  inline const ::std::string& attackrate() const;
  inline void set_attackrate(const ::std::string& value);
  inline void set_attackrate(const char* value);
  inline void set_attackrate(const char* value, size_t size);
  inline ::std::string* mutable_attackrate();
  inline ::std::string* release_attackrate();
  inline void set_allocated_attackrate(::std::string* attackrate);

  // optional string damageValue = 38;
  inline bool has_damagevalue() const;
  inline void clear_damagevalue();
  static const int kDamageValueFieldNumber = 38;
  inline const ::std::string& damagevalue() const;
  inline void set_damagevalue(const ::std::string& value);
  inline void set_damagevalue(const char* value);
  inline void set_damagevalue(const char* value, size_t size);
  inline ::std::string* mutable_damagevalue();
  inline ::std::string* release_damagevalue();
  inline void set_allocated_damagevalue(::std::string* damagevalue);

  // optional string damageRate = 39;
  inline bool has_damagerate() const;
  inline void clear_damagerate();
  static const int kDamageRateFieldNumber = 39;
  inline const ::std::string& damagerate() const;
  inline void set_damagerate(const ::std::string& value);
  inline void set_damagerate(const char* value);
  inline void set_damagerate(const char* value, size_t size);
  inline ::std::string* mutable_damagerate();
  inline ::std::string* release_damagerate();
  inline void set_allocated_damagerate(::std::string* damagerate);

  // optional int32 addhitrate = 40;
  inline bool has_addhitrate() const;
  inline void clear_addhitrate();
  static const int kAddhitrateFieldNumber = 40;
  inline ::google::protobuf::int32 addhitrate() const;
  inline void set_addhitrate(::google::protobuf::int32 value);

  // repeated .proto_ff.skillskillstateBagDesc stateBag = 41;
  inline int statebag_size() const;
  inline void clear_statebag();
  static const int kStateBagFieldNumber = 41;
  inline const ::proto_ff::skillskillstateBagDesc& statebag(int index) const;
  inline ::proto_ff::skillskillstateBagDesc* mutable_statebag(int index);
  inline ::proto_ff::skillskillstateBagDesc* add_statebag();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::skillskillstateBagDesc >&
      statebag() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::skillskillstateBagDesc >*
      mutable_statebag();

  // @@protoc_insertion_point(class_scope:proto_ff.skillskill)
 private:
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_skilltype();
  inline void clear_has_skilltype();
  inline void set_has_specialskill();
  inline void clear_has_specialskill();
  inline void set_has_cdskill();
  inline void clear_has_cdskill();
  inline void set_has_relation();
  inline void clear_has_relation();
  inline void set_has_addskill();
  inline void clear_has_addskill();
  inline void set_has_addskilltime();
  inline void clear_has_addskilltime();
  inline void set_has_unlocklevel();
  inline void clear_has_unlocklevel();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cd();
  inline void clear_has_cd();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_releasetype();
  inline void clear_has_releasetype();
  inline void set_has_processtypes();
  inline void clear_has_processtypes();
  inline void set_has_flyspeed();
  inline void clear_has_flyspeed();
  inline void set_has_readytime();
  inline void clear_has_readytime();
  inline void set_has_attacktime();
  inline void clear_has_attacktime();
  inline void set_has_damagetime();
  inline void clear_has_damagetime();
  inline void set_has_displacetime();
  inline void clear_has_displacetime();
  inline void set_has_displacesign();
  inline void clear_has_displacesign();
  inline void set_has_displacespeed();
  inline void clear_has_displacespeed();
  inline void set_has_distimes();
  inline void clear_has_distimes();
  inline void set_has_attackdistance();
  inline void clear_has_attackdistance();
  inline void set_has_rangetype();
  inline void clear_has_rangetype();
  inline void set_has_rangetypevalue();
  inline void clear_has_rangetypevalue();
  inline void set_has_warn();
  inline void clear_has_warn();
  inline void set_has_dazetime();
  inline void clear_has_dazetime();
  inline void set_has_warntime();
  inline void clear_has_warntime();
  inline void set_has_infomationid();
  inline void clear_has_infomationid();
  inline void set_has_summontype();
  inline void clear_has_summontype();
  inline void set_has_summonvalue();
  inline void clear_has_summonvalue();
  inline void set_has_attackmindistance();
  inline void clear_has_attackmindistance();
  inline void set_has_goalmaxnum();
  inline void clear_has_goalmaxnum();
  inline void set_has_damagetype();
  inline void clear_has_damagetype();
  inline void set_has_attackvalue();
  inline void clear_has_attackvalue();
  inline void set_has_attackrate();
  inline void clear_has_attackrate();
  inline void set_has_damagevalue();
  inline void clear_has_damagevalue();
  inline void set_has_damagerate();
  inline void clear_has_damagerate();
  inline void set_has_addhitrate();
  inline void clear_has_addhitrate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 skillid_;
  ::std::string* name_;
  ::google::protobuf::int32 skilltype_;
  ::google::protobuf::int32 specialskill_;
  ::google::protobuf::int64 relation_;
  ::google::protobuf::int32 cdskill_;
  ::google::protobuf::int32 addskilltime_;
  ::google::protobuf::int64 addskill_;
  ::google::protobuf::int32 unlocklevel_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 cd_;
  ::google::protobuf::int32 priority_;
  ::std::string* fighting_;
  ::google::protobuf::int32 releasetype_;
  ::google::protobuf::int32 processtypes_;
  ::google::protobuf::int32 flyspeed_;
  ::google::protobuf::int32 readytime_;
  ::google::protobuf::int32 attacktime_;
  ::google::protobuf::int32 displacetime_;
  ::std::string* damagetime_;
  ::std::string* displacespeed_;
  ::google::protobuf::int32 displacesign_;
  ::google::protobuf::int32 attackdistance_;
  ::std::string* distimes_;
  ::google::protobuf::int32 rangetype_;
  ::google::protobuf::int32 warn_;
  ::std::string* rangetypevalue_;
  ::google::protobuf::int32 dazetime_;
  ::google::protobuf::int32 warntime_;
  ::std::string* infomationid_;
  ::google::protobuf::int32 summontype_;
  ::google::protobuf::int32 attackmindistance_;
  ::std::string* summonvalue_;
  ::google::protobuf::int32 goalmaxnum_;
  ::google::protobuf::int32 damagetype_;
  ::std::string* attackvalue_;
  ::std::string* attackrate_;
  ::std::string* damagevalue_;
  ::std::string* damagerate_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::skillskillstateBagDesc > statebag_;
  ::google::protobuf::int32 addhitrate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(41 + 31) / 32];

  friend void  protobuf_AddDesc_skill_2eproto();
  friend void protobuf_AssignDesc_skill_2eproto();
  friend void protobuf_ShutdownFile_skill_2eproto();

  void InitAsDefaultInstance();
  static skillskill* default_instance_;
};
// -------------------------------------------------------------------

class Sheet_skillskill : public ::google::protobuf::Message {
 public:
  Sheet_skillskill();
  virtual ~Sheet_skillskill();

  Sheet_skillskill(const Sheet_skillskill& from);

  inline Sheet_skillskill& operator=(const Sheet_skillskill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sheet_skillskill& default_instance();

  void Swap(Sheet_skillskill* other);

  // implements Message ----------------------------------------------

  Sheet_skillskill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sheet_skillskill& from);
  void MergeFrom(const Sheet_skillskill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto_ff.skillskill skillskill_List = 1;
  inline int skillskill_list_size() const;
  inline void clear_skillskill_list();
  static const int kSkillskillListFieldNumber = 1;
  inline const ::proto_ff::skillskill& skillskill_list(int index) const;
  inline ::proto_ff::skillskill* mutable_skillskill_list(int index);
  inline ::proto_ff::skillskill* add_skillskill_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::skillskill >&
      skillskill_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::skillskill >*
      mutable_skillskill_list();

  // @@protoc_insertion_point(class_scope:proto_ff.Sheet_skillskill)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::skillskill > skillskill_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_skill_2eproto();
  friend void protobuf_AssignDesc_skill_2eproto();
  friend void protobuf_ShutdownFile_skill_2eproto();

  void InitAsDefaultInstance();
  static Sheet_skillskill* default_instance_;
};
// -------------------------------------------------------------------

class skillbuffeffectDesc : public ::google::protobuf::Message {
 public:
  skillbuffeffectDesc();
  virtual ~skillbuffeffectDesc();

  skillbuffeffectDesc(const skillbuffeffectDesc& from);

  inline skillbuffeffectDesc& operator=(const skillbuffeffectDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const skillbuffeffectDesc& default_instance();

  void Swap(skillbuffeffectDesc* other);

  // implements Message ----------------------------------------------

  skillbuffeffectDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const skillbuffeffectDesc& from);
  void MergeFrom(const skillbuffeffectDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string Param = 2;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline const ::std::string& param() const;
  inline void set_param(const ::std::string& value);
  inline void set_param(const char* value);
  inline void set_param(const char* value, size_t size);
  inline ::std::string* mutable_param();
  inline ::std::string* release_param();
  inline void set_allocated_param(::std::string* param);

  // @@protoc_insertion_point(class_scope:proto_ff.skillbuffeffectDesc)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* param_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_skill_2eproto();
  friend void protobuf_AssignDesc_skill_2eproto();
  friend void protobuf_ShutdownFile_skill_2eproto();

  void InitAsDefaultInstance();
  static skillbuffeffectDesc* default_instance_;
};
// -------------------------------------------------------------------

class skillbuff : public ::google::protobuf::Message {
 public:
  skillbuff();
  virtual ~skillbuff();

  skillbuff(const skillbuff& from);

  inline skillbuff& operator=(const skillbuff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const skillbuff& default_instance();

  void Swap(skillbuff* other);

  // implements Message ----------------------------------------------

  skillbuff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const skillbuff& from);
  void MergeFrom(const skillbuff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 stateBagID = 1;
  inline bool has_statebagid() const;
  inline void clear_statebagid();
  static const int kStateBagIDFieldNumber = 1;
  inline ::google::protobuf::int64 statebagid() const;
  inline void set_statebagid(::google::protobuf::int64 value);

  // optional string stateBagName = 2;
  inline bool has_statebagname() const;
  inline void clear_statebagname();
  static const int kStateBagNameFieldNumber = 2;
  inline const ::std::string& statebagname() const;
  inline void set_statebagname(const ::std::string& value);
  inline void set_statebagname(const char* value);
  inline void set_statebagname(const char* value, size_t size);
  inline ::std::string* mutable_statebagname();
  inline ::std::string* release_statebagname();
  inline void set_allocated_statebagname(::std::string* statebagname);

  // optional string stateBagIcon = 3;
  inline bool has_statebagicon() const;
  inline void clear_statebagicon();
  static const int kStateBagIconFieldNumber = 3;
  inline const ::std::string& statebagicon() const;
  inline void set_statebagicon(const ::std::string& value);
  inline void set_statebagicon(const char* value);
  inline void set_statebagicon(const char* value, size_t size);
  inline ::std::string* mutable_statebagicon();
  inline ::std::string* release_statebagicon();
  inline void set_allocated_statebagicon(::std::string* statebagicon);

  // optional string effectResources = 4;
  inline bool has_effectresources() const;
  inline void clear_effectresources();
  static const int kEffectResourcesFieldNumber = 4;
  inline const ::std::string& effectresources() const;
  inline void set_effectresources(const ::std::string& value);
  inline void set_effectresources(const char* value);
  inline void set_effectresources(const char* value, size_t size);
  inline ::std::string* mutable_effectresources();
  inline ::std::string* release_effectresources();
  inline void set_allocated_effectresources(::std::string* effectresources);

  // optional int32 startType = 5;
  inline bool has_starttype() const;
  inline void clear_starttype();
  static const int kStartTypeFieldNumber = 5;
  inline ::google::protobuf::int32 starttype() const;
  inline void set_starttype(::google::protobuf::int32 value);

  // optional int32 startProbability = 6;
  inline bool has_startprobability() const;
  inline void clear_startprobability();
  static const int kStartProbabilityFieldNumber = 6;
  inline ::google::protobuf::int32 startprobability() const;
  inline void set_startprobability(::google::protobuf::int32 value);

  // optional string startTypeValue = 7;
  inline bool has_starttypevalue() const;
  inline void clear_starttypevalue();
  static const int kStartTypeValueFieldNumber = 7;
  inline const ::std::string& starttypevalue() const;
  inline void set_starttypevalue(const ::std::string& value);
  inline void set_starttypevalue(const char* value);
  inline void set_starttypevalue(const char* value, size_t size);
  inline ::std::string* mutable_starttypevalue();
  inline ::std::string* release_starttypevalue();
  inline void set_allocated_starttypevalue(::std::string* starttypevalue);

  // optional string endType = 8;
  inline bool has_endtype() const;
  inline void clear_endtype();
  static const int kEndTypeFieldNumber = 8;
  inline const ::std::string& endtype() const;
  inline void set_endtype(const ::std::string& value);
  inline void set_endtype(const char* value);
  inline void set_endtype(const char* value, size_t size);
  inline ::std::string* mutable_endtype();
  inline ::std::string* release_endtype();
  inline void set_allocated_endtype(::std::string* endtype);

  // optional int32 save = 9;
  inline bool has_save() const;
  inline void clear_save();
  static const int kSaveFieldNumber = 9;
  inline ::google::protobuf::int32 save() const;
  inline void set_save(::google::protobuf::int32 value);

  // optional string stateBagRule = 10;
  inline bool has_statebagrule() const;
  inline void clear_statebagrule();
  static const int kStateBagRuleFieldNumber = 10;
  inline const ::std::string& statebagrule() const;
  inline void set_statebagrule(const ::std::string& value);
  inline void set_statebagrule(const char* value);
  inline void set_statebagrule(const char* value, size_t size);
  inline ::std::string* mutable_statebagrule();
  inline ::std::string* release_statebagrule();
  inline void set_allocated_statebagrule(::std::string* statebagrule);

  // optional int32 label = 11;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 11;
  inline ::google::protobuf::int32 label() const;
  inline void set_label(::google::protobuf::int32 value);

  // optional int32 mask = 12;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 12;
  inline ::google::protobuf::int32 mask() const;
  inline void set_mask(::google::protobuf::int32 value);

  // optional string stateBagCd = 13;
  inline bool has_statebagcd() const;
  inline void clear_statebagcd();
  static const int kStateBagCdFieldNumber = 13;
  inline const ::std::string& statebagcd() const;
  inline void set_statebagcd(const ::std::string& value);
  inline void set_statebagcd(const char* value);
  inline void set_statebagcd(const char* value, size_t size);
  inline ::std::string* mutable_statebagcd();
  inline ::std::string* release_statebagcd();
  inline void set_allocated_statebagcd(::std::string* statebagcd);

  // repeated .proto_ff.skillbuffeffectDesc effect = 14;
  inline int effect_size() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 14;
  inline const ::proto_ff::skillbuffeffectDesc& effect(int index) const;
  inline ::proto_ff::skillbuffeffectDesc* mutable_effect(int index);
  inline ::proto_ff::skillbuffeffectDesc* add_effect();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::skillbuffeffectDesc >&
      effect() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::skillbuffeffectDesc >*
      mutable_effect();

  // @@protoc_insertion_point(class_scope:proto_ff.skillbuff)
 private:
  inline void set_has_statebagid();
  inline void clear_has_statebagid();
  inline void set_has_statebagname();
  inline void clear_has_statebagname();
  inline void set_has_statebagicon();
  inline void clear_has_statebagicon();
  inline void set_has_effectresources();
  inline void clear_has_effectresources();
  inline void set_has_starttype();
  inline void clear_has_starttype();
  inline void set_has_startprobability();
  inline void clear_has_startprobability();
  inline void set_has_starttypevalue();
  inline void clear_has_starttypevalue();
  inline void set_has_endtype();
  inline void clear_has_endtype();
  inline void set_has_save();
  inline void clear_has_save();
  inline void set_has_statebagrule();
  inline void clear_has_statebagrule();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_statebagcd();
  inline void clear_has_statebagcd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 statebagid_;
  ::std::string* statebagname_;
  ::std::string* statebagicon_;
  ::std::string* effectresources_;
  ::google::protobuf::int32 starttype_;
  ::google::protobuf::int32 startprobability_;
  ::std::string* starttypevalue_;
  ::std::string* endtype_;
  ::std::string* statebagrule_;
  ::google::protobuf::int32 save_;
  ::google::protobuf::int32 label_;
  ::std::string* statebagcd_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::skillbuffeffectDesc > effect_;
  ::google::protobuf::int32 mask_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_skill_2eproto();
  friend void protobuf_AssignDesc_skill_2eproto();
  friend void protobuf_ShutdownFile_skill_2eproto();

  void InitAsDefaultInstance();
  static skillbuff* default_instance_;
};
// -------------------------------------------------------------------

class Sheet_skillbuff : public ::google::protobuf::Message {
 public:
  Sheet_skillbuff();
  virtual ~Sheet_skillbuff();

  Sheet_skillbuff(const Sheet_skillbuff& from);

  inline Sheet_skillbuff& operator=(const Sheet_skillbuff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sheet_skillbuff& default_instance();

  void Swap(Sheet_skillbuff* other);

  // implements Message ----------------------------------------------

  Sheet_skillbuff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sheet_skillbuff& from);
  void MergeFrom(const Sheet_skillbuff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto_ff.skillbuff skillbuff_List = 1;
  inline int skillbuff_list_size() const;
  inline void clear_skillbuff_list();
  static const int kSkillbuffListFieldNumber = 1;
  inline const ::proto_ff::skillbuff& skillbuff_list(int index) const;
  inline ::proto_ff::skillbuff* mutable_skillbuff_list(int index);
  inline ::proto_ff::skillbuff* add_skillbuff_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::skillbuff >&
      skillbuff_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::skillbuff >*
      mutable_skillbuff_list();

  // @@protoc_insertion_point(class_scope:proto_ff.Sheet_skillbuff)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::skillbuff > skillbuff_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_skill_2eproto();
  friend void protobuf_AssignDesc_skill_2eproto();
  friend void protobuf_ShutdownFile_skill_2eproto();

  void InitAsDefaultInstance();
  static Sheet_skillbuff* default_instance_;
};
// ===================================================================


// ===================================================================

// skillskillstateBagDesc

// optional int32 Target = 1;
inline bool skillskillstateBagDesc::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skillskillstateBagDesc::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skillskillstateBagDesc::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skillskillstateBagDesc::clear_target() {
  target_ = 0;
  clear_has_target();
}
inline ::google::protobuf::int32 skillskillstateBagDesc::target() const {
  return target_;
}
inline void skillskillstateBagDesc::set_target(::google::protobuf::int32 value) {
  set_has_target();
  target_ = value;
}

// optional int32 Point = 2;
inline bool skillskillstateBagDesc::has_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void skillskillstateBagDesc::set_has_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void skillskillstateBagDesc::clear_has_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void skillskillstateBagDesc::clear_point() {
  point_ = 0;
  clear_has_point();
}
inline ::google::protobuf::int32 skillskillstateBagDesc::point() const {
  return point_;
}
inline void skillskillstateBagDesc::set_point(::google::protobuf::int32 value) {
  set_has_point();
  point_ = value;
}

// optional string Parameter = 3;
inline bool skillskillstateBagDesc::has_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void skillskillstateBagDesc::set_has_parameter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void skillskillstateBagDesc::clear_has_parameter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void skillskillstateBagDesc::clear_parameter() {
  if (parameter_ != &::google::protobuf::internal::kEmptyString) {
    parameter_->clear();
  }
  clear_has_parameter();
}
inline const ::std::string& skillskillstateBagDesc::parameter() const {
  return *parameter_;
}
inline void skillskillstateBagDesc::set_parameter(const ::std::string& value) {
  set_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    parameter_ = new ::std::string;
  }
  parameter_->assign(value);
}
inline void skillskillstateBagDesc::set_parameter(const char* value) {
  set_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    parameter_ = new ::std::string;
  }
  parameter_->assign(value);
}
inline void skillskillstateBagDesc::set_parameter(const char* value, size_t size) {
  set_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    parameter_ = new ::std::string;
  }
  parameter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskillstateBagDesc::mutable_parameter() {
  set_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    parameter_ = new ::std::string;
  }
  return parameter_;
}
inline ::std::string* skillskillstateBagDesc::release_parameter() {
  clear_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parameter_;
    parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskillstateBagDesc::set_allocated_parameter(::std::string* parameter) {
  if (parameter_ != &::google::protobuf::internal::kEmptyString) {
    delete parameter_;
  }
  if (parameter) {
    set_has_parameter();
    parameter_ = parameter;
  } else {
    clear_has_parameter();
    parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Rate = 4;
inline bool skillskillstateBagDesc::has_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void skillskillstateBagDesc::set_has_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void skillskillstateBagDesc::clear_has_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void skillskillstateBagDesc::clear_rate() {
  if (rate_ != &::google::protobuf::internal::kEmptyString) {
    rate_->clear();
  }
  clear_has_rate();
}
inline const ::std::string& skillskillstateBagDesc::rate() const {
  return *rate_;
}
inline void skillskillstateBagDesc::set_rate(const ::std::string& value) {
  set_has_rate();
  if (rate_ == &::google::protobuf::internal::kEmptyString) {
    rate_ = new ::std::string;
  }
  rate_->assign(value);
}
inline void skillskillstateBagDesc::set_rate(const char* value) {
  set_has_rate();
  if (rate_ == &::google::protobuf::internal::kEmptyString) {
    rate_ = new ::std::string;
  }
  rate_->assign(value);
}
inline void skillskillstateBagDesc::set_rate(const char* value, size_t size) {
  set_has_rate();
  if (rate_ == &::google::protobuf::internal::kEmptyString) {
    rate_ = new ::std::string;
  }
  rate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskillstateBagDesc::mutable_rate() {
  set_has_rate();
  if (rate_ == &::google::protobuf::internal::kEmptyString) {
    rate_ = new ::std::string;
  }
  return rate_;
}
inline ::std::string* skillskillstateBagDesc::release_rate() {
  clear_has_rate();
  if (rate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rate_;
    rate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskillstateBagDesc::set_allocated_rate(::std::string* rate) {
  if (rate_ != &::google::protobuf::internal::kEmptyString) {
    delete rate_;
  }
  if (rate) {
    set_has_rate();
    rate_ = rate;
  } else {
    clear_has_rate();
    rate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Time = 5;
inline bool skillskillstateBagDesc::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void skillskillstateBagDesc::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void skillskillstateBagDesc::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void skillskillstateBagDesc::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& skillskillstateBagDesc::time() const {
  return *time_;
}
inline void skillskillstateBagDesc::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void skillskillstateBagDesc::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void skillskillstateBagDesc::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskillstateBagDesc::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* skillskillstateBagDesc::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskillstateBagDesc::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 Type = 6;
inline bool skillskillstateBagDesc::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void skillskillstateBagDesc::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void skillskillstateBagDesc::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void skillskillstateBagDesc::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 skillskillstateBagDesc::type() const {
  return type_;
}
inline void skillskillstateBagDesc::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int64 ID = 7;
inline bool skillskillstateBagDesc::has_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void skillskillstateBagDesc::set_has_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void skillskillstateBagDesc::clear_has_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void skillskillstateBagDesc::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 skillskillstateBagDesc::id() const {
  return id_;
}
inline void skillskillstateBagDesc::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// skillskill

// optional int64 skillID = 1;
inline bool skillskill::has_skillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skillskill::set_has_skillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skillskill::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skillskill::clear_skillid() {
  skillid_ = GOOGLE_LONGLONG(0);
  clear_has_skillid();
}
inline ::google::protobuf::int64 skillskill::skillid() const {
  return skillid_;
}
inline void skillskill::set_skillid(::google::protobuf::int64 value) {
  set_has_skillid();
  skillid_ = value;
}

// optional string name = 2;
inline bool skillskill::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void skillskill::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void skillskill::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void skillskill::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& skillskill::name() const {
  return *name_;
}
inline void skillskill::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skillskill::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skillskill::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskill::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* skillskill::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskill::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 skillType = 3;
inline bool skillskill::has_skilltype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void skillskill::set_has_skilltype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void skillskill::clear_has_skilltype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void skillskill::clear_skilltype() {
  skilltype_ = 0;
  clear_has_skilltype();
}
inline ::google::protobuf::int32 skillskill::skilltype() const {
  return skilltype_;
}
inline void skillskill::set_skilltype(::google::protobuf::int32 value) {
  set_has_skilltype();
  skilltype_ = value;
}

// optional int32 specialSkill = 4;
inline bool skillskill::has_specialskill() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void skillskill::set_has_specialskill() {
  _has_bits_[0] |= 0x00000008u;
}
inline void skillskill::clear_has_specialskill() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void skillskill::clear_specialskill() {
  specialskill_ = 0;
  clear_has_specialskill();
}
inline ::google::protobuf::int32 skillskill::specialskill() const {
  return specialskill_;
}
inline void skillskill::set_specialskill(::google::protobuf::int32 value) {
  set_has_specialskill();
  specialskill_ = value;
}

// optional int32 cdSkill = 5;
inline bool skillskill::has_cdskill() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void skillskill::set_has_cdskill() {
  _has_bits_[0] |= 0x00000010u;
}
inline void skillskill::clear_has_cdskill() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void skillskill::clear_cdskill() {
  cdskill_ = 0;
  clear_has_cdskill();
}
inline ::google::protobuf::int32 skillskill::cdskill() const {
  return cdskill_;
}
inline void skillskill::set_cdskill(::google::protobuf::int32 value) {
  set_has_cdskill();
  cdskill_ = value;
}

// optional int64 Relation = 6;
inline bool skillskill::has_relation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void skillskill::set_has_relation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void skillskill::clear_has_relation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void skillskill::clear_relation() {
  relation_ = GOOGLE_LONGLONG(0);
  clear_has_relation();
}
inline ::google::protobuf::int64 skillskill::relation() const {
  return relation_;
}
inline void skillskill::set_relation(::google::protobuf::int64 value) {
  set_has_relation();
  relation_ = value;
}

// optional int64 AddSkill = 7;
inline bool skillskill::has_addskill() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void skillskill::set_has_addskill() {
  _has_bits_[0] |= 0x00000040u;
}
inline void skillskill::clear_has_addskill() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void skillskill::clear_addskill() {
  addskill_ = GOOGLE_LONGLONG(0);
  clear_has_addskill();
}
inline ::google::protobuf::int64 skillskill::addskill() const {
  return addskill_;
}
inline void skillskill::set_addskill(::google::protobuf::int64 value) {
  set_has_addskill();
  addskill_ = value;
}

// optional int32 AddSkillTime = 8;
inline bool skillskill::has_addskilltime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void skillskill::set_has_addskilltime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void skillskill::clear_has_addskilltime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void skillskill::clear_addskilltime() {
  addskilltime_ = 0;
  clear_has_addskilltime();
}
inline ::google::protobuf::int32 skillskill::addskilltime() const {
  return addskilltime_;
}
inline void skillskill::set_addskilltime(::google::protobuf::int32 value) {
  set_has_addskilltime();
  addskilltime_ = value;
}

// optional int32 unlockLevel = 9;
inline bool skillskill::has_unlocklevel() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void skillskill::set_has_unlocklevel() {
  _has_bits_[0] |= 0x00000100u;
}
inline void skillskill::clear_has_unlocklevel() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void skillskill::clear_unlocklevel() {
  unlocklevel_ = 0;
  clear_has_unlocklevel();
}
inline ::google::protobuf::int32 skillskill::unlocklevel() const {
  return unlocklevel_;
}
inline void skillskill::set_unlocklevel(::google::protobuf::int32 value) {
  set_has_unlocklevel();
  unlocklevel_ = value;
}

// optional int32 type = 10;
inline bool skillskill::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void skillskill::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void skillskill::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void skillskill::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 skillskill::type() const {
  return type_;
}
inline void skillskill::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 cd = 11;
inline bool skillskill::has_cd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void skillskill::set_has_cd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void skillskill::clear_has_cd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void skillskill::clear_cd() {
  cd_ = 0;
  clear_has_cd();
}
inline ::google::protobuf::int32 skillskill::cd() const {
  return cd_;
}
inline void skillskill::set_cd(::google::protobuf::int32 value) {
  set_has_cd();
  cd_ = value;
}

// optional int32 priority = 12;
inline bool skillskill::has_priority() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void skillskill::set_has_priority() {
  _has_bits_[0] |= 0x00000800u;
}
inline void skillskill::clear_has_priority() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void skillskill::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 skillskill::priority() const {
  return priority_;
}
inline void skillskill::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
}

// optional string fighting = 13;
inline bool skillskill::has_fighting() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void skillskill::set_has_fighting() {
  _has_bits_[0] |= 0x00001000u;
}
inline void skillskill::clear_has_fighting() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void skillskill::clear_fighting() {
  if (fighting_ != &::google::protobuf::internal::kEmptyString) {
    fighting_->clear();
  }
  clear_has_fighting();
}
inline const ::std::string& skillskill::fighting() const {
  return *fighting_;
}
inline void skillskill::set_fighting(const ::std::string& value) {
  set_has_fighting();
  if (fighting_ == &::google::protobuf::internal::kEmptyString) {
    fighting_ = new ::std::string;
  }
  fighting_->assign(value);
}
inline void skillskill::set_fighting(const char* value) {
  set_has_fighting();
  if (fighting_ == &::google::protobuf::internal::kEmptyString) {
    fighting_ = new ::std::string;
  }
  fighting_->assign(value);
}
inline void skillskill::set_fighting(const char* value, size_t size) {
  set_has_fighting();
  if (fighting_ == &::google::protobuf::internal::kEmptyString) {
    fighting_ = new ::std::string;
  }
  fighting_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskill::mutable_fighting() {
  set_has_fighting();
  if (fighting_ == &::google::protobuf::internal::kEmptyString) {
    fighting_ = new ::std::string;
  }
  return fighting_;
}
inline ::std::string* skillskill::release_fighting() {
  clear_has_fighting();
  if (fighting_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fighting_;
    fighting_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskill::set_allocated_fighting(::std::string* fighting) {
  if (fighting_ != &::google::protobuf::internal::kEmptyString) {
    delete fighting_;
  }
  if (fighting) {
    set_has_fighting();
    fighting_ = fighting;
  } else {
    clear_has_fighting();
    fighting_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 releaseType = 14;
inline bool skillskill::has_releasetype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void skillskill::set_has_releasetype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void skillskill::clear_has_releasetype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void skillskill::clear_releasetype() {
  releasetype_ = 0;
  clear_has_releasetype();
}
inline ::google::protobuf::int32 skillskill::releasetype() const {
  return releasetype_;
}
inline void skillskill::set_releasetype(::google::protobuf::int32 value) {
  set_has_releasetype();
  releasetype_ = value;
}

// optional int32 processTypes = 15;
inline bool skillskill::has_processtypes() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void skillskill::set_has_processtypes() {
  _has_bits_[0] |= 0x00004000u;
}
inline void skillskill::clear_has_processtypes() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void skillskill::clear_processtypes() {
  processtypes_ = 0;
  clear_has_processtypes();
}
inline ::google::protobuf::int32 skillskill::processtypes() const {
  return processtypes_;
}
inline void skillskill::set_processtypes(::google::protobuf::int32 value) {
  set_has_processtypes();
  processtypes_ = value;
}

// optional int32 flySpeed = 16;
inline bool skillskill::has_flyspeed() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void skillskill::set_has_flyspeed() {
  _has_bits_[0] |= 0x00008000u;
}
inline void skillskill::clear_has_flyspeed() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void skillskill::clear_flyspeed() {
  flyspeed_ = 0;
  clear_has_flyspeed();
}
inline ::google::protobuf::int32 skillskill::flyspeed() const {
  return flyspeed_;
}
inline void skillskill::set_flyspeed(::google::protobuf::int32 value) {
  set_has_flyspeed();
  flyspeed_ = value;
}

// optional int32 readyTime = 17;
inline bool skillskill::has_readytime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void skillskill::set_has_readytime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void skillskill::clear_has_readytime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void skillskill::clear_readytime() {
  readytime_ = 0;
  clear_has_readytime();
}
inline ::google::protobuf::int32 skillskill::readytime() const {
  return readytime_;
}
inline void skillskill::set_readytime(::google::protobuf::int32 value) {
  set_has_readytime();
  readytime_ = value;
}

// optional int32 attackTime = 18;
inline bool skillskill::has_attacktime() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void skillskill::set_has_attacktime() {
  _has_bits_[0] |= 0x00020000u;
}
inline void skillskill::clear_has_attacktime() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void skillskill::clear_attacktime() {
  attacktime_ = 0;
  clear_has_attacktime();
}
inline ::google::protobuf::int32 skillskill::attacktime() const {
  return attacktime_;
}
inline void skillskill::set_attacktime(::google::protobuf::int32 value) {
  set_has_attacktime();
  attacktime_ = value;
}

// optional string damageTime = 19;
inline bool skillskill::has_damagetime() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void skillskill::set_has_damagetime() {
  _has_bits_[0] |= 0x00040000u;
}
inline void skillskill::clear_has_damagetime() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void skillskill::clear_damagetime() {
  if (damagetime_ != &::google::protobuf::internal::kEmptyString) {
    damagetime_->clear();
  }
  clear_has_damagetime();
}
inline const ::std::string& skillskill::damagetime() const {
  return *damagetime_;
}
inline void skillskill::set_damagetime(const ::std::string& value) {
  set_has_damagetime();
  if (damagetime_ == &::google::protobuf::internal::kEmptyString) {
    damagetime_ = new ::std::string;
  }
  damagetime_->assign(value);
}
inline void skillskill::set_damagetime(const char* value) {
  set_has_damagetime();
  if (damagetime_ == &::google::protobuf::internal::kEmptyString) {
    damagetime_ = new ::std::string;
  }
  damagetime_->assign(value);
}
inline void skillskill::set_damagetime(const char* value, size_t size) {
  set_has_damagetime();
  if (damagetime_ == &::google::protobuf::internal::kEmptyString) {
    damagetime_ = new ::std::string;
  }
  damagetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskill::mutable_damagetime() {
  set_has_damagetime();
  if (damagetime_ == &::google::protobuf::internal::kEmptyString) {
    damagetime_ = new ::std::string;
  }
  return damagetime_;
}
inline ::std::string* skillskill::release_damagetime() {
  clear_has_damagetime();
  if (damagetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = damagetime_;
    damagetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskill::set_allocated_damagetime(::std::string* damagetime) {
  if (damagetime_ != &::google::protobuf::internal::kEmptyString) {
    delete damagetime_;
  }
  if (damagetime) {
    set_has_damagetime();
    damagetime_ = damagetime;
  } else {
    clear_has_damagetime();
    damagetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 displaceTime = 20;
inline bool skillskill::has_displacetime() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void skillskill::set_has_displacetime() {
  _has_bits_[0] |= 0x00080000u;
}
inline void skillskill::clear_has_displacetime() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void skillskill::clear_displacetime() {
  displacetime_ = 0;
  clear_has_displacetime();
}
inline ::google::protobuf::int32 skillskill::displacetime() const {
  return displacetime_;
}
inline void skillskill::set_displacetime(::google::protobuf::int32 value) {
  set_has_displacetime();
  displacetime_ = value;
}

// optional int32 displaceSign = 21;
inline bool skillskill::has_displacesign() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void skillskill::set_has_displacesign() {
  _has_bits_[0] |= 0x00100000u;
}
inline void skillskill::clear_has_displacesign() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void skillskill::clear_displacesign() {
  displacesign_ = 0;
  clear_has_displacesign();
}
inline ::google::protobuf::int32 skillskill::displacesign() const {
  return displacesign_;
}
inline void skillskill::set_displacesign(::google::protobuf::int32 value) {
  set_has_displacesign();
  displacesign_ = value;
}

// optional string displaceSpeed = 22;
inline bool skillskill::has_displacespeed() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void skillskill::set_has_displacespeed() {
  _has_bits_[0] |= 0x00200000u;
}
inline void skillskill::clear_has_displacespeed() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void skillskill::clear_displacespeed() {
  if (displacespeed_ != &::google::protobuf::internal::kEmptyString) {
    displacespeed_->clear();
  }
  clear_has_displacespeed();
}
inline const ::std::string& skillskill::displacespeed() const {
  return *displacespeed_;
}
inline void skillskill::set_displacespeed(const ::std::string& value) {
  set_has_displacespeed();
  if (displacespeed_ == &::google::protobuf::internal::kEmptyString) {
    displacespeed_ = new ::std::string;
  }
  displacespeed_->assign(value);
}
inline void skillskill::set_displacespeed(const char* value) {
  set_has_displacespeed();
  if (displacespeed_ == &::google::protobuf::internal::kEmptyString) {
    displacespeed_ = new ::std::string;
  }
  displacespeed_->assign(value);
}
inline void skillskill::set_displacespeed(const char* value, size_t size) {
  set_has_displacespeed();
  if (displacespeed_ == &::google::protobuf::internal::kEmptyString) {
    displacespeed_ = new ::std::string;
  }
  displacespeed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskill::mutable_displacespeed() {
  set_has_displacespeed();
  if (displacespeed_ == &::google::protobuf::internal::kEmptyString) {
    displacespeed_ = new ::std::string;
  }
  return displacespeed_;
}
inline ::std::string* skillskill::release_displacespeed() {
  clear_has_displacespeed();
  if (displacespeed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displacespeed_;
    displacespeed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskill::set_allocated_displacespeed(::std::string* displacespeed) {
  if (displacespeed_ != &::google::protobuf::internal::kEmptyString) {
    delete displacespeed_;
  }
  if (displacespeed) {
    set_has_displacespeed();
    displacespeed_ = displacespeed;
  } else {
    clear_has_displacespeed();
    displacespeed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string disTimes = 23;
inline bool skillskill::has_distimes() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void skillskill::set_has_distimes() {
  _has_bits_[0] |= 0x00400000u;
}
inline void skillskill::clear_has_distimes() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void skillskill::clear_distimes() {
  if (distimes_ != &::google::protobuf::internal::kEmptyString) {
    distimes_->clear();
  }
  clear_has_distimes();
}
inline const ::std::string& skillskill::distimes() const {
  return *distimes_;
}
inline void skillskill::set_distimes(const ::std::string& value) {
  set_has_distimes();
  if (distimes_ == &::google::protobuf::internal::kEmptyString) {
    distimes_ = new ::std::string;
  }
  distimes_->assign(value);
}
inline void skillskill::set_distimes(const char* value) {
  set_has_distimes();
  if (distimes_ == &::google::protobuf::internal::kEmptyString) {
    distimes_ = new ::std::string;
  }
  distimes_->assign(value);
}
inline void skillskill::set_distimes(const char* value, size_t size) {
  set_has_distimes();
  if (distimes_ == &::google::protobuf::internal::kEmptyString) {
    distimes_ = new ::std::string;
  }
  distimes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskill::mutable_distimes() {
  set_has_distimes();
  if (distimes_ == &::google::protobuf::internal::kEmptyString) {
    distimes_ = new ::std::string;
  }
  return distimes_;
}
inline ::std::string* skillskill::release_distimes() {
  clear_has_distimes();
  if (distimes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = distimes_;
    distimes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskill::set_allocated_distimes(::std::string* distimes) {
  if (distimes_ != &::google::protobuf::internal::kEmptyString) {
    delete distimes_;
  }
  if (distimes) {
    set_has_distimes();
    distimes_ = distimes;
  } else {
    clear_has_distimes();
    distimes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 attackDistance = 24;
inline bool skillskill::has_attackdistance() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void skillskill::set_has_attackdistance() {
  _has_bits_[0] |= 0x00800000u;
}
inline void skillskill::clear_has_attackdistance() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void skillskill::clear_attackdistance() {
  attackdistance_ = 0;
  clear_has_attackdistance();
}
inline ::google::protobuf::int32 skillskill::attackdistance() const {
  return attackdistance_;
}
inline void skillskill::set_attackdistance(::google::protobuf::int32 value) {
  set_has_attackdistance();
  attackdistance_ = value;
}

// optional int32 rangeType = 25;
inline bool skillskill::has_rangetype() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void skillskill::set_has_rangetype() {
  _has_bits_[0] |= 0x01000000u;
}
inline void skillskill::clear_has_rangetype() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void skillskill::clear_rangetype() {
  rangetype_ = 0;
  clear_has_rangetype();
}
inline ::google::protobuf::int32 skillskill::rangetype() const {
  return rangetype_;
}
inline void skillskill::set_rangetype(::google::protobuf::int32 value) {
  set_has_rangetype();
  rangetype_ = value;
}

// optional string rangeTypeValue = 26;
inline bool skillskill::has_rangetypevalue() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void skillskill::set_has_rangetypevalue() {
  _has_bits_[0] |= 0x02000000u;
}
inline void skillskill::clear_has_rangetypevalue() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void skillskill::clear_rangetypevalue() {
  if (rangetypevalue_ != &::google::protobuf::internal::kEmptyString) {
    rangetypevalue_->clear();
  }
  clear_has_rangetypevalue();
}
inline const ::std::string& skillskill::rangetypevalue() const {
  return *rangetypevalue_;
}
inline void skillskill::set_rangetypevalue(const ::std::string& value) {
  set_has_rangetypevalue();
  if (rangetypevalue_ == &::google::protobuf::internal::kEmptyString) {
    rangetypevalue_ = new ::std::string;
  }
  rangetypevalue_->assign(value);
}
inline void skillskill::set_rangetypevalue(const char* value) {
  set_has_rangetypevalue();
  if (rangetypevalue_ == &::google::protobuf::internal::kEmptyString) {
    rangetypevalue_ = new ::std::string;
  }
  rangetypevalue_->assign(value);
}
inline void skillskill::set_rangetypevalue(const char* value, size_t size) {
  set_has_rangetypevalue();
  if (rangetypevalue_ == &::google::protobuf::internal::kEmptyString) {
    rangetypevalue_ = new ::std::string;
  }
  rangetypevalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskill::mutable_rangetypevalue() {
  set_has_rangetypevalue();
  if (rangetypevalue_ == &::google::protobuf::internal::kEmptyString) {
    rangetypevalue_ = new ::std::string;
  }
  return rangetypevalue_;
}
inline ::std::string* skillskill::release_rangetypevalue() {
  clear_has_rangetypevalue();
  if (rangetypevalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rangetypevalue_;
    rangetypevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskill::set_allocated_rangetypevalue(::std::string* rangetypevalue) {
  if (rangetypevalue_ != &::google::protobuf::internal::kEmptyString) {
    delete rangetypevalue_;
  }
  if (rangetypevalue) {
    set_has_rangetypevalue();
    rangetypevalue_ = rangetypevalue;
  } else {
    clear_has_rangetypevalue();
    rangetypevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 warn = 27;
inline bool skillskill::has_warn() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void skillskill::set_has_warn() {
  _has_bits_[0] |= 0x04000000u;
}
inline void skillskill::clear_has_warn() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void skillskill::clear_warn() {
  warn_ = 0;
  clear_has_warn();
}
inline ::google::protobuf::int32 skillskill::warn() const {
  return warn_;
}
inline void skillskill::set_warn(::google::protobuf::int32 value) {
  set_has_warn();
  warn_ = value;
}

// optional int32 dazeTime = 28;
inline bool skillskill::has_dazetime() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void skillskill::set_has_dazetime() {
  _has_bits_[0] |= 0x08000000u;
}
inline void skillskill::clear_has_dazetime() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void skillskill::clear_dazetime() {
  dazetime_ = 0;
  clear_has_dazetime();
}
inline ::google::protobuf::int32 skillskill::dazetime() const {
  return dazetime_;
}
inline void skillskill::set_dazetime(::google::protobuf::int32 value) {
  set_has_dazetime();
  dazetime_ = value;
}

// optional int32 warnTime = 29;
inline bool skillskill::has_warntime() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void skillskill::set_has_warntime() {
  _has_bits_[0] |= 0x10000000u;
}
inline void skillskill::clear_has_warntime() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void skillskill::clear_warntime() {
  warntime_ = 0;
  clear_has_warntime();
}
inline ::google::protobuf::int32 skillskill::warntime() const {
  return warntime_;
}
inline void skillskill::set_warntime(::google::protobuf::int32 value) {
  set_has_warntime();
  warntime_ = value;
}

// optional string infomationId = 30;
inline bool skillskill::has_infomationid() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void skillskill::set_has_infomationid() {
  _has_bits_[0] |= 0x20000000u;
}
inline void skillskill::clear_has_infomationid() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void skillskill::clear_infomationid() {
  if (infomationid_ != &::google::protobuf::internal::kEmptyString) {
    infomationid_->clear();
  }
  clear_has_infomationid();
}
inline const ::std::string& skillskill::infomationid() const {
  return *infomationid_;
}
inline void skillskill::set_infomationid(const ::std::string& value) {
  set_has_infomationid();
  if (infomationid_ == &::google::protobuf::internal::kEmptyString) {
    infomationid_ = new ::std::string;
  }
  infomationid_->assign(value);
}
inline void skillskill::set_infomationid(const char* value) {
  set_has_infomationid();
  if (infomationid_ == &::google::protobuf::internal::kEmptyString) {
    infomationid_ = new ::std::string;
  }
  infomationid_->assign(value);
}
inline void skillskill::set_infomationid(const char* value, size_t size) {
  set_has_infomationid();
  if (infomationid_ == &::google::protobuf::internal::kEmptyString) {
    infomationid_ = new ::std::string;
  }
  infomationid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskill::mutable_infomationid() {
  set_has_infomationid();
  if (infomationid_ == &::google::protobuf::internal::kEmptyString) {
    infomationid_ = new ::std::string;
  }
  return infomationid_;
}
inline ::std::string* skillskill::release_infomationid() {
  clear_has_infomationid();
  if (infomationid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = infomationid_;
    infomationid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskill::set_allocated_infomationid(::std::string* infomationid) {
  if (infomationid_ != &::google::protobuf::internal::kEmptyString) {
    delete infomationid_;
  }
  if (infomationid) {
    set_has_infomationid();
    infomationid_ = infomationid;
  } else {
    clear_has_infomationid();
    infomationid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 summonType = 31;
inline bool skillskill::has_summontype() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void skillskill::set_has_summontype() {
  _has_bits_[0] |= 0x40000000u;
}
inline void skillskill::clear_has_summontype() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void skillskill::clear_summontype() {
  summontype_ = 0;
  clear_has_summontype();
}
inline ::google::protobuf::int32 skillskill::summontype() const {
  return summontype_;
}
inline void skillskill::set_summontype(::google::protobuf::int32 value) {
  set_has_summontype();
  summontype_ = value;
}

// optional string summonValue = 32;
inline bool skillskill::has_summonvalue() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void skillskill::set_has_summonvalue() {
  _has_bits_[0] |= 0x80000000u;
}
inline void skillskill::clear_has_summonvalue() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void skillskill::clear_summonvalue() {
  if (summonvalue_ != &::google::protobuf::internal::kEmptyString) {
    summonvalue_->clear();
  }
  clear_has_summonvalue();
}
inline const ::std::string& skillskill::summonvalue() const {
  return *summonvalue_;
}
inline void skillskill::set_summonvalue(const ::std::string& value) {
  set_has_summonvalue();
  if (summonvalue_ == &::google::protobuf::internal::kEmptyString) {
    summonvalue_ = new ::std::string;
  }
  summonvalue_->assign(value);
}
inline void skillskill::set_summonvalue(const char* value) {
  set_has_summonvalue();
  if (summonvalue_ == &::google::protobuf::internal::kEmptyString) {
    summonvalue_ = new ::std::string;
  }
  summonvalue_->assign(value);
}
inline void skillskill::set_summonvalue(const char* value, size_t size) {
  set_has_summonvalue();
  if (summonvalue_ == &::google::protobuf::internal::kEmptyString) {
    summonvalue_ = new ::std::string;
  }
  summonvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskill::mutable_summonvalue() {
  set_has_summonvalue();
  if (summonvalue_ == &::google::protobuf::internal::kEmptyString) {
    summonvalue_ = new ::std::string;
  }
  return summonvalue_;
}
inline ::std::string* skillskill::release_summonvalue() {
  clear_has_summonvalue();
  if (summonvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = summonvalue_;
    summonvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskill::set_allocated_summonvalue(::std::string* summonvalue) {
  if (summonvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete summonvalue_;
  }
  if (summonvalue) {
    set_has_summonvalue();
    summonvalue_ = summonvalue;
  } else {
    clear_has_summonvalue();
    summonvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 attackMinDistance = 33;
inline bool skillskill::has_attackmindistance() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void skillskill::set_has_attackmindistance() {
  _has_bits_[1] |= 0x00000001u;
}
inline void skillskill::clear_has_attackmindistance() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void skillskill::clear_attackmindistance() {
  attackmindistance_ = 0;
  clear_has_attackmindistance();
}
inline ::google::protobuf::int32 skillskill::attackmindistance() const {
  return attackmindistance_;
}
inline void skillskill::set_attackmindistance(::google::protobuf::int32 value) {
  set_has_attackmindistance();
  attackmindistance_ = value;
}

// optional int32 goalMaxNum = 34;
inline bool skillskill::has_goalmaxnum() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void skillskill::set_has_goalmaxnum() {
  _has_bits_[1] |= 0x00000002u;
}
inline void skillskill::clear_has_goalmaxnum() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void skillskill::clear_goalmaxnum() {
  goalmaxnum_ = 0;
  clear_has_goalmaxnum();
}
inline ::google::protobuf::int32 skillskill::goalmaxnum() const {
  return goalmaxnum_;
}
inline void skillskill::set_goalmaxnum(::google::protobuf::int32 value) {
  set_has_goalmaxnum();
  goalmaxnum_ = value;
}

// optional int32 damageType = 35;
inline bool skillskill::has_damagetype() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void skillskill::set_has_damagetype() {
  _has_bits_[1] |= 0x00000004u;
}
inline void skillskill::clear_has_damagetype() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void skillskill::clear_damagetype() {
  damagetype_ = 0;
  clear_has_damagetype();
}
inline ::google::protobuf::int32 skillskill::damagetype() const {
  return damagetype_;
}
inline void skillskill::set_damagetype(::google::protobuf::int32 value) {
  set_has_damagetype();
  damagetype_ = value;
}

// optional string attackValue = 36;
inline bool skillskill::has_attackvalue() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void skillskill::set_has_attackvalue() {
  _has_bits_[1] |= 0x00000008u;
}
inline void skillskill::clear_has_attackvalue() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void skillskill::clear_attackvalue() {
  if (attackvalue_ != &::google::protobuf::internal::kEmptyString) {
    attackvalue_->clear();
  }
  clear_has_attackvalue();
}
inline const ::std::string& skillskill::attackvalue() const {
  return *attackvalue_;
}
inline void skillskill::set_attackvalue(const ::std::string& value) {
  set_has_attackvalue();
  if (attackvalue_ == &::google::protobuf::internal::kEmptyString) {
    attackvalue_ = new ::std::string;
  }
  attackvalue_->assign(value);
}
inline void skillskill::set_attackvalue(const char* value) {
  set_has_attackvalue();
  if (attackvalue_ == &::google::protobuf::internal::kEmptyString) {
    attackvalue_ = new ::std::string;
  }
  attackvalue_->assign(value);
}
inline void skillskill::set_attackvalue(const char* value, size_t size) {
  set_has_attackvalue();
  if (attackvalue_ == &::google::protobuf::internal::kEmptyString) {
    attackvalue_ = new ::std::string;
  }
  attackvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskill::mutable_attackvalue() {
  set_has_attackvalue();
  if (attackvalue_ == &::google::protobuf::internal::kEmptyString) {
    attackvalue_ = new ::std::string;
  }
  return attackvalue_;
}
inline ::std::string* skillskill::release_attackvalue() {
  clear_has_attackvalue();
  if (attackvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackvalue_;
    attackvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskill::set_allocated_attackvalue(::std::string* attackvalue) {
  if (attackvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete attackvalue_;
  }
  if (attackvalue) {
    set_has_attackvalue();
    attackvalue_ = attackvalue;
  } else {
    clear_has_attackvalue();
    attackvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string attackRate = 37;
inline bool skillskill::has_attackrate() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void skillskill::set_has_attackrate() {
  _has_bits_[1] |= 0x00000010u;
}
inline void skillskill::clear_has_attackrate() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void skillskill::clear_attackrate() {
  if (attackrate_ != &::google::protobuf::internal::kEmptyString) {
    attackrate_->clear();
  }
  clear_has_attackrate();
}
inline const ::std::string& skillskill::attackrate() const {
  return *attackrate_;
}
inline void skillskill::set_attackrate(const ::std::string& value) {
  set_has_attackrate();
  if (attackrate_ == &::google::protobuf::internal::kEmptyString) {
    attackrate_ = new ::std::string;
  }
  attackrate_->assign(value);
}
inline void skillskill::set_attackrate(const char* value) {
  set_has_attackrate();
  if (attackrate_ == &::google::protobuf::internal::kEmptyString) {
    attackrate_ = new ::std::string;
  }
  attackrate_->assign(value);
}
inline void skillskill::set_attackrate(const char* value, size_t size) {
  set_has_attackrate();
  if (attackrate_ == &::google::protobuf::internal::kEmptyString) {
    attackrate_ = new ::std::string;
  }
  attackrate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskill::mutable_attackrate() {
  set_has_attackrate();
  if (attackrate_ == &::google::protobuf::internal::kEmptyString) {
    attackrate_ = new ::std::string;
  }
  return attackrate_;
}
inline ::std::string* skillskill::release_attackrate() {
  clear_has_attackrate();
  if (attackrate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackrate_;
    attackrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskill::set_allocated_attackrate(::std::string* attackrate) {
  if (attackrate_ != &::google::protobuf::internal::kEmptyString) {
    delete attackrate_;
  }
  if (attackrate) {
    set_has_attackrate();
    attackrate_ = attackrate;
  } else {
    clear_has_attackrate();
    attackrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string damageValue = 38;
inline bool skillskill::has_damagevalue() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void skillskill::set_has_damagevalue() {
  _has_bits_[1] |= 0x00000020u;
}
inline void skillskill::clear_has_damagevalue() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void skillskill::clear_damagevalue() {
  if (damagevalue_ != &::google::protobuf::internal::kEmptyString) {
    damagevalue_->clear();
  }
  clear_has_damagevalue();
}
inline const ::std::string& skillskill::damagevalue() const {
  return *damagevalue_;
}
inline void skillskill::set_damagevalue(const ::std::string& value) {
  set_has_damagevalue();
  if (damagevalue_ == &::google::protobuf::internal::kEmptyString) {
    damagevalue_ = new ::std::string;
  }
  damagevalue_->assign(value);
}
inline void skillskill::set_damagevalue(const char* value) {
  set_has_damagevalue();
  if (damagevalue_ == &::google::protobuf::internal::kEmptyString) {
    damagevalue_ = new ::std::string;
  }
  damagevalue_->assign(value);
}
inline void skillskill::set_damagevalue(const char* value, size_t size) {
  set_has_damagevalue();
  if (damagevalue_ == &::google::protobuf::internal::kEmptyString) {
    damagevalue_ = new ::std::string;
  }
  damagevalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskill::mutable_damagevalue() {
  set_has_damagevalue();
  if (damagevalue_ == &::google::protobuf::internal::kEmptyString) {
    damagevalue_ = new ::std::string;
  }
  return damagevalue_;
}
inline ::std::string* skillskill::release_damagevalue() {
  clear_has_damagevalue();
  if (damagevalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = damagevalue_;
    damagevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskill::set_allocated_damagevalue(::std::string* damagevalue) {
  if (damagevalue_ != &::google::protobuf::internal::kEmptyString) {
    delete damagevalue_;
  }
  if (damagevalue) {
    set_has_damagevalue();
    damagevalue_ = damagevalue;
  } else {
    clear_has_damagevalue();
    damagevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string damageRate = 39;
inline bool skillskill::has_damagerate() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void skillskill::set_has_damagerate() {
  _has_bits_[1] |= 0x00000040u;
}
inline void skillskill::clear_has_damagerate() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void skillskill::clear_damagerate() {
  if (damagerate_ != &::google::protobuf::internal::kEmptyString) {
    damagerate_->clear();
  }
  clear_has_damagerate();
}
inline const ::std::string& skillskill::damagerate() const {
  return *damagerate_;
}
inline void skillskill::set_damagerate(const ::std::string& value) {
  set_has_damagerate();
  if (damagerate_ == &::google::protobuf::internal::kEmptyString) {
    damagerate_ = new ::std::string;
  }
  damagerate_->assign(value);
}
inline void skillskill::set_damagerate(const char* value) {
  set_has_damagerate();
  if (damagerate_ == &::google::protobuf::internal::kEmptyString) {
    damagerate_ = new ::std::string;
  }
  damagerate_->assign(value);
}
inline void skillskill::set_damagerate(const char* value, size_t size) {
  set_has_damagerate();
  if (damagerate_ == &::google::protobuf::internal::kEmptyString) {
    damagerate_ = new ::std::string;
  }
  damagerate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillskill::mutable_damagerate() {
  set_has_damagerate();
  if (damagerate_ == &::google::protobuf::internal::kEmptyString) {
    damagerate_ = new ::std::string;
  }
  return damagerate_;
}
inline ::std::string* skillskill::release_damagerate() {
  clear_has_damagerate();
  if (damagerate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = damagerate_;
    damagerate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillskill::set_allocated_damagerate(::std::string* damagerate) {
  if (damagerate_ != &::google::protobuf::internal::kEmptyString) {
    delete damagerate_;
  }
  if (damagerate) {
    set_has_damagerate();
    damagerate_ = damagerate;
  } else {
    clear_has_damagerate();
    damagerate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 addhitrate = 40;
inline bool skillskill::has_addhitrate() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void skillskill::set_has_addhitrate() {
  _has_bits_[1] |= 0x00000080u;
}
inline void skillskill::clear_has_addhitrate() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void skillskill::clear_addhitrate() {
  addhitrate_ = 0;
  clear_has_addhitrate();
}
inline ::google::protobuf::int32 skillskill::addhitrate() const {
  return addhitrate_;
}
inline void skillskill::set_addhitrate(::google::protobuf::int32 value) {
  set_has_addhitrate();
  addhitrate_ = value;
}

// repeated .proto_ff.skillskillstateBagDesc stateBag = 41;
inline int skillskill::statebag_size() const {
  return statebag_.size();
}
inline void skillskill::clear_statebag() {
  statebag_.Clear();
}
inline const ::proto_ff::skillskillstateBagDesc& skillskill::statebag(int index) const {
  return statebag_.Get(index);
}
inline ::proto_ff::skillskillstateBagDesc* skillskill::mutable_statebag(int index) {
  return statebag_.Mutable(index);
}
inline ::proto_ff::skillskillstateBagDesc* skillskill::add_statebag() {
  return statebag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::skillskillstateBagDesc >&
skillskill::statebag() const {
  return statebag_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::skillskillstateBagDesc >*
skillskill::mutable_statebag() {
  return &statebag_;
}

// -------------------------------------------------------------------

// Sheet_skillskill

// repeated .proto_ff.skillskill skillskill_List = 1;
inline int Sheet_skillskill::skillskill_list_size() const {
  return skillskill_list_.size();
}
inline void Sheet_skillskill::clear_skillskill_list() {
  skillskill_list_.Clear();
}
inline const ::proto_ff::skillskill& Sheet_skillskill::skillskill_list(int index) const {
  return skillskill_list_.Get(index);
}
inline ::proto_ff::skillskill* Sheet_skillskill::mutable_skillskill_list(int index) {
  return skillskill_list_.Mutable(index);
}
inline ::proto_ff::skillskill* Sheet_skillskill::add_skillskill_list() {
  return skillskill_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::skillskill >&
Sheet_skillskill::skillskill_list() const {
  return skillskill_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::skillskill >*
Sheet_skillskill::mutable_skillskill_list() {
  return &skillskill_list_;
}

// -------------------------------------------------------------------

// skillbuffeffectDesc

// optional int32 Type = 1;
inline bool skillbuffeffectDesc::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skillbuffeffectDesc::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skillbuffeffectDesc::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skillbuffeffectDesc::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 skillbuffeffectDesc::type() const {
  return type_;
}
inline void skillbuffeffectDesc::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string Param = 2;
inline bool skillbuffeffectDesc::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void skillbuffeffectDesc::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void skillbuffeffectDesc::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void skillbuffeffectDesc::clear_param() {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    param_->clear();
  }
  clear_has_param();
}
inline const ::std::string& skillbuffeffectDesc::param() const {
  return *param_;
}
inline void skillbuffeffectDesc::set_param(const ::std::string& value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void skillbuffeffectDesc::set_param(const char* value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void skillbuffeffectDesc::set_param(const char* value, size_t size) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillbuffeffectDesc::mutable_param() {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  return param_;
}
inline ::std::string* skillbuffeffectDesc::release_param() {
  clear_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param_;
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillbuffeffectDesc::set_allocated_param(::std::string* param) {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    delete param_;
  }
  if (param) {
    set_has_param();
    param_ = param;
  } else {
    clear_has_param();
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// skillbuff

// optional int64 stateBagID = 1;
inline bool skillbuff::has_statebagid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skillbuff::set_has_statebagid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skillbuff::clear_has_statebagid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skillbuff::clear_statebagid() {
  statebagid_ = GOOGLE_LONGLONG(0);
  clear_has_statebagid();
}
inline ::google::protobuf::int64 skillbuff::statebagid() const {
  return statebagid_;
}
inline void skillbuff::set_statebagid(::google::protobuf::int64 value) {
  set_has_statebagid();
  statebagid_ = value;
}

// optional string stateBagName = 2;
inline bool skillbuff::has_statebagname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void skillbuff::set_has_statebagname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void skillbuff::clear_has_statebagname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void skillbuff::clear_statebagname() {
  if (statebagname_ != &::google::protobuf::internal::kEmptyString) {
    statebagname_->clear();
  }
  clear_has_statebagname();
}
inline const ::std::string& skillbuff::statebagname() const {
  return *statebagname_;
}
inline void skillbuff::set_statebagname(const ::std::string& value) {
  set_has_statebagname();
  if (statebagname_ == &::google::protobuf::internal::kEmptyString) {
    statebagname_ = new ::std::string;
  }
  statebagname_->assign(value);
}
inline void skillbuff::set_statebagname(const char* value) {
  set_has_statebagname();
  if (statebagname_ == &::google::protobuf::internal::kEmptyString) {
    statebagname_ = new ::std::string;
  }
  statebagname_->assign(value);
}
inline void skillbuff::set_statebagname(const char* value, size_t size) {
  set_has_statebagname();
  if (statebagname_ == &::google::protobuf::internal::kEmptyString) {
    statebagname_ = new ::std::string;
  }
  statebagname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillbuff::mutable_statebagname() {
  set_has_statebagname();
  if (statebagname_ == &::google::protobuf::internal::kEmptyString) {
    statebagname_ = new ::std::string;
  }
  return statebagname_;
}
inline ::std::string* skillbuff::release_statebagname() {
  clear_has_statebagname();
  if (statebagname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = statebagname_;
    statebagname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillbuff::set_allocated_statebagname(::std::string* statebagname) {
  if (statebagname_ != &::google::protobuf::internal::kEmptyString) {
    delete statebagname_;
  }
  if (statebagname) {
    set_has_statebagname();
    statebagname_ = statebagname;
  } else {
    clear_has_statebagname();
    statebagname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string stateBagIcon = 3;
inline bool skillbuff::has_statebagicon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void skillbuff::set_has_statebagicon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void skillbuff::clear_has_statebagicon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void skillbuff::clear_statebagicon() {
  if (statebagicon_ != &::google::protobuf::internal::kEmptyString) {
    statebagicon_->clear();
  }
  clear_has_statebagicon();
}
inline const ::std::string& skillbuff::statebagicon() const {
  return *statebagicon_;
}
inline void skillbuff::set_statebagicon(const ::std::string& value) {
  set_has_statebagicon();
  if (statebagicon_ == &::google::protobuf::internal::kEmptyString) {
    statebagicon_ = new ::std::string;
  }
  statebagicon_->assign(value);
}
inline void skillbuff::set_statebagicon(const char* value) {
  set_has_statebagicon();
  if (statebagicon_ == &::google::protobuf::internal::kEmptyString) {
    statebagicon_ = new ::std::string;
  }
  statebagicon_->assign(value);
}
inline void skillbuff::set_statebagicon(const char* value, size_t size) {
  set_has_statebagicon();
  if (statebagicon_ == &::google::protobuf::internal::kEmptyString) {
    statebagicon_ = new ::std::string;
  }
  statebagicon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillbuff::mutable_statebagicon() {
  set_has_statebagicon();
  if (statebagicon_ == &::google::protobuf::internal::kEmptyString) {
    statebagicon_ = new ::std::string;
  }
  return statebagicon_;
}
inline ::std::string* skillbuff::release_statebagicon() {
  clear_has_statebagicon();
  if (statebagicon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = statebagicon_;
    statebagicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillbuff::set_allocated_statebagicon(::std::string* statebagicon) {
  if (statebagicon_ != &::google::protobuf::internal::kEmptyString) {
    delete statebagicon_;
  }
  if (statebagicon) {
    set_has_statebagicon();
    statebagicon_ = statebagicon;
  } else {
    clear_has_statebagicon();
    statebagicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string effectResources = 4;
inline bool skillbuff::has_effectresources() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void skillbuff::set_has_effectresources() {
  _has_bits_[0] |= 0x00000008u;
}
inline void skillbuff::clear_has_effectresources() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void skillbuff::clear_effectresources() {
  if (effectresources_ != &::google::protobuf::internal::kEmptyString) {
    effectresources_->clear();
  }
  clear_has_effectresources();
}
inline const ::std::string& skillbuff::effectresources() const {
  return *effectresources_;
}
inline void skillbuff::set_effectresources(const ::std::string& value) {
  set_has_effectresources();
  if (effectresources_ == &::google::protobuf::internal::kEmptyString) {
    effectresources_ = new ::std::string;
  }
  effectresources_->assign(value);
}
inline void skillbuff::set_effectresources(const char* value) {
  set_has_effectresources();
  if (effectresources_ == &::google::protobuf::internal::kEmptyString) {
    effectresources_ = new ::std::string;
  }
  effectresources_->assign(value);
}
inline void skillbuff::set_effectresources(const char* value, size_t size) {
  set_has_effectresources();
  if (effectresources_ == &::google::protobuf::internal::kEmptyString) {
    effectresources_ = new ::std::string;
  }
  effectresources_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillbuff::mutable_effectresources() {
  set_has_effectresources();
  if (effectresources_ == &::google::protobuf::internal::kEmptyString) {
    effectresources_ = new ::std::string;
  }
  return effectresources_;
}
inline ::std::string* skillbuff::release_effectresources() {
  clear_has_effectresources();
  if (effectresources_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effectresources_;
    effectresources_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillbuff::set_allocated_effectresources(::std::string* effectresources) {
  if (effectresources_ != &::google::protobuf::internal::kEmptyString) {
    delete effectresources_;
  }
  if (effectresources) {
    set_has_effectresources();
    effectresources_ = effectresources;
  } else {
    clear_has_effectresources();
    effectresources_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 startType = 5;
inline bool skillbuff::has_starttype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void skillbuff::set_has_starttype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void skillbuff::clear_has_starttype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void skillbuff::clear_starttype() {
  starttype_ = 0;
  clear_has_starttype();
}
inline ::google::protobuf::int32 skillbuff::starttype() const {
  return starttype_;
}
inline void skillbuff::set_starttype(::google::protobuf::int32 value) {
  set_has_starttype();
  starttype_ = value;
}

// optional int32 startProbability = 6;
inline bool skillbuff::has_startprobability() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void skillbuff::set_has_startprobability() {
  _has_bits_[0] |= 0x00000020u;
}
inline void skillbuff::clear_has_startprobability() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void skillbuff::clear_startprobability() {
  startprobability_ = 0;
  clear_has_startprobability();
}
inline ::google::protobuf::int32 skillbuff::startprobability() const {
  return startprobability_;
}
inline void skillbuff::set_startprobability(::google::protobuf::int32 value) {
  set_has_startprobability();
  startprobability_ = value;
}

// optional string startTypeValue = 7;
inline bool skillbuff::has_starttypevalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void skillbuff::set_has_starttypevalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void skillbuff::clear_has_starttypevalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void skillbuff::clear_starttypevalue() {
  if (starttypevalue_ != &::google::protobuf::internal::kEmptyString) {
    starttypevalue_->clear();
  }
  clear_has_starttypevalue();
}
inline const ::std::string& skillbuff::starttypevalue() const {
  return *starttypevalue_;
}
inline void skillbuff::set_starttypevalue(const ::std::string& value) {
  set_has_starttypevalue();
  if (starttypevalue_ == &::google::protobuf::internal::kEmptyString) {
    starttypevalue_ = new ::std::string;
  }
  starttypevalue_->assign(value);
}
inline void skillbuff::set_starttypevalue(const char* value) {
  set_has_starttypevalue();
  if (starttypevalue_ == &::google::protobuf::internal::kEmptyString) {
    starttypevalue_ = new ::std::string;
  }
  starttypevalue_->assign(value);
}
inline void skillbuff::set_starttypevalue(const char* value, size_t size) {
  set_has_starttypevalue();
  if (starttypevalue_ == &::google::protobuf::internal::kEmptyString) {
    starttypevalue_ = new ::std::string;
  }
  starttypevalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillbuff::mutable_starttypevalue() {
  set_has_starttypevalue();
  if (starttypevalue_ == &::google::protobuf::internal::kEmptyString) {
    starttypevalue_ = new ::std::string;
  }
  return starttypevalue_;
}
inline ::std::string* skillbuff::release_starttypevalue() {
  clear_has_starttypevalue();
  if (starttypevalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttypevalue_;
    starttypevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillbuff::set_allocated_starttypevalue(::std::string* starttypevalue) {
  if (starttypevalue_ != &::google::protobuf::internal::kEmptyString) {
    delete starttypevalue_;
  }
  if (starttypevalue) {
    set_has_starttypevalue();
    starttypevalue_ = starttypevalue;
  } else {
    clear_has_starttypevalue();
    starttypevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endType = 8;
inline bool skillbuff::has_endtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void skillbuff::set_has_endtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void skillbuff::clear_has_endtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void skillbuff::clear_endtype() {
  if (endtype_ != &::google::protobuf::internal::kEmptyString) {
    endtype_->clear();
  }
  clear_has_endtype();
}
inline const ::std::string& skillbuff::endtype() const {
  return *endtype_;
}
inline void skillbuff::set_endtype(const ::std::string& value) {
  set_has_endtype();
  if (endtype_ == &::google::protobuf::internal::kEmptyString) {
    endtype_ = new ::std::string;
  }
  endtype_->assign(value);
}
inline void skillbuff::set_endtype(const char* value) {
  set_has_endtype();
  if (endtype_ == &::google::protobuf::internal::kEmptyString) {
    endtype_ = new ::std::string;
  }
  endtype_->assign(value);
}
inline void skillbuff::set_endtype(const char* value, size_t size) {
  set_has_endtype();
  if (endtype_ == &::google::protobuf::internal::kEmptyString) {
    endtype_ = new ::std::string;
  }
  endtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillbuff::mutable_endtype() {
  set_has_endtype();
  if (endtype_ == &::google::protobuf::internal::kEmptyString) {
    endtype_ = new ::std::string;
  }
  return endtype_;
}
inline ::std::string* skillbuff::release_endtype() {
  clear_has_endtype();
  if (endtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtype_;
    endtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillbuff::set_allocated_endtype(::std::string* endtype) {
  if (endtype_ != &::google::protobuf::internal::kEmptyString) {
    delete endtype_;
  }
  if (endtype) {
    set_has_endtype();
    endtype_ = endtype;
  } else {
    clear_has_endtype();
    endtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 save = 9;
inline bool skillbuff::has_save() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void skillbuff::set_has_save() {
  _has_bits_[0] |= 0x00000100u;
}
inline void skillbuff::clear_has_save() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void skillbuff::clear_save() {
  save_ = 0;
  clear_has_save();
}
inline ::google::protobuf::int32 skillbuff::save() const {
  return save_;
}
inline void skillbuff::set_save(::google::protobuf::int32 value) {
  set_has_save();
  save_ = value;
}

// optional string stateBagRule = 10;
inline bool skillbuff::has_statebagrule() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void skillbuff::set_has_statebagrule() {
  _has_bits_[0] |= 0x00000200u;
}
inline void skillbuff::clear_has_statebagrule() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void skillbuff::clear_statebagrule() {
  if (statebagrule_ != &::google::protobuf::internal::kEmptyString) {
    statebagrule_->clear();
  }
  clear_has_statebagrule();
}
inline const ::std::string& skillbuff::statebagrule() const {
  return *statebagrule_;
}
inline void skillbuff::set_statebagrule(const ::std::string& value) {
  set_has_statebagrule();
  if (statebagrule_ == &::google::protobuf::internal::kEmptyString) {
    statebagrule_ = new ::std::string;
  }
  statebagrule_->assign(value);
}
inline void skillbuff::set_statebagrule(const char* value) {
  set_has_statebagrule();
  if (statebagrule_ == &::google::protobuf::internal::kEmptyString) {
    statebagrule_ = new ::std::string;
  }
  statebagrule_->assign(value);
}
inline void skillbuff::set_statebagrule(const char* value, size_t size) {
  set_has_statebagrule();
  if (statebagrule_ == &::google::protobuf::internal::kEmptyString) {
    statebagrule_ = new ::std::string;
  }
  statebagrule_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillbuff::mutable_statebagrule() {
  set_has_statebagrule();
  if (statebagrule_ == &::google::protobuf::internal::kEmptyString) {
    statebagrule_ = new ::std::string;
  }
  return statebagrule_;
}
inline ::std::string* skillbuff::release_statebagrule() {
  clear_has_statebagrule();
  if (statebagrule_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = statebagrule_;
    statebagrule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillbuff::set_allocated_statebagrule(::std::string* statebagrule) {
  if (statebagrule_ != &::google::protobuf::internal::kEmptyString) {
    delete statebagrule_;
  }
  if (statebagrule) {
    set_has_statebagrule();
    statebagrule_ = statebagrule;
  } else {
    clear_has_statebagrule();
    statebagrule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 label = 11;
inline bool skillbuff::has_label() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void skillbuff::set_has_label() {
  _has_bits_[0] |= 0x00000400u;
}
inline void skillbuff::clear_has_label() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void skillbuff::clear_label() {
  label_ = 0;
  clear_has_label();
}
inline ::google::protobuf::int32 skillbuff::label() const {
  return label_;
}
inline void skillbuff::set_label(::google::protobuf::int32 value) {
  set_has_label();
  label_ = value;
}

// optional int32 mask = 12;
inline bool skillbuff::has_mask() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void skillbuff::set_has_mask() {
  _has_bits_[0] |= 0x00000800u;
}
inline void skillbuff::clear_has_mask() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void skillbuff::clear_mask() {
  mask_ = 0;
  clear_has_mask();
}
inline ::google::protobuf::int32 skillbuff::mask() const {
  return mask_;
}
inline void skillbuff::set_mask(::google::protobuf::int32 value) {
  set_has_mask();
  mask_ = value;
}

// optional string stateBagCd = 13;
inline bool skillbuff::has_statebagcd() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void skillbuff::set_has_statebagcd() {
  _has_bits_[0] |= 0x00001000u;
}
inline void skillbuff::clear_has_statebagcd() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void skillbuff::clear_statebagcd() {
  if (statebagcd_ != &::google::protobuf::internal::kEmptyString) {
    statebagcd_->clear();
  }
  clear_has_statebagcd();
}
inline const ::std::string& skillbuff::statebagcd() const {
  return *statebagcd_;
}
inline void skillbuff::set_statebagcd(const ::std::string& value) {
  set_has_statebagcd();
  if (statebagcd_ == &::google::protobuf::internal::kEmptyString) {
    statebagcd_ = new ::std::string;
  }
  statebagcd_->assign(value);
}
inline void skillbuff::set_statebagcd(const char* value) {
  set_has_statebagcd();
  if (statebagcd_ == &::google::protobuf::internal::kEmptyString) {
    statebagcd_ = new ::std::string;
  }
  statebagcd_->assign(value);
}
inline void skillbuff::set_statebagcd(const char* value, size_t size) {
  set_has_statebagcd();
  if (statebagcd_ == &::google::protobuf::internal::kEmptyString) {
    statebagcd_ = new ::std::string;
  }
  statebagcd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skillbuff::mutable_statebagcd() {
  set_has_statebagcd();
  if (statebagcd_ == &::google::protobuf::internal::kEmptyString) {
    statebagcd_ = new ::std::string;
  }
  return statebagcd_;
}
inline ::std::string* skillbuff::release_statebagcd() {
  clear_has_statebagcd();
  if (statebagcd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = statebagcd_;
    statebagcd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skillbuff::set_allocated_statebagcd(::std::string* statebagcd) {
  if (statebagcd_ != &::google::protobuf::internal::kEmptyString) {
    delete statebagcd_;
  }
  if (statebagcd) {
    set_has_statebagcd();
    statebagcd_ = statebagcd;
  } else {
    clear_has_statebagcd();
    statebagcd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto_ff.skillbuffeffectDesc effect = 14;
inline int skillbuff::effect_size() const {
  return effect_.size();
}
inline void skillbuff::clear_effect() {
  effect_.Clear();
}
inline const ::proto_ff::skillbuffeffectDesc& skillbuff::effect(int index) const {
  return effect_.Get(index);
}
inline ::proto_ff::skillbuffeffectDesc* skillbuff::mutable_effect(int index) {
  return effect_.Mutable(index);
}
inline ::proto_ff::skillbuffeffectDesc* skillbuff::add_effect() {
  return effect_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::skillbuffeffectDesc >&
skillbuff::effect() const {
  return effect_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::skillbuffeffectDesc >*
skillbuff::mutable_effect() {
  return &effect_;
}

// -------------------------------------------------------------------

// Sheet_skillbuff

// repeated .proto_ff.skillbuff skillbuff_List = 1;
inline int Sheet_skillbuff::skillbuff_list_size() const {
  return skillbuff_list_.size();
}
inline void Sheet_skillbuff::clear_skillbuff_list() {
  skillbuff_list_.Clear();
}
inline const ::proto_ff::skillbuff& Sheet_skillbuff::skillbuff_list(int index) const {
  return skillbuff_list_.Get(index);
}
inline ::proto_ff::skillbuff* Sheet_skillbuff::mutable_skillbuff_list(int index) {
  return skillbuff_list_.Mutable(index);
}
inline ::proto_ff::skillbuff* Sheet_skillbuff::add_skillbuff_list() {
  return skillbuff_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::skillbuff >&
Sheet_skillbuff::skillbuff_list() const {
  return skillbuff_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::skillbuff >*
Sheet_skillbuff::mutable_skillbuff_list() {
  return &skillbuff_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_skill_2eproto__INCLUDED
