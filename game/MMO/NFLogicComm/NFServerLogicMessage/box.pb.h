// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: box.proto

#ifndef PROTOBUF_box_2eproto__INCLUDED
#define PROTOBUF_box_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "yd_fieldoptions.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_box_2eproto();
void protobuf_AssignDesc_box_2eproto();
void protobuf_ShutdownFile_box_2eproto();

class boxboxboxdataDesc;
class boxbox;
class Sheet_boxbox;
class boxboxdataequipDesc;
class boxboxdataitemDesc;
class boxboxdata;
class Sheet_boxboxdata;

// ===================================================================

class boxboxboxdataDesc : public ::google::protobuf::Message {
 public:
  boxboxboxdataDesc();
  virtual ~boxboxboxdataDesc();

  boxboxboxdataDesc(const boxboxboxdataDesc& from);

  inline boxboxboxdataDesc& operator=(const boxboxboxdataDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const boxboxboxdataDesc& default_instance();

  void Swap(boxboxboxdataDesc* other);

  // implements Message ----------------------------------------------

  boxboxboxdataDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const boxboxboxdataDesc& from);
  void MergeFrom(const boxboxboxdataDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 maxTimes = 1;
  inline bool has_maxtimes() const;
  inline void clear_maxtimes();
  static const int kMaxTimesFieldNumber = 1;
  inline ::google::protobuf::int32 maxtimes() const;
  inline void set_maxtimes(::google::protobuf::int32 value);

  // optional int64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional int32 weight = 3;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 3;
  inline ::google::protobuf::int32 weight() const;
  inline void set_weight(::google::protobuf::int32 value);

  // optional int32 minTimes = 4;
  inline bool has_mintimes() const;
  inline void clear_mintimes();
  static const int kMinTimesFieldNumber = 4;
  inline ::google::protobuf::int32 mintimes() const;
  inline void set_mintimes(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.boxboxboxdataDesc)
 private:
  inline void set_has_maxtimes();
  inline void clear_has_maxtimes();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_mintimes();
  inline void clear_has_mintimes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 maxtimes_;
  ::google::protobuf::int32 weight_;
  ::google::protobuf::int32 mintimes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_box_2eproto();
  friend void protobuf_AssignDesc_box_2eproto();
  friend void protobuf_ShutdownFile_box_2eproto();

  void InitAsDefaultInstance();
  static boxboxboxdataDesc* default_instance_;
};
// -------------------------------------------------------------------

class boxbox : public ::google::protobuf::Message {
 public:
  boxbox();
  virtual ~boxbox();

  boxbox(const boxbox& from);

  inline boxbox& operator=(const boxbox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const boxbox& default_instance();

  void Swap(boxbox* other);

  // implements Message ----------------------------------------------

  boxbox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const boxbox& from);
  void MergeFrom(const boxbox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 Rate = 3;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 3;
  inline ::google::protobuf::int32 rate() const;
  inline void set_rate(::google::protobuf::int32 value);

  // optional int32 Mask = 4;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 4;
  inline ::google::protobuf::int32 mask() const;
  inline void set_mask(::google::protobuf::int32 value);

  // optional int32 minTimes = 5;
  inline bool has_mintimes() const;
  inline void clear_mintimes();
  static const int kMinTimesFieldNumber = 5;
  inline ::google::protobuf::int32 mintimes() const;
  inline void set_mintimes(::google::protobuf::int32 value);

  // optional int32 maxTimes = 6;
  inline bool has_maxtimes() const;
  inline void clear_maxtimes();
  static const int kMaxTimesFieldNumber = 6;
  inline ::google::protobuf::int32 maxtimes() const;
  inline void set_maxtimes(::google::protobuf::int32 value);

  // repeated .proto_ff.boxboxboxdataDesc boxdata = 7;
  inline int boxdata_size() const;
  inline void clear_boxdata();
  static const int kBoxdataFieldNumber = 7;
  inline const ::proto_ff::boxboxboxdataDesc& boxdata(int index) const;
  inline ::proto_ff::boxboxboxdataDesc* mutable_boxdata(int index);
  inline ::proto_ff::boxboxboxdataDesc* add_boxdata();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxboxdataDesc >&
      boxdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxboxdataDesc >*
      mutable_boxdata();

  // @@protoc_insertion_point(class_scope:proto_ff.boxbox)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_rate();
  inline void clear_has_rate();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_mintimes();
  inline void clear_has_mintimes();
  inline void set_has_maxtimes();
  inline void clear_has_maxtimes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 rate_;
  ::google::protobuf::int32 mask_;
  ::google::protobuf::int32 mintimes_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxboxdataDesc > boxdata_;
  ::google::protobuf::int32 maxtimes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_box_2eproto();
  friend void protobuf_AssignDesc_box_2eproto();
  friend void protobuf_ShutdownFile_box_2eproto();

  void InitAsDefaultInstance();
  static boxbox* default_instance_;
};
// -------------------------------------------------------------------

class Sheet_boxbox : public ::google::protobuf::Message {
 public:
  Sheet_boxbox();
  virtual ~Sheet_boxbox();

  Sheet_boxbox(const Sheet_boxbox& from);

  inline Sheet_boxbox& operator=(const Sheet_boxbox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sheet_boxbox& default_instance();

  void Swap(Sheet_boxbox* other);

  // implements Message ----------------------------------------------

  Sheet_boxbox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sheet_boxbox& from);
  void MergeFrom(const Sheet_boxbox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto_ff.boxbox boxbox_List = 1;
  inline int boxbox_list_size() const;
  inline void clear_boxbox_list();
  static const int kBoxboxListFieldNumber = 1;
  inline const ::proto_ff::boxbox& boxbox_list(int index) const;
  inline ::proto_ff::boxbox* mutable_boxbox_list(int index);
  inline ::proto_ff::boxbox* add_boxbox_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxbox >&
      boxbox_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxbox >*
      mutable_boxbox_list();

  // @@protoc_insertion_point(class_scope:proto_ff.Sheet_boxbox)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::boxbox > boxbox_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_box_2eproto();
  friend void protobuf_AssignDesc_box_2eproto();
  friend void protobuf_ShutdownFile_box_2eproto();

  void InitAsDefaultInstance();
  static Sheet_boxbox* default_instance_;
};
// -------------------------------------------------------------------

class boxboxdataequipDesc : public ::google::protobuf::Message {
 public:
  boxboxdataequipDesc();
  virtual ~boxboxdataequipDesc();

  boxboxdataequipDesc(const boxboxdataequipDesc& from);

  inline boxboxdataequipDesc& operator=(const boxboxdataequipDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const boxboxdataequipDesc& default_instance();

  void Swap(boxboxdataequipDesc* other);

  // implements Message ----------------------------------------------

  boxboxdataequipDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const boxboxdataequipDesc& from);
  void MergeFrom(const boxboxdataequipDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 rand = 1;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 1;
  inline ::google::protobuf::int32 rand() const;
  inline void set_rand(::google::protobuf::int32 value);

  // optional int32 minNum = 2;
  inline bool has_minnum() const;
  inline void clear_minnum();
  static const int kMinNumFieldNumber = 2;
  inline ::google::protobuf::int32 minnum() const;
  inline void set_minnum(::google::protobuf::int32 value);

  // optional int32 isbind = 3;
  inline bool has_isbind() const;
  inline void clear_isbind();
  static const int kIsbindFieldNumber = 3;
  inline ::google::protobuf::int32 isbind() const;
  inline void set_isbind(::google::protobuf::int32 value);

  // optional int32 maxNum = 4;
  inline bool has_maxnum() const;
  inline void clear_maxnum();
  static const int kMaxNumFieldNumber = 4;
  inline ::google::protobuf::int32 maxnum() const;
  inline void set_maxnum(::google::protobuf::int32 value);

  // optional string id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:proto_ff.boxboxdataequipDesc)
 private:
  inline void set_has_rand();
  inline void clear_has_rand();
  inline void set_has_minnum();
  inline void clear_has_minnum();
  inline void set_has_isbind();
  inline void clear_has_isbind();
  inline void set_has_maxnum();
  inline void clear_has_maxnum();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 rand_;
  ::google::protobuf::int32 minnum_;
  ::google::protobuf::int32 isbind_;
  ::google::protobuf::int32 maxnum_;
  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_box_2eproto();
  friend void protobuf_AssignDesc_box_2eproto();
  friend void protobuf_ShutdownFile_box_2eproto();

  void InitAsDefaultInstance();
  static boxboxdataequipDesc* default_instance_;
};
// -------------------------------------------------------------------

class boxboxdataitemDesc : public ::google::protobuf::Message {
 public:
  boxboxdataitemDesc();
  virtual ~boxboxdataitemDesc();

  boxboxdataitemDesc(const boxboxdataitemDesc& from);

  inline boxboxdataitemDesc& operator=(const boxboxdataitemDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const boxboxdataitemDesc& default_instance();

  void Swap(boxboxdataitemDesc* other);

  // implements Message ----------------------------------------------

  boxboxdataitemDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const boxboxdataitemDesc& from);
  void MergeFrom(const boxboxdataitemDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string rand = 1;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 1;
  inline const ::std::string& rand() const;
  inline void set_rand(const ::std::string& value);
  inline void set_rand(const char* value);
  inline void set_rand(const char* value, size_t size);
  inline ::std::string* mutable_rand();
  inline ::std::string* release_rand();
  inline void set_allocated_rand(::std::string* rand);

  // optional int32 maxNum = 2;
  inline bool has_maxnum() const;
  inline void clear_maxnum();
  static const int kMaxNumFieldNumber = 2;
  inline ::google::protobuf::int32 maxnum() const;
  inline void set_maxnum(::google::protobuf::int32 value);

  // optional int32 rarerand = 3;
  inline bool has_rarerand() const;
  inline void clear_rarerand();
  static const int kRarerandFieldNumber = 3;
  inline ::google::protobuf::int32 rarerand() const;
  inline void set_rarerand(::google::protobuf::int32 value);

  // optional int32 minNum = 4;
  inline bool has_minnum() const;
  inline void clear_minnum();
  static const int kMinNumFieldNumber = 4;
  inline ::google::protobuf::int32 minnum() const;
  inline void set_minnum(::google::protobuf::int32 value);

  // optional string isbind = 5;
  inline bool has_isbind() const;
  inline void clear_isbind();
  static const int kIsbindFieldNumber = 5;
  inline const ::std::string& isbind() const;
  inline void set_isbind(const ::std::string& value);
  inline void set_isbind(const char* value);
  inline void set_isbind(const char* value, size_t size);
  inline ::std::string* mutable_isbind();
  inline ::std::string* release_isbind();
  inline void set_allocated_isbind(::std::string* isbind);

  // optional string id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:proto_ff.boxboxdataitemDesc)
 private:
  inline void set_has_rand();
  inline void clear_has_rand();
  inline void set_has_maxnum();
  inline void clear_has_maxnum();
  inline void set_has_rarerand();
  inline void clear_has_rarerand();
  inline void set_has_minnum();
  inline void clear_has_minnum();
  inline void set_has_isbind();
  inline void clear_has_isbind();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* rand_;
  ::google::protobuf::int32 maxnum_;
  ::google::protobuf::int32 rarerand_;
  ::std::string* isbind_;
  ::std::string* id_;
  ::google::protobuf::int32 minnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_box_2eproto();
  friend void protobuf_AssignDesc_box_2eproto();
  friend void protobuf_ShutdownFile_box_2eproto();

  void InitAsDefaultInstance();
  static boxboxdataitemDesc* default_instance_;
};
// -------------------------------------------------------------------

class boxboxdata : public ::google::protobuf::Message {
 public:
  boxboxdata();
  virtual ~boxboxdata();

  boxboxdata(const boxboxdata& from);

  inline boxboxdata& operator=(const boxboxdata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const boxboxdata& default_instance();

  void Swap(boxboxdata* other);

  // implements Message ----------------------------------------------

  boxboxdata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const boxboxdata& from);
  void MergeFrom(const boxboxdata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional int32 drop_type = 2;
  inline bool has_drop_type() const;
  inline void clear_drop_type();
  static const int kDropTypeFieldNumber = 2;
  inline ::google::protobuf::int32 drop_type() const;
  inline void set_drop_type(::google::protobuf::int32 value);

  // optional int32 goldminNum = 3;
  inline bool has_goldminnum() const;
  inline void clear_goldminnum();
  static const int kGoldminNumFieldNumber = 3;
  inline ::google::protobuf::int32 goldminnum() const;
  inline void set_goldminnum(::google::protobuf::int32 value);

  // optional int32 goldmaxNum = 4;
  inline bool has_goldmaxnum() const;
  inline void clear_goldmaxnum();
  static const int kGoldmaxNumFieldNumber = 4;
  inline ::google::protobuf::int32 goldmaxnum() const;
  inline void set_goldmaxnum(::google::protobuf::int32 value);

  // optional int32 goldrand = 5;
  inline bool has_goldrand() const;
  inline void clear_goldrand();
  static const int kGoldrandFieldNumber = 5;
  inline ::google::protobuf::int32 goldrand() const;
  inline void set_goldrand(::google::protobuf::int32 value);

  // optional int32 bindjewelminNum = 6;
  inline bool has_bindjewelminnum() const;
  inline void clear_bindjewelminnum();
  static const int kBindjewelminNumFieldNumber = 6;
  inline ::google::protobuf::int32 bindjewelminnum() const;
  inline void set_bindjewelminnum(::google::protobuf::int32 value);

  // optional int32 bindjewelmaxNum = 7;
  inline bool has_bindjewelmaxnum() const;
  inline void clear_bindjewelmaxnum();
  static const int kBindjewelmaxNumFieldNumber = 7;
  inline ::google::protobuf::int32 bindjewelmaxnum() const;
  inline void set_bindjewelmaxnum(::google::protobuf::int32 value);

  // optional int32 bindjewelrand = 8;
  inline bool has_bindjewelrand() const;
  inline void clear_bindjewelrand();
  static const int kBindjewelrandFieldNumber = 8;
  inline ::google::protobuf::int32 bindjewelrand() const;
  inline void set_bindjewelrand(::google::protobuf::int32 value);

  // optional int32 jewelminNum = 9;
  inline bool has_jewelminnum() const;
  inline void clear_jewelminnum();
  static const int kJewelminNumFieldNumber = 9;
  inline ::google::protobuf::int32 jewelminnum() const;
  inline void set_jewelminnum(::google::protobuf::int32 value);

  // optional int32 jewelmaxNum = 10;
  inline bool has_jewelmaxnum() const;
  inline void clear_jewelmaxnum();
  static const int kJewelmaxNumFieldNumber = 10;
  inline ::google::protobuf::int32 jewelmaxnum() const;
  inline void set_jewelmaxnum(::google::protobuf::int32 value);

  // optional int32 jewelrand = 11;
  inline bool has_jewelrand() const;
  inline void clear_jewelrand();
  static const int kJewelrandFieldNumber = 11;
  inline ::google::protobuf::int32 jewelrand() const;
  inline void set_jewelrand(::google::protobuf::int32 value);

  // optional string eq_profession = 12;
  inline bool has_eq_profession() const;
  inline void clear_eq_profession();
  static const int kEqProfessionFieldNumber = 12;
  inline const ::std::string& eq_profession() const;
  inline void set_eq_profession(const ::std::string& value);
  inline void set_eq_profession(const char* value);
  inline void set_eq_profession(const char* value, size_t size);
  inline ::std::string* mutable_eq_profession();
  inline ::std::string* release_eq_profession();
  inline void set_allocated_eq_profession(::std::string* eq_profession);

  // repeated .proto_ff.boxboxdataequipDesc equip = 13;
  inline int equip_size() const;
  inline void clear_equip();
  static const int kEquipFieldNumber = 13;
  inline const ::proto_ff::boxboxdataequipDesc& equip(int index) const;
  inline ::proto_ff::boxboxdataequipDesc* mutable_equip(int index);
  inline ::proto_ff::boxboxdataequipDesc* add_equip();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdataequipDesc >&
      equip() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdataequipDesc >*
      mutable_equip();

  // repeated .proto_ff.boxboxdataitemDesc item = 14;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 14;
  inline const ::proto_ff::boxboxdataitemDesc& item(int index) const;
  inline ::proto_ff::boxboxdataitemDesc* mutable_item(int index);
  inline ::proto_ff::boxboxdataitemDesc* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdataitemDesc >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdataitemDesc >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:proto_ff.boxboxdata)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_drop_type();
  inline void clear_has_drop_type();
  inline void set_has_goldminnum();
  inline void clear_has_goldminnum();
  inline void set_has_goldmaxnum();
  inline void clear_has_goldmaxnum();
  inline void set_has_goldrand();
  inline void clear_has_goldrand();
  inline void set_has_bindjewelminnum();
  inline void clear_has_bindjewelminnum();
  inline void set_has_bindjewelmaxnum();
  inline void clear_has_bindjewelmaxnum();
  inline void set_has_bindjewelrand();
  inline void clear_has_bindjewelrand();
  inline void set_has_jewelminnum();
  inline void clear_has_jewelminnum();
  inline void set_has_jewelmaxnum();
  inline void clear_has_jewelmaxnum();
  inline void set_has_jewelrand();
  inline void clear_has_jewelrand();
  inline void set_has_eq_profession();
  inline void clear_has_eq_profession();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 drop_type_;
  ::google::protobuf::int32 goldminnum_;
  ::google::protobuf::int32 goldmaxnum_;
  ::google::protobuf::int32 goldrand_;
  ::google::protobuf::int32 bindjewelminnum_;
  ::google::protobuf::int32 bindjewelmaxnum_;
  ::google::protobuf::int32 bindjewelrand_;
  ::google::protobuf::int32 jewelminnum_;
  ::google::protobuf::int32 jewelmaxnum_;
  ::google::protobuf::int32 jewelrand_;
  ::std::string* eq_profession_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdataequipDesc > equip_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdataitemDesc > item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_box_2eproto();
  friend void protobuf_AssignDesc_box_2eproto();
  friend void protobuf_ShutdownFile_box_2eproto();

  void InitAsDefaultInstance();
  static boxboxdata* default_instance_;
};
// -------------------------------------------------------------------

class Sheet_boxboxdata : public ::google::protobuf::Message {
 public:
  Sheet_boxboxdata();
  virtual ~Sheet_boxboxdata();

  Sheet_boxboxdata(const Sheet_boxboxdata& from);

  inline Sheet_boxboxdata& operator=(const Sheet_boxboxdata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sheet_boxboxdata& default_instance();

  void Swap(Sheet_boxboxdata* other);

  // implements Message ----------------------------------------------

  Sheet_boxboxdata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sheet_boxboxdata& from);
  void MergeFrom(const Sheet_boxboxdata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto_ff.boxboxdata boxboxdata_List = 1;
  inline int boxboxdata_list_size() const;
  inline void clear_boxboxdata_list();
  static const int kBoxboxdataListFieldNumber = 1;
  inline const ::proto_ff::boxboxdata& boxboxdata_list(int index) const;
  inline ::proto_ff::boxboxdata* mutable_boxboxdata_list(int index);
  inline ::proto_ff::boxboxdata* add_boxboxdata_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdata >&
      boxboxdata_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdata >*
      mutable_boxboxdata_list();

  // @@protoc_insertion_point(class_scope:proto_ff.Sheet_boxboxdata)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdata > boxboxdata_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_box_2eproto();
  friend void protobuf_AssignDesc_box_2eproto();
  friend void protobuf_ShutdownFile_box_2eproto();

  void InitAsDefaultInstance();
  static Sheet_boxboxdata* default_instance_;
};
// ===================================================================


// ===================================================================

// boxboxboxdataDesc

// optional int32 maxTimes = 1;
inline bool boxboxboxdataDesc::has_maxtimes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void boxboxboxdataDesc::set_has_maxtimes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void boxboxboxdataDesc::clear_has_maxtimes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void boxboxboxdataDesc::clear_maxtimes() {
  maxtimes_ = 0;
  clear_has_maxtimes();
}
inline ::google::protobuf::int32 boxboxboxdataDesc::maxtimes() const {
  return maxtimes_;
}
inline void boxboxboxdataDesc::set_maxtimes(::google::protobuf::int32 value) {
  set_has_maxtimes();
  maxtimes_ = value;
}

// optional int64 id = 2;
inline bool boxboxboxdataDesc::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void boxboxboxdataDesc::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void boxboxboxdataDesc::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void boxboxboxdataDesc::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 boxboxboxdataDesc::id() const {
  return id_;
}
inline void boxboxboxdataDesc::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional int32 weight = 3;
inline bool boxboxboxdataDesc::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void boxboxboxdataDesc::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void boxboxboxdataDesc::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void boxboxboxdataDesc::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline ::google::protobuf::int32 boxboxboxdataDesc::weight() const {
  return weight_;
}
inline void boxboxboxdataDesc::set_weight(::google::protobuf::int32 value) {
  set_has_weight();
  weight_ = value;
}

// optional int32 minTimes = 4;
inline bool boxboxboxdataDesc::has_mintimes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void boxboxboxdataDesc::set_has_mintimes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void boxboxboxdataDesc::clear_has_mintimes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void boxboxboxdataDesc::clear_mintimes() {
  mintimes_ = 0;
  clear_has_mintimes();
}
inline ::google::protobuf::int32 boxboxboxdataDesc::mintimes() const {
  return mintimes_;
}
inline void boxboxboxdataDesc::set_mintimes(::google::protobuf::int32 value) {
  set_has_mintimes();
  mintimes_ = value;
}

// -------------------------------------------------------------------

// boxbox

// optional int64 id = 1;
inline bool boxbox::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void boxbox::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void boxbox::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void boxbox::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 boxbox::id() const {
  return id_;
}
inline void boxbox::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional int32 type = 2;
inline bool boxbox::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void boxbox::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void boxbox::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void boxbox::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 boxbox::type() const {
  return type_;
}
inline void boxbox::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 Rate = 3;
inline bool boxbox::has_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void boxbox::set_has_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void boxbox::clear_has_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void boxbox::clear_rate() {
  rate_ = 0;
  clear_has_rate();
}
inline ::google::protobuf::int32 boxbox::rate() const {
  return rate_;
}
inline void boxbox::set_rate(::google::protobuf::int32 value) {
  set_has_rate();
  rate_ = value;
}

// optional int32 Mask = 4;
inline bool boxbox::has_mask() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void boxbox::set_has_mask() {
  _has_bits_[0] |= 0x00000008u;
}
inline void boxbox::clear_has_mask() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void boxbox::clear_mask() {
  mask_ = 0;
  clear_has_mask();
}
inline ::google::protobuf::int32 boxbox::mask() const {
  return mask_;
}
inline void boxbox::set_mask(::google::protobuf::int32 value) {
  set_has_mask();
  mask_ = value;
}

// optional int32 minTimes = 5;
inline bool boxbox::has_mintimes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void boxbox::set_has_mintimes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void boxbox::clear_has_mintimes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void boxbox::clear_mintimes() {
  mintimes_ = 0;
  clear_has_mintimes();
}
inline ::google::protobuf::int32 boxbox::mintimes() const {
  return mintimes_;
}
inline void boxbox::set_mintimes(::google::protobuf::int32 value) {
  set_has_mintimes();
  mintimes_ = value;
}

// optional int32 maxTimes = 6;
inline bool boxbox::has_maxtimes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void boxbox::set_has_maxtimes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void boxbox::clear_has_maxtimes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void boxbox::clear_maxtimes() {
  maxtimes_ = 0;
  clear_has_maxtimes();
}
inline ::google::protobuf::int32 boxbox::maxtimes() const {
  return maxtimes_;
}
inline void boxbox::set_maxtimes(::google::protobuf::int32 value) {
  set_has_maxtimes();
  maxtimes_ = value;
}

// repeated .proto_ff.boxboxboxdataDesc boxdata = 7;
inline int boxbox::boxdata_size() const {
  return boxdata_.size();
}
inline void boxbox::clear_boxdata() {
  boxdata_.Clear();
}
inline const ::proto_ff::boxboxboxdataDesc& boxbox::boxdata(int index) const {
  return boxdata_.Get(index);
}
inline ::proto_ff::boxboxboxdataDesc* boxbox::mutable_boxdata(int index) {
  return boxdata_.Mutable(index);
}
inline ::proto_ff::boxboxboxdataDesc* boxbox::add_boxdata() {
  return boxdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxboxdataDesc >&
boxbox::boxdata() const {
  return boxdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxboxdataDesc >*
boxbox::mutable_boxdata() {
  return &boxdata_;
}

// -------------------------------------------------------------------

// Sheet_boxbox

// repeated .proto_ff.boxbox boxbox_List = 1;
inline int Sheet_boxbox::boxbox_list_size() const {
  return boxbox_list_.size();
}
inline void Sheet_boxbox::clear_boxbox_list() {
  boxbox_list_.Clear();
}
inline const ::proto_ff::boxbox& Sheet_boxbox::boxbox_list(int index) const {
  return boxbox_list_.Get(index);
}
inline ::proto_ff::boxbox* Sheet_boxbox::mutable_boxbox_list(int index) {
  return boxbox_list_.Mutable(index);
}
inline ::proto_ff::boxbox* Sheet_boxbox::add_boxbox_list() {
  return boxbox_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxbox >&
Sheet_boxbox::boxbox_list() const {
  return boxbox_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxbox >*
Sheet_boxbox::mutable_boxbox_list() {
  return &boxbox_list_;
}

// -------------------------------------------------------------------

// boxboxdataequipDesc

// optional int32 rand = 1;
inline bool boxboxdataequipDesc::has_rand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void boxboxdataequipDesc::set_has_rand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void boxboxdataequipDesc::clear_has_rand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void boxboxdataequipDesc::clear_rand() {
  rand_ = 0;
  clear_has_rand();
}
inline ::google::protobuf::int32 boxboxdataequipDesc::rand() const {
  return rand_;
}
inline void boxboxdataequipDesc::set_rand(::google::protobuf::int32 value) {
  set_has_rand();
  rand_ = value;
}

// optional int32 minNum = 2;
inline bool boxboxdataequipDesc::has_minnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void boxboxdataequipDesc::set_has_minnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void boxboxdataequipDesc::clear_has_minnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void boxboxdataequipDesc::clear_minnum() {
  minnum_ = 0;
  clear_has_minnum();
}
inline ::google::protobuf::int32 boxboxdataequipDesc::minnum() const {
  return minnum_;
}
inline void boxboxdataequipDesc::set_minnum(::google::protobuf::int32 value) {
  set_has_minnum();
  minnum_ = value;
}

// optional int32 isbind = 3;
inline bool boxboxdataequipDesc::has_isbind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void boxboxdataequipDesc::set_has_isbind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void boxboxdataequipDesc::clear_has_isbind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void boxboxdataequipDesc::clear_isbind() {
  isbind_ = 0;
  clear_has_isbind();
}
inline ::google::protobuf::int32 boxboxdataequipDesc::isbind() const {
  return isbind_;
}
inline void boxboxdataequipDesc::set_isbind(::google::protobuf::int32 value) {
  set_has_isbind();
  isbind_ = value;
}

// optional int32 maxNum = 4;
inline bool boxboxdataequipDesc::has_maxnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void boxboxdataequipDesc::set_has_maxnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void boxboxdataequipDesc::clear_has_maxnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void boxboxdataequipDesc::clear_maxnum() {
  maxnum_ = 0;
  clear_has_maxnum();
}
inline ::google::protobuf::int32 boxboxdataequipDesc::maxnum() const {
  return maxnum_;
}
inline void boxboxdataequipDesc::set_maxnum(::google::protobuf::int32 value) {
  set_has_maxnum();
  maxnum_ = value;
}

// optional string id = 5;
inline bool boxboxdataequipDesc::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void boxboxdataequipDesc::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void boxboxdataequipDesc::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void boxboxdataequipDesc::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& boxboxdataequipDesc::id() const {
  return *id_;
}
inline void boxboxdataequipDesc::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void boxboxdataequipDesc::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void boxboxdataequipDesc::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* boxboxdataequipDesc::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* boxboxdataequipDesc::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void boxboxdataequipDesc::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// boxboxdataitemDesc

// optional string rand = 1;
inline bool boxboxdataitemDesc::has_rand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void boxboxdataitemDesc::set_has_rand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void boxboxdataitemDesc::clear_has_rand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void boxboxdataitemDesc::clear_rand() {
  if (rand_ != &::google::protobuf::internal::kEmptyString) {
    rand_->clear();
  }
  clear_has_rand();
}
inline const ::std::string& boxboxdataitemDesc::rand() const {
  return *rand_;
}
inline void boxboxdataitemDesc::set_rand(const ::std::string& value) {
  set_has_rand();
  if (rand_ == &::google::protobuf::internal::kEmptyString) {
    rand_ = new ::std::string;
  }
  rand_->assign(value);
}
inline void boxboxdataitemDesc::set_rand(const char* value) {
  set_has_rand();
  if (rand_ == &::google::protobuf::internal::kEmptyString) {
    rand_ = new ::std::string;
  }
  rand_->assign(value);
}
inline void boxboxdataitemDesc::set_rand(const char* value, size_t size) {
  set_has_rand();
  if (rand_ == &::google::protobuf::internal::kEmptyString) {
    rand_ = new ::std::string;
  }
  rand_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* boxboxdataitemDesc::mutable_rand() {
  set_has_rand();
  if (rand_ == &::google::protobuf::internal::kEmptyString) {
    rand_ = new ::std::string;
  }
  return rand_;
}
inline ::std::string* boxboxdataitemDesc::release_rand() {
  clear_has_rand();
  if (rand_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rand_;
    rand_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void boxboxdataitemDesc::set_allocated_rand(::std::string* rand) {
  if (rand_ != &::google::protobuf::internal::kEmptyString) {
    delete rand_;
  }
  if (rand) {
    set_has_rand();
    rand_ = rand;
  } else {
    clear_has_rand();
    rand_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 maxNum = 2;
inline bool boxboxdataitemDesc::has_maxnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void boxboxdataitemDesc::set_has_maxnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void boxboxdataitemDesc::clear_has_maxnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void boxboxdataitemDesc::clear_maxnum() {
  maxnum_ = 0;
  clear_has_maxnum();
}
inline ::google::protobuf::int32 boxboxdataitemDesc::maxnum() const {
  return maxnum_;
}
inline void boxboxdataitemDesc::set_maxnum(::google::protobuf::int32 value) {
  set_has_maxnum();
  maxnum_ = value;
}

// optional int32 rarerand = 3;
inline bool boxboxdataitemDesc::has_rarerand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void boxboxdataitemDesc::set_has_rarerand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void boxboxdataitemDesc::clear_has_rarerand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void boxboxdataitemDesc::clear_rarerand() {
  rarerand_ = 0;
  clear_has_rarerand();
}
inline ::google::protobuf::int32 boxboxdataitemDesc::rarerand() const {
  return rarerand_;
}
inline void boxboxdataitemDesc::set_rarerand(::google::protobuf::int32 value) {
  set_has_rarerand();
  rarerand_ = value;
}

// optional int32 minNum = 4;
inline bool boxboxdataitemDesc::has_minnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void boxboxdataitemDesc::set_has_minnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void boxboxdataitemDesc::clear_has_minnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void boxboxdataitemDesc::clear_minnum() {
  minnum_ = 0;
  clear_has_minnum();
}
inline ::google::protobuf::int32 boxboxdataitemDesc::minnum() const {
  return minnum_;
}
inline void boxboxdataitemDesc::set_minnum(::google::protobuf::int32 value) {
  set_has_minnum();
  minnum_ = value;
}

// optional string isbind = 5;
inline bool boxboxdataitemDesc::has_isbind() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void boxboxdataitemDesc::set_has_isbind() {
  _has_bits_[0] |= 0x00000010u;
}
inline void boxboxdataitemDesc::clear_has_isbind() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void boxboxdataitemDesc::clear_isbind() {
  if (isbind_ != &::google::protobuf::internal::kEmptyString) {
    isbind_->clear();
  }
  clear_has_isbind();
}
inline const ::std::string& boxboxdataitemDesc::isbind() const {
  return *isbind_;
}
inline void boxboxdataitemDesc::set_isbind(const ::std::string& value) {
  set_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    isbind_ = new ::std::string;
  }
  isbind_->assign(value);
}
inline void boxboxdataitemDesc::set_isbind(const char* value) {
  set_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    isbind_ = new ::std::string;
  }
  isbind_->assign(value);
}
inline void boxboxdataitemDesc::set_isbind(const char* value, size_t size) {
  set_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    isbind_ = new ::std::string;
  }
  isbind_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* boxboxdataitemDesc::mutable_isbind() {
  set_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    isbind_ = new ::std::string;
  }
  return isbind_;
}
inline ::std::string* boxboxdataitemDesc::release_isbind() {
  clear_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isbind_;
    isbind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void boxboxdataitemDesc::set_allocated_isbind(::std::string* isbind) {
  if (isbind_ != &::google::protobuf::internal::kEmptyString) {
    delete isbind_;
  }
  if (isbind) {
    set_has_isbind();
    isbind_ = isbind;
  } else {
    clear_has_isbind();
    isbind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id = 6;
inline bool boxboxdataitemDesc::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void boxboxdataitemDesc::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void boxboxdataitemDesc::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void boxboxdataitemDesc::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& boxboxdataitemDesc::id() const {
  return *id_;
}
inline void boxboxdataitemDesc::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void boxboxdataitemDesc::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void boxboxdataitemDesc::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* boxboxdataitemDesc::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* boxboxdataitemDesc::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void boxboxdataitemDesc::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// boxboxdata

// optional int64 id = 1;
inline bool boxboxdata::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void boxboxdata::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void boxboxdata::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void boxboxdata::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 boxboxdata::id() const {
  return id_;
}
inline void boxboxdata::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional int32 drop_type = 2;
inline bool boxboxdata::has_drop_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void boxboxdata::set_has_drop_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void boxboxdata::clear_has_drop_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void boxboxdata::clear_drop_type() {
  drop_type_ = 0;
  clear_has_drop_type();
}
inline ::google::protobuf::int32 boxboxdata::drop_type() const {
  return drop_type_;
}
inline void boxboxdata::set_drop_type(::google::protobuf::int32 value) {
  set_has_drop_type();
  drop_type_ = value;
}

// optional int32 goldminNum = 3;
inline bool boxboxdata::has_goldminnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void boxboxdata::set_has_goldminnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void boxboxdata::clear_has_goldminnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void boxboxdata::clear_goldminnum() {
  goldminnum_ = 0;
  clear_has_goldminnum();
}
inline ::google::protobuf::int32 boxboxdata::goldminnum() const {
  return goldminnum_;
}
inline void boxboxdata::set_goldminnum(::google::protobuf::int32 value) {
  set_has_goldminnum();
  goldminnum_ = value;
}

// optional int32 goldmaxNum = 4;
inline bool boxboxdata::has_goldmaxnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void boxboxdata::set_has_goldmaxnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void boxboxdata::clear_has_goldmaxnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void boxboxdata::clear_goldmaxnum() {
  goldmaxnum_ = 0;
  clear_has_goldmaxnum();
}
inline ::google::protobuf::int32 boxboxdata::goldmaxnum() const {
  return goldmaxnum_;
}
inline void boxboxdata::set_goldmaxnum(::google::protobuf::int32 value) {
  set_has_goldmaxnum();
  goldmaxnum_ = value;
}

// optional int32 goldrand = 5;
inline bool boxboxdata::has_goldrand() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void boxboxdata::set_has_goldrand() {
  _has_bits_[0] |= 0x00000010u;
}
inline void boxboxdata::clear_has_goldrand() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void boxboxdata::clear_goldrand() {
  goldrand_ = 0;
  clear_has_goldrand();
}
inline ::google::protobuf::int32 boxboxdata::goldrand() const {
  return goldrand_;
}
inline void boxboxdata::set_goldrand(::google::protobuf::int32 value) {
  set_has_goldrand();
  goldrand_ = value;
}

// optional int32 bindjewelminNum = 6;
inline bool boxboxdata::has_bindjewelminnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void boxboxdata::set_has_bindjewelminnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void boxboxdata::clear_has_bindjewelminnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void boxboxdata::clear_bindjewelminnum() {
  bindjewelminnum_ = 0;
  clear_has_bindjewelminnum();
}
inline ::google::protobuf::int32 boxboxdata::bindjewelminnum() const {
  return bindjewelminnum_;
}
inline void boxboxdata::set_bindjewelminnum(::google::protobuf::int32 value) {
  set_has_bindjewelminnum();
  bindjewelminnum_ = value;
}

// optional int32 bindjewelmaxNum = 7;
inline bool boxboxdata::has_bindjewelmaxnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void boxboxdata::set_has_bindjewelmaxnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void boxboxdata::clear_has_bindjewelmaxnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void boxboxdata::clear_bindjewelmaxnum() {
  bindjewelmaxnum_ = 0;
  clear_has_bindjewelmaxnum();
}
inline ::google::protobuf::int32 boxboxdata::bindjewelmaxnum() const {
  return bindjewelmaxnum_;
}
inline void boxboxdata::set_bindjewelmaxnum(::google::protobuf::int32 value) {
  set_has_bindjewelmaxnum();
  bindjewelmaxnum_ = value;
}

// optional int32 bindjewelrand = 8;
inline bool boxboxdata::has_bindjewelrand() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void boxboxdata::set_has_bindjewelrand() {
  _has_bits_[0] |= 0x00000080u;
}
inline void boxboxdata::clear_has_bindjewelrand() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void boxboxdata::clear_bindjewelrand() {
  bindjewelrand_ = 0;
  clear_has_bindjewelrand();
}
inline ::google::protobuf::int32 boxboxdata::bindjewelrand() const {
  return bindjewelrand_;
}
inline void boxboxdata::set_bindjewelrand(::google::protobuf::int32 value) {
  set_has_bindjewelrand();
  bindjewelrand_ = value;
}

// optional int32 jewelminNum = 9;
inline bool boxboxdata::has_jewelminnum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void boxboxdata::set_has_jewelminnum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void boxboxdata::clear_has_jewelminnum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void boxboxdata::clear_jewelminnum() {
  jewelminnum_ = 0;
  clear_has_jewelminnum();
}
inline ::google::protobuf::int32 boxboxdata::jewelminnum() const {
  return jewelminnum_;
}
inline void boxboxdata::set_jewelminnum(::google::protobuf::int32 value) {
  set_has_jewelminnum();
  jewelminnum_ = value;
}

// optional int32 jewelmaxNum = 10;
inline bool boxboxdata::has_jewelmaxnum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void boxboxdata::set_has_jewelmaxnum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void boxboxdata::clear_has_jewelmaxnum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void boxboxdata::clear_jewelmaxnum() {
  jewelmaxnum_ = 0;
  clear_has_jewelmaxnum();
}
inline ::google::protobuf::int32 boxboxdata::jewelmaxnum() const {
  return jewelmaxnum_;
}
inline void boxboxdata::set_jewelmaxnum(::google::protobuf::int32 value) {
  set_has_jewelmaxnum();
  jewelmaxnum_ = value;
}

// optional int32 jewelrand = 11;
inline bool boxboxdata::has_jewelrand() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void boxboxdata::set_has_jewelrand() {
  _has_bits_[0] |= 0x00000400u;
}
inline void boxboxdata::clear_has_jewelrand() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void boxboxdata::clear_jewelrand() {
  jewelrand_ = 0;
  clear_has_jewelrand();
}
inline ::google::protobuf::int32 boxboxdata::jewelrand() const {
  return jewelrand_;
}
inline void boxboxdata::set_jewelrand(::google::protobuf::int32 value) {
  set_has_jewelrand();
  jewelrand_ = value;
}

// optional string eq_profession = 12;
inline bool boxboxdata::has_eq_profession() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void boxboxdata::set_has_eq_profession() {
  _has_bits_[0] |= 0x00000800u;
}
inline void boxboxdata::clear_has_eq_profession() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void boxboxdata::clear_eq_profession() {
  if (eq_profession_ != &::google::protobuf::internal::kEmptyString) {
    eq_profession_->clear();
  }
  clear_has_eq_profession();
}
inline const ::std::string& boxboxdata::eq_profession() const {
  return *eq_profession_;
}
inline void boxboxdata::set_eq_profession(const ::std::string& value) {
  set_has_eq_profession();
  if (eq_profession_ == &::google::protobuf::internal::kEmptyString) {
    eq_profession_ = new ::std::string;
  }
  eq_profession_->assign(value);
}
inline void boxboxdata::set_eq_profession(const char* value) {
  set_has_eq_profession();
  if (eq_profession_ == &::google::protobuf::internal::kEmptyString) {
    eq_profession_ = new ::std::string;
  }
  eq_profession_->assign(value);
}
inline void boxboxdata::set_eq_profession(const char* value, size_t size) {
  set_has_eq_profession();
  if (eq_profession_ == &::google::protobuf::internal::kEmptyString) {
    eq_profession_ = new ::std::string;
  }
  eq_profession_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* boxboxdata::mutable_eq_profession() {
  set_has_eq_profession();
  if (eq_profession_ == &::google::protobuf::internal::kEmptyString) {
    eq_profession_ = new ::std::string;
  }
  return eq_profession_;
}
inline ::std::string* boxboxdata::release_eq_profession() {
  clear_has_eq_profession();
  if (eq_profession_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eq_profession_;
    eq_profession_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void boxboxdata::set_allocated_eq_profession(::std::string* eq_profession) {
  if (eq_profession_ != &::google::protobuf::internal::kEmptyString) {
    delete eq_profession_;
  }
  if (eq_profession) {
    set_has_eq_profession();
    eq_profession_ = eq_profession;
  } else {
    clear_has_eq_profession();
    eq_profession_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto_ff.boxboxdataequipDesc equip = 13;
inline int boxboxdata::equip_size() const {
  return equip_.size();
}
inline void boxboxdata::clear_equip() {
  equip_.Clear();
}
inline const ::proto_ff::boxboxdataequipDesc& boxboxdata::equip(int index) const {
  return equip_.Get(index);
}
inline ::proto_ff::boxboxdataequipDesc* boxboxdata::mutable_equip(int index) {
  return equip_.Mutable(index);
}
inline ::proto_ff::boxboxdataequipDesc* boxboxdata::add_equip() {
  return equip_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdataequipDesc >&
boxboxdata::equip() const {
  return equip_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdataequipDesc >*
boxboxdata::mutable_equip() {
  return &equip_;
}

// repeated .proto_ff.boxboxdataitemDesc item = 14;
inline int boxboxdata::item_size() const {
  return item_.size();
}
inline void boxboxdata::clear_item() {
  item_.Clear();
}
inline const ::proto_ff::boxboxdataitemDesc& boxboxdata::item(int index) const {
  return item_.Get(index);
}
inline ::proto_ff::boxboxdataitemDesc* boxboxdata::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::proto_ff::boxboxdataitemDesc* boxboxdata::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdataitemDesc >&
boxboxdata::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdataitemDesc >*
boxboxdata::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// Sheet_boxboxdata

// repeated .proto_ff.boxboxdata boxboxdata_List = 1;
inline int Sheet_boxboxdata::boxboxdata_list_size() const {
  return boxboxdata_list_.size();
}
inline void Sheet_boxboxdata::clear_boxboxdata_list() {
  boxboxdata_list_.Clear();
}
inline const ::proto_ff::boxboxdata& Sheet_boxboxdata::boxboxdata_list(int index) const {
  return boxboxdata_list_.Get(index);
}
inline ::proto_ff::boxboxdata* Sheet_boxboxdata::mutable_boxboxdata_list(int index) {
  return boxboxdata_list_.Mutable(index);
}
inline ::proto_ff::boxboxdata* Sheet_boxboxdata::add_boxboxdata_list() {
  return boxboxdata_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdata >&
Sheet_boxboxdata::boxboxdata_list() const {
  return boxboxdata_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::boxboxdata >*
Sheet_boxboxdata::mutable_boxboxdata_list() {
  return &boxboxdata_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_box_2eproto__INCLUDED
