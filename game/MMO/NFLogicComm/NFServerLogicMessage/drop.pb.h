// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: drop.proto

#ifndef PROTOBUF_drop_2eproto__INCLUDED
#define PROTOBUF_drop_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "yd_fieldoptions.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_drop_2eproto();
void protobuf_AssignDesc_drop_2eproto();
void protobuf_ShutdownFile_drop_2eproto();

class dropdropitemDesc;
class dropdropitemTeamDesc;
class dropdropequipDesc;
class dropdrop;
class Sheet_dropdrop;

// ===================================================================

class dropdropitemDesc : public ::google::protobuf::Message {
 public:
  dropdropitemDesc();
  virtual ~dropdropitemDesc();

  dropdropitemDesc(const dropdropitemDesc& from);

  inline dropdropitemDesc& operator=(const dropdropitemDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dropdropitemDesc& default_instance();

  void Swap(dropdropitemDesc* other);

  // implements Message ----------------------------------------------

  dropdropitemDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dropdropitemDesc& from);
  void MergeFrom(const dropdropitemDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bd = 1;
  inline bool has_bd() const;
  inline void clear_bd();
  static const int kBdFieldNumber = 1;
  inline const ::std::string& bd() const;
  inline void set_bd(const ::std::string& value);
  inline void set_bd(const char* value);
  inline void set_bd(const char* value, size_t size);
  inline ::std::string* mutable_bd();
  inline ::std::string* release_bd();
  inline void set_allocated_bd(::std::string* bd);

  // optional int32 rand = 2;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 2;
  inline ::google::protobuf::int32 rand() const;
  inline void set_rand(::google::protobuf::int32 value);

  // optional int32 maxNum = 3;
  inline bool has_maxnum() const;
  inline void clear_maxnum();
  static const int kMaxNumFieldNumber = 3;
  inline ::google::protobuf::int32 maxnum() const;
  inline void set_maxnum(::google::protobuf::int32 value);

  // optional string QZ = 4;
  inline bool has_qz() const;
  inline void clear_qz();
  static const int kQZFieldNumber = 4;
  inline const ::std::string& qz() const;
  inline void set_qz(const ::std::string& value);
  inline void set_qz(const char* value);
  inline void set_qz(const char* value, size_t size);
  inline ::std::string* mutable_qz();
  inline ::std::string* release_qz();
  inline void set_allocated_qz(::std::string* qz);

  // optional int32 minNum = 5;
  inline bool has_minnum() const;
  inline void clear_minnum();
  static const int kMinNumFieldNumber = 5;
  inline ::google::protobuf::int32 minnum() const;
  inline void set_minnum(::google::protobuf::int32 value);

  // optional string id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:proto_ff.dropdropitemDesc)
 private:
  inline void set_has_bd();
  inline void clear_has_bd();
  inline void set_has_rand();
  inline void clear_has_rand();
  inline void set_has_maxnum();
  inline void clear_has_maxnum();
  inline void set_has_qz();
  inline void clear_has_qz();
  inline void set_has_minnum();
  inline void clear_has_minnum();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bd_;
  ::google::protobuf::int32 rand_;
  ::google::protobuf::int32 maxnum_;
  ::std::string* qz_;
  ::std::string* id_;
  ::google::protobuf::int32 minnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_drop_2eproto();
  friend void protobuf_AssignDesc_drop_2eproto();
  friend void protobuf_ShutdownFile_drop_2eproto();

  void InitAsDefaultInstance();
  static dropdropitemDesc* default_instance_;
};
// -------------------------------------------------------------------

class dropdropitemTeamDesc : public ::google::protobuf::Message {
 public:
  dropdropitemTeamDesc();
  virtual ~dropdropitemTeamDesc();

  dropdropitemTeamDesc(const dropdropitemTeamDesc& from);

  inline dropdropitemTeamDesc& operator=(const dropdropitemTeamDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dropdropitemTeamDesc& default_instance();

  void Swap(dropdropitemTeamDesc* other);

  // implements Message ----------------------------------------------

  dropdropitemTeamDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dropdropitemTeamDesc& from);
  void MergeFrom(const dropdropitemTeamDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bd = 1;
  inline bool has_bd() const;
  inline void clear_bd();
  static const int kBdFieldNumber = 1;
  inline const ::std::string& bd() const;
  inline void set_bd(const ::std::string& value);
  inline void set_bd(const char* value);
  inline void set_bd(const char* value, size_t size);
  inline ::std::string* mutable_bd();
  inline ::std::string* release_bd();
  inline void set_allocated_bd(::std::string* bd);

  // optional int32 rand = 2;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 2;
  inline ::google::protobuf::int32 rand() const;
  inline void set_rand(::google::protobuf::int32 value);

  // optional int32 maxNum = 3;
  inline bool has_maxnum() const;
  inline void clear_maxnum();
  static const int kMaxNumFieldNumber = 3;
  inline ::google::protobuf::int32 maxnum() const;
  inline void set_maxnum(::google::protobuf::int32 value);

  // optional string QZ = 4;
  inline bool has_qz() const;
  inline void clear_qz();
  static const int kQZFieldNumber = 4;
  inline const ::std::string& qz() const;
  inline void set_qz(const ::std::string& value);
  inline void set_qz(const char* value);
  inline void set_qz(const char* value, size_t size);
  inline ::std::string* mutable_qz();
  inline ::std::string* release_qz();
  inline void set_allocated_qz(::std::string* qz);

  // optional int32 minNum = 5;
  inline bool has_minnum() const;
  inline void clear_minnum();
  static const int kMinNumFieldNumber = 5;
  inline ::google::protobuf::int32 minnum() const;
  inline void set_minnum(::google::protobuf::int32 value);

  // optional string id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:proto_ff.dropdropitemTeamDesc)
 private:
  inline void set_has_bd();
  inline void clear_has_bd();
  inline void set_has_rand();
  inline void clear_has_rand();
  inline void set_has_maxnum();
  inline void clear_has_maxnum();
  inline void set_has_qz();
  inline void clear_has_qz();
  inline void set_has_minnum();
  inline void clear_has_minnum();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bd_;
  ::google::protobuf::int32 rand_;
  ::google::protobuf::int32 maxnum_;
  ::std::string* qz_;
  ::std::string* id_;
  ::google::protobuf::int32 minnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_drop_2eproto();
  friend void protobuf_AssignDesc_drop_2eproto();
  friend void protobuf_ShutdownFile_drop_2eproto();

  void InitAsDefaultInstance();
  static dropdropitemTeamDesc* default_instance_;
};
// -------------------------------------------------------------------

class dropdropequipDesc : public ::google::protobuf::Message {
 public:
  dropdropequipDesc();
  virtual ~dropdropequipDesc();

  dropdropequipDesc(const dropdropequipDesc& from);

  inline dropdropequipDesc& operator=(const dropdropequipDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dropdropequipDesc& default_instance();

  void Swap(dropdropequipDesc* other);

  // implements Message ----------------------------------------------

  dropdropequipDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dropdropequipDesc& from);
  void MergeFrom(const dropdropequipDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 rand = 1;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 1;
  inline ::google::protobuf::int32 rand() const;
  inline void set_rand(::google::protobuf::int32 value);

  // optional int32 maxNum = 2;
  inline bool has_maxnum() const;
  inline void clear_maxnum();
  static const int kMaxNumFieldNumber = 2;
  inline ::google::protobuf::int32 maxnum() const;
  inline void set_maxnum(::google::protobuf::int32 value);

  // optional string weight = 3;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 3;
  inline const ::std::string& weight() const;
  inline void set_weight(const ::std::string& value);
  inline void set_weight(const char* value);
  inline void set_weight(const char* value, size_t size);
  inline ::std::string* mutable_weight();
  inline ::std::string* release_weight();
  inline void set_allocated_weight(::std::string* weight);

  // optional int32 minNum = 4;
  inline bool has_minnum() const;
  inline void clear_minnum();
  static const int kMinNumFieldNumber = 4;
  inline ::google::protobuf::int32 minnum() const;
  inline void set_minnum(::google::protobuf::int32 value);

  // optional string isbind = 5;
  inline bool has_isbind() const;
  inline void clear_isbind();
  static const int kIsbindFieldNumber = 5;
  inline const ::std::string& isbind() const;
  inline void set_isbind(const ::std::string& value);
  inline void set_isbind(const char* value);
  inline void set_isbind(const char* value, size_t size);
  inline ::std::string* mutable_isbind();
  inline ::std::string* release_isbind();
  inline void set_allocated_isbind(::std::string* isbind);

  // optional string prof = 6;
  inline bool has_prof() const;
  inline void clear_prof();
  static const int kProfFieldNumber = 6;
  inline const ::std::string& prof() const;
  inline void set_prof(const ::std::string& value);
  inline void set_prof(const char* value);
  inline void set_prof(const char* value, size_t size);
  inline ::std::string* mutable_prof();
  inline ::std::string* release_prof();
  inline void set_allocated_prof(::std::string* prof);

  // optional string id = 7;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 7;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:proto_ff.dropdropequipDesc)
 private:
  inline void set_has_rand();
  inline void clear_has_rand();
  inline void set_has_maxnum();
  inline void clear_has_maxnum();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_minnum();
  inline void clear_has_minnum();
  inline void set_has_isbind();
  inline void clear_has_isbind();
  inline void set_has_prof();
  inline void clear_has_prof();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 rand_;
  ::google::protobuf::int32 maxnum_;
  ::std::string* weight_;
  ::std::string* isbind_;
  ::std::string* prof_;
  ::std::string* id_;
  ::google::protobuf::int32 minnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_drop_2eproto();
  friend void protobuf_AssignDesc_drop_2eproto();
  friend void protobuf_ShutdownFile_drop_2eproto();

  void InitAsDefaultInstance();
  static dropdropequipDesc* default_instance_;
};
// -------------------------------------------------------------------

class dropdrop : public ::google::protobuf::Message {
 public:
  dropdrop();
  virtual ~dropdrop();

  dropdrop(const dropdrop& from);

  inline dropdrop& operator=(const dropdrop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dropdrop& default_instance();

  void Swap(dropdrop* other);

  // implements Message ----------------------------------------------

  dropdrop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dropdrop& from);
  void MergeFrom(const dropdrop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional int32 goldlow = 2;
  inline bool has_goldlow() const;
  inline void clear_goldlow();
  static const int kGoldlowFieldNumber = 2;
  inline ::google::protobuf::int32 goldlow() const;
  inline void set_goldlow(::google::protobuf::int32 value);

  // optional int32 goldup = 3;
  inline bool has_goldup() const;
  inline void clear_goldup();
  static const int kGoldupFieldNumber = 3;
  inline ::google::protobuf::int32 goldup() const;
  inline void set_goldup(::google::protobuf::int32 value);

  // optional int32 gold_heapMin = 4;
  inline bool has_gold_heapmin() const;
  inline void clear_gold_heapmin();
  static const int kGoldHeapMinFieldNumber = 4;
  inline ::google::protobuf::int32 gold_heapmin() const;
  inline void set_gold_heapmin(::google::protobuf::int32 value);

  // optional int32 gold_heapMax = 5;
  inline bool has_gold_heapmax() const;
  inline void clear_gold_heapmax();
  static const int kGoldHeapMaxFieldNumber = 5;
  inline ::google::protobuf::int32 gold_heapmax() const;
  inline void set_gold_heapmax(::google::protobuf::int32 value);

  // optional int32 gold_rand = 6;
  inline bool has_gold_rand() const;
  inline void clear_gold_rand();
  static const int kGoldRandFieldNumber = 6;
  inline ::google::protobuf::int32 gold_rand() const;
  inline void set_gold_rand(::google::protobuf::int32 value);

  // repeated .proto_ff.dropdropitemDesc item = 7;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 7;
  inline const ::proto_ff::dropdropitemDesc& item(int index) const;
  inline ::proto_ff::dropdropitemDesc* mutable_item(int index);
  inline ::proto_ff::dropdropitemDesc* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropitemDesc >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropitemDesc >*
      mutable_item();

  // repeated .proto_ff.dropdropitemTeamDesc itemTeam = 8;
  inline int itemteam_size() const;
  inline void clear_itemteam();
  static const int kItemTeamFieldNumber = 8;
  inline const ::proto_ff::dropdropitemTeamDesc& itemteam(int index) const;
  inline ::proto_ff::dropdropitemTeamDesc* mutable_itemteam(int index);
  inline ::proto_ff::dropdropitemTeamDesc* add_itemteam();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropitemTeamDesc >&
      itemteam() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropitemTeamDesc >*
      mutable_itemteam();

  // repeated .proto_ff.dropdropequipDesc equip = 9;
  inline int equip_size() const;
  inline void clear_equip();
  static const int kEquipFieldNumber = 9;
  inline const ::proto_ff::dropdropequipDesc& equip(int index) const;
  inline ::proto_ff::dropdropequipDesc* mutable_equip(int index);
  inline ::proto_ff::dropdropequipDesc* add_equip();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropequipDesc >&
      equip() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropequipDesc >*
      mutable_equip();

  // @@protoc_insertion_point(class_scope:proto_ff.dropdrop)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_goldlow();
  inline void clear_has_goldlow();
  inline void set_has_goldup();
  inline void clear_has_goldup();
  inline void set_has_gold_heapmin();
  inline void clear_has_gold_heapmin();
  inline void set_has_gold_heapmax();
  inline void clear_has_gold_heapmax();
  inline void set_has_gold_rand();
  inline void clear_has_gold_rand();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 goldlow_;
  ::google::protobuf::int32 goldup_;
  ::google::protobuf::int32 gold_heapmin_;
  ::google::protobuf::int32 gold_heapmax_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropitemDesc > item_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropitemTeamDesc > itemteam_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropequipDesc > equip_;
  ::google::protobuf::int32 gold_rand_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_drop_2eproto();
  friend void protobuf_AssignDesc_drop_2eproto();
  friend void protobuf_ShutdownFile_drop_2eproto();

  void InitAsDefaultInstance();
  static dropdrop* default_instance_;
};
// -------------------------------------------------------------------

class Sheet_dropdrop : public ::google::protobuf::Message {
 public:
  Sheet_dropdrop();
  virtual ~Sheet_dropdrop();

  Sheet_dropdrop(const Sheet_dropdrop& from);

  inline Sheet_dropdrop& operator=(const Sheet_dropdrop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sheet_dropdrop& default_instance();

  void Swap(Sheet_dropdrop* other);

  // implements Message ----------------------------------------------

  Sheet_dropdrop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sheet_dropdrop& from);
  void MergeFrom(const Sheet_dropdrop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto_ff.dropdrop dropdrop_List = 1;
  inline int dropdrop_list_size() const;
  inline void clear_dropdrop_list();
  static const int kDropdropListFieldNumber = 1;
  inline const ::proto_ff::dropdrop& dropdrop_list(int index) const;
  inline ::proto_ff::dropdrop* mutable_dropdrop_list(int index);
  inline ::proto_ff::dropdrop* add_dropdrop_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdrop >&
      dropdrop_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdrop >*
      mutable_dropdrop_list();

  // @@protoc_insertion_point(class_scope:proto_ff.Sheet_dropdrop)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdrop > dropdrop_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_drop_2eproto();
  friend void protobuf_AssignDesc_drop_2eproto();
  friend void protobuf_ShutdownFile_drop_2eproto();

  void InitAsDefaultInstance();
  static Sheet_dropdrop* default_instance_;
};
// ===================================================================


// ===================================================================

// dropdropitemDesc

// optional string bd = 1;
inline bool dropdropitemDesc::has_bd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dropdropitemDesc::set_has_bd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dropdropitemDesc::clear_has_bd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dropdropitemDesc::clear_bd() {
  if (bd_ != &::google::protobuf::internal::kEmptyString) {
    bd_->clear();
  }
  clear_has_bd();
}
inline const ::std::string& dropdropitemDesc::bd() const {
  return *bd_;
}
inline void dropdropitemDesc::set_bd(const ::std::string& value) {
  set_has_bd();
  if (bd_ == &::google::protobuf::internal::kEmptyString) {
    bd_ = new ::std::string;
  }
  bd_->assign(value);
}
inline void dropdropitemDesc::set_bd(const char* value) {
  set_has_bd();
  if (bd_ == &::google::protobuf::internal::kEmptyString) {
    bd_ = new ::std::string;
  }
  bd_->assign(value);
}
inline void dropdropitemDesc::set_bd(const char* value, size_t size) {
  set_has_bd();
  if (bd_ == &::google::protobuf::internal::kEmptyString) {
    bd_ = new ::std::string;
  }
  bd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dropdropitemDesc::mutable_bd() {
  set_has_bd();
  if (bd_ == &::google::protobuf::internal::kEmptyString) {
    bd_ = new ::std::string;
  }
  return bd_;
}
inline ::std::string* dropdropitemDesc::release_bd() {
  clear_has_bd();
  if (bd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bd_;
    bd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dropdropitemDesc::set_allocated_bd(::std::string* bd) {
  if (bd_ != &::google::protobuf::internal::kEmptyString) {
    delete bd_;
  }
  if (bd) {
    set_has_bd();
    bd_ = bd;
  } else {
    clear_has_bd();
    bd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 rand = 2;
inline bool dropdropitemDesc::has_rand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dropdropitemDesc::set_has_rand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dropdropitemDesc::clear_has_rand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dropdropitemDesc::clear_rand() {
  rand_ = 0;
  clear_has_rand();
}
inline ::google::protobuf::int32 dropdropitemDesc::rand() const {
  return rand_;
}
inline void dropdropitemDesc::set_rand(::google::protobuf::int32 value) {
  set_has_rand();
  rand_ = value;
}

// optional int32 maxNum = 3;
inline bool dropdropitemDesc::has_maxnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dropdropitemDesc::set_has_maxnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dropdropitemDesc::clear_has_maxnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dropdropitemDesc::clear_maxnum() {
  maxnum_ = 0;
  clear_has_maxnum();
}
inline ::google::protobuf::int32 dropdropitemDesc::maxnum() const {
  return maxnum_;
}
inline void dropdropitemDesc::set_maxnum(::google::protobuf::int32 value) {
  set_has_maxnum();
  maxnum_ = value;
}

// optional string QZ = 4;
inline bool dropdropitemDesc::has_qz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dropdropitemDesc::set_has_qz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dropdropitemDesc::clear_has_qz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dropdropitemDesc::clear_qz() {
  if (qz_ != &::google::protobuf::internal::kEmptyString) {
    qz_->clear();
  }
  clear_has_qz();
}
inline const ::std::string& dropdropitemDesc::qz() const {
  return *qz_;
}
inline void dropdropitemDesc::set_qz(const ::std::string& value) {
  set_has_qz();
  if (qz_ == &::google::protobuf::internal::kEmptyString) {
    qz_ = new ::std::string;
  }
  qz_->assign(value);
}
inline void dropdropitemDesc::set_qz(const char* value) {
  set_has_qz();
  if (qz_ == &::google::protobuf::internal::kEmptyString) {
    qz_ = new ::std::string;
  }
  qz_->assign(value);
}
inline void dropdropitemDesc::set_qz(const char* value, size_t size) {
  set_has_qz();
  if (qz_ == &::google::protobuf::internal::kEmptyString) {
    qz_ = new ::std::string;
  }
  qz_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dropdropitemDesc::mutable_qz() {
  set_has_qz();
  if (qz_ == &::google::protobuf::internal::kEmptyString) {
    qz_ = new ::std::string;
  }
  return qz_;
}
inline ::std::string* dropdropitemDesc::release_qz() {
  clear_has_qz();
  if (qz_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qz_;
    qz_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dropdropitemDesc::set_allocated_qz(::std::string* qz) {
  if (qz_ != &::google::protobuf::internal::kEmptyString) {
    delete qz_;
  }
  if (qz) {
    set_has_qz();
    qz_ = qz;
  } else {
    clear_has_qz();
    qz_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 minNum = 5;
inline bool dropdropitemDesc::has_minnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dropdropitemDesc::set_has_minnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dropdropitemDesc::clear_has_minnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dropdropitemDesc::clear_minnum() {
  minnum_ = 0;
  clear_has_minnum();
}
inline ::google::protobuf::int32 dropdropitemDesc::minnum() const {
  return minnum_;
}
inline void dropdropitemDesc::set_minnum(::google::protobuf::int32 value) {
  set_has_minnum();
  minnum_ = value;
}

// optional string id = 6;
inline bool dropdropitemDesc::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dropdropitemDesc::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dropdropitemDesc::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dropdropitemDesc::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& dropdropitemDesc::id() const {
  return *id_;
}
inline void dropdropitemDesc::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void dropdropitemDesc::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void dropdropitemDesc::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dropdropitemDesc::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* dropdropitemDesc::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dropdropitemDesc::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// dropdropitemTeamDesc

// optional string bd = 1;
inline bool dropdropitemTeamDesc::has_bd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dropdropitemTeamDesc::set_has_bd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dropdropitemTeamDesc::clear_has_bd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dropdropitemTeamDesc::clear_bd() {
  if (bd_ != &::google::protobuf::internal::kEmptyString) {
    bd_->clear();
  }
  clear_has_bd();
}
inline const ::std::string& dropdropitemTeamDesc::bd() const {
  return *bd_;
}
inline void dropdropitemTeamDesc::set_bd(const ::std::string& value) {
  set_has_bd();
  if (bd_ == &::google::protobuf::internal::kEmptyString) {
    bd_ = new ::std::string;
  }
  bd_->assign(value);
}
inline void dropdropitemTeamDesc::set_bd(const char* value) {
  set_has_bd();
  if (bd_ == &::google::protobuf::internal::kEmptyString) {
    bd_ = new ::std::string;
  }
  bd_->assign(value);
}
inline void dropdropitemTeamDesc::set_bd(const char* value, size_t size) {
  set_has_bd();
  if (bd_ == &::google::protobuf::internal::kEmptyString) {
    bd_ = new ::std::string;
  }
  bd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dropdropitemTeamDesc::mutable_bd() {
  set_has_bd();
  if (bd_ == &::google::protobuf::internal::kEmptyString) {
    bd_ = new ::std::string;
  }
  return bd_;
}
inline ::std::string* dropdropitemTeamDesc::release_bd() {
  clear_has_bd();
  if (bd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bd_;
    bd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dropdropitemTeamDesc::set_allocated_bd(::std::string* bd) {
  if (bd_ != &::google::protobuf::internal::kEmptyString) {
    delete bd_;
  }
  if (bd) {
    set_has_bd();
    bd_ = bd;
  } else {
    clear_has_bd();
    bd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 rand = 2;
inline bool dropdropitemTeamDesc::has_rand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dropdropitemTeamDesc::set_has_rand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dropdropitemTeamDesc::clear_has_rand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dropdropitemTeamDesc::clear_rand() {
  rand_ = 0;
  clear_has_rand();
}
inline ::google::protobuf::int32 dropdropitemTeamDesc::rand() const {
  return rand_;
}
inline void dropdropitemTeamDesc::set_rand(::google::protobuf::int32 value) {
  set_has_rand();
  rand_ = value;
}

// optional int32 maxNum = 3;
inline bool dropdropitemTeamDesc::has_maxnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dropdropitemTeamDesc::set_has_maxnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dropdropitemTeamDesc::clear_has_maxnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dropdropitemTeamDesc::clear_maxnum() {
  maxnum_ = 0;
  clear_has_maxnum();
}
inline ::google::protobuf::int32 dropdropitemTeamDesc::maxnum() const {
  return maxnum_;
}
inline void dropdropitemTeamDesc::set_maxnum(::google::protobuf::int32 value) {
  set_has_maxnum();
  maxnum_ = value;
}

// optional string QZ = 4;
inline bool dropdropitemTeamDesc::has_qz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dropdropitemTeamDesc::set_has_qz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dropdropitemTeamDesc::clear_has_qz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dropdropitemTeamDesc::clear_qz() {
  if (qz_ != &::google::protobuf::internal::kEmptyString) {
    qz_->clear();
  }
  clear_has_qz();
}
inline const ::std::string& dropdropitemTeamDesc::qz() const {
  return *qz_;
}
inline void dropdropitemTeamDesc::set_qz(const ::std::string& value) {
  set_has_qz();
  if (qz_ == &::google::protobuf::internal::kEmptyString) {
    qz_ = new ::std::string;
  }
  qz_->assign(value);
}
inline void dropdropitemTeamDesc::set_qz(const char* value) {
  set_has_qz();
  if (qz_ == &::google::protobuf::internal::kEmptyString) {
    qz_ = new ::std::string;
  }
  qz_->assign(value);
}
inline void dropdropitemTeamDesc::set_qz(const char* value, size_t size) {
  set_has_qz();
  if (qz_ == &::google::protobuf::internal::kEmptyString) {
    qz_ = new ::std::string;
  }
  qz_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dropdropitemTeamDesc::mutable_qz() {
  set_has_qz();
  if (qz_ == &::google::protobuf::internal::kEmptyString) {
    qz_ = new ::std::string;
  }
  return qz_;
}
inline ::std::string* dropdropitemTeamDesc::release_qz() {
  clear_has_qz();
  if (qz_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qz_;
    qz_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dropdropitemTeamDesc::set_allocated_qz(::std::string* qz) {
  if (qz_ != &::google::protobuf::internal::kEmptyString) {
    delete qz_;
  }
  if (qz) {
    set_has_qz();
    qz_ = qz;
  } else {
    clear_has_qz();
    qz_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 minNum = 5;
inline bool dropdropitemTeamDesc::has_minnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dropdropitemTeamDesc::set_has_minnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dropdropitemTeamDesc::clear_has_minnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dropdropitemTeamDesc::clear_minnum() {
  minnum_ = 0;
  clear_has_minnum();
}
inline ::google::protobuf::int32 dropdropitemTeamDesc::minnum() const {
  return minnum_;
}
inline void dropdropitemTeamDesc::set_minnum(::google::protobuf::int32 value) {
  set_has_minnum();
  minnum_ = value;
}

// optional string id = 6;
inline bool dropdropitemTeamDesc::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dropdropitemTeamDesc::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dropdropitemTeamDesc::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dropdropitemTeamDesc::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& dropdropitemTeamDesc::id() const {
  return *id_;
}
inline void dropdropitemTeamDesc::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void dropdropitemTeamDesc::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void dropdropitemTeamDesc::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dropdropitemTeamDesc::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* dropdropitemTeamDesc::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dropdropitemTeamDesc::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// dropdropequipDesc

// optional int32 rand = 1;
inline bool dropdropequipDesc::has_rand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dropdropequipDesc::set_has_rand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dropdropequipDesc::clear_has_rand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dropdropequipDesc::clear_rand() {
  rand_ = 0;
  clear_has_rand();
}
inline ::google::protobuf::int32 dropdropequipDesc::rand() const {
  return rand_;
}
inline void dropdropequipDesc::set_rand(::google::protobuf::int32 value) {
  set_has_rand();
  rand_ = value;
}

// optional int32 maxNum = 2;
inline bool dropdropequipDesc::has_maxnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dropdropequipDesc::set_has_maxnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dropdropequipDesc::clear_has_maxnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dropdropequipDesc::clear_maxnum() {
  maxnum_ = 0;
  clear_has_maxnum();
}
inline ::google::protobuf::int32 dropdropequipDesc::maxnum() const {
  return maxnum_;
}
inline void dropdropequipDesc::set_maxnum(::google::protobuf::int32 value) {
  set_has_maxnum();
  maxnum_ = value;
}

// optional string weight = 3;
inline bool dropdropequipDesc::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dropdropequipDesc::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dropdropequipDesc::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dropdropequipDesc::clear_weight() {
  if (weight_ != &::google::protobuf::internal::kEmptyString) {
    weight_->clear();
  }
  clear_has_weight();
}
inline const ::std::string& dropdropequipDesc::weight() const {
  return *weight_;
}
inline void dropdropequipDesc::set_weight(const ::std::string& value) {
  set_has_weight();
  if (weight_ == &::google::protobuf::internal::kEmptyString) {
    weight_ = new ::std::string;
  }
  weight_->assign(value);
}
inline void dropdropequipDesc::set_weight(const char* value) {
  set_has_weight();
  if (weight_ == &::google::protobuf::internal::kEmptyString) {
    weight_ = new ::std::string;
  }
  weight_->assign(value);
}
inline void dropdropequipDesc::set_weight(const char* value, size_t size) {
  set_has_weight();
  if (weight_ == &::google::protobuf::internal::kEmptyString) {
    weight_ = new ::std::string;
  }
  weight_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dropdropequipDesc::mutable_weight() {
  set_has_weight();
  if (weight_ == &::google::protobuf::internal::kEmptyString) {
    weight_ = new ::std::string;
  }
  return weight_;
}
inline ::std::string* dropdropequipDesc::release_weight() {
  clear_has_weight();
  if (weight_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weight_;
    weight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dropdropequipDesc::set_allocated_weight(::std::string* weight) {
  if (weight_ != &::google::protobuf::internal::kEmptyString) {
    delete weight_;
  }
  if (weight) {
    set_has_weight();
    weight_ = weight;
  } else {
    clear_has_weight();
    weight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 minNum = 4;
inline bool dropdropequipDesc::has_minnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dropdropequipDesc::set_has_minnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dropdropequipDesc::clear_has_minnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dropdropequipDesc::clear_minnum() {
  minnum_ = 0;
  clear_has_minnum();
}
inline ::google::protobuf::int32 dropdropequipDesc::minnum() const {
  return minnum_;
}
inline void dropdropequipDesc::set_minnum(::google::protobuf::int32 value) {
  set_has_minnum();
  minnum_ = value;
}

// optional string isbind = 5;
inline bool dropdropequipDesc::has_isbind() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dropdropequipDesc::set_has_isbind() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dropdropequipDesc::clear_has_isbind() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dropdropequipDesc::clear_isbind() {
  if (isbind_ != &::google::protobuf::internal::kEmptyString) {
    isbind_->clear();
  }
  clear_has_isbind();
}
inline const ::std::string& dropdropequipDesc::isbind() const {
  return *isbind_;
}
inline void dropdropequipDesc::set_isbind(const ::std::string& value) {
  set_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    isbind_ = new ::std::string;
  }
  isbind_->assign(value);
}
inline void dropdropequipDesc::set_isbind(const char* value) {
  set_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    isbind_ = new ::std::string;
  }
  isbind_->assign(value);
}
inline void dropdropequipDesc::set_isbind(const char* value, size_t size) {
  set_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    isbind_ = new ::std::string;
  }
  isbind_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dropdropequipDesc::mutable_isbind() {
  set_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    isbind_ = new ::std::string;
  }
  return isbind_;
}
inline ::std::string* dropdropequipDesc::release_isbind() {
  clear_has_isbind();
  if (isbind_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isbind_;
    isbind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dropdropequipDesc::set_allocated_isbind(::std::string* isbind) {
  if (isbind_ != &::google::protobuf::internal::kEmptyString) {
    delete isbind_;
  }
  if (isbind) {
    set_has_isbind();
    isbind_ = isbind;
  } else {
    clear_has_isbind();
    isbind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string prof = 6;
inline bool dropdropequipDesc::has_prof() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dropdropequipDesc::set_has_prof() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dropdropequipDesc::clear_has_prof() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dropdropequipDesc::clear_prof() {
  if (prof_ != &::google::protobuf::internal::kEmptyString) {
    prof_->clear();
  }
  clear_has_prof();
}
inline const ::std::string& dropdropequipDesc::prof() const {
  return *prof_;
}
inline void dropdropequipDesc::set_prof(const ::std::string& value) {
  set_has_prof();
  if (prof_ == &::google::protobuf::internal::kEmptyString) {
    prof_ = new ::std::string;
  }
  prof_->assign(value);
}
inline void dropdropequipDesc::set_prof(const char* value) {
  set_has_prof();
  if (prof_ == &::google::protobuf::internal::kEmptyString) {
    prof_ = new ::std::string;
  }
  prof_->assign(value);
}
inline void dropdropequipDesc::set_prof(const char* value, size_t size) {
  set_has_prof();
  if (prof_ == &::google::protobuf::internal::kEmptyString) {
    prof_ = new ::std::string;
  }
  prof_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dropdropequipDesc::mutable_prof() {
  set_has_prof();
  if (prof_ == &::google::protobuf::internal::kEmptyString) {
    prof_ = new ::std::string;
  }
  return prof_;
}
inline ::std::string* dropdropequipDesc::release_prof() {
  clear_has_prof();
  if (prof_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prof_;
    prof_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dropdropequipDesc::set_allocated_prof(::std::string* prof) {
  if (prof_ != &::google::protobuf::internal::kEmptyString) {
    delete prof_;
  }
  if (prof) {
    set_has_prof();
    prof_ = prof;
  } else {
    clear_has_prof();
    prof_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id = 7;
inline bool dropdropequipDesc::has_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dropdropequipDesc::set_has_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dropdropequipDesc::clear_has_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dropdropequipDesc::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& dropdropequipDesc::id() const {
  return *id_;
}
inline void dropdropequipDesc::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void dropdropequipDesc::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void dropdropequipDesc::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dropdropequipDesc::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* dropdropequipDesc::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void dropdropequipDesc::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// dropdrop

// optional int64 id = 1;
inline bool dropdrop::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dropdrop::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dropdrop::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dropdrop::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 dropdrop::id() const {
  return id_;
}
inline void dropdrop::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional int32 goldlow = 2;
inline bool dropdrop::has_goldlow() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dropdrop::set_has_goldlow() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dropdrop::clear_has_goldlow() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dropdrop::clear_goldlow() {
  goldlow_ = 0;
  clear_has_goldlow();
}
inline ::google::protobuf::int32 dropdrop::goldlow() const {
  return goldlow_;
}
inline void dropdrop::set_goldlow(::google::protobuf::int32 value) {
  set_has_goldlow();
  goldlow_ = value;
}

// optional int32 goldup = 3;
inline bool dropdrop::has_goldup() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dropdrop::set_has_goldup() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dropdrop::clear_has_goldup() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dropdrop::clear_goldup() {
  goldup_ = 0;
  clear_has_goldup();
}
inline ::google::protobuf::int32 dropdrop::goldup() const {
  return goldup_;
}
inline void dropdrop::set_goldup(::google::protobuf::int32 value) {
  set_has_goldup();
  goldup_ = value;
}

// optional int32 gold_heapMin = 4;
inline bool dropdrop::has_gold_heapmin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dropdrop::set_has_gold_heapmin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dropdrop::clear_has_gold_heapmin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dropdrop::clear_gold_heapmin() {
  gold_heapmin_ = 0;
  clear_has_gold_heapmin();
}
inline ::google::protobuf::int32 dropdrop::gold_heapmin() const {
  return gold_heapmin_;
}
inline void dropdrop::set_gold_heapmin(::google::protobuf::int32 value) {
  set_has_gold_heapmin();
  gold_heapmin_ = value;
}

// optional int32 gold_heapMax = 5;
inline bool dropdrop::has_gold_heapmax() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dropdrop::set_has_gold_heapmax() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dropdrop::clear_has_gold_heapmax() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dropdrop::clear_gold_heapmax() {
  gold_heapmax_ = 0;
  clear_has_gold_heapmax();
}
inline ::google::protobuf::int32 dropdrop::gold_heapmax() const {
  return gold_heapmax_;
}
inline void dropdrop::set_gold_heapmax(::google::protobuf::int32 value) {
  set_has_gold_heapmax();
  gold_heapmax_ = value;
}

// optional int32 gold_rand = 6;
inline bool dropdrop::has_gold_rand() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dropdrop::set_has_gold_rand() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dropdrop::clear_has_gold_rand() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dropdrop::clear_gold_rand() {
  gold_rand_ = 0;
  clear_has_gold_rand();
}
inline ::google::protobuf::int32 dropdrop::gold_rand() const {
  return gold_rand_;
}
inline void dropdrop::set_gold_rand(::google::protobuf::int32 value) {
  set_has_gold_rand();
  gold_rand_ = value;
}

// repeated .proto_ff.dropdropitemDesc item = 7;
inline int dropdrop::item_size() const {
  return item_.size();
}
inline void dropdrop::clear_item() {
  item_.Clear();
}
inline const ::proto_ff::dropdropitemDesc& dropdrop::item(int index) const {
  return item_.Get(index);
}
inline ::proto_ff::dropdropitemDesc* dropdrop::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::proto_ff::dropdropitemDesc* dropdrop::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropitemDesc >&
dropdrop::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropitemDesc >*
dropdrop::mutable_item() {
  return &item_;
}

// repeated .proto_ff.dropdropitemTeamDesc itemTeam = 8;
inline int dropdrop::itemteam_size() const {
  return itemteam_.size();
}
inline void dropdrop::clear_itemteam() {
  itemteam_.Clear();
}
inline const ::proto_ff::dropdropitemTeamDesc& dropdrop::itemteam(int index) const {
  return itemteam_.Get(index);
}
inline ::proto_ff::dropdropitemTeamDesc* dropdrop::mutable_itemteam(int index) {
  return itemteam_.Mutable(index);
}
inline ::proto_ff::dropdropitemTeamDesc* dropdrop::add_itemteam() {
  return itemteam_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropitemTeamDesc >&
dropdrop::itemteam() const {
  return itemteam_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropitemTeamDesc >*
dropdrop::mutable_itemteam() {
  return &itemteam_;
}

// repeated .proto_ff.dropdropequipDesc equip = 9;
inline int dropdrop::equip_size() const {
  return equip_.size();
}
inline void dropdrop::clear_equip() {
  equip_.Clear();
}
inline const ::proto_ff::dropdropequipDesc& dropdrop::equip(int index) const {
  return equip_.Get(index);
}
inline ::proto_ff::dropdropequipDesc* dropdrop::mutable_equip(int index) {
  return equip_.Mutable(index);
}
inline ::proto_ff::dropdropequipDesc* dropdrop::add_equip() {
  return equip_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropequipDesc >&
dropdrop::equip() const {
  return equip_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdropequipDesc >*
dropdrop::mutable_equip() {
  return &equip_;
}

// -------------------------------------------------------------------

// Sheet_dropdrop

// repeated .proto_ff.dropdrop dropdrop_List = 1;
inline int Sheet_dropdrop::dropdrop_list_size() const {
  return dropdrop_list_.size();
}
inline void Sheet_dropdrop::clear_dropdrop_list() {
  dropdrop_list_.Clear();
}
inline const ::proto_ff::dropdrop& Sheet_dropdrop::dropdrop_list(int index) const {
  return dropdrop_list_.Get(index);
}
inline ::proto_ff::dropdrop* Sheet_dropdrop::mutable_dropdrop_list(int index) {
  return dropdrop_list_.Mutable(index);
}
inline ::proto_ff::dropdrop* Sheet_dropdrop::add_dropdrop_list() {
  return dropdrop_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdrop >&
Sheet_dropdrop::dropdrop_list() const {
  return dropdrop_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::dropdrop >*
Sheet_dropdrop::mutable_dropdrop_list() {
  return &dropdrop_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_drop_2eproto__INCLUDED
