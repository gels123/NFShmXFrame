// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Pay.proto

#ifndef PROTOBUF_Pay_2eproto__INCLUDED
#define PROTOBUF_Pay_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "Com.pb.h"
#include "ComDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Pay_2eproto();
void protobuf_AssignDesc_Pay_2eproto();
void protobuf_ShutdownFile_Pay_2eproto();

class PayReq;
class PayRsp;
class PayOrderIdReq;
class PayOrderIdRsp;
class PayProductNotify;
class PayProto;
class CL_PayDeliverNotify;
class LC_PayDeliverFailRsp;
class LoadPayDBReq;
class LoadPayDBRsp;
class SavePayDBReq;
class UpdatePayDBReq;

// ===================================================================

class PayReq : public ::google::protobuf::Message {
 public:
  PayReq();
  virtual ~PayReq();

  PayReq(const PayReq& from);

  inline PayReq& operator=(const PayReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayReq& default_instance();

  void Swap(PayReq* other);

  // implements Message ----------------------------------------------

  PayReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayReq& from);
  void MergeFrom(const PayReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 chanId = 1;
  inline bool has_chanid() const;
  inline void clear_chanid();
  static const int kChanIdFieldNumber = 1;
  inline ::google::protobuf::uint32 chanid() const;
  inline void set_chanid(::google::protobuf::uint32 value);

  // required string productId = 2;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 2;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  inline void set_allocated_productid(::std::string* productid);

  // required string payString = 3;
  inline bool has_paystring() const;
  inline void clear_paystring();
  static const int kPayStringFieldNumber = 3;
  inline const ::std::string& paystring() const;
  inline void set_paystring(const ::std::string& value);
  inline void set_paystring(const char* value);
  inline void set_paystring(const char* value, size_t size);
  inline ::std::string* mutable_paystring();
  inline ::std::string* release_paystring();
  inline void set_allocated_paystring(::std::string* paystring);

  // required string myoder = 4;
  inline bool has_myoder() const;
  inline void clear_myoder();
  static const int kMyoderFieldNumber = 4;
  inline const ::std::string& myoder() const;
  inline void set_myoder(const ::std::string& value);
  inline void set_myoder(const char* value);
  inline void set_myoder(const char* value, size_t size);
  inline ::std::string* mutable_myoder();
  inline ::std::string* release_myoder();
  inline void set_allocated_myoder(::std::string* myoder);

  // @@protoc_insertion_point(class_scope:proto_ff.PayReq)
 private:
  inline void set_has_chanid();
  inline void clear_has_chanid();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_paystring();
  inline void clear_has_paystring();
  inline void set_has_myoder();
  inline void clear_has_myoder();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* productid_;
  ::std::string* paystring_;
  ::std::string* myoder_;
  ::google::protobuf::uint32 chanid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Pay_2eproto();
  friend void protobuf_AssignDesc_Pay_2eproto();
  friend void protobuf_ShutdownFile_Pay_2eproto();

  void InitAsDefaultInstance();
  static PayReq* default_instance_;
};
// -------------------------------------------------------------------

class PayRsp : public ::google::protobuf::Message {
 public:
  PayRsp();
  virtual ~PayRsp();

  PayRsp(const PayRsp& from);

  inline PayRsp& operator=(const PayRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayRsp& default_instance();

  void Swap(PayRsp* other);

  // implements Message ----------------------------------------------

  PayRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayRsp& from);
  void MergeFrom(const PayRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string productId = 1;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 1;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  inline void set_allocated_productid(::std::string* productid);

  // required uint32 payRet = 2;
  inline bool has_payret() const;
  inline void clear_payret();
  static const int kPayRetFieldNumber = 2;
  inline ::google::protobuf::uint32 payret() const;
  inline void set_payret(::google::protobuf::uint32 value);

  // optional string payRspString = 3;
  inline bool has_payrspstring() const;
  inline void clear_payrspstring();
  static const int kPayRspStringFieldNumber = 3;
  inline const ::std::string& payrspstring() const;
  inline void set_payrspstring(const ::std::string& value);
  inline void set_payrspstring(const char* value);
  inline void set_payrspstring(const char* value, size_t size);
  inline ::std::string* mutable_payrspstring();
  inline ::std::string* release_payrspstring();
  inline void set_allocated_payrspstring(::std::string* payrspstring);

  // optional string payRetMsg = 4;
  inline bool has_payretmsg() const;
  inline void clear_payretmsg();
  static const int kPayRetMsgFieldNumber = 4;
  inline const ::std::string& payretmsg() const;
  inline void set_payretmsg(const ::std::string& value);
  inline void set_payretmsg(const char* value);
  inline void set_payretmsg(const char* value, size_t size);
  inline ::std::string* mutable_payretmsg();
  inline ::std::string* release_payretmsg();
  inline void set_allocated_payretmsg(::std::string* payretmsg);

  // @@protoc_insertion_point(class_scope:proto_ff.PayRsp)
 private:
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_payret();
  inline void clear_has_payret();
  inline void set_has_payrspstring();
  inline void clear_has_payrspstring();
  inline void set_has_payretmsg();
  inline void clear_has_payretmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* productid_;
  ::std::string* payrspstring_;
  ::std::string* payretmsg_;
  ::google::protobuf::uint32 payret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Pay_2eproto();
  friend void protobuf_AssignDesc_Pay_2eproto();
  friend void protobuf_ShutdownFile_Pay_2eproto();

  void InitAsDefaultInstance();
  static PayRsp* default_instance_;
};
// -------------------------------------------------------------------

class PayOrderIdReq : public ::google::protobuf::Message {
 public:
  PayOrderIdReq();
  virtual ~PayOrderIdReq();

  PayOrderIdReq(const PayOrderIdReq& from);

  inline PayOrderIdReq& operator=(const PayOrderIdReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayOrderIdReq& default_instance();

  void Swap(PayOrderIdReq* other);

  // implements Message ----------------------------------------------

  PayOrderIdReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayOrderIdReq& from);
  void MergeFrom(const PayOrderIdReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 channId = 1;
  inline bool has_channid() const;
  inline void clear_channid();
  static const int kChannIdFieldNumber = 1;
  inline ::google::protobuf::uint32 channid() const;
  inline void set_channid(::google::protobuf::uint32 value);

  // required string productId = 2;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 2;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  inline void set_allocated_productid(::std::string* productid);

  // optional string orderString = 3;
  inline bool has_orderstring() const;
  inline void clear_orderstring();
  static const int kOrderStringFieldNumber = 3;
  inline const ::std::string& orderstring() const;
  inline void set_orderstring(const ::std::string& value);
  inline void set_orderstring(const char* value);
  inline void set_orderstring(const char* value, size_t size);
  inline ::std::string* mutable_orderstring();
  inline ::std::string* release_orderstring();
  inline void set_allocated_orderstring(::std::string* orderstring);

  // repeated string productLst = 4;
  inline int productlst_size() const;
  inline void clear_productlst();
  static const int kProductLstFieldNumber = 4;
  inline const ::std::string& productlst(int index) const;
  inline ::std::string* mutable_productlst(int index);
  inline void set_productlst(int index, const ::std::string& value);
  inline void set_productlst(int index, const char* value);
  inline void set_productlst(int index, const char* value, size_t size);
  inline ::std::string* add_productlst();
  inline void add_productlst(const ::std::string& value);
  inline void add_productlst(const char* value);
  inline void add_productlst(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& productlst() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_productlst();

  // @@protoc_insertion_point(class_scope:proto_ff.PayOrderIdReq)
 private:
  inline void set_has_channid();
  inline void clear_has_channid();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_orderstring();
  inline void clear_has_orderstring();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* productid_;
  ::std::string* orderstring_;
  ::google::protobuf::RepeatedPtrField< ::std::string> productlst_;
  ::google::protobuf::uint32 channid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Pay_2eproto();
  friend void protobuf_AssignDesc_Pay_2eproto();
  friend void protobuf_ShutdownFile_Pay_2eproto();

  void InitAsDefaultInstance();
  static PayOrderIdReq* default_instance_;
};
// -------------------------------------------------------------------

class PayOrderIdRsp : public ::google::protobuf::Message {
 public:
  PayOrderIdRsp();
  virtual ~PayOrderIdRsp();

  PayOrderIdRsp(const PayOrderIdRsp& from);

  inline PayOrderIdRsp& operator=(const PayOrderIdRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayOrderIdRsp& default_instance();

  void Swap(PayOrderIdRsp* other);

  // implements Message ----------------------------------------------

  PayOrderIdRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayOrderIdRsp& from);
  void MergeFrom(const PayOrderIdRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 retCode = 1;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 retcode() const;
  inline void set_retcode(::google::protobuf::uint32 value);

  // optional string order = 2;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 2;
  inline const ::std::string& order() const;
  inline void set_order(const ::std::string& value);
  inline void set_order(const char* value);
  inline void set_order(const char* value, size_t size);
  inline ::std::string* mutable_order();
  inline ::std::string* release_order();
  inline void set_allocated_order(::std::string* order);

  // optional string orderString = 3;
  inline bool has_orderstring() const;
  inline void clear_orderstring();
  static const int kOrderStringFieldNumber = 3;
  inline const ::std::string& orderstring() const;
  inline void set_orderstring(const ::std::string& value);
  inline void set_orderstring(const char* value);
  inline void set_orderstring(const char* value, size_t size);
  inline ::std::string* mutable_orderstring();
  inline ::std::string* release_orderstring();
  inline void set_allocated_orderstring(::std::string* orderstring);

  // optional string cbUrl = 4;
  inline bool has_cburl() const;
  inline void clear_cburl();
  static const int kCbUrlFieldNumber = 4;
  inline const ::std::string& cburl() const;
  inline void set_cburl(const ::std::string& value);
  inline void set_cburl(const char* value);
  inline void set_cburl(const char* value, size_t size);
  inline ::std::string* mutable_cburl();
  inline ::std::string* release_cburl();
  inline void set_allocated_cburl(::std::string* cburl);

  // optional string productId = 5;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 5;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  inline void set_allocated_productid(::std::string* productid);

  // optional string retMsg = 6;
  inline bool has_retmsg() const;
  inline void clear_retmsg();
  static const int kRetMsgFieldNumber = 6;
  inline const ::std::string& retmsg() const;
  inline void set_retmsg(const ::std::string& value);
  inline void set_retmsg(const char* value);
  inline void set_retmsg(const char* value, size_t size);
  inline ::std::string* mutable_retmsg();
  inline ::std::string* release_retmsg();
  inline void set_allocated_retmsg(::std::string* retmsg);

  // repeated string productLst = 7;
  inline int productlst_size() const;
  inline void clear_productlst();
  static const int kProductLstFieldNumber = 7;
  inline const ::std::string& productlst(int index) const;
  inline ::std::string* mutable_productlst(int index);
  inline void set_productlst(int index, const ::std::string& value);
  inline void set_productlst(int index, const char* value);
  inline void set_productlst(int index, const char* value, size_t size);
  inline ::std::string* add_productlst();
  inline void add_productlst(const ::std::string& value);
  inline void add_productlst(const char* value);
  inline void add_productlst(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& productlst() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_productlst();

  // @@protoc_insertion_point(class_scope:proto_ff.PayOrderIdRsp)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_orderstring();
  inline void clear_has_orderstring();
  inline void set_has_cburl();
  inline void clear_has_cburl();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_retmsg();
  inline void clear_has_retmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* order_;
  ::std::string* orderstring_;
  ::std::string* cburl_;
  ::std::string* productid_;
  ::std::string* retmsg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> productlst_;
  ::google::protobuf::uint32 retcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Pay_2eproto();
  friend void protobuf_AssignDesc_Pay_2eproto();
  friend void protobuf_ShutdownFile_Pay_2eproto();

  void InitAsDefaultInstance();
  static PayOrderIdRsp* default_instance_;
};
// -------------------------------------------------------------------

class PayProductNotify : public ::google::protobuf::Message {
 public:
  PayProductNotify();
  virtual ~PayProductNotify();

  PayProductNotify(const PayProductNotify& from);

  inline PayProductNotify& operator=(const PayProductNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayProductNotify& default_instance();

  void Swap(PayProductNotify* other);

  // implements Message ----------------------------------------------

  PayProductNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayProductNotify& from);
  void MergeFrom(const PayProductNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string productId = 1;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 1;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  inline void set_allocated_productid(::std::string* productid);

  // optional int32 isfirst = 2;
  inline bool has_isfirst() const;
  inline void clear_isfirst();
  static const int kIsfirstFieldNumber = 2;
  inline ::google::protobuf::int32 isfirst() const;
  inline void set_isfirst(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.PayProductNotify)
 private:
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_isfirst();
  inline void clear_has_isfirst();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* productid_;
  ::google::protobuf::int32 isfirst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Pay_2eproto();
  friend void protobuf_AssignDesc_Pay_2eproto();
  friend void protobuf_ShutdownFile_Pay_2eproto();

  void InitAsDefaultInstance();
  static PayProductNotify* default_instance_;
};
// -------------------------------------------------------------------

class PayProto : public ::google::protobuf::Message {
 public:
  PayProto();
  virtual ~PayProto();

  PayProto(const PayProto& from);

  inline PayProto& operator=(const PayProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayProto& default_instance();

  void Swap(PayProto* other);

  // implements Message ----------------------------------------------

  PayProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayProto& from);
  void MergeFrom(const PayProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 zid = 1;
  inline bool has_zid() const;
  inline void clear_zid();
  static const int kZidFieldNumber = 1;
  inline ::google::protobuf::uint32 zid() const;
  inline void set_zid(::google::protobuf::uint32 value);

  // required uint32 channId = 2;
  inline bool has_channid() const;
  inline void clear_channid();
  static const int kChannIdFieldNumber = 2;
  inline ::google::protobuf::uint32 channid() const;
  inline void set_channid(::google::protobuf::uint32 value);

  // required uint32 uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // required uint64 cid = 4;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 4;
  inline ::google::protobuf::uint64 cid() const;
  inline void set_cid(::google::protobuf::uint64 value);

  // required string productId = 5;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 5;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  inline void set_allocated_productid(::std::string* productid);

  // required uint32 money = 6;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 6;
  inline ::google::protobuf::uint32 money() const;
  inline void set_money(::google::protobuf::uint32 value);

  // required string order = 7;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 7;
  inline const ::std::string& order() const;
  inline void set_order(const ::std::string& value);
  inline void set_order(const char* value);
  inline void set_order(const char* value, size_t size);
  inline ::std::string* mutable_order();
  inline ::std::string* release_order();
  inline void set_allocated_order(::std::string* order);

  // optional uint32 dbid = 8;
  inline bool has_dbid() const;
  inline void clear_dbid();
  static const int kDbidFieldNumber = 8;
  inline ::google::protobuf::uint32 dbid() const;
  inline void set_dbid(::google::protobuf::uint32 value);

  // required string myOrder = 9;
  inline bool has_myorder() const;
  inline void clear_myorder();
  static const int kMyOrderFieldNumber = 9;
  inline const ::std::string& myorder() const;
  inline void set_myorder(const ::std::string& value);
  inline void set_myorder(const char* value);
  inline void set_myorder(const char* value, size_t size);
  inline ::std::string* mutable_myorder();
  inline ::std::string* release_myorder();
  inline void set_allocated_myorder(::std::string* myorder);

  // required bool fakePay = 10;
  inline bool has_fakepay() const;
  inline void clear_fakepay();
  static const int kFakePayFieldNumber = 10;
  inline bool fakepay() const;
  inline void set_fakepay(bool value);

  // repeated string productLst = 11;
  inline int productlst_size() const;
  inline void clear_productlst();
  static const int kProductLstFieldNumber = 11;
  inline const ::std::string& productlst(int index) const;
  inline ::std::string* mutable_productlst(int index);
  inline void set_productlst(int index, const ::std::string& value);
  inline void set_productlst(int index, const char* value);
  inline void set_productlst(int index, const char* value, size_t size);
  inline ::std::string* add_productlst();
  inline void add_productlst(const ::std::string& value);
  inline void add_productlst(const char* value);
  inline void add_productlst(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& productlst() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_productlst();

  // optional int64 payTime = 12;
  inline bool has_paytime() const;
  inline void clear_paytime();
  static const int kPayTimeFieldNumber = 12;
  inline ::google::protobuf::int64 paytime() const;
  inline void set_paytime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.PayProto)
 private:
  inline void set_has_zid();
  inline void clear_has_zid();
  inline void set_has_channid();
  inline void clear_has_channid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_dbid();
  inline void clear_has_dbid();
  inline void set_has_myorder();
  inline void clear_has_myorder();
  inline void set_has_fakepay();
  inline void clear_has_fakepay();
  inline void set_has_paytime();
  inline void clear_has_paytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 zid_;
  ::google::protobuf::uint32 channid_;
  ::google::protobuf::uint64 cid_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 money_;
  ::std::string* productid_;
  ::std::string* order_;
  ::std::string* myorder_;
  ::google::protobuf::uint32 dbid_;
  bool fakepay_;
  ::google::protobuf::RepeatedPtrField< ::std::string> productlst_;
  ::google::protobuf::int64 paytime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_Pay_2eproto();
  friend void protobuf_AssignDesc_Pay_2eproto();
  friend void protobuf_ShutdownFile_Pay_2eproto();

  void InitAsDefaultInstance();
  static PayProto* default_instance_;
};
// -------------------------------------------------------------------

class CL_PayDeliverNotify : public ::google::protobuf::Message {
 public:
  CL_PayDeliverNotify();
  virtual ~CL_PayDeliverNotify();

  CL_PayDeliverNotify(const CL_PayDeliverNotify& from);

  inline CL_PayDeliverNotify& operator=(const CL_PayDeliverNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CL_PayDeliverNotify& default_instance();

  void Swap(CL_PayDeliverNotify* other);

  // implements Message ----------------------------------------------

  CL_PayDeliverNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CL_PayDeliverNotify& from);
  void MergeFrom(const CL_PayDeliverNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto_ff.PayProto info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::proto_ff::PayProto& info() const;
  inline ::proto_ff::PayProto* mutable_info();
  inline ::proto_ff::PayProto* release_info();
  inline void set_allocated_info(::proto_ff::PayProto* info);

  // required uint32 zid = 2;
  inline bool has_zid() const;
  inline void clear_zid();
  static const int kZidFieldNumber = 2;
  inline ::google::protobuf::uint32 zid() const;
  inline void set_zid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.CL_PayDeliverNotify)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_zid();
  inline void clear_has_zid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto_ff::PayProto* info_;
  ::google::protobuf::uint32 zid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Pay_2eproto();
  friend void protobuf_AssignDesc_Pay_2eproto();
  friend void protobuf_ShutdownFile_Pay_2eproto();

  void InitAsDefaultInstance();
  static CL_PayDeliverNotify* default_instance_;
};
// -------------------------------------------------------------------

class LC_PayDeliverFailRsp : public ::google::protobuf::Message {
 public:
  LC_PayDeliverFailRsp();
  virtual ~LC_PayDeliverFailRsp();

  LC_PayDeliverFailRsp(const LC_PayDeliverFailRsp& from);

  inline LC_PayDeliverFailRsp& operator=(const LC_PayDeliverFailRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LC_PayDeliverFailRsp& default_instance();

  void Swap(LC_PayDeliverFailRsp* other);

  // implements Message ----------------------------------------------

  LC_PayDeliverFailRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LC_PayDeliverFailRsp& from);
  void MergeFrom(const LC_PayDeliverFailRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto_ff.PayProto info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::proto_ff::PayProto& info() const;
  inline ::proto_ff::PayProto* mutable_info();
  inline ::proto_ff::PayProto* release_info();
  inline void set_allocated_info(::proto_ff::PayProto* info);

  // @@protoc_insertion_point(class_scope:proto_ff.LC_PayDeliverFailRsp)
 private:
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto_ff::PayProto* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Pay_2eproto();
  friend void protobuf_AssignDesc_Pay_2eproto();
  friend void protobuf_ShutdownFile_Pay_2eproto();

  void InitAsDefaultInstance();
  static LC_PayDeliverFailRsp* default_instance_;
};
// -------------------------------------------------------------------

class LoadPayDBReq : public ::google::protobuf::Message {
 public:
  LoadPayDBReq();
  virtual ~LoadPayDBReq();

  LoadPayDBReq(const LoadPayDBReq& from);

  inline LoadPayDBReq& operator=(const LoadPayDBReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadPayDBReq& default_instance();

  void Swap(LoadPayDBReq* other);

  // implements Message ----------------------------------------------

  LoadPayDBReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadPayDBReq& from);
  void MergeFrom(const LoadPayDBReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline ::google::protobuf::uint64 cid() const;
  inline void set_cid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.LoadPayDBReq)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Pay_2eproto();
  friend void protobuf_AssignDesc_Pay_2eproto();
  friend void protobuf_ShutdownFile_Pay_2eproto();

  void InitAsDefaultInstance();
  static LoadPayDBReq* default_instance_;
};
// -------------------------------------------------------------------

class LoadPayDBRsp : public ::google::protobuf::Message {
 public:
  LoadPayDBRsp();
  virtual ~LoadPayDBRsp();

  LoadPayDBRsp(const LoadPayDBRsp& from);

  inline LoadPayDBRsp& operator=(const LoadPayDBRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadPayDBRsp& default_instance();

  void Swap(LoadPayDBRsp* other);

  // implements Message ----------------------------------------------

  LoadPayDBRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadPayDBRsp& from);
  void MergeFrom(const LoadPayDBRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline ::google::protobuf::uint64 cid() const;
  inline void set_cid(::google::protobuf::uint64 value);

  // repeated .proto_ff.PayProto info_lst = 2;
  inline int info_lst_size() const;
  inline void clear_info_lst();
  static const int kInfoLstFieldNumber = 2;
  inline const ::proto_ff::PayProto& info_lst(int index) const;
  inline ::proto_ff::PayProto* mutable_info_lst(int index);
  inline ::proto_ff::PayProto* add_info_lst();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::PayProto >&
      info_lst() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::PayProto >*
      mutable_info_lst();

  // @@protoc_insertion_point(class_scope:proto_ff.LoadPayDBRsp)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cid_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::PayProto > info_lst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Pay_2eproto();
  friend void protobuf_AssignDesc_Pay_2eproto();
  friend void protobuf_ShutdownFile_Pay_2eproto();

  void InitAsDefaultInstance();
  static LoadPayDBRsp* default_instance_;
};
// -------------------------------------------------------------------

class SavePayDBReq : public ::google::protobuf::Message {
 public:
  SavePayDBReq();
  virtual ~SavePayDBReq();

  SavePayDBReq(const SavePayDBReq& from);

  inline SavePayDBReq& operator=(const SavePayDBReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SavePayDBReq& default_instance();

  void Swap(SavePayDBReq* other);

  // implements Message ----------------------------------------------

  SavePayDBReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SavePayDBReq& from);
  void MergeFrom(const SavePayDBReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline ::google::protobuf::uint64 cid() const;
  inline void set_cid(::google::protobuf::uint64 value);

  // required .proto_ff.PayProto info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::proto_ff::PayProto& info() const;
  inline ::proto_ff::PayProto* mutable_info();
  inline ::proto_ff::PayProto* release_info();
  inline void set_allocated_info(::proto_ff::PayProto* info);

  // @@protoc_insertion_point(class_scope:proto_ff.SavePayDBReq)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cid_;
  ::proto_ff::PayProto* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Pay_2eproto();
  friend void protobuf_AssignDesc_Pay_2eproto();
  friend void protobuf_ShutdownFile_Pay_2eproto();

  void InitAsDefaultInstance();
  static SavePayDBReq* default_instance_;
};
// -------------------------------------------------------------------

class UpdatePayDBReq : public ::google::protobuf::Message {
 public:
  UpdatePayDBReq();
  virtual ~UpdatePayDBReq();

  UpdatePayDBReq(const UpdatePayDBReq& from);

  inline UpdatePayDBReq& operator=(const UpdatePayDBReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatePayDBReq& default_instance();

  void Swap(UpdatePayDBReq* other);

  // implements Message ----------------------------------------------

  UpdatePayDBReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdatePayDBReq& from);
  void MergeFrom(const UpdatePayDBReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 dbid = 1;
  inline int dbid_size() const;
  inline void clear_dbid();
  static const int kDbidFieldNumber = 1;
  inline ::google::protobuf::uint32 dbid(int index) const;
  inline void set_dbid(int index, ::google::protobuf::uint32 value);
  inline void add_dbid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dbid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dbid();

  // @@protoc_insertion_point(class_scope:proto_ff.UpdatePayDBReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dbid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Pay_2eproto();
  friend void protobuf_AssignDesc_Pay_2eproto();
  friend void protobuf_ShutdownFile_Pay_2eproto();

  void InitAsDefaultInstance();
  static UpdatePayDBReq* default_instance_;
};
// ===================================================================


// ===================================================================

// PayReq

// required uint32 chanId = 1;
inline bool PayReq::has_chanid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayReq::set_has_chanid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayReq::clear_has_chanid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayReq::clear_chanid() {
  chanid_ = 0u;
  clear_has_chanid();
}
inline ::google::protobuf::uint32 PayReq::chanid() const {
  return chanid_;
}
inline void PayReq::set_chanid(::google::protobuf::uint32 value) {
  set_has_chanid();
  chanid_ = value;
}

// required string productId = 2;
inline bool PayReq::has_productid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayReq::set_has_productid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayReq::clear_has_productid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayReq::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& PayReq::productid() const {
  return *productid_;
}
inline void PayReq::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void PayReq::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void PayReq::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayReq::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* PayReq::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayReq::set_allocated_productid(::std::string* productid) {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    delete productid_;
  }
  if (productid) {
    set_has_productid();
    productid_ = productid;
  } else {
    clear_has_productid();
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string payString = 3;
inline bool PayReq::has_paystring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayReq::set_has_paystring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayReq::clear_has_paystring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayReq::clear_paystring() {
  if (paystring_ != &::google::protobuf::internal::kEmptyString) {
    paystring_->clear();
  }
  clear_has_paystring();
}
inline const ::std::string& PayReq::paystring() const {
  return *paystring_;
}
inline void PayReq::set_paystring(const ::std::string& value) {
  set_has_paystring();
  if (paystring_ == &::google::protobuf::internal::kEmptyString) {
    paystring_ = new ::std::string;
  }
  paystring_->assign(value);
}
inline void PayReq::set_paystring(const char* value) {
  set_has_paystring();
  if (paystring_ == &::google::protobuf::internal::kEmptyString) {
    paystring_ = new ::std::string;
  }
  paystring_->assign(value);
}
inline void PayReq::set_paystring(const char* value, size_t size) {
  set_has_paystring();
  if (paystring_ == &::google::protobuf::internal::kEmptyString) {
    paystring_ = new ::std::string;
  }
  paystring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayReq::mutable_paystring() {
  set_has_paystring();
  if (paystring_ == &::google::protobuf::internal::kEmptyString) {
    paystring_ = new ::std::string;
  }
  return paystring_;
}
inline ::std::string* PayReq::release_paystring() {
  clear_has_paystring();
  if (paystring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paystring_;
    paystring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayReq::set_allocated_paystring(::std::string* paystring) {
  if (paystring_ != &::google::protobuf::internal::kEmptyString) {
    delete paystring_;
  }
  if (paystring) {
    set_has_paystring();
    paystring_ = paystring;
  } else {
    clear_has_paystring();
    paystring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string myoder = 4;
inline bool PayReq::has_myoder() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayReq::set_has_myoder() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayReq::clear_has_myoder() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayReq::clear_myoder() {
  if (myoder_ != &::google::protobuf::internal::kEmptyString) {
    myoder_->clear();
  }
  clear_has_myoder();
}
inline const ::std::string& PayReq::myoder() const {
  return *myoder_;
}
inline void PayReq::set_myoder(const ::std::string& value) {
  set_has_myoder();
  if (myoder_ == &::google::protobuf::internal::kEmptyString) {
    myoder_ = new ::std::string;
  }
  myoder_->assign(value);
}
inline void PayReq::set_myoder(const char* value) {
  set_has_myoder();
  if (myoder_ == &::google::protobuf::internal::kEmptyString) {
    myoder_ = new ::std::string;
  }
  myoder_->assign(value);
}
inline void PayReq::set_myoder(const char* value, size_t size) {
  set_has_myoder();
  if (myoder_ == &::google::protobuf::internal::kEmptyString) {
    myoder_ = new ::std::string;
  }
  myoder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayReq::mutable_myoder() {
  set_has_myoder();
  if (myoder_ == &::google::protobuf::internal::kEmptyString) {
    myoder_ = new ::std::string;
  }
  return myoder_;
}
inline ::std::string* PayReq::release_myoder() {
  clear_has_myoder();
  if (myoder_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = myoder_;
    myoder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayReq::set_allocated_myoder(::std::string* myoder) {
  if (myoder_ != &::google::protobuf::internal::kEmptyString) {
    delete myoder_;
  }
  if (myoder) {
    set_has_myoder();
    myoder_ = myoder;
  } else {
    clear_has_myoder();
    myoder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PayRsp

// required string productId = 1;
inline bool PayRsp::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayRsp::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayRsp::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayRsp::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& PayRsp::productid() const {
  return *productid_;
}
inline void PayRsp::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void PayRsp::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void PayRsp::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayRsp::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* PayRsp::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayRsp::set_allocated_productid(::std::string* productid) {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    delete productid_;
  }
  if (productid) {
    set_has_productid();
    productid_ = productid;
  } else {
    clear_has_productid();
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 payRet = 2;
inline bool PayRsp::has_payret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayRsp::set_has_payret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayRsp::clear_has_payret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayRsp::clear_payret() {
  payret_ = 0u;
  clear_has_payret();
}
inline ::google::protobuf::uint32 PayRsp::payret() const {
  return payret_;
}
inline void PayRsp::set_payret(::google::protobuf::uint32 value) {
  set_has_payret();
  payret_ = value;
}

// optional string payRspString = 3;
inline bool PayRsp::has_payrspstring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayRsp::set_has_payrspstring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayRsp::clear_has_payrspstring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayRsp::clear_payrspstring() {
  if (payrspstring_ != &::google::protobuf::internal::kEmptyString) {
    payrspstring_->clear();
  }
  clear_has_payrspstring();
}
inline const ::std::string& PayRsp::payrspstring() const {
  return *payrspstring_;
}
inline void PayRsp::set_payrspstring(const ::std::string& value) {
  set_has_payrspstring();
  if (payrspstring_ == &::google::protobuf::internal::kEmptyString) {
    payrspstring_ = new ::std::string;
  }
  payrspstring_->assign(value);
}
inline void PayRsp::set_payrspstring(const char* value) {
  set_has_payrspstring();
  if (payrspstring_ == &::google::protobuf::internal::kEmptyString) {
    payrspstring_ = new ::std::string;
  }
  payrspstring_->assign(value);
}
inline void PayRsp::set_payrspstring(const char* value, size_t size) {
  set_has_payrspstring();
  if (payrspstring_ == &::google::protobuf::internal::kEmptyString) {
    payrspstring_ = new ::std::string;
  }
  payrspstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayRsp::mutable_payrspstring() {
  set_has_payrspstring();
  if (payrspstring_ == &::google::protobuf::internal::kEmptyString) {
    payrspstring_ = new ::std::string;
  }
  return payrspstring_;
}
inline ::std::string* PayRsp::release_payrspstring() {
  clear_has_payrspstring();
  if (payrspstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payrspstring_;
    payrspstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayRsp::set_allocated_payrspstring(::std::string* payrspstring) {
  if (payrspstring_ != &::google::protobuf::internal::kEmptyString) {
    delete payrspstring_;
  }
  if (payrspstring) {
    set_has_payrspstring();
    payrspstring_ = payrspstring;
  } else {
    clear_has_payrspstring();
    payrspstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string payRetMsg = 4;
inline bool PayRsp::has_payretmsg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayRsp::set_has_payretmsg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayRsp::clear_has_payretmsg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayRsp::clear_payretmsg() {
  if (payretmsg_ != &::google::protobuf::internal::kEmptyString) {
    payretmsg_->clear();
  }
  clear_has_payretmsg();
}
inline const ::std::string& PayRsp::payretmsg() const {
  return *payretmsg_;
}
inline void PayRsp::set_payretmsg(const ::std::string& value) {
  set_has_payretmsg();
  if (payretmsg_ == &::google::protobuf::internal::kEmptyString) {
    payretmsg_ = new ::std::string;
  }
  payretmsg_->assign(value);
}
inline void PayRsp::set_payretmsg(const char* value) {
  set_has_payretmsg();
  if (payretmsg_ == &::google::protobuf::internal::kEmptyString) {
    payretmsg_ = new ::std::string;
  }
  payretmsg_->assign(value);
}
inline void PayRsp::set_payretmsg(const char* value, size_t size) {
  set_has_payretmsg();
  if (payretmsg_ == &::google::protobuf::internal::kEmptyString) {
    payretmsg_ = new ::std::string;
  }
  payretmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayRsp::mutable_payretmsg() {
  set_has_payretmsg();
  if (payretmsg_ == &::google::protobuf::internal::kEmptyString) {
    payretmsg_ = new ::std::string;
  }
  return payretmsg_;
}
inline ::std::string* PayRsp::release_payretmsg() {
  clear_has_payretmsg();
  if (payretmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payretmsg_;
    payretmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayRsp::set_allocated_payretmsg(::std::string* payretmsg) {
  if (payretmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete payretmsg_;
  }
  if (payretmsg) {
    set_has_payretmsg();
    payretmsg_ = payretmsg;
  } else {
    clear_has_payretmsg();
    payretmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PayOrderIdReq

// required uint32 channId = 1;
inline bool PayOrderIdReq::has_channid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayOrderIdReq::set_has_channid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayOrderIdReq::clear_has_channid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayOrderIdReq::clear_channid() {
  channid_ = 0u;
  clear_has_channid();
}
inline ::google::protobuf::uint32 PayOrderIdReq::channid() const {
  return channid_;
}
inline void PayOrderIdReq::set_channid(::google::protobuf::uint32 value) {
  set_has_channid();
  channid_ = value;
}

// required string productId = 2;
inline bool PayOrderIdReq::has_productid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayOrderIdReq::set_has_productid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayOrderIdReq::clear_has_productid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayOrderIdReq::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& PayOrderIdReq::productid() const {
  return *productid_;
}
inline void PayOrderIdReq::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void PayOrderIdReq::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void PayOrderIdReq::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOrderIdReq::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* PayOrderIdReq::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOrderIdReq::set_allocated_productid(::std::string* productid) {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    delete productid_;
  }
  if (productid) {
    set_has_productid();
    productid_ = productid;
  } else {
    clear_has_productid();
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string orderString = 3;
inline bool PayOrderIdReq::has_orderstring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayOrderIdReq::set_has_orderstring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayOrderIdReq::clear_has_orderstring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayOrderIdReq::clear_orderstring() {
  if (orderstring_ != &::google::protobuf::internal::kEmptyString) {
    orderstring_->clear();
  }
  clear_has_orderstring();
}
inline const ::std::string& PayOrderIdReq::orderstring() const {
  return *orderstring_;
}
inline void PayOrderIdReq::set_orderstring(const ::std::string& value) {
  set_has_orderstring();
  if (orderstring_ == &::google::protobuf::internal::kEmptyString) {
    orderstring_ = new ::std::string;
  }
  orderstring_->assign(value);
}
inline void PayOrderIdReq::set_orderstring(const char* value) {
  set_has_orderstring();
  if (orderstring_ == &::google::protobuf::internal::kEmptyString) {
    orderstring_ = new ::std::string;
  }
  orderstring_->assign(value);
}
inline void PayOrderIdReq::set_orderstring(const char* value, size_t size) {
  set_has_orderstring();
  if (orderstring_ == &::google::protobuf::internal::kEmptyString) {
    orderstring_ = new ::std::string;
  }
  orderstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOrderIdReq::mutable_orderstring() {
  set_has_orderstring();
  if (orderstring_ == &::google::protobuf::internal::kEmptyString) {
    orderstring_ = new ::std::string;
  }
  return orderstring_;
}
inline ::std::string* PayOrderIdReq::release_orderstring() {
  clear_has_orderstring();
  if (orderstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderstring_;
    orderstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOrderIdReq::set_allocated_orderstring(::std::string* orderstring) {
  if (orderstring_ != &::google::protobuf::internal::kEmptyString) {
    delete orderstring_;
  }
  if (orderstring) {
    set_has_orderstring();
    orderstring_ = orderstring;
  } else {
    clear_has_orderstring();
    orderstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string productLst = 4;
inline int PayOrderIdReq::productlst_size() const {
  return productlst_.size();
}
inline void PayOrderIdReq::clear_productlst() {
  productlst_.Clear();
}
inline const ::std::string& PayOrderIdReq::productlst(int index) const {
  return productlst_.Get(index);
}
inline ::std::string* PayOrderIdReq::mutable_productlst(int index) {
  return productlst_.Mutable(index);
}
inline void PayOrderIdReq::set_productlst(int index, const ::std::string& value) {
  productlst_.Mutable(index)->assign(value);
}
inline void PayOrderIdReq::set_productlst(int index, const char* value) {
  productlst_.Mutable(index)->assign(value);
}
inline void PayOrderIdReq::set_productlst(int index, const char* value, size_t size) {
  productlst_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOrderIdReq::add_productlst() {
  return productlst_.Add();
}
inline void PayOrderIdReq::add_productlst(const ::std::string& value) {
  productlst_.Add()->assign(value);
}
inline void PayOrderIdReq::add_productlst(const char* value) {
  productlst_.Add()->assign(value);
}
inline void PayOrderIdReq::add_productlst(const char* value, size_t size) {
  productlst_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PayOrderIdReq::productlst() const {
  return productlst_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PayOrderIdReq::mutable_productlst() {
  return &productlst_;
}

// -------------------------------------------------------------------

// PayOrderIdRsp

// required uint32 retCode = 1;
inline bool PayOrderIdRsp::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayOrderIdRsp::set_has_retcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayOrderIdRsp::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayOrderIdRsp::clear_retcode() {
  retcode_ = 0u;
  clear_has_retcode();
}
inline ::google::protobuf::uint32 PayOrderIdRsp::retcode() const {
  return retcode_;
}
inline void PayOrderIdRsp::set_retcode(::google::protobuf::uint32 value) {
  set_has_retcode();
  retcode_ = value;
}

// optional string order = 2;
inline bool PayOrderIdRsp::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayOrderIdRsp::set_has_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayOrderIdRsp::clear_has_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayOrderIdRsp::clear_order() {
  if (order_ != &::google::protobuf::internal::kEmptyString) {
    order_->clear();
  }
  clear_has_order();
}
inline const ::std::string& PayOrderIdRsp::order() const {
  return *order_;
}
inline void PayOrderIdRsp::set_order(const ::std::string& value) {
  set_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    order_ = new ::std::string;
  }
  order_->assign(value);
}
inline void PayOrderIdRsp::set_order(const char* value) {
  set_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    order_ = new ::std::string;
  }
  order_->assign(value);
}
inline void PayOrderIdRsp::set_order(const char* value, size_t size) {
  set_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    order_ = new ::std::string;
  }
  order_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOrderIdRsp::mutable_order() {
  set_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    order_ = new ::std::string;
  }
  return order_;
}
inline ::std::string* PayOrderIdRsp::release_order() {
  clear_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_;
    order_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOrderIdRsp::set_allocated_order(::std::string* order) {
  if (order_ != &::google::protobuf::internal::kEmptyString) {
    delete order_;
  }
  if (order) {
    set_has_order();
    order_ = order;
  } else {
    clear_has_order();
    order_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string orderString = 3;
inline bool PayOrderIdRsp::has_orderstring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayOrderIdRsp::set_has_orderstring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayOrderIdRsp::clear_has_orderstring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayOrderIdRsp::clear_orderstring() {
  if (orderstring_ != &::google::protobuf::internal::kEmptyString) {
    orderstring_->clear();
  }
  clear_has_orderstring();
}
inline const ::std::string& PayOrderIdRsp::orderstring() const {
  return *orderstring_;
}
inline void PayOrderIdRsp::set_orderstring(const ::std::string& value) {
  set_has_orderstring();
  if (orderstring_ == &::google::protobuf::internal::kEmptyString) {
    orderstring_ = new ::std::string;
  }
  orderstring_->assign(value);
}
inline void PayOrderIdRsp::set_orderstring(const char* value) {
  set_has_orderstring();
  if (orderstring_ == &::google::protobuf::internal::kEmptyString) {
    orderstring_ = new ::std::string;
  }
  orderstring_->assign(value);
}
inline void PayOrderIdRsp::set_orderstring(const char* value, size_t size) {
  set_has_orderstring();
  if (orderstring_ == &::google::protobuf::internal::kEmptyString) {
    orderstring_ = new ::std::string;
  }
  orderstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOrderIdRsp::mutable_orderstring() {
  set_has_orderstring();
  if (orderstring_ == &::google::protobuf::internal::kEmptyString) {
    orderstring_ = new ::std::string;
  }
  return orderstring_;
}
inline ::std::string* PayOrderIdRsp::release_orderstring() {
  clear_has_orderstring();
  if (orderstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderstring_;
    orderstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOrderIdRsp::set_allocated_orderstring(::std::string* orderstring) {
  if (orderstring_ != &::google::protobuf::internal::kEmptyString) {
    delete orderstring_;
  }
  if (orderstring) {
    set_has_orderstring();
    orderstring_ = orderstring;
  } else {
    clear_has_orderstring();
    orderstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cbUrl = 4;
inline bool PayOrderIdRsp::has_cburl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayOrderIdRsp::set_has_cburl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayOrderIdRsp::clear_has_cburl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayOrderIdRsp::clear_cburl() {
  if (cburl_ != &::google::protobuf::internal::kEmptyString) {
    cburl_->clear();
  }
  clear_has_cburl();
}
inline const ::std::string& PayOrderIdRsp::cburl() const {
  return *cburl_;
}
inline void PayOrderIdRsp::set_cburl(const ::std::string& value) {
  set_has_cburl();
  if (cburl_ == &::google::protobuf::internal::kEmptyString) {
    cburl_ = new ::std::string;
  }
  cburl_->assign(value);
}
inline void PayOrderIdRsp::set_cburl(const char* value) {
  set_has_cburl();
  if (cburl_ == &::google::protobuf::internal::kEmptyString) {
    cburl_ = new ::std::string;
  }
  cburl_->assign(value);
}
inline void PayOrderIdRsp::set_cburl(const char* value, size_t size) {
  set_has_cburl();
  if (cburl_ == &::google::protobuf::internal::kEmptyString) {
    cburl_ = new ::std::string;
  }
  cburl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOrderIdRsp::mutable_cburl() {
  set_has_cburl();
  if (cburl_ == &::google::protobuf::internal::kEmptyString) {
    cburl_ = new ::std::string;
  }
  return cburl_;
}
inline ::std::string* PayOrderIdRsp::release_cburl() {
  clear_has_cburl();
  if (cburl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cburl_;
    cburl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOrderIdRsp::set_allocated_cburl(::std::string* cburl) {
  if (cburl_ != &::google::protobuf::internal::kEmptyString) {
    delete cburl_;
  }
  if (cburl) {
    set_has_cburl();
    cburl_ = cburl;
  } else {
    clear_has_cburl();
    cburl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string productId = 5;
inline bool PayOrderIdRsp::has_productid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PayOrderIdRsp::set_has_productid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PayOrderIdRsp::clear_has_productid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PayOrderIdRsp::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& PayOrderIdRsp::productid() const {
  return *productid_;
}
inline void PayOrderIdRsp::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void PayOrderIdRsp::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void PayOrderIdRsp::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOrderIdRsp::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* PayOrderIdRsp::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOrderIdRsp::set_allocated_productid(::std::string* productid) {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    delete productid_;
  }
  if (productid) {
    set_has_productid();
    productid_ = productid;
  } else {
    clear_has_productid();
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string retMsg = 6;
inline bool PayOrderIdRsp::has_retmsg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PayOrderIdRsp::set_has_retmsg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PayOrderIdRsp::clear_has_retmsg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PayOrderIdRsp::clear_retmsg() {
  if (retmsg_ != &::google::protobuf::internal::kEmptyString) {
    retmsg_->clear();
  }
  clear_has_retmsg();
}
inline const ::std::string& PayOrderIdRsp::retmsg() const {
  return *retmsg_;
}
inline void PayOrderIdRsp::set_retmsg(const ::std::string& value) {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  retmsg_->assign(value);
}
inline void PayOrderIdRsp::set_retmsg(const char* value) {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  retmsg_->assign(value);
}
inline void PayOrderIdRsp::set_retmsg(const char* value, size_t size) {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  retmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOrderIdRsp::mutable_retmsg() {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  return retmsg_;
}
inline ::std::string* PayOrderIdRsp::release_retmsg() {
  clear_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = retmsg_;
    retmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayOrderIdRsp::set_allocated_retmsg(::std::string* retmsg) {
  if (retmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete retmsg_;
  }
  if (retmsg) {
    set_has_retmsg();
    retmsg_ = retmsg;
  } else {
    clear_has_retmsg();
    retmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string productLst = 7;
inline int PayOrderIdRsp::productlst_size() const {
  return productlst_.size();
}
inline void PayOrderIdRsp::clear_productlst() {
  productlst_.Clear();
}
inline const ::std::string& PayOrderIdRsp::productlst(int index) const {
  return productlst_.Get(index);
}
inline ::std::string* PayOrderIdRsp::mutable_productlst(int index) {
  return productlst_.Mutable(index);
}
inline void PayOrderIdRsp::set_productlst(int index, const ::std::string& value) {
  productlst_.Mutable(index)->assign(value);
}
inline void PayOrderIdRsp::set_productlst(int index, const char* value) {
  productlst_.Mutable(index)->assign(value);
}
inline void PayOrderIdRsp::set_productlst(int index, const char* value, size_t size) {
  productlst_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayOrderIdRsp::add_productlst() {
  return productlst_.Add();
}
inline void PayOrderIdRsp::add_productlst(const ::std::string& value) {
  productlst_.Add()->assign(value);
}
inline void PayOrderIdRsp::add_productlst(const char* value) {
  productlst_.Add()->assign(value);
}
inline void PayOrderIdRsp::add_productlst(const char* value, size_t size) {
  productlst_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PayOrderIdRsp::productlst() const {
  return productlst_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PayOrderIdRsp::mutable_productlst() {
  return &productlst_;
}

// -------------------------------------------------------------------

// PayProductNotify

// optional string productId = 1;
inline bool PayProductNotify::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayProductNotify::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayProductNotify::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayProductNotify::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& PayProductNotify::productid() const {
  return *productid_;
}
inline void PayProductNotify::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void PayProductNotify::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void PayProductNotify::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayProductNotify::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* PayProductNotify::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayProductNotify::set_allocated_productid(::std::string* productid) {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    delete productid_;
  }
  if (productid) {
    set_has_productid();
    productid_ = productid;
  } else {
    clear_has_productid();
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 isfirst = 2;
inline bool PayProductNotify::has_isfirst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayProductNotify::set_has_isfirst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayProductNotify::clear_has_isfirst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayProductNotify::clear_isfirst() {
  isfirst_ = 0;
  clear_has_isfirst();
}
inline ::google::protobuf::int32 PayProductNotify::isfirst() const {
  return isfirst_;
}
inline void PayProductNotify::set_isfirst(::google::protobuf::int32 value) {
  set_has_isfirst();
  isfirst_ = value;
}

// -------------------------------------------------------------------

// PayProto

// required uint32 zid = 1;
inline bool PayProto::has_zid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayProto::set_has_zid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayProto::clear_has_zid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayProto::clear_zid() {
  zid_ = 0u;
  clear_has_zid();
}
inline ::google::protobuf::uint32 PayProto::zid() const {
  return zid_;
}
inline void PayProto::set_zid(::google::protobuf::uint32 value) {
  set_has_zid();
  zid_ = value;
}

// required uint32 channId = 2;
inline bool PayProto::has_channid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayProto::set_has_channid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayProto::clear_has_channid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayProto::clear_channid() {
  channid_ = 0u;
  clear_has_channid();
}
inline ::google::protobuf::uint32 PayProto::channid() const {
  return channid_;
}
inline void PayProto::set_channid(::google::protobuf::uint32 value) {
  set_has_channid();
  channid_ = value;
}

// required uint32 uid = 3;
inline bool PayProto::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayProto::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayProto::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayProto::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 PayProto::uid() const {
  return uid_;
}
inline void PayProto::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// required uint64 cid = 4;
inline bool PayProto::has_cid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayProto::set_has_cid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayProto::clear_has_cid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayProto::clear_cid() {
  cid_ = GOOGLE_ULONGLONG(0);
  clear_has_cid();
}
inline ::google::protobuf::uint64 PayProto::cid() const {
  return cid_;
}
inline void PayProto::set_cid(::google::protobuf::uint64 value) {
  set_has_cid();
  cid_ = value;
}

// required string productId = 5;
inline bool PayProto::has_productid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PayProto::set_has_productid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PayProto::clear_has_productid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PayProto::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& PayProto::productid() const {
  return *productid_;
}
inline void PayProto::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void PayProto::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void PayProto::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayProto::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* PayProto::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayProto::set_allocated_productid(::std::string* productid) {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    delete productid_;
  }
  if (productid) {
    set_has_productid();
    productid_ = productid;
  } else {
    clear_has_productid();
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 money = 6;
inline bool PayProto::has_money() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PayProto::set_has_money() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PayProto::clear_has_money() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PayProto::clear_money() {
  money_ = 0u;
  clear_has_money();
}
inline ::google::protobuf::uint32 PayProto::money() const {
  return money_;
}
inline void PayProto::set_money(::google::protobuf::uint32 value) {
  set_has_money();
  money_ = value;
}

// required string order = 7;
inline bool PayProto::has_order() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PayProto::set_has_order() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PayProto::clear_has_order() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PayProto::clear_order() {
  if (order_ != &::google::protobuf::internal::kEmptyString) {
    order_->clear();
  }
  clear_has_order();
}
inline const ::std::string& PayProto::order() const {
  return *order_;
}
inline void PayProto::set_order(const ::std::string& value) {
  set_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    order_ = new ::std::string;
  }
  order_->assign(value);
}
inline void PayProto::set_order(const char* value) {
  set_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    order_ = new ::std::string;
  }
  order_->assign(value);
}
inline void PayProto::set_order(const char* value, size_t size) {
  set_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    order_ = new ::std::string;
  }
  order_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayProto::mutable_order() {
  set_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    order_ = new ::std::string;
  }
  return order_;
}
inline ::std::string* PayProto::release_order() {
  clear_has_order();
  if (order_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_;
    order_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayProto::set_allocated_order(::std::string* order) {
  if (order_ != &::google::protobuf::internal::kEmptyString) {
    delete order_;
  }
  if (order) {
    set_has_order();
    order_ = order;
  } else {
    clear_has_order();
    order_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 dbid = 8;
inline bool PayProto::has_dbid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PayProto::set_has_dbid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PayProto::clear_has_dbid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PayProto::clear_dbid() {
  dbid_ = 0u;
  clear_has_dbid();
}
inline ::google::protobuf::uint32 PayProto::dbid() const {
  return dbid_;
}
inline void PayProto::set_dbid(::google::protobuf::uint32 value) {
  set_has_dbid();
  dbid_ = value;
}

// required string myOrder = 9;
inline bool PayProto::has_myorder() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PayProto::set_has_myorder() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PayProto::clear_has_myorder() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PayProto::clear_myorder() {
  if (myorder_ != &::google::protobuf::internal::kEmptyString) {
    myorder_->clear();
  }
  clear_has_myorder();
}
inline const ::std::string& PayProto::myorder() const {
  return *myorder_;
}
inline void PayProto::set_myorder(const ::std::string& value) {
  set_has_myorder();
  if (myorder_ == &::google::protobuf::internal::kEmptyString) {
    myorder_ = new ::std::string;
  }
  myorder_->assign(value);
}
inline void PayProto::set_myorder(const char* value) {
  set_has_myorder();
  if (myorder_ == &::google::protobuf::internal::kEmptyString) {
    myorder_ = new ::std::string;
  }
  myorder_->assign(value);
}
inline void PayProto::set_myorder(const char* value, size_t size) {
  set_has_myorder();
  if (myorder_ == &::google::protobuf::internal::kEmptyString) {
    myorder_ = new ::std::string;
  }
  myorder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayProto::mutable_myorder() {
  set_has_myorder();
  if (myorder_ == &::google::protobuf::internal::kEmptyString) {
    myorder_ = new ::std::string;
  }
  return myorder_;
}
inline ::std::string* PayProto::release_myorder() {
  clear_has_myorder();
  if (myorder_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = myorder_;
    myorder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayProto::set_allocated_myorder(::std::string* myorder) {
  if (myorder_ != &::google::protobuf::internal::kEmptyString) {
    delete myorder_;
  }
  if (myorder) {
    set_has_myorder();
    myorder_ = myorder;
  } else {
    clear_has_myorder();
    myorder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool fakePay = 10;
inline bool PayProto::has_fakepay() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PayProto::set_has_fakepay() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PayProto::clear_has_fakepay() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PayProto::clear_fakepay() {
  fakepay_ = false;
  clear_has_fakepay();
}
inline bool PayProto::fakepay() const {
  return fakepay_;
}
inline void PayProto::set_fakepay(bool value) {
  set_has_fakepay();
  fakepay_ = value;
}

// repeated string productLst = 11;
inline int PayProto::productlst_size() const {
  return productlst_.size();
}
inline void PayProto::clear_productlst() {
  productlst_.Clear();
}
inline const ::std::string& PayProto::productlst(int index) const {
  return productlst_.Get(index);
}
inline ::std::string* PayProto::mutable_productlst(int index) {
  return productlst_.Mutable(index);
}
inline void PayProto::set_productlst(int index, const ::std::string& value) {
  productlst_.Mutable(index)->assign(value);
}
inline void PayProto::set_productlst(int index, const char* value) {
  productlst_.Mutable(index)->assign(value);
}
inline void PayProto::set_productlst(int index, const char* value, size_t size) {
  productlst_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayProto::add_productlst() {
  return productlst_.Add();
}
inline void PayProto::add_productlst(const ::std::string& value) {
  productlst_.Add()->assign(value);
}
inline void PayProto::add_productlst(const char* value) {
  productlst_.Add()->assign(value);
}
inline void PayProto::add_productlst(const char* value, size_t size) {
  productlst_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PayProto::productlst() const {
  return productlst_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PayProto::mutable_productlst() {
  return &productlst_;
}

// optional int64 payTime = 12;
inline bool PayProto::has_paytime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PayProto::set_has_paytime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PayProto::clear_has_paytime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PayProto::clear_paytime() {
  paytime_ = GOOGLE_LONGLONG(0);
  clear_has_paytime();
}
inline ::google::protobuf::int64 PayProto::paytime() const {
  return paytime_;
}
inline void PayProto::set_paytime(::google::protobuf::int64 value) {
  set_has_paytime();
  paytime_ = value;
}

// -------------------------------------------------------------------

// CL_PayDeliverNotify

// required .proto_ff.PayProto info = 1;
inline bool CL_PayDeliverNotify::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CL_PayDeliverNotify::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CL_PayDeliverNotify::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CL_PayDeliverNotify::clear_info() {
  if (info_ != NULL) info_->::proto_ff::PayProto::Clear();
  clear_has_info();
}
inline const ::proto_ff::PayProto& CL_PayDeliverNotify::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::proto_ff::PayProto* CL_PayDeliverNotify::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::proto_ff::PayProto;
  return info_;
}
inline ::proto_ff::PayProto* CL_PayDeliverNotify::release_info() {
  clear_has_info();
  ::proto_ff::PayProto* temp = info_;
  info_ = NULL;
  return temp;
}
inline void CL_PayDeliverNotify::set_allocated_info(::proto_ff::PayProto* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// required uint32 zid = 2;
inline bool CL_PayDeliverNotify::has_zid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CL_PayDeliverNotify::set_has_zid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CL_PayDeliverNotify::clear_has_zid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CL_PayDeliverNotify::clear_zid() {
  zid_ = 0u;
  clear_has_zid();
}
inline ::google::protobuf::uint32 CL_PayDeliverNotify::zid() const {
  return zid_;
}
inline void CL_PayDeliverNotify::set_zid(::google::protobuf::uint32 value) {
  set_has_zid();
  zid_ = value;
}

// -------------------------------------------------------------------

// LC_PayDeliverFailRsp

// required .proto_ff.PayProto info = 1;
inline bool LC_PayDeliverFailRsp::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LC_PayDeliverFailRsp::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LC_PayDeliverFailRsp::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LC_PayDeliverFailRsp::clear_info() {
  if (info_ != NULL) info_->::proto_ff::PayProto::Clear();
  clear_has_info();
}
inline const ::proto_ff::PayProto& LC_PayDeliverFailRsp::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::proto_ff::PayProto* LC_PayDeliverFailRsp::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::proto_ff::PayProto;
  return info_;
}
inline ::proto_ff::PayProto* LC_PayDeliverFailRsp::release_info() {
  clear_has_info();
  ::proto_ff::PayProto* temp = info_;
  info_ = NULL;
  return temp;
}
inline void LC_PayDeliverFailRsp::set_allocated_info(::proto_ff::PayProto* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// LoadPayDBReq

// required uint64 cid = 1;
inline bool LoadPayDBReq::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadPayDBReq::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadPayDBReq::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadPayDBReq::clear_cid() {
  cid_ = GOOGLE_ULONGLONG(0);
  clear_has_cid();
}
inline ::google::protobuf::uint64 LoadPayDBReq::cid() const {
  return cid_;
}
inline void LoadPayDBReq::set_cid(::google::protobuf::uint64 value) {
  set_has_cid();
  cid_ = value;
}

// -------------------------------------------------------------------

// LoadPayDBRsp

// required uint64 cid = 1;
inline bool LoadPayDBRsp::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadPayDBRsp::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadPayDBRsp::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadPayDBRsp::clear_cid() {
  cid_ = GOOGLE_ULONGLONG(0);
  clear_has_cid();
}
inline ::google::protobuf::uint64 LoadPayDBRsp::cid() const {
  return cid_;
}
inline void LoadPayDBRsp::set_cid(::google::protobuf::uint64 value) {
  set_has_cid();
  cid_ = value;
}

// repeated .proto_ff.PayProto info_lst = 2;
inline int LoadPayDBRsp::info_lst_size() const {
  return info_lst_.size();
}
inline void LoadPayDBRsp::clear_info_lst() {
  info_lst_.Clear();
}
inline const ::proto_ff::PayProto& LoadPayDBRsp::info_lst(int index) const {
  return info_lst_.Get(index);
}
inline ::proto_ff::PayProto* LoadPayDBRsp::mutable_info_lst(int index) {
  return info_lst_.Mutable(index);
}
inline ::proto_ff::PayProto* LoadPayDBRsp::add_info_lst() {
  return info_lst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::PayProto >&
LoadPayDBRsp::info_lst() const {
  return info_lst_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::PayProto >*
LoadPayDBRsp::mutable_info_lst() {
  return &info_lst_;
}

// -------------------------------------------------------------------

// SavePayDBReq

// required uint64 cid = 1;
inline bool SavePayDBReq::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SavePayDBReq::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SavePayDBReq::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SavePayDBReq::clear_cid() {
  cid_ = GOOGLE_ULONGLONG(0);
  clear_has_cid();
}
inline ::google::protobuf::uint64 SavePayDBReq::cid() const {
  return cid_;
}
inline void SavePayDBReq::set_cid(::google::protobuf::uint64 value) {
  set_has_cid();
  cid_ = value;
}

// required .proto_ff.PayProto info = 2;
inline bool SavePayDBReq::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SavePayDBReq::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SavePayDBReq::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SavePayDBReq::clear_info() {
  if (info_ != NULL) info_->::proto_ff::PayProto::Clear();
  clear_has_info();
}
inline const ::proto_ff::PayProto& SavePayDBReq::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::proto_ff::PayProto* SavePayDBReq::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::proto_ff::PayProto;
  return info_;
}
inline ::proto_ff::PayProto* SavePayDBReq::release_info() {
  clear_has_info();
  ::proto_ff::PayProto* temp = info_;
  info_ = NULL;
  return temp;
}
inline void SavePayDBReq::set_allocated_info(::proto_ff::PayProto* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// UpdatePayDBReq

// repeated uint32 dbid = 1;
inline int UpdatePayDBReq::dbid_size() const {
  return dbid_.size();
}
inline void UpdatePayDBReq::clear_dbid() {
  dbid_.Clear();
}
inline ::google::protobuf::uint32 UpdatePayDBReq::dbid(int index) const {
  return dbid_.Get(index);
}
inline void UpdatePayDBReq::set_dbid(int index, ::google::protobuf::uint32 value) {
  dbid_.Set(index, value);
}
inline void UpdatePayDBReq::add_dbid(::google::protobuf::uint32 value) {
  dbid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UpdatePayDBReq::dbid() const {
  return dbid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UpdatePayDBReq::mutable_dbid() {
  return &dbid_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Pay_2eproto__INCLUDED
