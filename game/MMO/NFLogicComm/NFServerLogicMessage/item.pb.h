// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: item.proto

#ifndef PROTOBUF_item_2eproto__INCLUDED
#define PROTOBUF_item_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "yd_fieldoptions.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_item_2eproto();
void protobuf_AssignDesc_item_2eproto();
void protobuf_ShutdownFile_item_2eproto();

class itemitem;
class Sheet_itemitem;

// ===================================================================

class itemitem : public ::google::protobuf::Message {
 public:
  itemitem();
  virtual ~itemitem();

  itemitem(const itemitem& from);

  inline itemitem& operator=(const itemitem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const itemitem& default_instance();

  void Swap(itemitem* other);

  // implements Message ----------------------------------------------

  itemitem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const itemitem& from);
  void MergeFrom(const itemitem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 itemType = 3;
  inline bool has_itemtype() const;
  inline void clear_itemtype();
  static const int kItemTypeFieldNumber = 3;
  inline ::google::protobuf::int32 itemtype() const;
  inline void set_itemtype(::google::protobuf::int32 value);

  // optional int32 subType = 4;
  inline bool has_subtype() const;
  inline void clear_subtype();
  static const int kSubTypeFieldNumber = 4;
  inline ::google::protobuf::int32 subtype() const;
  inline void set_subtype(::google::protobuf::int32 value);

  // optional int32 functionType = 5;
  inline bool has_functiontype() const;
  inline void clear_functiontype();
  static const int kFunctionTypeFieldNumber = 5;
  inline ::google::protobuf::int32 functiontype() const;
  inline void set_functiontype(::google::protobuf::int32 value);

  // optional string functionValue = 6;
  inline bool has_functionvalue() const;
  inline void clear_functionvalue();
  static const int kFunctionValueFieldNumber = 6;
  inline const ::std::string& functionvalue() const;
  inline void set_functionvalue(const ::std::string& value);
  inline void set_functionvalue(const char* value);
  inline void set_functionvalue(const char* value, size_t size);
  inline ::std::string* mutable_functionvalue();
  inline ::std::string* release_functionvalue();
  inline void set_allocated_functionvalue(::std::string* functionvalue);

  // optional string usecondition = 7;
  inline bool has_usecondition() const;
  inline void clear_usecondition();
  static const int kUseconditionFieldNumber = 7;
  inline const ::std::string& usecondition() const;
  inline void set_usecondition(const ::std::string& value);
  inline void set_usecondition(const char* value);
  inline void set_usecondition(const char* value, size_t size);
  inline ::std::string* mutable_usecondition();
  inline ::std::string* release_usecondition();
  inline void set_allocated_usecondition(::std::string* usecondition);

  // optional int32 level = 8;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 8;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 quality = 9;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 9;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional int32 levelRequest = 10;
  inline bool has_levelrequest() const;
  inline void clear_levelrequest();
  static const int kLevelRequestFieldNumber = 10;
  inline ::google::protobuf::int32 levelrequest() const;
  inline void set_levelrequest(::google::protobuf::int32 value);

  // optional string profession = 11;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 11;
  inline const ::std::string& profession() const;
  inline void set_profession(const ::std::string& value);
  inline void set_profession(const char* value);
  inline void set_profession(const char* value, size_t size);
  inline ::std::string* mutable_profession();
  inline ::std::string* release_profession();
  inline void set_allocated_profession(::std::string* profession);

  // optional int32 bindType = 12;
  inline bool has_bindtype() const;
  inline void clear_bindtype();
  static const int kBindTypeFieldNumber = 12;
  inline ::google::protobuf::int32 bindtype() const;
  inline void set_bindtype(::google::protobuf::int32 value);

  // optional int32 isTradeBind = 13;
  inline bool has_istradebind() const;
  inline void clear_istradebind();
  static const int kIsTradeBindFieldNumber = 13;
  inline ::google::protobuf::int32 istradebind() const;
  inline void set_istradebind(::google::protobuf::int32 value);

  // optional int32 stackLimit = 14;
  inline bool has_stacklimit() const;
  inline void clear_stacklimit();
  static const int kStackLimitFieldNumber = 14;
  inline ::google::protobuf::int32 stacklimit() const;
  inline void set_stacklimit(::google::protobuf::int32 value);

  // optional int32 sellPrice = 15;
  inline bool has_sellprice() const;
  inline void clear_sellprice();
  static const int kSellPriceFieldNumber = 15;
  inline ::google::protobuf::int32 sellprice() const;
  inline void set_sellprice(::google::protobuf::int32 value);

  // optional int64 sellBox = 16;
  inline bool has_sellbox() const;
  inline void clear_sellbox();
  static const int kSellBoxFieldNumber = 16;
  inline ::google::protobuf::int64 sellbox() const;
  inline void set_sellbox(::google::protobuf::int64 value);

  // optional int32 broadcast = 17;
  inline bool has_broadcast() const;
  inline void clear_broadcast();
  static const int kBroadcastFieldNumber = 17;
  inline ::google::protobuf::int32 broadcast() const;
  inline void set_broadcast(::google::protobuf::int32 value);

  // optional int32 isCanBatchUse = 18;
  inline bool has_iscanbatchuse() const;
  inline void clear_iscanbatchuse();
  static const int kIsCanBatchUseFieldNumber = 18;
  inline ::google::protobuf::int32 iscanbatchuse() const;
  inline void set_iscanbatchuse(::google::protobuf::int32 value);

  // optional int32 dayUse = 19;
  inline bool has_dayuse() const;
  inline void clear_dayuse();
  static const int kDayUseFieldNumber = 19;
  inline ::google::protobuf::int32 dayuse() const;
  inline void set_dayuse(::google::protobuf::int32 value);

  // optional int32 outTime = 20;
  inline bool has_outtime() const;
  inline void clear_outtime();
  static const int kOutTimeFieldNumber = 20;
  inline ::google::protobuf::int32 outtime() const;
  inline void set_outtime(::google::protobuf::int32 value);

  // optional string useLimit = 21;
  inline bool has_uselimit() const;
  inline void clear_uselimit();
  static const int kUseLimitFieldNumber = 21;
  inline const ::std::string& uselimit() const;
  inline void set_uselimit(const ::std::string& value);
  inline void set_uselimit(const char* value);
  inline void set_uselimit(const char* value, size_t size);
  inline ::std::string* mutable_uselimit();
  inline ::std::string* release_uselimit();
  inline void set_allocated_uselimit(::std::string* uselimit);

  // optional int32 blessing = 22;
  inline bool has_blessing() const;
  inline void clear_blessing();
  static const int kBlessingFieldNumber = 22;
  inline ::google::protobuf::int32 blessing() const;
  inline void set_blessing(::google::protobuf::int32 value);

  // optional int32 invest = 23;
  inline bool has_invest() const;
  inline void clear_invest();
  static const int kInvestFieldNumber = 23;
  inline ::google::protobuf::int32 invest() const;
  inline void set_invest(::google::protobuf::int32 value);

  // optional int32 exchange = 24;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 24;
  inline ::google::protobuf::int32 exchange() const;
  inline void set_exchange(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.itemitem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_itemtype();
  inline void clear_has_itemtype();
  inline void set_has_subtype();
  inline void clear_has_subtype();
  inline void set_has_functiontype();
  inline void clear_has_functiontype();
  inline void set_has_functionvalue();
  inline void clear_has_functionvalue();
  inline void set_has_usecondition();
  inline void clear_has_usecondition();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_levelrequest();
  inline void clear_has_levelrequest();
  inline void set_has_profession();
  inline void clear_has_profession();
  inline void set_has_bindtype();
  inline void clear_has_bindtype();
  inline void set_has_istradebind();
  inline void clear_has_istradebind();
  inline void set_has_stacklimit();
  inline void clear_has_stacklimit();
  inline void set_has_sellprice();
  inline void clear_has_sellprice();
  inline void set_has_sellbox();
  inline void clear_has_sellbox();
  inline void set_has_broadcast();
  inline void clear_has_broadcast();
  inline void set_has_iscanbatchuse();
  inline void clear_has_iscanbatchuse();
  inline void set_has_dayuse();
  inline void clear_has_dayuse();
  inline void set_has_outtime();
  inline void clear_has_outtime();
  inline void set_has_uselimit();
  inline void clear_has_uselimit();
  inline void set_has_blessing();
  inline void clear_has_blessing();
  inline void set_has_invest();
  inline void clear_has_invest();
  inline void set_has_exchange();
  inline void clear_has_exchange();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::std::string* name_;
  ::google::protobuf::int32 itemtype_;
  ::google::protobuf::int32 subtype_;
  ::std::string* functionvalue_;
  ::google::protobuf::int32 functiontype_;
  ::google::protobuf::int32 level_;
  ::std::string* usecondition_;
  ::google::protobuf::int32 quality_;
  ::google::protobuf::int32 levelrequest_;
  ::std::string* profession_;
  ::google::protobuf::int32 bindtype_;
  ::google::protobuf::int32 istradebind_;
  ::google::protobuf::int32 stacklimit_;
  ::google::protobuf::int32 sellprice_;
  ::google::protobuf::int64 sellbox_;
  ::google::protobuf::int32 broadcast_;
  ::google::protobuf::int32 iscanbatchuse_;
  ::google::protobuf::int32 dayuse_;
  ::google::protobuf::int32 outtime_;
  ::std::string* uselimit_;
  ::google::protobuf::int32 blessing_;
  ::google::protobuf::int32 invest_;
  ::google::protobuf::int32 exchange_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(24 + 31) / 32];

  friend void  protobuf_AddDesc_item_2eproto();
  friend void protobuf_AssignDesc_item_2eproto();
  friend void protobuf_ShutdownFile_item_2eproto();

  void InitAsDefaultInstance();
  static itemitem* default_instance_;
};
// -------------------------------------------------------------------

class Sheet_itemitem : public ::google::protobuf::Message {
 public:
  Sheet_itemitem();
  virtual ~Sheet_itemitem();

  Sheet_itemitem(const Sheet_itemitem& from);

  inline Sheet_itemitem& operator=(const Sheet_itemitem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sheet_itemitem& default_instance();

  void Swap(Sheet_itemitem* other);

  // implements Message ----------------------------------------------

  Sheet_itemitem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sheet_itemitem& from);
  void MergeFrom(const Sheet_itemitem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto_ff.itemitem itemitem_List = 1;
  inline int itemitem_list_size() const;
  inline void clear_itemitem_list();
  static const int kItemitemListFieldNumber = 1;
  inline const ::proto_ff::itemitem& itemitem_list(int index) const;
  inline ::proto_ff::itemitem* mutable_itemitem_list(int index);
  inline ::proto_ff::itemitem* add_itemitem_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::itemitem >&
      itemitem_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::itemitem >*
      mutable_itemitem_list();

  // @@protoc_insertion_point(class_scope:proto_ff.Sheet_itemitem)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::itemitem > itemitem_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_item_2eproto();
  friend void protobuf_AssignDesc_item_2eproto();
  friend void protobuf_ShutdownFile_item_2eproto();

  void InitAsDefaultInstance();
  static Sheet_itemitem* default_instance_;
};
// ===================================================================


// ===================================================================

// itemitem

// optional int64 id = 1;
inline bool itemitem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void itemitem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void itemitem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void itemitem::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 itemitem::id() const {
  return id_;
}
inline void itemitem::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool itemitem::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void itemitem::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void itemitem::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void itemitem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& itemitem::name() const {
  return *name_;
}
inline void itemitem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void itemitem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void itemitem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* itemitem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* itemitem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void itemitem::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 itemType = 3;
inline bool itemitem::has_itemtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void itemitem::set_has_itemtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void itemitem::clear_has_itemtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void itemitem::clear_itemtype() {
  itemtype_ = 0;
  clear_has_itemtype();
}
inline ::google::protobuf::int32 itemitem::itemtype() const {
  return itemtype_;
}
inline void itemitem::set_itemtype(::google::protobuf::int32 value) {
  set_has_itemtype();
  itemtype_ = value;
}

// optional int32 subType = 4;
inline bool itemitem::has_subtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void itemitem::set_has_subtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void itemitem::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void itemitem::clear_subtype() {
  subtype_ = 0;
  clear_has_subtype();
}
inline ::google::protobuf::int32 itemitem::subtype() const {
  return subtype_;
}
inline void itemitem::set_subtype(::google::protobuf::int32 value) {
  set_has_subtype();
  subtype_ = value;
}

// optional int32 functionType = 5;
inline bool itemitem::has_functiontype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void itemitem::set_has_functiontype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void itemitem::clear_has_functiontype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void itemitem::clear_functiontype() {
  functiontype_ = 0;
  clear_has_functiontype();
}
inline ::google::protobuf::int32 itemitem::functiontype() const {
  return functiontype_;
}
inline void itemitem::set_functiontype(::google::protobuf::int32 value) {
  set_has_functiontype();
  functiontype_ = value;
}

// optional string functionValue = 6;
inline bool itemitem::has_functionvalue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void itemitem::set_has_functionvalue() {
  _has_bits_[0] |= 0x00000020u;
}
inline void itemitem::clear_has_functionvalue() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void itemitem::clear_functionvalue() {
  if (functionvalue_ != &::google::protobuf::internal::kEmptyString) {
    functionvalue_->clear();
  }
  clear_has_functionvalue();
}
inline const ::std::string& itemitem::functionvalue() const {
  return *functionvalue_;
}
inline void itemitem::set_functionvalue(const ::std::string& value) {
  set_has_functionvalue();
  if (functionvalue_ == &::google::protobuf::internal::kEmptyString) {
    functionvalue_ = new ::std::string;
  }
  functionvalue_->assign(value);
}
inline void itemitem::set_functionvalue(const char* value) {
  set_has_functionvalue();
  if (functionvalue_ == &::google::protobuf::internal::kEmptyString) {
    functionvalue_ = new ::std::string;
  }
  functionvalue_->assign(value);
}
inline void itemitem::set_functionvalue(const char* value, size_t size) {
  set_has_functionvalue();
  if (functionvalue_ == &::google::protobuf::internal::kEmptyString) {
    functionvalue_ = new ::std::string;
  }
  functionvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* itemitem::mutable_functionvalue() {
  set_has_functionvalue();
  if (functionvalue_ == &::google::protobuf::internal::kEmptyString) {
    functionvalue_ = new ::std::string;
  }
  return functionvalue_;
}
inline ::std::string* itemitem::release_functionvalue() {
  clear_has_functionvalue();
  if (functionvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = functionvalue_;
    functionvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void itemitem::set_allocated_functionvalue(::std::string* functionvalue) {
  if (functionvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete functionvalue_;
  }
  if (functionvalue) {
    set_has_functionvalue();
    functionvalue_ = functionvalue;
  } else {
    clear_has_functionvalue();
    functionvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string usecondition = 7;
inline bool itemitem::has_usecondition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void itemitem::set_has_usecondition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void itemitem::clear_has_usecondition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void itemitem::clear_usecondition() {
  if (usecondition_ != &::google::protobuf::internal::kEmptyString) {
    usecondition_->clear();
  }
  clear_has_usecondition();
}
inline const ::std::string& itemitem::usecondition() const {
  return *usecondition_;
}
inline void itemitem::set_usecondition(const ::std::string& value) {
  set_has_usecondition();
  if (usecondition_ == &::google::protobuf::internal::kEmptyString) {
    usecondition_ = new ::std::string;
  }
  usecondition_->assign(value);
}
inline void itemitem::set_usecondition(const char* value) {
  set_has_usecondition();
  if (usecondition_ == &::google::protobuf::internal::kEmptyString) {
    usecondition_ = new ::std::string;
  }
  usecondition_->assign(value);
}
inline void itemitem::set_usecondition(const char* value, size_t size) {
  set_has_usecondition();
  if (usecondition_ == &::google::protobuf::internal::kEmptyString) {
    usecondition_ = new ::std::string;
  }
  usecondition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* itemitem::mutable_usecondition() {
  set_has_usecondition();
  if (usecondition_ == &::google::protobuf::internal::kEmptyString) {
    usecondition_ = new ::std::string;
  }
  return usecondition_;
}
inline ::std::string* itemitem::release_usecondition() {
  clear_has_usecondition();
  if (usecondition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usecondition_;
    usecondition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void itemitem::set_allocated_usecondition(::std::string* usecondition) {
  if (usecondition_ != &::google::protobuf::internal::kEmptyString) {
    delete usecondition_;
  }
  if (usecondition) {
    set_has_usecondition();
    usecondition_ = usecondition;
  } else {
    clear_has_usecondition();
    usecondition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 8;
inline bool itemitem::has_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void itemitem::set_has_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void itemitem::clear_has_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void itemitem::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 itemitem::level() const {
  return level_;
}
inline void itemitem::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 quality = 9;
inline bool itemitem::has_quality() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void itemitem::set_has_quality() {
  _has_bits_[0] |= 0x00000100u;
}
inline void itemitem::clear_has_quality() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void itemitem::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 itemitem::quality() const {
  return quality_;
}
inline void itemitem::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
}

// optional int32 levelRequest = 10;
inline bool itemitem::has_levelrequest() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void itemitem::set_has_levelrequest() {
  _has_bits_[0] |= 0x00000200u;
}
inline void itemitem::clear_has_levelrequest() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void itemitem::clear_levelrequest() {
  levelrequest_ = 0;
  clear_has_levelrequest();
}
inline ::google::protobuf::int32 itemitem::levelrequest() const {
  return levelrequest_;
}
inline void itemitem::set_levelrequest(::google::protobuf::int32 value) {
  set_has_levelrequest();
  levelrequest_ = value;
}

// optional string profession = 11;
inline bool itemitem::has_profession() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void itemitem::set_has_profession() {
  _has_bits_[0] |= 0x00000400u;
}
inline void itemitem::clear_has_profession() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void itemitem::clear_profession() {
  if (profession_ != &::google::protobuf::internal::kEmptyString) {
    profession_->clear();
  }
  clear_has_profession();
}
inline const ::std::string& itemitem::profession() const {
  return *profession_;
}
inline void itemitem::set_profession(const ::std::string& value) {
  set_has_profession();
  if (profession_ == &::google::protobuf::internal::kEmptyString) {
    profession_ = new ::std::string;
  }
  profession_->assign(value);
}
inline void itemitem::set_profession(const char* value) {
  set_has_profession();
  if (profession_ == &::google::protobuf::internal::kEmptyString) {
    profession_ = new ::std::string;
  }
  profession_->assign(value);
}
inline void itemitem::set_profession(const char* value, size_t size) {
  set_has_profession();
  if (profession_ == &::google::protobuf::internal::kEmptyString) {
    profession_ = new ::std::string;
  }
  profession_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* itemitem::mutable_profession() {
  set_has_profession();
  if (profession_ == &::google::protobuf::internal::kEmptyString) {
    profession_ = new ::std::string;
  }
  return profession_;
}
inline ::std::string* itemitem::release_profession() {
  clear_has_profession();
  if (profession_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = profession_;
    profession_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void itemitem::set_allocated_profession(::std::string* profession) {
  if (profession_ != &::google::protobuf::internal::kEmptyString) {
    delete profession_;
  }
  if (profession) {
    set_has_profession();
    profession_ = profession;
  } else {
    clear_has_profession();
    profession_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 bindType = 12;
inline bool itemitem::has_bindtype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void itemitem::set_has_bindtype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void itemitem::clear_has_bindtype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void itemitem::clear_bindtype() {
  bindtype_ = 0;
  clear_has_bindtype();
}
inline ::google::protobuf::int32 itemitem::bindtype() const {
  return bindtype_;
}
inline void itemitem::set_bindtype(::google::protobuf::int32 value) {
  set_has_bindtype();
  bindtype_ = value;
}

// optional int32 isTradeBind = 13;
inline bool itemitem::has_istradebind() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void itemitem::set_has_istradebind() {
  _has_bits_[0] |= 0x00001000u;
}
inline void itemitem::clear_has_istradebind() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void itemitem::clear_istradebind() {
  istradebind_ = 0;
  clear_has_istradebind();
}
inline ::google::protobuf::int32 itemitem::istradebind() const {
  return istradebind_;
}
inline void itemitem::set_istradebind(::google::protobuf::int32 value) {
  set_has_istradebind();
  istradebind_ = value;
}

// optional int32 stackLimit = 14;
inline bool itemitem::has_stacklimit() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void itemitem::set_has_stacklimit() {
  _has_bits_[0] |= 0x00002000u;
}
inline void itemitem::clear_has_stacklimit() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void itemitem::clear_stacklimit() {
  stacklimit_ = 0;
  clear_has_stacklimit();
}
inline ::google::protobuf::int32 itemitem::stacklimit() const {
  return stacklimit_;
}
inline void itemitem::set_stacklimit(::google::protobuf::int32 value) {
  set_has_stacklimit();
  stacklimit_ = value;
}

// optional int32 sellPrice = 15;
inline bool itemitem::has_sellprice() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void itemitem::set_has_sellprice() {
  _has_bits_[0] |= 0x00004000u;
}
inline void itemitem::clear_has_sellprice() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void itemitem::clear_sellprice() {
  sellprice_ = 0;
  clear_has_sellprice();
}
inline ::google::protobuf::int32 itemitem::sellprice() const {
  return sellprice_;
}
inline void itemitem::set_sellprice(::google::protobuf::int32 value) {
  set_has_sellprice();
  sellprice_ = value;
}

// optional int64 sellBox = 16;
inline bool itemitem::has_sellbox() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void itemitem::set_has_sellbox() {
  _has_bits_[0] |= 0x00008000u;
}
inline void itemitem::clear_has_sellbox() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void itemitem::clear_sellbox() {
  sellbox_ = GOOGLE_LONGLONG(0);
  clear_has_sellbox();
}
inline ::google::protobuf::int64 itemitem::sellbox() const {
  return sellbox_;
}
inline void itemitem::set_sellbox(::google::protobuf::int64 value) {
  set_has_sellbox();
  sellbox_ = value;
}

// optional int32 broadcast = 17;
inline bool itemitem::has_broadcast() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void itemitem::set_has_broadcast() {
  _has_bits_[0] |= 0x00010000u;
}
inline void itemitem::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void itemitem::clear_broadcast() {
  broadcast_ = 0;
  clear_has_broadcast();
}
inline ::google::protobuf::int32 itemitem::broadcast() const {
  return broadcast_;
}
inline void itemitem::set_broadcast(::google::protobuf::int32 value) {
  set_has_broadcast();
  broadcast_ = value;
}

// optional int32 isCanBatchUse = 18;
inline bool itemitem::has_iscanbatchuse() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void itemitem::set_has_iscanbatchuse() {
  _has_bits_[0] |= 0x00020000u;
}
inline void itemitem::clear_has_iscanbatchuse() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void itemitem::clear_iscanbatchuse() {
  iscanbatchuse_ = 0;
  clear_has_iscanbatchuse();
}
inline ::google::protobuf::int32 itemitem::iscanbatchuse() const {
  return iscanbatchuse_;
}
inline void itemitem::set_iscanbatchuse(::google::protobuf::int32 value) {
  set_has_iscanbatchuse();
  iscanbatchuse_ = value;
}

// optional int32 dayUse = 19;
inline bool itemitem::has_dayuse() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void itemitem::set_has_dayuse() {
  _has_bits_[0] |= 0x00040000u;
}
inline void itemitem::clear_has_dayuse() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void itemitem::clear_dayuse() {
  dayuse_ = 0;
  clear_has_dayuse();
}
inline ::google::protobuf::int32 itemitem::dayuse() const {
  return dayuse_;
}
inline void itemitem::set_dayuse(::google::protobuf::int32 value) {
  set_has_dayuse();
  dayuse_ = value;
}

// optional int32 outTime = 20;
inline bool itemitem::has_outtime() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void itemitem::set_has_outtime() {
  _has_bits_[0] |= 0x00080000u;
}
inline void itemitem::clear_has_outtime() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void itemitem::clear_outtime() {
  outtime_ = 0;
  clear_has_outtime();
}
inline ::google::protobuf::int32 itemitem::outtime() const {
  return outtime_;
}
inline void itemitem::set_outtime(::google::protobuf::int32 value) {
  set_has_outtime();
  outtime_ = value;
}

// optional string useLimit = 21;
inline bool itemitem::has_uselimit() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void itemitem::set_has_uselimit() {
  _has_bits_[0] |= 0x00100000u;
}
inline void itemitem::clear_has_uselimit() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void itemitem::clear_uselimit() {
  if (uselimit_ != &::google::protobuf::internal::kEmptyString) {
    uselimit_->clear();
  }
  clear_has_uselimit();
}
inline const ::std::string& itemitem::uselimit() const {
  return *uselimit_;
}
inline void itemitem::set_uselimit(const ::std::string& value) {
  set_has_uselimit();
  if (uselimit_ == &::google::protobuf::internal::kEmptyString) {
    uselimit_ = new ::std::string;
  }
  uselimit_->assign(value);
}
inline void itemitem::set_uselimit(const char* value) {
  set_has_uselimit();
  if (uselimit_ == &::google::protobuf::internal::kEmptyString) {
    uselimit_ = new ::std::string;
  }
  uselimit_->assign(value);
}
inline void itemitem::set_uselimit(const char* value, size_t size) {
  set_has_uselimit();
  if (uselimit_ == &::google::protobuf::internal::kEmptyString) {
    uselimit_ = new ::std::string;
  }
  uselimit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* itemitem::mutable_uselimit() {
  set_has_uselimit();
  if (uselimit_ == &::google::protobuf::internal::kEmptyString) {
    uselimit_ = new ::std::string;
  }
  return uselimit_;
}
inline ::std::string* itemitem::release_uselimit() {
  clear_has_uselimit();
  if (uselimit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uselimit_;
    uselimit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void itemitem::set_allocated_uselimit(::std::string* uselimit) {
  if (uselimit_ != &::google::protobuf::internal::kEmptyString) {
    delete uselimit_;
  }
  if (uselimit) {
    set_has_uselimit();
    uselimit_ = uselimit;
  } else {
    clear_has_uselimit();
    uselimit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 blessing = 22;
inline bool itemitem::has_blessing() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void itemitem::set_has_blessing() {
  _has_bits_[0] |= 0x00200000u;
}
inline void itemitem::clear_has_blessing() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void itemitem::clear_blessing() {
  blessing_ = 0;
  clear_has_blessing();
}
inline ::google::protobuf::int32 itemitem::blessing() const {
  return blessing_;
}
inline void itemitem::set_blessing(::google::protobuf::int32 value) {
  set_has_blessing();
  blessing_ = value;
}

// optional int32 invest = 23;
inline bool itemitem::has_invest() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void itemitem::set_has_invest() {
  _has_bits_[0] |= 0x00400000u;
}
inline void itemitem::clear_has_invest() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void itemitem::clear_invest() {
  invest_ = 0;
  clear_has_invest();
}
inline ::google::protobuf::int32 itemitem::invest() const {
  return invest_;
}
inline void itemitem::set_invest(::google::protobuf::int32 value) {
  set_has_invest();
  invest_ = value;
}

// optional int32 exchange = 24;
inline bool itemitem::has_exchange() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void itemitem::set_has_exchange() {
  _has_bits_[0] |= 0x00800000u;
}
inline void itemitem::clear_has_exchange() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void itemitem::clear_exchange() {
  exchange_ = 0;
  clear_has_exchange();
}
inline ::google::protobuf::int32 itemitem::exchange() const {
  return exchange_;
}
inline void itemitem::set_exchange(::google::protobuf::int32 value) {
  set_has_exchange();
  exchange_ = value;
}

// -------------------------------------------------------------------

// Sheet_itemitem

// repeated .proto_ff.itemitem itemitem_List = 1;
inline int Sheet_itemitem::itemitem_list_size() const {
  return itemitem_list_.size();
}
inline void Sheet_itemitem::clear_itemitem_list() {
  itemitem_list_.Clear();
}
inline const ::proto_ff::itemitem& Sheet_itemitem::itemitem_list(int index) const {
  return itemitem_list_.Get(index);
}
inline ::proto_ff::itemitem* Sheet_itemitem::mutable_itemitem_list(int index) {
  return itemitem_list_.Mutable(index);
}
inline ::proto_ff::itemitem* Sheet_itemitem::add_itemitem_list() {
  return itemitem_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::itemitem >&
Sheet_itemitem::itemitem_list() const {
  return itemitem_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::itemitem >*
Sheet_itemitem::mutable_itemitem_list() {
  return &itemitem_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_item_2eproto__INCLUDED
