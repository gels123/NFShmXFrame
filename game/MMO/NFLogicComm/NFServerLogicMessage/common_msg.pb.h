// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common_msg.proto

#ifndef PROTOBUF_common_5fmsg_2eproto__INCLUDED
#define PROTOBUF_common_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "yd_fieldoptions.pb.h"
#include "common_logic.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_5fmsg_2eproto();
void protobuf_AssignDesc_common_5fmsg_2eproto();
void protobuf_ShutdownFile_common_5fmsg_2eproto();

class ClientToLogInfoProto;
class PingRsp;
class ClientLoginGateReq;

// ===================================================================

class ClientToLogInfoProto : public ::google::protobuf::Message {
 public:
  ClientToLogInfoProto();
  virtual ~ClientToLogInfoProto();

  ClientToLogInfoProto(const ClientToLogInfoProto& from);

  inline ClientToLogInfoProto& operator=(const ClientToLogInfoProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToLogInfoProto& default_instance();

  void Swap(ClientToLogInfoProto* other);

  // implements Message ----------------------------------------------

  ClientToLogInfoProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientToLogInfoProto& from);
  void MergeFrom(const ClientToLogInfoProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string os_name = 1;
  inline bool has_os_name() const;
  inline void clear_os_name();
  static const int kOsNameFieldNumber = 1;
  inline const ::std::string& os_name() const;
  inline void set_os_name(const ::std::string& value);
  inline void set_os_name(const char* value);
  inline void set_os_name(const char* value, size_t size);
  inline ::std::string* mutable_os_name();
  inline ::std::string* release_os_name();
  inline void set_allocated_os_name(::std::string* os_name);

  // optional string os_ver = 2;
  inline bool has_os_ver() const;
  inline void clear_os_ver();
  static const int kOsVerFieldNumber = 2;
  inline const ::std::string& os_ver() const;
  inline void set_os_ver(const ::std::string& value);
  inline void set_os_ver(const char* value);
  inline void set_os_ver(const char* value, size_t size);
  inline ::std::string* mutable_os_ver();
  inline ::std::string* release_os_ver();
  inline void set_allocated_os_ver(::std::string* os_ver);

  // optional string mac_addr = 3;
  inline bool has_mac_addr() const;
  inline void clear_mac_addr();
  static const int kMacAddrFieldNumber = 3;
  inline const ::std::string& mac_addr() const;
  inline void set_mac_addr(const ::std::string& value);
  inline void set_mac_addr(const char* value);
  inline void set_mac_addr(const char* value, size_t size);
  inline ::std::string* mutable_mac_addr();
  inline ::std::string* release_mac_addr();
  inline void set_allocated_mac_addr(::std::string* mac_addr);

  // optional string udid = 4;
  inline bool has_udid() const;
  inline void clear_udid();
  static const int kUdidFieldNumber = 4;
  inline const ::std::string& udid() const;
  inline void set_udid(const ::std::string& value);
  inline void set_udid(const char* value);
  inline void set_udid(const char* value, size_t size);
  inline ::std::string* mutable_udid();
  inline ::std::string* release_udid();
  inline void set_allocated_udid(::std::string* udid);

  // optional string device_model = 5;
  inline bool has_device_model() const;
  inline void clear_device_model();
  static const int kDeviceModelFieldNumber = 5;
  inline const ::std::string& device_model() const;
  inline void set_device_model(const ::std::string& value);
  inline void set_device_model(const char* value);
  inline void set_device_model(const char* value, size_t size);
  inline ::std::string* mutable_device_model();
  inline ::std::string* release_device_model();
  inline void set_allocated_device_model(::std::string* device_model);

  // optional string ip = 6;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 6;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string app_channel = 7;
  inline bool has_app_channel() const;
  inline void clear_app_channel();
  static const int kAppChannelFieldNumber = 7;
  inline const ::std::string& app_channel() const;
  inline void set_app_channel(const ::std::string& value);
  inline void set_app_channel(const char* value);
  inline void set_app_channel(const char* value, size_t size);
  inline ::std::string* mutable_app_channel();
  inline ::std::string* release_app_channel();
  inline void set_allocated_app_channel(::std::string* app_channel);

  // optional string app_ver = 8;
  inline bool has_app_ver() const;
  inline void clear_app_ver();
  static const int kAppVerFieldNumber = 8;
  inline const ::std::string& app_ver() const;
  inline void set_app_ver(const ::std::string& value);
  inline void set_app_ver(const char* value);
  inline void set_app_ver(const char* value, size_t size);
  inline ::std::string* mutable_app_ver();
  inline ::std::string* release_app_ver();
  inline void set_allocated_app_ver(::std::string* app_ver);

  // optional string network = 9;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 9;
  inline const ::std::string& network() const;
  inline void set_network(const ::std::string& value);
  inline void set_network(const char* value);
  inline void set_network(const char* value, size_t size);
  inline ::std::string* mutable_network();
  inline ::std::string* release_network();
  inline void set_allocated_network(::std::string* network);

  // optional string platform_tag = 10;
  inline bool has_platform_tag() const;
  inline void clear_platform_tag();
  static const int kPlatformTagFieldNumber = 10;
  inline const ::std::string& platform_tag() const;
  inline void set_platform_tag(const ::std::string& value);
  inline void set_platform_tag(const char* value);
  inline void set_platform_tag(const char* value, size_t size);
  inline ::std::string* mutable_platform_tag();
  inline ::std::string* release_platform_tag();
  inline void set_allocated_platform_tag(::std::string* platform_tag);

  // optional int32 group_id = 11;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 11;
  inline ::google::protobuf::int32 group_id() const;
  inline void set_group_id(::google::protobuf::int32 value);

  // optional int32 channel_id = 12;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 12;
  inline ::google::protobuf::int32 channel_id() const;
  inline void set_channel_id(::google::protobuf::int32 value);

  // optional int32 active_time = 13;
  inline bool has_active_time() const;
  inline void clear_active_time();
  static const int kActiveTimeFieldNumber = 13;
  inline ::google::protobuf::int32 active_time() const;
  inline void set_active_time(::google::protobuf::int32 value);

  // optional string device_screen = 14;
  inline bool has_device_screen() const;
  inline void clear_device_screen();
  static const int kDeviceScreenFieldNumber = 14;
  inline const ::std::string& device_screen() const;
  inline void set_device_screen(const ::std::string& value);
  inline void set_device_screen(const char* value);
  inline void set_device_screen(const char* value, size_t size);
  inline ::std::string* mutable_device_screen();
  inline ::std::string* release_device_screen();
  inline void set_allocated_device_screen(::std::string* device_screen);

  // optional string idfa = 15;
  inline bool has_idfa() const;
  inline void clear_idfa();
  static const int kIdfaFieldNumber = 15;
  inline const ::std::string& idfa() const;
  inline void set_idfa(const ::std::string& value);
  inline void set_idfa(const char* value);
  inline void set_idfa(const char* value, size_t size);
  inline ::std::string* mutable_idfa();
  inline ::std::string* release_idfa();
  inline void set_allocated_idfa(::std::string* idfa);

  // optional string imei = 16;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 16;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional uint32 port = 17;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 17;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ClientToLogInfoProto)
 private:
  inline void set_has_os_name();
  inline void clear_has_os_name();
  inline void set_has_os_ver();
  inline void clear_has_os_ver();
  inline void set_has_mac_addr();
  inline void clear_has_mac_addr();
  inline void set_has_udid();
  inline void clear_has_udid();
  inline void set_has_device_model();
  inline void clear_has_device_model();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_app_channel();
  inline void clear_has_app_channel();
  inline void set_has_app_ver();
  inline void clear_has_app_ver();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_platform_tag();
  inline void clear_has_platform_tag();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_active_time();
  inline void clear_has_active_time();
  inline void set_has_device_screen();
  inline void clear_has_device_screen();
  inline void set_has_idfa();
  inline void clear_has_idfa();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* os_name_;
  ::std::string* os_ver_;
  ::std::string* mac_addr_;
  ::std::string* udid_;
  ::std::string* device_model_;
  ::std::string* ip_;
  ::std::string* app_channel_;
  ::std::string* app_ver_;
  ::std::string* network_;
  ::std::string* platform_tag_;
  ::google::protobuf::int32 group_id_;
  ::google::protobuf::int32 channel_id_;
  ::std::string* device_screen_;
  ::std::string* idfa_;
  ::google::protobuf::int32 active_time_;
  ::google::protobuf::uint32 port_;
  ::std::string* imei_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_common_5fmsg_2eproto();
  friend void protobuf_AssignDesc_common_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_common_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static ClientToLogInfoProto* default_instance_;
};
// -------------------------------------------------------------------

class PingRsp : public ::google::protobuf::Message {
 public:
  PingRsp();
  virtual ~PingRsp();

  PingRsp(const PingRsp& from);

  inline PingRsp& operator=(const PingRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingRsp& default_instance();

  void Swap(PingRsp* other);

  // implements Message ----------------------------------------------

  PingRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PingRsp& from);
  void MergeFrom(const PingRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 currentmsTime = 1;
  inline bool has_currentmstime() const;
  inline void clear_currentmstime();
  static const int kCurrentmsTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 currentmstime() const;
  inline void set_currentmstime(::google::protobuf::uint64 value);

  // optional uint32 queuereducenum = 2;
  inline bool has_queuereducenum() const;
  inline void clear_queuereducenum();
  static const int kQueuereducenumFieldNumber = 2;
  inline ::google::protobuf::uint32 queuereducenum() const;
  inline void set_queuereducenum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.PingRsp)
 private:
  inline void set_has_currentmstime();
  inline void clear_has_currentmstime();
  inline void set_has_queuereducenum();
  inline void clear_has_queuereducenum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 currentmstime_;
  ::google::protobuf::uint32 queuereducenum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_5fmsg_2eproto();
  friend void protobuf_AssignDesc_common_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_common_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static PingRsp* default_instance_;
};
// -------------------------------------------------------------------

class ClientLoginGateReq : public ::google::protobuf::Message {
 public:
  ClientLoginGateReq();
  virtual ~ClientLoginGateReq();

  ClientLoginGateReq(const ClientLoginGateReq& from);

  inline ClientLoginGateReq& operator=(const ClientLoginGateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientLoginGateReq& default_instance();

  void Swap(ClientLoginGateReq* other);

  // implements Message ----------------------------------------------

  ClientLoginGateReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientLoginGateReq& from);
  void MergeFrom(const ClientLoginGateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // required uint32 channelId = 2;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIdFieldNumber = 2;
  inline ::google::protobuf::uint32 channelid() const;
  inline void set_channelid(::google::protobuf::uint32 value);

  // required string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required uint64 loginTimeStamp = 4;
  inline bool has_logintimestamp() const;
  inline void clear_logintimestamp();
  static const int kLoginTimeStampFieldNumber = 4;
  inline ::google::protobuf::uint64 logintimestamp() const;
  inline void set_logintimestamp(::google::protobuf::uint64 value);

  // required uint32 gateId = 5;
  inline bool has_gateid() const;
  inline void clear_gateid();
  static const int kGateIdFieldNumber = 5;
  inline ::google::protobuf::uint32 gateid() const;
  inline void set_gateid(::google::protobuf::uint32 value);

  // optional string clientSdkString = 6;
  inline bool has_clientsdkstring() const;
  inline void clear_clientsdkstring();
  static const int kClientSdkStringFieldNumber = 6;
  inline const ::std::string& clientsdkstring() const;
  inline void set_clientsdkstring(const ::std::string& value);
  inline void set_clientsdkstring(const char* value);
  inline void set_clientsdkstring(const char* value, size_t size);
  inline ::std::string* mutable_clientsdkstring();
  inline ::std::string* release_clientsdkstring();
  inline void set_allocated_clientsdkstring(::std::string* clientsdkstring);

  // optional string srvSdkString = 7;
  inline bool has_srvsdkstring() const;
  inline void clear_srvsdkstring();
  static const int kSrvSdkStringFieldNumber = 7;
  inline const ::std::string& srvsdkstring() const;
  inline void set_srvsdkstring(const ::std::string& value);
  inline void set_srvsdkstring(const char* value);
  inline void set_srvsdkstring(const char* value, size_t size);
  inline ::std::string* mutable_srvsdkstring();
  inline ::std::string* release_srvsdkstring();
  inline void set_allocated_srvsdkstring(::std::string* srvsdkstring);

  // optional uint32 version = 8;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 8;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional .proto_ff.ClientToLogInfoProto loginfo = 9;
  inline bool has_loginfo() const;
  inline void clear_loginfo();
  static const int kLoginfoFieldNumber = 9;
  inline const ::proto_ff::ClientToLogInfoProto& loginfo() const;
  inline ::proto_ff::ClientToLogInfoProto* mutable_loginfo();
  inline ::proto_ff::ClientToLogInfoProto* release_loginfo();
  inline void set_allocated_loginfo(::proto_ff::ClientToLogInfoProto* loginfo);

  // @@protoc_insertion_point(class_scope:proto_ff.ClientLoginGateReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_logintimestamp();
  inline void clear_has_logintimestamp();
  inline void set_has_gateid();
  inline void clear_has_gateid();
  inline void set_has_clientsdkstring();
  inline void clear_has_clientsdkstring();
  inline void set_has_srvsdkstring();
  inline void clear_has_srvsdkstring();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_loginfo();
  inline void clear_has_loginfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 channelid_;
  ::std::string* token_;
  ::google::protobuf::uint64 logintimestamp_;
  ::std::string* clientsdkstring_;
  ::google::protobuf::uint32 gateid_;
  ::google::protobuf::uint32 version_;
  ::std::string* srvsdkstring_;
  ::proto_ff::ClientToLogInfoProto* loginfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_common_5fmsg_2eproto();
  friend void protobuf_AssignDesc_common_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_common_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static ClientLoginGateReq* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientToLogInfoProto

// optional string os_name = 1;
inline bool ClientToLogInfoProto::has_os_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToLogInfoProto::set_has_os_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToLogInfoProto::clear_has_os_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToLogInfoProto::clear_os_name() {
  if (os_name_ != &::google::protobuf::internal::kEmptyString) {
    os_name_->clear();
  }
  clear_has_os_name();
}
inline const ::std::string& ClientToLogInfoProto::os_name() const {
  return *os_name_;
}
inline void ClientToLogInfoProto::set_os_name(const ::std::string& value) {
  set_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    os_name_ = new ::std::string;
  }
  os_name_->assign(value);
}
inline void ClientToLogInfoProto::set_os_name(const char* value) {
  set_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    os_name_ = new ::std::string;
  }
  os_name_->assign(value);
}
inline void ClientToLogInfoProto::set_os_name(const char* value, size_t size) {
  set_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    os_name_ = new ::std::string;
  }
  os_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_os_name() {
  set_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    os_name_ = new ::std::string;
  }
  return os_name_;
}
inline ::std::string* ClientToLogInfoProto::release_os_name() {
  clear_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_name_;
    os_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_os_name(::std::string* os_name) {
  if (os_name_ != &::google::protobuf::internal::kEmptyString) {
    delete os_name_;
  }
  if (os_name) {
    set_has_os_name();
    os_name_ = os_name;
  } else {
    clear_has_os_name();
    os_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string os_ver = 2;
inline bool ClientToLogInfoProto::has_os_ver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientToLogInfoProto::set_has_os_ver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientToLogInfoProto::clear_has_os_ver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientToLogInfoProto::clear_os_ver() {
  if (os_ver_ != &::google::protobuf::internal::kEmptyString) {
    os_ver_->clear();
  }
  clear_has_os_ver();
}
inline const ::std::string& ClientToLogInfoProto::os_ver() const {
  return *os_ver_;
}
inline void ClientToLogInfoProto::set_os_ver(const ::std::string& value) {
  set_has_os_ver();
  if (os_ver_ == &::google::protobuf::internal::kEmptyString) {
    os_ver_ = new ::std::string;
  }
  os_ver_->assign(value);
}
inline void ClientToLogInfoProto::set_os_ver(const char* value) {
  set_has_os_ver();
  if (os_ver_ == &::google::protobuf::internal::kEmptyString) {
    os_ver_ = new ::std::string;
  }
  os_ver_->assign(value);
}
inline void ClientToLogInfoProto::set_os_ver(const char* value, size_t size) {
  set_has_os_ver();
  if (os_ver_ == &::google::protobuf::internal::kEmptyString) {
    os_ver_ = new ::std::string;
  }
  os_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_os_ver() {
  set_has_os_ver();
  if (os_ver_ == &::google::protobuf::internal::kEmptyString) {
    os_ver_ = new ::std::string;
  }
  return os_ver_;
}
inline ::std::string* ClientToLogInfoProto::release_os_ver() {
  clear_has_os_ver();
  if (os_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_ver_;
    os_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_os_ver(::std::string* os_ver) {
  if (os_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete os_ver_;
  }
  if (os_ver) {
    set_has_os_ver();
    os_ver_ = os_ver;
  } else {
    clear_has_os_ver();
    os_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mac_addr = 3;
inline bool ClientToLogInfoProto::has_mac_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientToLogInfoProto::set_has_mac_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientToLogInfoProto::clear_has_mac_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientToLogInfoProto::clear_mac_addr() {
  if (mac_addr_ != &::google::protobuf::internal::kEmptyString) {
    mac_addr_->clear();
  }
  clear_has_mac_addr();
}
inline const ::std::string& ClientToLogInfoProto::mac_addr() const {
  return *mac_addr_;
}
inline void ClientToLogInfoProto::set_mac_addr(const ::std::string& value) {
  set_has_mac_addr();
  if (mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    mac_addr_ = new ::std::string;
  }
  mac_addr_->assign(value);
}
inline void ClientToLogInfoProto::set_mac_addr(const char* value) {
  set_has_mac_addr();
  if (mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    mac_addr_ = new ::std::string;
  }
  mac_addr_->assign(value);
}
inline void ClientToLogInfoProto::set_mac_addr(const char* value, size_t size) {
  set_has_mac_addr();
  if (mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    mac_addr_ = new ::std::string;
  }
  mac_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_mac_addr() {
  set_has_mac_addr();
  if (mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    mac_addr_ = new ::std::string;
  }
  return mac_addr_;
}
inline ::std::string* ClientToLogInfoProto::release_mac_addr() {
  clear_has_mac_addr();
  if (mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_addr_;
    mac_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_mac_addr(::std::string* mac_addr) {
  if (mac_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_addr_;
  }
  if (mac_addr) {
    set_has_mac_addr();
    mac_addr_ = mac_addr;
  } else {
    clear_has_mac_addr();
    mac_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string udid = 4;
inline bool ClientToLogInfoProto::has_udid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientToLogInfoProto::set_has_udid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientToLogInfoProto::clear_has_udid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientToLogInfoProto::clear_udid() {
  if (udid_ != &::google::protobuf::internal::kEmptyString) {
    udid_->clear();
  }
  clear_has_udid();
}
inline const ::std::string& ClientToLogInfoProto::udid() const {
  return *udid_;
}
inline void ClientToLogInfoProto::set_udid(const ::std::string& value) {
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(value);
}
inline void ClientToLogInfoProto::set_udid(const char* value) {
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(value);
}
inline void ClientToLogInfoProto::set_udid(const char* value, size_t size) {
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_udid() {
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  return udid_;
}
inline ::std::string* ClientToLogInfoProto::release_udid() {
  clear_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = udid_;
    udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_udid(::std::string* udid) {
  if (udid_ != &::google::protobuf::internal::kEmptyString) {
    delete udid_;
  }
  if (udid) {
    set_has_udid();
    udid_ = udid;
  } else {
    clear_has_udid();
    udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_model = 5;
inline bool ClientToLogInfoProto::has_device_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientToLogInfoProto::set_has_device_model() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientToLogInfoProto::clear_has_device_model() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientToLogInfoProto::clear_device_model() {
  if (device_model_ != &::google::protobuf::internal::kEmptyString) {
    device_model_->clear();
  }
  clear_has_device_model();
}
inline const ::std::string& ClientToLogInfoProto::device_model() const {
  return *device_model_;
}
inline void ClientToLogInfoProto::set_device_model(const ::std::string& value) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(value);
}
inline void ClientToLogInfoProto::set_device_model(const char* value) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(value);
}
inline void ClientToLogInfoProto::set_device_model(const char* value, size_t size) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_device_model() {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  return device_model_;
}
inline ::std::string* ClientToLogInfoProto::release_device_model() {
  clear_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_model_;
    device_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_device_model(::std::string* device_model) {
  if (device_model_ != &::google::protobuf::internal::kEmptyString) {
    delete device_model_;
  }
  if (device_model) {
    set_has_device_model();
    device_model_ = device_model;
  } else {
    clear_has_device_model();
    device_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 6;
inline bool ClientToLogInfoProto::has_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientToLogInfoProto::set_has_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientToLogInfoProto::clear_has_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientToLogInfoProto::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& ClientToLogInfoProto::ip() const {
  return *ip_;
}
inline void ClientToLogInfoProto::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void ClientToLogInfoProto::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void ClientToLogInfoProto::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* ClientToLogInfoProto::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string app_channel = 7;
inline bool ClientToLogInfoProto::has_app_channel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientToLogInfoProto::set_has_app_channel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientToLogInfoProto::clear_has_app_channel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientToLogInfoProto::clear_app_channel() {
  if (app_channel_ != &::google::protobuf::internal::kEmptyString) {
    app_channel_->clear();
  }
  clear_has_app_channel();
}
inline const ::std::string& ClientToLogInfoProto::app_channel() const {
  return *app_channel_;
}
inline void ClientToLogInfoProto::set_app_channel(const ::std::string& value) {
  set_has_app_channel();
  if (app_channel_ == &::google::protobuf::internal::kEmptyString) {
    app_channel_ = new ::std::string;
  }
  app_channel_->assign(value);
}
inline void ClientToLogInfoProto::set_app_channel(const char* value) {
  set_has_app_channel();
  if (app_channel_ == &::google::protobuf::internal::kEmptyString) {
    app_channel_ = new ::std::string;
  }
  app_channel_->assign(value);
}
inline void ClientToLogInfoProto::set_app_channel(const char* value, size_t size) {
  set_has_app_channel();
  if (app_channel_ == &::google::protobuf::internal::kEmptyString) {
    app_channel_ = new ::std::string;
  }
  app_channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_app_channel() {
  set_has_app_channel();
  if (app_channel_ == &::google::protobuf::internal::kEmptyString) {
    app_channel_ = new ::std::string;
  }
  return app_channel_;
}
inline ::std::string* ClientToLogInfoProto::release_app_channel() {
  clear_has_app_channel();
  if (app_channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_channel_;
    app_channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_app_channel(::std::string* app_channel) {
  if (app_channel_ != &::google::protobuf::internal::kEmptyString) {
    delete app_channel_;
  }
  if (app_channel) {
    set_has_app_channel();
    app_channel_ = app_channel;
  } else {
    clear_has_app_channel();
    app_channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string app_ver = 8;
inline bool ClientToLogInfoProto::has_app_ver() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientToLogInfoProto::set_has_app_ver() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientToLogInfoProto::clear_has_app_ver() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientToLogInfoProto::clear_app_ver() {
  if (app_ver_ != &::google::protobuf::internal::kEmptyString) {
    app_ver_->clear();
  }
  clear_has_app_ver();
}
inline const ::std::string& ClientToLogInfoProto::app_ver() const {
  return *app_ver_;
}
inline void ClientToLogInfoProto::set_app_ver(const ::std::string& value) {
  set_has_app_ver();
  if (app_ver_ == &::google::protobuf::internal::kEmptyString) {
    app_ver_ = new ::std::string;
  }
  app_ver_->assign(value);
}
inline void ClientToLogInfoProto::set_app_ver(const char* value) {
  set_has_app_ver();
  if (app_ver_ == &::google::protobuf::internal::kEmptyString) {
    app_ver_ = new ::std::string;
  }
  app_ver_->assign(value);
}
inline void ClientToLogInfoProto::set_app_ver(const char* value, size_t size) {
  set_has_app_ver();
  if (app_ver_ == &::google::protobuf::internal::kEmptyString) {
    app_ver_ = new ::std::string;
  }
  app_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_app_ver() {
  set_has_app_ver();
  if (app_ver_ == &::google::protobuf::internal::kEmptyString) {
    app_ver_ = new ::std::string;
  }
  return app_ver_;
}
inline ::std::string* ClientToLogInfoProto::release_app_ver() {
  clear_has_app_ver();
  if (app_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_ver_;
    app_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_app_ver(::std::string* app_ver) {
  if (app_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete app_ver_;
  }
  if (app_ver) {
    set_has_app_ver();
    app_ver_ = app_ver;
  } else {
    clear_has_app_ver();
    app_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string network = 9;
inline bool ClientToLogInfoProto::has_network() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientToLogInfoProto::set_has_network() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientToLogInfoProto::clear_has_network() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientToLogInfoProto::clear_network() {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    network_->clear();
  }
  clear_has_network();
}
inline const ::std::string& ClientToLogInfoProto::network() const {
  return *network_;
}
inline void ClientToLogInfoProto::set_network(const ::std::string& value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void ClientToLogInfoProto::set_network(const char* value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void ClientToLogInfoProto::set_network(const char* value, size_t size) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_network() {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  return network_;
}
inline ::std::string* ClientToLogInfoProto::release_network() {
  clear_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_;
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_network(::std::string* network) {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    delete network_;
  }
  if (network) {
    set_has_network();
    network_ = network;
  } else {
    clear_has_network();
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string platform_tag = 10;
inline bool ClientToLogInfoProto::has_platform_tag() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientToLogInfoProto::set_has_platform_tag() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientToLogInfoProto::clear_has_platform_tag() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientToLogInfoProto::clear_platform_tag() {
  if (platform_tag_ != &::google::protobuf::internal::kEmptyString) {
    platform_tag_->clear();
  }
  clear_has_platform_tag();
}
inline const ::std::string& ClientToLogInfoProto::platform_tag() const {
  return *platform_tag_;
}
inline void ClientToLogInfoProto::set_platform_tag(const ::std::string& value) {
  set_has_platform_tag();
  if (platform_tag_ == &::google::protobuf::internal::kEmptyString) {
    platform_tag_ = new ::std::string;
  }
  platform_tag_->assign(value);
}
inline void ClientToLogInfoProto::set_platform_tag(const char* value) {
  set_has_platform_tag();
  if (platform_tag_ == &::google::protobuf::internal::kEmptyString) {
    platform_tag_ = new ::std::string;
  }
  platform_tag_->assign(value);
}
inline void ClientToLogInfoProto::set_platform_tag(const char* value, size_t size) {
  set_has_platform_tag();
  if (platform_tag_ == &::google::protobuf::internal::kEmptyString) {
    platform_tag_ = new ::std::string;
  }
  platform_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_platform_tag() {
  set_has_platform_tag();
  if (platform_tag_ == &::google::protobuf::internal::kEmptyString) {
    platform_tag_ = new ::std::string;
  }
  return platform_tag_;
}
inline ::std::string* ClientToLogInfoProto::release_platform_tag() {
  clear_has_platform_tag();
  if (platform_tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_tag_;
    platform_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_platform_tag(::std::string* platform_tag) {
  if (platform_tag_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_tag_;
  }
  if (platform_tag) {
    set_has_platform_tag();
    platform_tag_ = platform_tag;
  } else {
    clear_has_platform_tag();
    platform_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 group_id = 11;
inline bool ClientToLogInfoProto::has_group_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientToLogInfoProto::set_has_group_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientToLogInfoProto::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientToLogInfoProto::clear_group_id() {
  group_id_ = 0;
  clear_has_group_id();
}
inline ::google::protobuf::int32 ClientToLogInfoProto::group_id() const {
  return group_id_;
}
inline void ClientToLogInfoProto::set_group_id(::google::protobuf::int32 value) {
  set_has_group_id();
  group_id_ = value;
}

// optional int32 channel_id = 12;
inline bool ClientToLogInfoProto::has_channel_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClientToLogInfoProto::set_has_channel_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ClientToLogInfoProto::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ClientToLogInfoProto::clear_channel_id() {
  channel_id_ = 0;
  clear_has_channel_id();
}
inline ::google::protobuf::int32 ClientToLogInfoProto::channel_id() const {
  return channel_id_;
}
inline void ClientToLogInfoProto::set_channel_id(::google::protobuf::int32 value) {
  set_has_channel_id();
  channel_id_ = value;
}

// optional int32 active_time = 13;
inline bool ClientToLogInfoProto::has_active_time() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ClientToLogInfoProto::set_has_active_time() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ClientToLogInfoProto::clear_has_active_time() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ClientToLogInfoProto::clear_active_time() {
  active_time_ = 0;
  clear_has_active_time();
}
inline ::google::protobuf::int32 ClientToLogInfoProto::active_time() const {
  return active_time_;
}
inline void ClientToLogInfoProto::set_active_time(::google::protobuf::int32 value) {
  set_has_active_time();
  active_time_ = value;
}

// optional string device_screen = 14;
inline bool ClientToLogInfoProto::has_device_screen() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ClientToLogInfoProto::set_has_device_screen() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ClientToLogInfoProto::clear_has_device_screen() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ClientToLogInfoProto::clear_device_screen() {
  if (device_screen_ != &::google::protobuf::internal::kEmptyString) {
    device_screen_->clear();
  }
  clear_has_device_screen();
}
inline const ::std::string& ClientToLogInfoProto::device_screen() const {
  return *device_screen_;
}
inline void ClientToLogInfoProto::set_device_screen(const ::std::string& value) {
  set_has_device_screen();
  if (device_screen_ == &::google::protobuf::internal::kEmptyString) {
    device_screen_ = new ::std::string;
  }
  device_screen_->assign(value);
}
inline void ClientToLogInfoProto::set_device_screen(const char* value) {
  set_has_device_screen();
  if (device_screen_ == &::google::protobuf::internal::kEmptyString) {
    device_screen_ = new ::std::string;
  }
  device_screen_->assign(value);
}
inline void ClientToLogInfoProto::set_device_screen(const char* value, size_t size) {
  set_has_device_screen();
  if (device_screen_ == &::google::protobuf::internal::kEmptyString) {
    device_screen_ = new ::std::string;
  }
  device_screen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_device_screen() {
  set_has_device_screen();
  if (device_screen_ == &::google::protobuf::internal::kEmptyString) {
    device_screen_ = new ::std::string;
  }
  return device_screen_;
}
inline ::std::string* ClientToLogInfoProto::release_device_screen() {
  clear_has_device_screen();
  if (device_screen_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_screen_;
    device_screen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_device_screen(::std::string* device_screen) {
  if (device_screen_ != &::google::protobuf::internal::kEmptyString) {
    delete device_screen_;
  }
  if (device_screen) {
    set_has_device_screen();
    device_screen_ = device_screen;
  } else {
    clear_has_device_screen();
    device_screen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string idfa = 15;
inline bool ClientToLogInfoProto::has_idfa() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ClientToLogInfoProto::set_has_idfa() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ClientToLogInfoProto::clear_has_idfa() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ClientToLogInfoProto::clear_idfa() {
  if (idfa_ != &::google::protobuf::internal::kEmptyString) {
    idfa_->clear();
  }
  clear_has_idfa();
}
inline const ::std::string& ClientToLogInfoProto::idfa() const {
  return *idfa_;
}
inline void ClientToLogInfoProto::set_idfa(const ::std::string& value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
}
inline void ClientToLogInfoProto::set_idfa(const char* value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
}
inline void ClientToLogInfoProto::set_idfa(const char* value, size_t size) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_idfa() {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  return idfa_;
}
inline ::std::string* ClientToLogInfoProto::release_idfa() {
  clear_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idfa_;
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_idfa(::std::string* idfa) {
  if (idfa_ != &::google::protobuf::internal::kEmptyString) {
    delete idfa_;
  }
  if (idfa) {
    set_has_idfa();
    idfa_ = idfa;
  } else {
    clear_has_idfa();
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string imei = 16;
inline bool ClientToLogInfoProto::has_imei() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ClientToLogInfoProto::set_has_imei() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ClientToLogInfoProto::clear_has_imei() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ClientToLogInfoProto::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& ClientToLogInfoProto::imei() const {
  return *imei_;
}
inline void ClientToLogInfoProto::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void ClientToLogInfoProto::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void ClientToLogInfoProto::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToLogInfoProto::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* ClientToLogInfoProto::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToLogInfoProto::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 17;
inline bool ClientToLogInfoProto::has_port() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ClientToLogInfoProto::set_has_port() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ClientToLogInfoProto::clear_has_port() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ClientToLogInfoProto::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ClientToLogInfoProto::port() const {
  return port_;
}
inline void ClientToLogInfoProto::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// PingRsp

// required uint64 currentmsTime = 1;
inline bool PingRsp::has_currentmstime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingRsp::set_has_currentmstime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingRsp::clear_has_currentmstime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingRsp::clear_currentmstime() {
  currentmstime_ = GOOGLE_ULONGLONG(0);
  clear_has_currentmstime();
}
inline ::google::protobuf::uint64 PingRsp::currentmstime() const {
  return currentmstime_;
}
inline void PingRsp::set_currentmstime(::google::protobuf::uint64 value) {
  set_has_currentmstime();
  currentmstime_ = value;
}

// optional uint32 queuereducenum = 2;
inline bool PingRsp::has_queuereducenum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PingRsp::set_has_queuereducenum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PingRsp::clear_has_queuereducenum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PingRsp::clear_queuereducenum() {
  queuereducenum_ = 0u;
  clear_has_queuereducenum();
}
inline ::google::protobuf::uint32 PingRsp::queuereducenum() const {
  return queuereducenum_;
}
inline void PingRsp::set_queuereducenum(::google::protobuf::uint32 value) {
  set_has_queuereducenum();
  queuereducenum_ = value;
}

// -------------------------------------------------------------------

// ClientLoginGateReq

// required uint32 uid = 1;
inline bool ClientLoginGateReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientLoginGateReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientLoginGateReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientLoginGateReq::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 ClientLoginGateReq::uid() const {
  return uid_;
}
inline void ClientLoginGateReq::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// required uint32 channelId = 2;
inline bool ClientLoginGateReq::has_channelid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientLoginGateReq::set_has_channelid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientLoginGateReq::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientLoginGateReq::clear_channelid() {
  channelid_ = 0u;
  clear_has_channelid();
}
inline ::google::protobuf::uint32 ClientLoginGateReq::channelid() const {
  return channelid_;
}
inline void ClientLoginGateReq::set_channelid(::google::protobuf::uint32 value) {
  set_has_channelid();
  channelid_ = value;
}

// required string token = 3;
inline bool ClientLoginGateReq::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientLoginGateReq::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientLoginGateReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientLoginGateReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ClientLoginGateReq::token() const {
  return *token_;
}
inline void ClientLoginGateReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ClientLoginGateReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ClientLoginGateReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLoginGateReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ClientLoginGateReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLoginGateReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 loginTimeStamp = 4;
inline bool ClientLoginGateReq::has_logintimestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientLoginGateReq::set_has_logintimestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientLoginGateReq::clear_has_logintimestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientLoginGateReq::clear_logintimestamp() {
  logintimestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_logintimestamp();
}
inline ::google::protobuf::uint64 ClientLoginGateReq::logintimestamp() const {
  return logintimestamp_;
}
inline void ClientLoginGateReq::set_logintimestamp(::google::protobuf::uint64 value) {
  set_has_logintimestamp();
  logintimestamp_ = value;
}

// required uint32 gateId = 5;
inline bool ClientLoginGateReq::has_gateid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientLoginGateReq::set_has_gateid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientLoginGateReq::clear_has_gateid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientLoginGateReq::clear_gateid() {
  gateid_ = 0u;
  clear_has_gateid();
}
inline ::google::protobuf::uint32 ClientLoginGateReq::gateid() const {
  return gateid_;
}
inline void ClientLoginGateReq::set_gateid(::google::protobuf::uint32 value) {
  set_has_gateid();
  gateid_ = value;
}

// optional string clientSdkString = 6;
inline bool ClientLoginGateReq::has_clientsdkstring() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientLoginGateReq::set_has_clientsdkstring() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientLoginGateReq::clear_has_clientsdkstring() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientLoginGateReq::clear_clientsdkstring() {
  if (clientsdkstring_ != &::google::protobuf::internal::kEmptyString) {
    clientsdkstring_->clear();
  }
  clear_has_clientsdkstring();
}
inline const ::std::string& ClientLoginGateReq::clientsdkstring() const {
  return *clientsdkstring_;
}
inline void ClientLoginGateReq::set_clientsdkstring(const ::std::string& value) {
  set_has_clientsdkstring();
  if (clientsdkstring_ == &::google::protobuf::internal::kEmptyString) {
    clientsdkstring_ = new ::std::string;
  }
  clientsdkstring_->assign(value);
}
inline void ClientLoginGateReq::set_clientsdkstring(const char* value) {
  set_has_clientsdkstring();
  if (clientsdkstring_ == &::google::protobuf::internal::kEmptyString) {
    clientsdkstring_ = new ::std::string;
  }
  clientsdkstring_->assign(value);
}
inline void ClientLoginGateReq::set_clientsdkstring(const char* value, size_t size) {
  set_has_clientsdkstring();
  if (clientsdkstring_ == &::google::protobuf::internal::kEmptyString) {
    clientsdkstring_ = new ::std::string;
  }
  clientsdkstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLoginGateReq::mutable_clientsdkstring() {
  set_has_clientsdkstring();
  if (clientsdkstring_ == &::google::protobuf::internal::kEmptyString) {
    clientsdkstring_ = new ::std::string;
  }
  return clientsdkstring_;
}
inline ::std::string* ClientLoginGateReq::release_clientsdkstring() {
  clear_has_clientsdkstring();
  if (clientsdkstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientsdkstring_;
    clientsdkstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLoginGateReq::set_allocated_clientsdkstring(::std::string* clientsdkstring) {
  if (clientsdkstring_ != &::google::protobuf::internal::kEmptyString) {
    delete clientsdkstring_;
  }
  if (clientsdkstring) {
    set_has_clientsdkstring();
    clientsdkstring_ = clientsdkstring;
  } else {
    clear_has_clientsdkstring();
    clientsdkstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srvSdkString = 7;
inline bool ClientLoginGateReq::has_srvsdkstring() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientLoginGateReq::set_has_srvsdkstring() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientLoginGateReq::clear_has_srvsdkstring() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientLoginGateReq::clear_srvsdkstring() {
  if (srvsdkstring_ != &::google::protobuf::internal::kEmptyString) {
    srvsdkstring_->clear();
  }
  clear_has_srvsdkstring();
}
inline const ::std::string& ClientLoginGateReq::srvsdkstring() const {
  return *srvsdkstring_;
}
inline void ClientLoginGateReq::set_srvsdkstring(const ::std::string& value) {
  set_has_srvsdkstring();
  if (srvsdkstring_ == &::google::protobuf::internal::kEmptyString) {
    srvsdkstring_ = new ::std::string;
  }
  srvsdkstring_->assign(value);
}
inline void ClientLoginGateReq::set_srvsdkstring(const char* value) {
  set_has_srvsdkstring();
  if (srvsdkstring_ == &::google::protobuf::internal::kEmptyString) {
    srvsdkstring_ = new ::std::string;
  }
  srvsdkstring_->assign(value);
}
inline void ClientLoginGateReq::set_srvsdkstring(const char* value, size_t size) {
  set_has_srvsdkstring();
  if (srvsdkstring_ == &::google::protobuf::internal::kEmptyString) {
    srvsdkstring_ = new ::std::string;
  }
  srvsdkstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLoginGateReq::mutable_srvsdkstring() {
  set_has_srvsdkstring();
  if (srvsdkstring_ == &::google::protobuf::internal::kEmptyString) {
    srvsdkstring_ = new ::std::string;
  }
  return srvsdkstring_;
}
inline ::std::string* ClientLoginGateReq::release_srvsdkstring() {
  clear_has_srvsdkstring();
  if (srvsdkstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srvsdkstring_;
    srvsdkstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLoginGateReq::set_allocated_srvsdkstring(::std::string* srvsdkstring) {
  if (srvsdkstring_ != &::google::protobuf::internal::kEmptyString) {
    delete srvsdkstring_;
  }
  if (srvsdkstring) {
    set_has_srvsdkstring();
    srvsdkstring_ = srvsdkstring;
  } else {
    clear_has_srvsdkstring();
    srvsdkstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 version = 8;
inline bool ClientLoginGateReq::has_version() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientLoginGateReq::set_has_version() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientLoginGateReq::clear_has_version() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientLoginGateReq::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 ClientLoginGateReq::version() const {
  return version_;
}
inline void ClientLoginGateReq::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// optional .proto_ff.ClientToLogInfoProto loginfo = 9;
inline bool ClientLoginGateReq::has_loginfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientLoginGateReq::set_has_loginfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientLoginGateReq::clear_has_loginfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientLoginGateReq::clear_loginfo() {
  if (loginfo_ != NULL) loginfo_->::proto_ff::ClientToLogInfoProto::Clear();
  clear_has_loginfo();
}
inline const ::proto_ff::ClientToLogInfoProto& ClientLoginGateReq::loginfo() const {
  return loginfo_ != NULL ? *loginfo_ : *default_instance_->loginfo_;
}
inline ::proto_ff::ClientToLogInfoProto* ClientLoginGateReq::mutable_loginfo() {
  set_has_loginfo();
  if (loginfo_ == NULL) loginfo_ = new ::proto_ff::ClientToLogInfoProto;
  return loginfo_;
}
inline ::proto_ff::ClientToLogInfoProto* ClientLoginGateReq::release_loginfo() {
  clear_has_loginfo();
  ::proto_ff::ClientToLogInfoProto* temp = loginfo_;
  loginfo_ = NULL;
  return temp;
}
inline void ClientLoginGateReq::set_allocated_loginfo(::proto_ff::ClientToLogInfoProto* loginfo) {
  delete loginfo_;
  loginfo_ = loginfo;
  if (loginfo) {
    set_has_loginfo();
  } else {
    clear_has_loginfo();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_5fmsg_2eproto__INCLUDED
