// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ComDefine.proto

#ifndef PROTOBUF_ComDefine_2eproto__INCLUDED
#define PROTOBUF_ComDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "yd_fieldoptions.pb.h"
#include "common_logic.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ComDefine_2eproto();
void protobuf_AssignDesc_ComDefine_2eproto();
void protobuf_ShutdownFile_ComDefine_2eproto();

class LoginRoleProto;

enum PingConfig {
  CLIENT_PING_INTERVAL = 9,
  SERVER_PING_INTERVAL = 9
};
bool PingConfig_IsValid(int value);
const PingConfig PingConfig_MIN = CLIENT_PING_INTERVAL;
const PingConfig PingConfig_MAX = CLIENT_PING_INTERVAL;
const int PingConfig_ARRAYSIZE = PingConfig_MAX + 1;

const ::google::protobuf::EnumDescriptor* PingConfig_descriptor();
inline const ::std::string& PingConfig_Name(PingConfig value) {
  return ::google::protobuf::internal::NameOfEnum(
    PingConfig_descriptor(), value);
}
inline bool PingConfig_Parse(
    const ::std::string& name, PingConfig* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PingConfig>(
    PingConfig_descriptor(), name, value);
}
enum ECharacterSex {
  ECHARACTER_SEX_MAN = 1,
  ECHARACTER_SEX_FEMAL = 2
};
bool ECharacterSex_IsValid(int value);
const ECharacterSex ECharacterSex_MIN = ECHARACTER_SEX_MAN;
const ECharacterSex ECharacterSex_MAX = ECHARACTER_SEX_FEMAL;
const int ECharacterSex_ARRAYSIZE = ECharacterSex_MAX + 1;

const ::google::protobuf::EnumDescriptor* ECharacterSex_descriptor();
inline const ::std::string& ECharacterSex_Name(ECharacterSex value) {
  return ::google::protobuf::internal::NameOfEnum(
    ECharacterSex_descriptor(), value);
}
inline bool ECharacterSex_Parse(
    const ::std::string& name, ECharacterSex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECharacterSex>(
    ECharacterSex_descriptor(), name, value);
}
enum ERace {
  ERace_Human = 1,
  ERace_Fairy = 2
};
bool ERace_IsValid(int value);
const ERace ERace_MIN = ERace_Human;
const ERace ERace_MAX = ERace_Fairy;
const int ERace_ARRAYSIZE = ERace_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERace_descriptor();
inline const ::std::string& ERace_Name(ERace value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERace_descriptor(), value);
}
inline bool ERace_Parse(
    const ::std::string& name, ERace* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERace>(
    ERace_descriptor(), name, value);
}
enum ECharacterProf {
  ECHARACTER_PROF_WARRIOR = 1,
  ECHARACTER_PROF_MAGICIAN = 2,
  ECHARACTER_PROF_ASSASSIN = 3,
  ECHARACTER_PROF_ARCHER = 4
};
bool ECharacterProf_IsValid(int value);
const ECharacterProf ECharacterProf_MIN = ECHARACTER_PROF_WARRIOR;
const ECharacterProf ECharacterProf_MAX = ECHARACTER_PROF_ARCHER;
const int ECharacterProf_ARRAYSIZE = ECharacterProf_MAX + 1;

const ::google::protobuf::EnumDescriptor* ECharacterProf_descriptor();
inline const ::std::string& ECharacterProf_Name(ECharacterProf value) {
  return ::google::protobuf::internal::NameOfEnum(
    ECharacterProf_descriptor(), value);
}
inline bool ECharacterProf_Parse(
    const ::std::string& name, ECharacterProf* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECharacterProf>(
    ECharacterProf_descriptor(), name, value);
}
enum CurrencyType {
  VALUE_CURRENCY_NULL = 0,
  VALUE_CURRENCY_SILVER = 1,
  VALUE_CURRENCY_GOLD = 2,
  VALUE_CURRENCY_BIND_GOLD = 3,
  VALUE_CURRENCY_REPUTATION = 5
};
bool CurrencyType_IsValid(int value);
const CurrencyType CurrencyType_MIN = VALUE_CURRENCY_NULL;
const CurrencyType CurrencyType_MAX = VALUE_CURRENCY_REPUTATION;
const int CurrencyType_ARRAYSIZE = CurrencyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CurrencyType_descriptor();
inline const ::std::string& CurrencyType_Name(CurrencyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CurrencyType_descriptor(), value);
}
inline bool CurrencyType_Parse(
    const ::std::string& name, CurrencyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CurrencyType>(
    CurrencyType_descriptor(), name, value);
}
enum AreaType {
  en_AreaType_Common = 0,
  en_AreaType_Safe = 1,
  en_AreaType_Dup = 2
};
bool AreaType_IsValid(int value);
const AreaType AreaType_MIN = en_AreaType_Common;
const AreaType AreaType_MAX = en_AreaType_Dup;
const int AreaType_ARRAYSIZE = AreaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AreaType_descriptor();
inline const ::std::string& AreaType_Name(AreaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AreaType_descriptor(), value);
}
inline bool AreaType_Parse(
    const ::std::string& name, AreaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AreaType>(
    AreaType_descriptor(), name, value);
}
enum SamplePolyFlags {
  SAMPLE_POLYFLAGS_WALK = 1,
  SAMPLE_POLYFLAGS_SWIM = 2,
  SAMPLE_POLYFLAGS_FORBIT_ACROSS = 4,
  SAMPLE_POLYFLAGS_DOOR = 8,
  SAMPLE_POLYFLAGS_DISABLED = 16,
  SAMPLE_POLYFLAGS_ALL = 65535
};
bool SamplePolyFlags_IsValid(int value);
const SamplePolyFlags SamplePolyFlags_MIN = SAMPLE_POLYFLAGS_WALK;
const SamplePolyFlags SamplePolyFlags_MAX = SAMPLE_POLYFLAGS_ALL;
const int SamplePolyFlags_ARRAYSIZE = SamplePolyFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* SamplePolyFlags_descriptor();
inline const ::std::string& SamplePolyFlags_Name(SamplePolyFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    SamplePolyFlags_descriptor(), value);
}
inline bool SamplePolyFlags_Parse(
    const ::std::string& name, SamplePolyFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SamplePolyFlags>(
    SamplePolyFlags_descriptor(), name, value);
}
enum MapDefine {
  MAX_NAV_POLYS = 3076,
  MAX_NAV_POINT_VALUE = 1024,
  INVALID_NAVMESH_POLYREF = 0
};
bool MapDefine_IsValid(int value);
const MapDefine MapDefine_MIN = INVALID_NAVMESH_POLYREF;
const MapDefine MapDefine_MAX = MAX_NAV_POLYS;
const int MapDefine_ARRAYSIZE = MapDefine_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapDefine_descriptor();
inline const ::std::string& MapDefine_Name(MapDefine value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapDefine_descriptor(), value);
}
inline bool MapDefine_Parse(
    const ::std::string& name, MapDefine* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapDefine>(
    MapDefine_descriptor(), name, value);
}
enum REGION_DEFINE {
  DEFAULT_REGION_WIDTH = 18,
  DEFAULT_REGION_HEIGHT = 18
};
bool REGION_DEFINE_IsValid(int value);
const REGION_DEFINE REGION_DEFINE_MIN = DEFAULT_REGION_WIDTH;
const REGION_DEFINE REGION_DEFINE_MAX = DEFAULT_REGION_WIDTH;
const int REGION_DEFINE_ARRAYSIZE = REGION_DEFINE_MAX + 1;

const ::google::protobuf::EnumDescriptor* REGION_DEFINE_descriptor();
inline const ::std::string& REGION_DEFINE_Name(REGION_DEFINE value) {
  return ::google::protobuf::internal::NameOfEnum(
    REGION_DEFINE_descriptor(), value);
}
inline bool REGION_DEFINE_Parse(
    const ::std::string& name, REGION_DEFINE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<REGION_DEFINE>(
    REGION_DEFINE_descriptor(), name, value);
}
enum CharacterDefine {
  MAX_CREATE_CHARACTER_COUNT = 3,
  CHARACTER_NAME_MIN_LENGTH = 4,
  CHARACTER_NAME_MAX_LENGTH = 32
};
bool CharacterDefine_IsValid(int value);
const CharacterDefine CharacterDefine_MIN = MAX_CREATE_CHARACTER_COUNT;
const CharacterDefine CharacterDefine_MAX = CHARACTER_NAME_MAX_LENGTH;
const int CharacterDefine_ARRAYSIZE = CharacterDefine_MAX + 1;

const ::google::protobuf::EnumDescriptor* CharacterDefine_descriptor();
inline const ::std::string& CharacterDefine_Name(CharacterDefine value) {
  return ::google::protobuf::internal::NameOfEnum(
    CharacterDefine_descriptor(), value);
}
inline bool CharacterDefine_Parse(
    const ::std::string& name, CharacterDefine* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterDefine>(
    CharacterDefine_descriptor(), name, value);
}
enum EItemType {
  EItemType_None = 0,
  EItemType_Equip = 1,
  EItemType_Material = 2,
  EItemType_Other = 3,
  EItemType_Task = 4,
  EItemType_Star = 5,
  EItemType_Soul = 6,
  EItemType_FaiMateri = 7,
  EItemType_FaiCrystal = 8,
  EItemType_Symbol = 9,
  EItemType_BossIdentify = 10,
  EItemType_FaiIdentify = 11,
  EItemType_Limit = 12
};
bool EItemType_IsValid(int value);
const EItemType EItemType_MIN = EItemType_None;
const EItemType EItemType_MAX = EItemType_Limit;
const int EItemType_ARRAYSIZE = EItemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EItemType_descriptor();
inline const ::std::string& EItemType_Name(EItemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EItemType_descriptor(), value);
}
inline bool EItemType_Parse(
    const ::std::string& name, EItemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EItemType>(
    EItemType_descriptor(), name, value);
}
enum EPackageType {
  EPackageType_None = 0,
  EPackageType_Common = 1,
  EPackageType_Storage = 2,
  EPackageType_Task = 3,
  EPackageType_Star = 4,
  EPackageType_Soul = 5,
  EPackageType_FaiMateri = 6,
  EPackageType_FaiCrystal = 7,
  EPackageType_Symbol = 8,
  EPackageType_BossIdentify = 9,
  EPackageType_FaiIdentify = 10,
  EPackageType_Limit = 11
};
bool EPackageType_IsValid(int value);
const EPackageType EPackageType_MIN = EPackageType_None;
const EPackageType EPackageType_MAX = EPackageType_Limit;
const int EPackageType_ARRAYSIZE = EPackageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EPackageType_descriptor();
inline const ::std::string& EPackageType_Name(EPackageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EPackageType_descriptor(), value);
}
inline bool EPackageType_Parse(
    const ::std::string& name, EPackageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EPackageType>(
    EPackageType_descriptor(), name, value);
}
enum EQuality {
  EQuality_grey = 1,
  EQuality_white = 2,
  EQuality_green = 3,
  EQuality_blue = 4,
  EQuality_purple = 5,
  EQuality_orange = 6,
  EQuality_red = 7,
  EQuality_gold = 8
};
bool EQuality_IsValid(int value);
const EQuality EQuality_MIN = EQuality_grey;
const EQuality EQuality_MAX = EQuality_gold;
const int EQuality_ARRAYSIZE = EQuality_MAX + 1;

const ::google::protobuf::EnumDescriptor* EQuality_descriptor();
inline const ::std::string& EQuality_Name(EQuality value) {
  return ::google::protobuf::internal::NameOfEnum(
    EQuality_descriptor(), value);
}
inline bool EQuality_Parse(
    const ::std::string& name, EQuality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EQuality>(
    EQuality_descriptor(), name, value);
}
enum EEquipPos {
  EEquipPos_none = 0,
  EEquipPos_weapon = 1,
  EEquipPos_clothes = 2,
  EEquipPos_hat = 3,
  EEquipPos_cloak = 4,
  EEquipPos_pants = 5,
  EEquipPos_shoe = 6,
  EEquipPos_necklace = 7,
  EEquipPos_ring = 8,
  EEquipPos_thering = 9,
  EEquipPos_holysymbols = 10,
  EEquipPos_guarddef = 11,
  EEquipPos_guardexp = 12,
  EEquipPos_marryEquip1 = 13,
  EEquipPos_marryEquip2 = 14,
  EEquipPos_limit = 15
};
bool EEquipPos_IsValid(int value);
const EEquipPos EEquipPos_MIN = EEquipPos_none;
const EEquipPos EEquipPos_MAX = EEquipPos_limit;
const int EEquipPos_ARRAYSIZE = EEquipPos_MAX + 1;

const ::google::protobuf::EnumDescriptor* EEquipPos_descriptor();
inline const ::std::string& EEquipPos_Name(EEquipPos value) {
  return ::google::protobuf::internal::NameOfEnum(
    EEquipPos_descriptor(), value);
}
inline bool EEquipPos_Parse(
    const ::std::string& name, EEquipPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EEquipPos>(
    EEquipPos_descriptor(), name, value);
}
enum EConst {
  EConst_ServerUpdateTime = 1
};
bool EConst_IsValid(int value);
const EConst EConst_MIN = EConst_ServerUpdateTime;
const EConst EConst_MAX = EConst_ServerUpdateTime;
const int EConst_ARRAYSIZE = EConst_MAX + 1;

const ::google::protobuf::EnumDescriptor* EConst_descriptor();
inline const ::std::string& EConst_Name(EConst value) {
  return ::google::protobuf::internal::NameOfEnum(
    EConst_descriptor(), value);
}
inline bool EConst_Parse(
    const ::std::string& name, EConst* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EConst>(
    EConst_descriptor(), name, value);
}
enum ERetCode {
  RET_SUCCESS = 0,
  RET_FAIL = 1,
  RET_LEVEL_LACK = 2,
  RET_MONEY_LACK = 3,
  RET_GOLD_LACK = 4,
  RET_BIND_GOLD_LACK = 5,
  RET_DIAMOND_LACK = 6,
  RET_BIND_DIAMOND_LACK = 7,
  RET_VIP_LEVEL_LACK = 8,
  RET_PROF_ERROR = 10,
  RET_PLAYER_NOT_ONLINE = 11,
  RET_RACE_ERROR = 12,
  RET_SEX_ERROR = 13,
  RET_NOT_ONLINE = 14,
  RET_DATA_ERROR = 15,
  RET_NOT_HAVE_CHARACTER = 16,
  RET_BAG_FULL = 17,
  RET_PARMAR_ERROR = 18,
  RET_CONFIG_ERROR = 19,
  RET_OTHER_LEVEL_LACK = 20,
  RET_ID_UNKNOW = 21,
  RET_REPEATED_OPERATE = 22,
  RET_UNAVAILABLE = 23,
  RET_FIGHT_LACK = 24,
  RET_APTITUDE_LACK = 25,
  RET_OVER_MAX_NUM = 26,
  RET_PRICE_ERROR = 27,
  RET_OTHER_NOT_ONLINE = 28,
  RET_STAR_ESSENCE_LACK = 29,
  RET_STAR_LAYER_LIMIT = 30,
  RET_OCCUPATION_ERROR = 31,
  RET_SMALL_SPIRIT_LACK = 32,
  RET_SMALL_BIG_LACK = 33,
  RET_ITEM_PARAM_ERROR = 34,
  RET_CAN_NOT_RECONNECT = 35,
  RET_DISALLOW_ENTER_GAME = 36,
  RET_MATERIAL_LACK = 37,
  RET_HOLY_DIAMOND_LACK = 38,
  RET_LOGIN_BAD_USER_NAME_LEN = 100,
  RET_LOGIN_CHARACTER_NOT_EXITS = 101,
  RET_LOGIN_ACCOUNT_OTHER_LOGIN = 102,
  RET_LOGIN_CHARACTER_NUM_LIMIT = 103,
  RET_LOGIN_CHARACTER_NAME_EXISTS = 104,
  RET_LOGIN_CHARACTER_SEX_ERROR = 105,
  RET_LOGIN_CHARACTER_PROF_ERROR = 106,
  RET_LOGIN_CHARACTER_NAME_LEN_ERROR = 107,
  RET_LOGIN_CHARACTER_CREATE_FAILED = 108,
  RET_LOGIN_CHARACTER_NOT_ACCOUNT = 109,
  RET_LOGIN_CHARACTER_ILLEGAL = 110,
  RET_LOGIN_CHARACTER_VESION_ERR = 111,
  RET_LOGIN_ACCOUNT_SYSTEM_MAINTENANCE = 112,
  RET_LOGIN_ILLEGAL_REQUEST = 113,
  RET_LOGIN_CHANNEL_FAIL = 114,
  RET_LOGIN_ORBIDDEN_ACCOUNT = 115,
  RET_LOGIN_QUEUE_ENOUGHT_NUM = 116,
  RET_LOGIN_HAS_DELETE_CHAR = 117,
  RET_LOGIN_TIME_OUT = 118,
  RET_TOKEN_ERROR = 119,
  RET_ACCOUNT_FULL = 120,
  RET_NOT_OPEN_TIME = 121,
  RET_CAN_NOT_RETURN_ROLE_LIST = 122
};
bool ERetCode_IsValid(int value);
const ERetCode ERetCode_MIN = RET_SUCCESS;
const ERetCode ERetCode_MAX = RET_CAN_NOT_RETURN_ROLE_LIST;
const int ERetCode_ARRAYSIZE = ERetCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERetCode_descriptor();
inline const ::std::string& ERetCode_Name(ERetCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERetCode_descriptor(), value);
}
inline bool ERetCode_Parse(
    const ::std::string& name, ERetCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERetCode>(
    ERetCode_descriptor(), name, value);
}
enum LOGOUT_TYPE {
  LOGOUT_NONE = 0,
  LOGOUT_LOGOUT = 1,
  LOGOUT_KICK_OUT = 2,
  LOGOUT_REPLACE = 3,
  LOGOUT_DIS_TIME_OUT = 4,
  LOGOUT_CHANGE_LOGIC = 5,
  LOGOUT_RETURN_ROLE_LIST = 6,
  LOGOUT_LOGIN_TIME_OUT = 7,
  LOGOUT_WEB_KICK = 8,
  LOGOUT_CHEAR_KICK = 9,
  LOGOUT_CRASH = 10,
  LOGOUT_OTHER = 11
};
bool LOGOUT_TYPE_IsValid(int value);
const LOGOUT_TYPE LOGOUT_TYPE_MIN = LOGOUT_NONE;
const LOGOUT_TYPE LOGOUT_TYPE_MAX = LOGOUT_OTHER;
const int LOGOUT_TYPE_ARRAYSIZE = LOGOUT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* LOGOUT_TYPE_descriptor();
inline const ::std::string& LOGOUT_TYPE_Name(LOGOUT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    LOGOUT_TYPE_descriptor(), value);
}
inline bool LOGOUT_TYPE_Parse(
    const ::std::string& name, LOGOUT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LOGOUT_TYPE>(
    LOGOUT_TYPE_descriptor(), name, value);
}
// ===================================================================

class LoginRoleProto : public ::google::protobuf::Message {
 public:
  LoginRoleProto();
  virtual ~LoginRoleProto();

  LoginRoleProto(const LoginRoleProto& from);

  inline LoginRoleProto& operator=(const LoginRoleProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRoleProto& default_instance();

  void Swap(LoginRoleProto* other);

  // implements Message ----------------------------------------------

  LoginRoleProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRoleProto& from);
  void MergeFrom(const LoginRoleProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline ::google::protobuf::uint64 cid() const;
  inline void set_cid(::google::protobuf::uint64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 prof = 3;
  inline bool has_prof() const;
  inline void clear_prof();
  static const int kProfFieldNumber = 3;
  inline ::google::protobuf::uint32 prof() const;
  inline void set_prof(::google::protobuf::uint32 value);

  // required uint32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint64 fight = 5;
  inline bool has_fight() const;
  inline void clear_fight();
  static const int kFightFieldNumber = 5;
  inline ::google::protobuf::uint64 fight() const;
  inline void set_fight(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.LoginRoleProto)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_prof();
  inline void clear_has_prof();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_fight();
  inline void clear_has_fight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cid_;
  ::std::string* name_;
  ::google::protobuf::uint32 prof_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint64 fight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ComDefine_2eproto();
  friend void protobuf_AssignDesc_ComDefine_2eproto();
  friend void protobuf_ShutdownFile_ComDefine_2eproto();

  void InitAsDefaultInstance();
  static LoginRoleProto* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRoleProto

// required uint64 cid = 1;
inline bool LoginRoleProto::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRoleProto::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRoleProto::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRoleProto::clear_cid() {
  cid_ = GOOGLE_ULONGLONG(0);
  clear_has_cid();
}
inline ::google::protobuf::uint64 LoginRoleProto::cid() const {
  return cid_;
}
inline void LoginRoleProto::set_cid(::google::protobuf::uint64 value) {
  set_has_cid();
  cid_ = value;
}

// required string name = 2;
inline bool LoginRoleProto::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRoleProto::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRoleProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRoleProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LoginRoleProto::name() const {
  return *name_;
}
inline void LoginRoleProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoginRoleProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoginRoleProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRoleProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LoginRoleProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRoleProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 prof = 3;
inline bool LoginRoleProto::has_prof() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRoleProto::set_has_prof() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRoleProto::clear_has_prof() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRoleProto::clear_prof() {
  prof_ = 0u;
  clear_has_prof();
}
inline ::google::protobuf::uint32 LoginRoleProto::prof() const {
  return prof_;
}
inline void LoginRoleProto::set_prof(::google::protobuf::uint32 value) {
  set_has_prof();
  prof_ = value;
}

// required uint32 level = 4;
inline bool LoginRoleProto::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRoleProto::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRoleProto::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRoleProto::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 LoginRoleProto::level() const {
  return level_;
}
inline void LoginRoleProto::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint64 fight = 5;
inline bool LoginRoleProto::has_fight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginRoleProto::set_has_fight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginRoleProto::clear_has_fight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginRoleProto::clear_fight() {
  fight_ = GOOGLE_ULONGLONG(0);
  clear_has_fight();
}
inline ::google::protobuf::uint64 LoginRoleProto::fight() const {
  return fight_;
}
inline void LoginRoleProto::set_fight(::google::protobuf::uint64 value) {
  set_has_fight();
  fight_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::PingConfig>() {
  return ::proto_ff::PingConfig_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::ECharacterSex>() {
  return ::proto_ff::ECharacterSex_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::ERace>() {
  return ::proto_ff::ERace_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::ECharacterProf>() {
  return ::proto_ff::ECharacterProf_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::CurrencyType>() {
  return ::proto_ff::CurrencyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::AreaType>() {
  return ::proto_ff::AreaType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::SamplePolyFlags>() {
  return ::proto_ff::SamplePolyFlags_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::MapDefine>() {
  return ::proto_ff::MapDefine_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::REGION_DEFINE>() {
  return ::proto_ff::REGION_DEFINE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::CharacterDefine>() {
  return ::proto_ff::CharacterDefine_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EItemType>() {
  return ::proto_ff::EItemType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EPackageType>() {
  return ::proto_ff::EPackageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EQuality>() {
  return ::proto_ff::EQuality_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EEquipPos>() {
  return ::proto_ff::EEquipPos_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EConst>() {
  return ::proto_ff::EConst_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::ERetCode>() {
  return ::proto_ff::ERetCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::LOGOUT_TYPE>() {
  return ::proto_ff::LOGOUT_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ComDefine_2eproto__INCLUDED
