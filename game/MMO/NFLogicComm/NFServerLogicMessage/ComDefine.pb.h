// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ComDefine.proto

#ifndef PROTOBUF_ComDefine_2eproto__INCLUDED
#define PROTOBUF_ComDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include "yd_fieldoptions.pb.h"
#include "common_logic.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ComDefine_2eproto();
void protobuf_AssignDesc_ComDefine_2eproto();
void protobuf_ShutdownFile_ComDefine_2eproto();


enum PingConfig {
  CLIENT_PING_INTERVAL = 9,
  SERVER_PING_INTERVAL = 9
};
bool PingConfig_IsValid(int value);
const PingConfig PingConfig_MIN = CLIENT_PING_INTERVAL;
const PingConfig PingConfig_MAX = CLIENT_PING_INTERVAL;
const int PingConfig_ARRAYSIZE = PingConfig_MAX + 1;

const ::google::protobuf::EnumDescriptor* PingConfig_descriptor();
inline const ::std::string& PingConfig_Name(PingConfig value) {
  return ::google::protobuf::internal::NameOfEnum(
    PingConfig_descriptor(), value);
}
inline bool PingConfig_Parse(
    const ::std::string& name, PingConfig* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PingConfig>(
    PingConfig_descriptor(), name, value);
}
enum ERoleSex {
  EROLE_SEX_MALE = 1,
  EROLE_SEX_FEMAL = 2
};
bool ERoleSex_IsValid(int value);
const ERoleSex ERoleSex_MIN = EROLE_SEX_MALE;
const ERoleSex ERoleSex_MAX = EROLE_SEX_FEMAL;
const int ERoleSex_ARRAYSIZE = ERoleSex_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERoleSex_descriptor();
inline const ::std::string& ERoleSex_Name(ERoleSex value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERoleSex_descriptor(), value);
}
inline bool ERoleSex_Parse(
    const ::std::string& name, ERoleSex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERoleSex>(
    ERoleSex_descriptor(), name, value);
}
enum ERoleProf {
  EROLE_PROF_MALE_MASTER = 1,
  EROLE_PROF_FEMALE_MASTER = 2,
  EROLE_PROF_MALE_SICKLE = 3,
  EROLE_PROF_FEMALE_SICKLE = 4,
  EROLE_PROF_MALE_SWORD = 5,
  EROLE_PROF_FEMALE_SWORD = 6,
  EROLE_PROF_MALE_KNIFE = 7,
  EROLE_PROF_FEMALE_KNIFE = 8
};
bool ERoleProf_IsValid(int value);
const ERoleProf ERoleProf_MIN = EROLE_PROF_MALE_MASTER;
const ERoleProf ERoleProf_MAX = EROLE_PROF_FEMALE_KNIFE;
const int ERoleProf_ARRAYSIZE = ERoleProf_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERoleProf_descriptor();
inline const ::std::string& ERoleProf_Name(ERoleProf value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERoleProf_descriptor(), value);
}
inline bool ERoleProf_Parse(
    const ::std::string& name, ERoleProf* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERoleProf>(
    ERoleProf_descriptor(), name, value);
}
enum CurrencyType {
  VALUE_CURRENCY_NULL = 0,
  VALUE_CURRENCY_SILVER = 1,
  VALUE_CURRENCY_GOLD = 2,
  VALUE_CURRENCY_BIND_GOLD = 3,
  VALUE_CURRENCY_REPUTATION = 5
};
bool CurrencyType_IsValid(int value);
const CurrencyType CurrencyType_MIN = VALUE_CURRENCY_NULL;
const CurrencyType CurrencyType_MAX = VALUE_CURRENCY_REPUTATION;
const int CurrencyType_ARRAYSIZE = CurrencyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CurrencyType_descriptor();
inline const ::std::string& CurrencyType_Name(CurrencyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CurrencyType_descriptor(), value);
}
inline bool CurrencyType_Parse(
    const ::std::string& name, CurrencyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CurrencyType>(
    CurrencyType_descriptor(), name, value);
}
enum AreaType {
  en_AreaType_Common = 0,
  en_AreaType_Safe = 1,
  en_AreaType_Dup = 2
};
bool AreaType_IsValid(int value);
const AreaType AreaType_MIN = en_AreaType_Common;
const AreaType AreaType_MAX = en_AreaType_Dup;
const int AreaType_ARRAYSIZE = AreaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AreaType_descriptor();
inline const ::std::string& AreaType_Name(AreaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AreaType_descriptor(), value);
}
inline bool AreaType_Parse(
    const ::std::string& name, AreaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AreaType>(
    AreaType_descriptor(), name, value);
}
enum SamplePolyFlags {
  SAMPLE_POLYFLAGS_WALK = 1,
  SAMPLE_POLYFLAGS_SWIM = 2,
  SAMPLE_POLYFLAGS_FORBIT_ACROSS = 4,
  SAMPLE_POLYFLAGS_DOOR = 8,
  SAMPLE_POLYFLAGS_DISABLED = 16,
  SAMPLE_POLYFLAGS_ALL = 65535
};
bool SamplePolyFlags_IsValid(int value);
const SamplePolyFlags SamplePolyFlags_MIN = SAMPLE_POLYFLAGS_WALK;
const SamplePolyFlags SamplePolyFlags_MAX = SAMPLE_POLYFLAGS_ALL;
const int SamplePolyFlags_ARRAYSIZE = SamplePolyFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* SamplePolyFlags_descriptor();
inline const ::std::string& SamplePolyFlags_Name(SamplePolyFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    SamplePolyFlags_descriptor(), value);
}
inline bool SamplePolyFlags_Parse(
    const ::std::string& name, SamplePolyFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SamplePolyFlags>(
    SamplePolyFlags_descriptor(), name, value);
}
enum MapDefine {
  MAX_NAV_POLYS = 3076,
  MAX_NAV_POINT_VALUE = 1024,
  INVALID_NAVMESH_POLYREF = 0
};
bool MapDefine_IsValid(int value);
const MapDefine MapDefine_MIN = INVALID_NAVMESH_POLYREF;
const MapDefine MapDefine_MAX = MAX_NAV_POLYS;
const int MapDefine_ARRAYSIZE = MapDefine_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapDefine_descriptor();
inline const ::std::string& MapDefine_Name(MapDefine value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapDefine_descriptor(), value);
}
inline bool MapDefine_Parse(
    const ::std::string& name, MapDefine* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapDefine>(
    MapDefine_descriptor(), name, value);
}
enum REGION_DEFINE {
  DEFAULT_REGION_WIDTH = 18,
  DEFAULT_REGION_HEIGHT = 18
};
bool REGION_DEFINE_IsValid(int value);
const REGION_DEFINE REGION_DEFINE_MIN = DEFAULT_REGION_WIDTH;
const REGION_DEFINE REGION_DEFINE_MAX = DEFAULT_REGION_WIDTH;
const int REGION_DEFINE_ARRAYSIZE = REGION_DEFINE_MAX + 1;

const ::google::protobuf::EnumDescriptor* REGION_DEFINE_descriptor();
inline const ::std::string& REGION_DEFINE_Name(REGION_DEFINE value) {
  return ::google::protobuf::internal::NameOfEnum(
    REGION_DEFINE_descriptor(), value);
}
inline bool REGION_DEFINE_Parse(
    const ::std::string& name, REGION_DEFINE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<REGION_DEFINE>(
    REGION_DEFINE_descriptor(), name, value);
}
enum CharacterDefine {
  MAX_CREATE_CHARACTER_COUNT = 3,
  CHARACTER_NAME_MIN_LENGTH = 4,
  CHARACTER_NAME_MAX_LENGTH = 32
};
bool CharacterDefine_IsValid(int value);
const CharacterDefine CharacterDefine_MIN = MAX_CREATE_CHARACTER_COUNT;
const CharacterDefine CharacterDefine_MAX = CHARACTER_NAME_MAX_LENGTH;
const int CharacterDefine_ARRAYSIZE = CharacterDefine_MAX + 1;

const ::google::protobuf::EnumDescriptor* CharacterDefine_descriptor();
inline const ::std::string& CharacterDefine_Name(CharacterDefine value) {
  return ::google::protobuf::internal::NameOfEnum(
    CharacterDefine_descriptor(), value);
}
inline bool CharacterDefine_Parse(
    const ::std::string& name, CharacterDefine* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterDefine>(
    CharacterDefine_descriptor(), name, value);
}
enum EItemType {
  EItemType_None = 0,
  EItemType_Equip = 1,
  EItemType_Material = 2,
  EItemType_Other = 3,
  EItemType_Task = 4,
  EItemType_Star = 5,
  EItemType_Soul = 6,
  EItemType_FaiMateri = 7,
  EItemType_FaiCrystal = 8,
  EItemType_Symbol = 9,
  EItemType_BossIdentify = 10,
  EItemType_FaiIdentify = 11,
  EItemType_Limit = 12
};
bool EItemType_IsValid(int value);
const EItemType EItemType_MIN = EItemType_None;
const EItemType EItemType_MAX = EItemType_Limit;
const int EItemType_ARRAYSIZE = EItemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EItemType_descriptor();
inline const ::std::string& EItemType_Name(EItemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EItemType_descriptor(), value);
}
inline bool EItemType_Parse(
    const ::std::string& name, EItemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EItemType>(
    EItemType_descriptor(), name, value);
}
enum EPackageType {
  EPackageType_None = 0,
  EPackageType_Common = 1,
  EPackageType_Storage = 2,
  EPackageType_Limit = 3
};
bool EPackageType_IsValid(int value);
const EPackageType EPackageType_MIN = EPackageType_None;
const EPackageType EPackageType_MAX = EPackageType_Limit;
const int EPackageType_ARRAYSIZE = EPackageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EPackageType_descriptor();
inline const ::std::string& EPackageType_Name(EPackageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EPackageType_descriptor(), value);
}
inline bool EPackageType_Parse(
    const ::std::string& name, EPackageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EPackageType>(
    EPackageType_descriptor(), name, value);
}
enum EQuality {
  EQuality_grey = 1,
  EQuality_white = 2,
  EQuality_green = 3,
  EQuality_blue = 4,
  EQuality_purple = 5,
  EQuality_orange = 6,
  EQuality_red = 7,
  EQuality_gold = 8
};
bool EQuality_IsValid(int value);
const EQuality EQuality_MIN = EQuality_grey;
const EQuality EQuality_MAX = EQuality_gold;
const int EQuality_ARRAYSIZE = EQuality_MAX + 1;

const ::google::protobuf::EnumDescriptor* EQuality_descriptor();
inline const ::std::string& EQuality_Name(EQuality value) {
  return ::google::protobuf::internal::NameOfEnum(
    EQuality_descriptor(), value);
}
inline bool EQuality_Parse(
    const ::std::string& name, EQuality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EQuality>(
    EQuality_descriptor(), name, value);
}
enum EEquipPos {
  EEquipPos_none = 0,
  EEquipPos_m_weapon = 1,
  EEquipPos_s_weapon = 2,
  EEquipPos_hat = 3,
  EEquipPos_clothes = 4,
  EEquipPos_hand = 5,
  EEquipPos_belt = 6,
  EEquipPos_shoe = 7,
  EEquipPos_necklace = 8,
  EEquipPos_bracelet = 9,
  EEquipPos_ring = 10,
  EEquipPos_guard1 = 11,
  EEquipPos_guard2 = 12,
  EEquipPos_jade = 13,
  EEquipPos_marry = 14,
  EEquipPos_limit = 15
};
bool EEquipPos_IsValid(int value);
const EEquipPos EEquipPos_MIN = EEquipPos_none;
const EEquipPos EEquipPos_MAX = EEquipPos_limit;
const int EEquipPos_ARRAYSIZE = EEquipPos_MAX + 1;

const ::google::protobuf::EnumDescriptor* EEquipPos_descriptor();
inline const ::std::string& EEquipPos_Name(EEquipPos value) {
  return ::google::protobuf::internal::NameOfEnum(
    EEquipPos_descriptor(), value);
}
inline bool EEquipPos_Parse(
    const ::std::string& name, EEquipPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EEquipPos>(
    EEquipPos_descriptor(), name, value);
}
enum EConst {
  EConst_RelationRecentSize = 20,
  EConst_RelationFriendSize = 21,
  EConst_RelationHateSize = 22,
  EConst_RelationBlackSize = 23,
  EConst_ServerUpdateTime = 34,
  EConst_ChgNameItemId = 61,
  EConst_WorldChatLevLimit = 75,
  EConst_CrossChatLevLimit = 76,
  EConst_CrossChatCost = 113,
  EConst_WorldChannelNeedPay = 142,
  EConst_CreateUnionNeedPay = 143,
  EConst_SceneChatLevLimit = 146,
  EConst_TeamEnList_CostBindDia = 149,
  EConst_RoleSkillPubCd = 181,
  EConst_GodSkillPubCd = 182,
  EConst_PetSkillPubCd = 183,
  EConst_SkillGroupChgCd = 190,
  EConst_CorpseTime = 192,
  EConst_BossCorpseTime = 193,
  EConst_DropProtectSec = 195,
  EConstTiredReliveNum = 200,
  EConstTiredContiSec = 201,
  EConstTiredReliveSec = 202,
  EConst_ImmediateReliveCostItem = 203,
  EConst_ImmediateReliveCost = 206,
  EConst_AutoPickDropSec = 231
};
bool EConst_IsValid(int value);
const EConst EConst_MIN = EConst_RelationRecentSize;
const EConst EConst_MAX = EConst_AutoPickDropSec;
const int EConst_ARRAYSIZE = EConst_MAX + 1;

const ::google::protobuf::EnumDescriptor* EConst_descriptor();
inline const ::std::string& EConst_Name(EConst value) {
  return ::google::protobuf::internal::NameOfEnum(
    EConst_descriptor(), value);
}
inline bool EConst_Parse(
    const ::std::string& name, EConst* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EConst>(
    EConst_descriptor(), name, value);
}
enum ERetCode {
  RET_SUCCESS = 0,
  RET_FAIL = 1,
  RET_LEVEL_LACK = 2,
  RET_MONEY_LACK = 3,
  RET_GOLD_LACK = 4,
  RET_BIND_GOLD_LACK = 5,
  RET_DIAMOND_LACK = 6,
  RET_BIND_DIAMOND_LACK = 7,
  RET_VIP_LEVEL_LACK = 8,
  RET_PROF_ERROR = 10,
  RET_PLAYER_NOT_ONLINE = 11,
  RET_RACE_ERROR = 12,
  RET_SEX_ERROR = 13,
  RET_NOT_ONLINE = 14,
  RET_DATA_ERROR = 15,
  RET_NOT_HAVE_CHARACTER = 16,
  RET_BAG_FULL = 17,
  RET_PARMAR_ERROR = 18,
  RET_CONFIG_ERROR = 19,
  RET_OTHER_LEVEL_LACK = 20,
  RET_ID_UNKNOW = 21,
  RET_REPEATED_OPERATE = 22,
  RET_UNAVAILABLE = 23,
  RET_FIGHT_LACK = 24,
  RET_APTITUDE_LACK = 25,
  RET_OVER_MAX_NUM = 26,
  RET_PRICE_ERROR = 27,
  RET_OTHER_NOT_ONLINE = 28,
  RET_STAR_ESSENCE_LACK = 29,
  RET_STAR_LAYER_LIMIT = 30,
  RET_OCCUPATION_ERROR = 31,
  RET_SMALL_SPIRIT_LACK = 32,
  RET_SMALL_BIG_LACK = 33,
  RET_ITEM_PARAM_ERROR = 34,
  RET_CAN_NOT_RECONNECT = 35,
  RET_DISALLOW_ENTER_GAME = 36,
  RET_MATERIAL_LACK = 37,
  RET_LOGIN_BAD_USER_NAME_LEN = 100,
  RET_LOGIN_CHARACTER_NOT_EXITS = 101,
  RET_LOGIN_ACCOUNT_OTHER_LOGIN = 102,
  RET_LOGIN_CHARACTER_NUM_LIMIT = 103,
  RET_LOGIN_CHARACTER_NAME_EXISTS = 104,
  RET_LOGIN_CHARACTER_SEX_ERROR = 105,
  RET_LOGIN_CHARACTER_PROF_ERROR = 106,
  RET_LOGIN_CHARACTER_NAME_LEN_ERROR = 107,
  RET_LOGIN_CHARACTER_CREATE_FAILED = 108,
  RET_LOGIN_CHARACTER_NOT_ACCOUNT = 109,
  RET_LOGIN_CHARACTER_ILLEGAL = 110,
  RET_LOGIN_CHARACTER_VESION_ERR = 111,
  RET_LOGIN_ACCOUNT_SYSTEM_MAINTENANCE = 112,
  RET_LOGIN_ILLEGAL_REQUEST = 113,
  RET_LOGIN_CHANNEL_FAIL = 114,
  RET_LOGIN_ORBIDDEN_ACCOUNT = 115,
  RET_LOGIN_QUEUE_ENOUGHT_NUM = 116,
  RET_LOGIN_HAS_DELETE_CHAR = 117,
  RET_LOGIN_TIME_OUT = 118,
  RET_TOKEN_ERROR = 119,
  RET_ACCOUNT_FULL = 120,
  RET_NOT_OPEN_TIME = 121,
  RET_CAN_NOT_RETURN_ROLE_LIST = 122,
  RET_LOGIN_TOKEN_ERROR = 123,
  RET_SCENE_DST_NOT_EXIST = 200,
  RET_SCENE_INVALID_DST_POS = 201,
  RET_SCENE_CAN_NOT_TRAN = 202,
  RET_SCENE_TRANS_PARAM_ERROR = 203,
  RET_MAIL_SEND_TARGET_ERROR = 300,
  RET_MAIL_DATA_ERROR = 301,
  RET_MAIL_NOT_EXIST = 302,
  RET_MAIL_NOT_HAVE_ATTACHMENT = 303,
  RET_MAIL_GOODS_NUM_LIMIT = 304,
  RET_MAIL_TOPIC_LEN_LIMIT = 305,
  RET_MAIL_ALREADY_FETCH = 306,
  RET_MAIL_ATTATCH_COUNT_LIMIT = 307,
  RET_MAIL_ALREDAY_EXPIRE = 308,
  RET_MAIL_HAS_NOT_BEGIN_TIME = 309,
  RET_PACKAGE_ITEM_NOT_EXITS = 401,
  RET_PACKAGE_ITEM_CAN_NOT_SELL = 402,
  RET_PACKAGE_ITEM_NUM_LACK = 403,
  RET_PACKAGE_ITEM_CAN_NOT_USE = 404,
  RET_PACKAGE_ITEM_CAN_NOT_BATCH_USE = 405,
  RET_PACKAGE_EXPAND_LIMIT = 406,
  RET_PACKAGE_ITEM_FUNC_PARAM_ERR = 407,
  RET_PACKAGE_SORT_IN_COOL = 408,
  RET_PACKAGE_COMMON_SPACE_NOT_ENOUGH = 409,
  RET_PACKAGE_STORAGE_SPACE_NOT_ENOUGH = 410,
  RET_PACKAGE_HP_FULL = 417,
  RET_PACKAGE_WAITING = 421,
  RET_PACKAGE_USE_HANGUP_CARD_MAX = 433,
  RET_PACKAGE_LACK_CHANGE_NAME_ITEM = 436,
  RET_PACKAGE_USE_ITEM_NOT_REMOVE = 437,
  RET_PACKAGE_FUSHI_CARD_MAX = 438,
  RET_PACKAGE_TASK_SPACE_NOT_ENOUGH = 440,
  RET_PACKAGE_STAR_SPACE_NOT_ENOUGH = 441,
  RET_PACKAGE_SOUL_SPACE_NOT_ENOUGH = 442,
  RET_PACKAGE_FAIMATERI_SPACE_NOT_ENOUGH = 443,
  RET_PACKAGE_FAICRYSTAL_SPACE_NOT_ENOUGH = 444,
  RET_PACKAGE_SYMBOL_SPACE_NOT_ENOUGH = 445,
  RET_PACKAGE_BOSSIDENTIFY_SPACE_NOT_ENOUGH = 446,
  RET_PACKAGE_FAILIDENTIFY_SPACE_NOT_ENOUGH = 447,
  RET_PACKAGE_USE_NOT_HAVE_PK_VALUE = 448,
  RET_PACKAGE_ITEM_USE_LIMIT = 449,
  RET_PACKAGE_ITEM_LOGIN_GIFT_FETCHED = 450,
  RET_PACKAGE_USE_ITEM_MAP_LIMIT = 451,
  RET_GROW_PART_ENTRY_LEVEL_FULL = 500,
  RET_GROW_PART_NOT_ACTIVE = 501,
  RET_PLAYER_SEAT_STATE_ERROR = 510,
  RET_PLAYER_SEAT_MAP_NOT_SEAT = 511,
  RET_PLAYER_SEAT_NO_TIME = 512,
  RET_GM_NOT_KEY = 601,
  RET_GM_PRAMA_COUNT_ERROR = 602,
  RET_GM_NOT_FIND = 603,
  RET_EQUIP_NOT_EXIST = 620,
  RET_EQUIP_POS_NOT_EXIT_EQUIP = 621,
  RET_MISSION_HAVE_ACCEPT = 700,
  RET_MISSION_CAN_NOT_ACCEPT = 701,
  RET_MISSION_LEVEL_ERROR = 702,
  RET_MISSION_NOT_EXIST = 703,
  RET_MISSION_STATE_NOT_MATCH = 704,
  RET_MISSION_PROFESSION_LIMIT = 705,
  RET_MISSION_TIMES_ERROR = 706,
  RET_MISSION_HAVE_ACCEPT_NUMBER_LIMIT = 707,
  RET_MISSION_GROUP_LIMIT = 708,
  RET_MISSION_NOT_ABANDON = 709,
  RET_MISSION_PERIOD_FINISH_NUM_LIMIT = 710,
  RET_MISSION_PERIOD_ONCE_EXIST_NUM_LIMIT = 711,
  RET_MISSION_HAVE_TYPE_ACCEPT = 712,
  RET_MISSION_CAN_NOT_ONE_KEY = 713,
  RET_MISSION_ONE_KEY_NUM_LIMIT = 714,
  RET_MISSION_NOT_FINISH = 715,
  RET_MISSION_NOT_ACCEPT_UNION = 716,
  RET_MISSION_CAN_NOT_ONCE_FINISH = 717,
  RET_MISSION_ALREADY_SUBMIT = 718,
  RET_RELATION_HAVE_APPLY = 800,
  RET_RELATION_NOT_AGREE = 801,
  RET_RELATION_CAN_NOT_APPLY_SELF = 802,
  RET_RELATION_APPLY_GROUP_ERROR = 803,
  RET_RELATION_NOT_ADD_SELF = 804,
  RET_RELATION_NOT_IN_APPLY = 805,
  RET_RELATION_SIZE_LIMIT_NO_APPLY = 806,
  RET_RELATION_SIZE_LIMIT_NO_APPLY_OTHER = 807,
  RET_RELATION_IS_MY_FRIEND = 808,
  RET_RELATION_SIZE_LIMIT_NO_ADD = 809,
  RET_RELATION_SIZE_LIMIT_NO_ADD_OTHER = 810,
  RET_RELATION_ADD_BLACK_MYSELF = 811,
  RET_RELATION_BALCK_SIZE_LIMIT = 812,
  RET_RELATION_IN_YOUR_BALCK = 813,
  RET_RELATION_IN_OTHER_BALCK = 814,
  RET_RELATION_IN_OTHER_BALCK_CAN_NOT_APPLY = 815,
  RET_RELATION_IN_YOUR_BALCK_CAN_NOT_APPLY = 816,
  RET_RELATION_NOT_SEARCH = 817,
  RET_RELATION_NOT_FRIENDS = 818,
  RET_RELATION_CANOT_ADDFRIEND_TO_BLACK = 819,
  RET_RELATION_GIVE_PHYSICAL_TIMES_LIMIT = 820,
  RET_RELATION_GET_PHYSICAL_TIME_LIMTI = 821,
  RET_RELATION_NOT_GET_PHYSICAL = 822,
  RET_RELATION_HAVE_GET_PHYSICAL = 823,
  RET_RELATION_GET_PHYSICAL_GIFT_LIMIT = 824,
  RET_RELATION_IN_CD_TIME = 825,
  RET_RELATION_TRACK_HATE_ERROR = 826,
  RET_RELATION_GIFT_TO_MAIL = 827,
  RET_RELATION_HAVE_NO_DATA = 828,
  RET_RELATION_MARRY_REFUSE = 829,
  RET_RELATION_HAS_MARRY = 830,
  RET_RELATION_TARGET_HAS_MARRY = 831,
  RET_RELATION_NOT_MARRY = 832,
  RET_RELATION_CLOSENESS_NOT_ENOUGH = 833,
  RET_RELATION_CAN_NOT_DELETE_SPOUSE = 834,
  RET_RELATION_HAVE_PROPOSE_MARRY = 835,
  RET_RELATION_EXIST_SHIELD = 836,
  RET_RELATION_WAIT_DBDATA = 837,
  RET_RELATION_GIFT_NOT_FRIEND = 838,
  RET_RELATION_GIFT_ERROR = 839,
  RET_RELATION_NOT_HAVE_DATE = 840,
  RET_CHAT_NOT_MYSELF = 900,
  RET_CHAT_TARGET_NOT_ONLINE = 901,
  RET_CHAT_TARGET_IN_BLACK = 902,
  RET_CHAT_QUREY_CHAR_NOT_EXITS = 903,
  RET_CHAT_FREE_TIMES_LIMIT = 904,
  RET_CHAT_FREE_GOODS_LIMIT = 905,
  RET_CHAT_CD_TIME_LIMIT = 906,
  RET_CHAT_BIG_HORN_LIMIT = 907,
  RET_CHAT_CD_NoSpeakIng = 908,
  RET_CHAT_PAY_RMB_LIMIT = 909,
  RET_CHAT_COND_LIMIT = 910,
  RET_FACADE_UNACTIVE = 100,
  RET_FACADE_MAX_LEVEL = 4341,
  RET_FACADE_HAVE_DRESS = 4342,
  RET_FACADE_HAVE_NOT_DRESS = 4343,
  RET_FACADE_FRAGMENT_USE_LIMIT = 4344,
  RET_FACADE_NOT_BREAK = 4339,
  RET_FACADE_ALREADY_BREAK = 4338,
  RET_DUPLICATE_CAN_NOT_ENTER = 920,
  RET_DUPLICATE_ALREAY_IN = 921,
  RET_DUPLICATE_RELIVE_NO_DEAD = 922,
  RET_DUPLICATE_PRE_NOT_PASS = 923,
  RET_DUPLICATE_MAX_LEVEL_LIMIT = 924,
  RET_DUPLICATE_CAN_NOT_LEAVE = 925,
  RET_DUPLICATE_LACK_ENTER_NUM = 926,
  RET_DUPLICATE_NOT_IN_TEAM = 927,
  RET_DUPLICATE_NOT_TEM_LEADER = 928,
  RET_DUPLICATE_PLAYER_NUM_LIMIT = 929,
  RET_DUPLICATE_RELIVE_NUM_LIMIT = 930,
  RET_DUPLICATE_BUY_NUM_LIMIT = 931,
  RET_DUPLICATE_ALREADY_PASS = 932,
  RET_DUPLICATE_NOT_IN_DUPLICATE = 933,
  RET_DUPLICATE_TEAM_NOT_INVITE = 934,
  RET_DUPLICATE_TEAM_NOT_REPLY = 935,
  RET_DUPLICATE_TEAM_ALREADY_REPLY = 936,
  RET_DUPLICATE_TEAM_MEM_ALREADY_IN = 937,
  RET_DUPLICATE_TEAM_MEM_NOT_ONLINE = 938,
  RET_DUPLICATE_TEAM_MEM_NOT_AGREE = 939,
  RET_DUPLICATE_NOT_EXISTS = 940,
  RET_DUPLICATE_CAN_NOT_RELIVE = 941,
  RET_DUPLICATE_ALREDY_DEAD = 942,
  RET_DUPLICATE_LACK_GROUP_ENTER_NUM = 943,
  RET_DUPLICATE_CAN_NOT_SEEP = 944,
  RET_DUPLICATE_STAR_LIMIT = 945,
  RET_DULICATE_SWEEP_ITEM_LACK = 946,
  RET_DUPLICATE_TEAMDUP_NOT_ALLOW = 947,
  RET_DUPLICATE_CAN_NOT_INSPIRE = 948,
  RET_DUPLICATE_INSPIRE_NUM_LIMIT = 949,
  RET_DUPLICATE_SWEEP_NOT_SET_INSPIRE = 950,
  RET_DUPLICATE_TEAM_MEM_DEAD = 951,
  RET_DUPLICATE_TEAM_DIE_NOT_REPLY = 952,
  RET_DUPLICATE_TEAM_MEM_SPECIAL_MAP = 953,
  RET_DUPLICATE_ALREDAY_END = 954,
  RET_DUPLICATE_NOT_OPEN = 955,
  RET_DUPLICATE_ALREADY_OPEN = 956,
  RET_DUPLICATE_HAS_NO_OPEN = 957,
  RET_DUPLICATE_IN_CREATE = 958,
  RET_DUPLICATE_CAN_NOT_RESET = 959,
  RET_DUPLICATE_LAYER_ALL_FETCHED = 960,
  RET_DUPLICATE_PALACE_LAYER_FETCHED = 961,
  RET_DUPLICATE_NO_PALACE_REWARD = 962,
  RET_DUPLICATE_TEAM_MEM_NO_UNION = 963,
  RET_DUPLICATE_TEAM_MEM_NOT_SAME_UNION = 964,
  RET_DUPLICATE_TEAM_NOT_SAME_UNION = 965,
  RET_DUPLICATE_MAX_PALACE_LAYER_LIMIT = 966,
  RET_DUPLICATE_TEAM_MEM_NOT_IN_DUP = 967,
  RET_DUPLICATE_PALACE_LAYER_UNUSUAL = 968,
  RET_SKILL_IN_CD = 1000,
  RET_SKILL_CAN_NOT_USE = 1001,
  RET_SKILL_TARGET_NOT_EXIST = 1002,
  RET_SKILL_IN_GROUP_CD = 1003,
  RET_SKILL_IN_FACADE_CD = 1004,
  RET_SKILL_NOT_EXIST = 1005,
  RET_SKILL_LEV_MAX = 1006,
  RET_SKILL_ALREADY_WAKE_UP = 1007,
  RET_SKILL_INVALID_POS = 1008,
  RET_SKILL_CAN_NOT_CHG_POS = 1009,
  RET_SKILL_ALREADY_IN_POS = 1010,
  RET_PLAYER_TIRED_STATE = 1101,
  RET_PLAYER_NOT_DEAD = 1102,
  RET_PLAYER_CAN_NOT_RELIVE = 1103,
  RET_PLAYER_MAP_NOT_RELIVE = 1104,
  RET_PLAYER_RELIVE_NUM_LIMIT = 1105,
  RET_TEAM_ALREADY_JOIN = 1700,
  RET_TEAM_OTHER_ALREADY_JOIN = 1701,
  RET_TEAM_OBJECT_NOT_CHANGE = 1702,
  RET_TEAM_REPEAT_JOIN = 1703,
  RET_TEAM_NO_EXIST = 1704,
  RET_TEAM_FULL = 1705,
  RET_TEAM_HAVE_APPLICANT = 1706,
  RET_TEAM_INVALID_APPLICANT = 1707,
  RET_TEAM_NOT_MEMBER = 1708,
  RET_TEAM_SETTING_LV_ERROR = 1709,
  RET_TEAM_NO_AUTO_MATCH = 1710,
  RET_TEAM_HAVE_AUTO_MATCH = 1711,
  RET_TEAM_NOT_LEADER = 1712,
  RET_TEAM_DUP_NOT_AUTO_MATCH = 1713,
  RET_TEAM_MAP_CAN_NOT_OPERATE = 1714,
  RET_TEAM_MAP_OTHER_CAN_NOT_OPERATE = 1715,
  RET_TEAM_MAP_SELF_IN_SPECIAL = 1716,
  RET_TEAM_MAP_OTHER_IN_SPECIAL = 1717,
  RET_TEAM_MAP_TARGET_IN_MATCH = 1718,
  RET_TEAM_OBJECT_CAN_NOT_OPERATE = 1719,
  RET_USE_ITEM_DAY_LIMIT = 1800
};
bool ERetCode_IsValid(int value);
const ERetCode ERetCode_MIN = RET_SUCCESS;
const ERetCode ERetCode_MAX = RET_FACADE_FRAGMENT_USE_LIMIT;
const int ERetCode_ARRAYSIZE = ERetCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERetCode_descriptor();
inline const ::std::string& ERetCode_Name(ERetCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERetCode_descriptor(), value);
}
inline bool ERetCode_Parse(
    const ::std::string& name, ERetCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERetCode>(
    ERetCode_descriptor(), name, value);
}
enum LOGOUT_TYPE {
  LOGOUT_NONE = 0,
  LOGOUT_LOGOUT = 1,
  LOGOUT_KICK_OUT = 2,
  LOGOUT_REPLACE = 3,
  LOGOUT_DIS_TIME_OUT = 4,
  LOGOUT_CHANGE_LOGIC = 5,
  LOGOUT_RETURN_ROLE_LIST = 6,
  LOGOUT_LOGIN_TIME_OUT = 7,
  LOGOUT_WEB_KICK = 8,
  LOGOUT_CHEAR_KICK = 9,
  LOGOUT_CRASH = 10,
  LOGOUT_OTHER = 11
};
bool LOGOUT_TYPE_IsValid(int value);
const LOGOUT_TYPE LOGOUT_TYPE_MIN = LOGOUT_NONE;
const LOGOUT_TYPE LOGOUT_TYPE_MAX = LOGOUT_OTHER;
const int LOGOUT_TYPE_ARRAYSIZE = LOGOUT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* LOGOUT_TYPE_descriptor();
inline const ::std::string& LOGOUT_TYPE_Name(LOGOUT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    LOGOUT_TYPE_descriptor(), value);
}
inline bool LOGOUT_TYPE_Parse(
    const ::std::string& name, LOGOUT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LOGOUT_TYPE>(
    LOGOUT_TYPE_descriptor(), name, value);
}
enum EMailType {
  MAIL_TYPE_PLAYER = 2,
  MAIL_TYPE_SYSTEM = 3
};
bool EMailType_IsValid(int value);
const EMailType EMailType_MIN = MAIL_TYPE_PLAYER;
const EMailType EMailType_MAX = MAIL_TYPE_SYSTEM;
const int EMailType_ARRAYSIZE = EMailType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EMailType_descriptor();
inline const ::std::string& EMailType_Name(EMailType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EMailType_descriptor(), value);
}
inline bool EMailType_Parse(
    const ::std::string& name, EMailType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EMailType>(
    EMailType_descriptor(), name, value);
}
enum CHAT_CHANNEL {
  CHAT_CHANNEL_NONE = 0,
  CHAT_CHANNEL_WORLD = 1,
  CHAT_CHANNEL_GUILD = 2,
  CHAT_CHANNEL_ENLIST = 3,
  CHAT_CHANNEL_TEAM = 4,
  CHAT_CHANNEL_SCENE = 5,
  CHAT_CHANNEL_CROSS = 6,
  CHAT_CHANNEL_SYSTEM = 7,
  CHAT_CHANNEL_PRIVATE = 8,
  CHAT_CHANNEL_RUMOR = 9,
  CHAT_CHANNEL_HORN = 10,
  CHAT_CHANNEL_BACKEND_RUMOR = 11,
  CHAT_CHANNEL_ACTIVITY = 12,
  CHAT_CHANNEL_POKERROOM = 13,
  CHAT_CHANNEL_LIMIT = 14
};
bool CHAT_CHANNEL_IsValid(int value);
const CHAT_CHANNEL CHAT_CHANNEL_MIN = CHAT_CHANNEL_NONE;
const CHAT_CHANNEL CHAT_CHANNEL_MAX = CHAT_CHANNEL_LIMIT;
const int CHAT_CHANNEL_ARRAYSIZE = CHAT_CHANNEL_MAX + 1;

const ::google::protobuf::EnumDescriptor* CHAT_CHANNEL_descriptor();
inline const ::std::string& CHAT_CHANNEL_Name(CHAT_CHANNEL value) {
  return ::google::protobuf::internal::NameOfEnum(
    CHAT_CHANNEL_descriptor(), value);
}
inline bool CHAT_CHANNEL_Parse(
    const ::std::string& name, CHAT_CHANNEL* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CHAT_CHANNEL>(
    CHAT_CHANNEL_descriptor(), name, value);
}
enum FacadeType {
  FACADE_WING_TYPE = 1,
  FACADE_TREASURE_TYPE = 2,
  FACADE_ARTIFACT_TYPE = 3,
  FACADE_PARTNER_TYPE = 4,
  FACADE_TYPE_MAX = 5
};
bool FacadeType_IsValid(int value);
const FacadeType FacadeType_MIN = FACADE_WING_TYPE;
const FacadeType FacadeType_MAX = FACADE_TYPE_MAX;
const int FacadeType_ARRAYSIZE = FacadeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FacadeType_descriptor();
inline const ::std::string& FacadeType_Name(FacadeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FacadeType_descriptor(), value);
}
inline bool FacadeType_Parse(
    const ::std::string& name, FacadeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FacadeType>(
    FacadeType_descriptor(), name, value);
}
enum EFacadeType {
  EFacadeType_Advance = 1,
  EFacadeType_Fantasy = 2
};
bool EFacadeType_IsValid(int value);
const EFacadeType EFacadeType_MIN = EFacadeType_Advance;
const EFacadeType EFacadeType_MAX = EFacadeType_Fantasy;
const int EFacadeType_ARRAYSIZE = EFacadeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EFacadeType_descriptor();
inline const ::std::string& EFacadeType_Name(EFacadeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EFacadeType_descriptor(), value);
}
inline bool EFacadeType_Parse(
    const ::std::string& name, EFacadeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EFacadeType>(
    EFacadeType_descriptor(), name, value);
}
enum FunctionUnlock_ID_TYPE {
  FunctionUnlock_ID_TYPE_ROLE = 1001,
  FunctionUnlock_ID_TYPE_SKILL = 1002,
  FunctionUnlock_ID_TYPE_WING = 2022,
  FunctionUnlock_ID_TYPE_TREASURE = 2026,
  FunctionUnlock_ID_TYPE_ARTIFACT = 2030,
  FunctionUnlock_ID_TYPE_PARTNER = 2036
};
bool FunctionUnlock_ID_TYPE_IsValid(int value);
const FunctionUnlock_ID_TYPE FunctionUnlock_ID_TYPE_MIN = FunctionUnlock_ID_TYPE_ROLE;
const FunctionUnlock_ID_TYPE FunctionUnlock_ID_TYPE_MAX = FunctionUnlock_ID_TYPE_PARTNER;
const int FunctionUnlock_ID_TYPE_ARRAYSIZE = FunctionUnlock_ID_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* FunctionUnlock_ID_TYPE_descriptor();
inline const ::std::string& FunctionUnlock_ID_TYPE_Name(FunctionUnlock_ID_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    FunctionUnlock_ID_TYPE_descriptor(), value);
}
inline bool FunctionUnlock_ID_TYPE_Parse(
    const ::std::string& name, FunctionUnlock_ID_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FunctionUnlock_ID_TYPE>(
    FunctionUnlock_ID_TYPE_descriptor(), name, value);
}
enum EFacadeAttrType {
  EAttrType_Advance = 1,
  EAttrType_Fantasy = 2,
  EAttrType_Fragment = 3,
  EAttrType_Skill = 4
};
bool EFacadeAttrType_IsValid(int value);
const EFacadeAttrType EFacadeAttrType_MIN = EAttrType_Advance;
const EFacadeAttrType EFacadeAttrType_MAX = EAttrType_Skill;
const int EFacadeAttrType_ARRAYSIZE = EFacadeAttrType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EFacadeAttrType_descriptor();
inline const ::std::string& EFacadeAttrType_Name(EFacadeAttrType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EFacadeAttrType_descriptor(), value);
}
inline bool EFacadeAttrType_Parse(
    const ::std::string& name, EFacadeAttrType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EFacadeAttrType>(
    EFacadeAttrType_descriptor(), name, value);
}
enum EDailyTaskPlayType {
  EDailyTaskPlayType_DUP = 1
};
bool EDailyTaskPlayType_IsValid(int value);
const EDailyTaskPlayType EDailyTaskPlayType_MIN = EDailyTaskPlayType_DUP;
const EDailyTaskPlayType EDailyTaskPlayType_MAX = EDailyTaskPlayType_DUP;
const int EDailyTaskPlayType_ARRAYSIZE = EDailyTaskPlayType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EDailyTaskPlayType_descriptor();
inline const ::std::string& EDailyTaskPlayType_Name(EDailyTaskPlayType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EDailyTaskPlayType_descriptor(), value);
}
inline bool EDailyTaskPlayType_Parse(
    const ::std::string& name, EDailyTaskPlayType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EDailyTaskPlayType>(
    EDailyTaskPlayType_descriptor(), name, value);
}
enum EDailyTaskBackType {
  EDailyTaskBackType_DUP = 1
};
bool EDailyTaskBackType_IsValid(int value);
const EDailyTaskBackType EDailyTaskBackType_MIN = EDailyTaskBackType_DUP;
const EDailyTaskBackType EDailyTaskBackType_MAX = EDailyTaskBackType_DUP;
const int EDailyTaskBackType_ARRAYSIZE = EDailyTaskBackType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EDailyTaskBackType_descriptor();
inline const ::std::string& EDailyTaskBackType_Name(EDailyTaskBackType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EDailyTaskBackType_descriptor(), value);
}
inline bool EDailyTaskBackType_Parse(
    const ::std::string& name, EDailyTaskBackType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EDailyTaskBackType>(
    EDailyTaskBackType_descriptor(), name, value);
}
enum PGType {
  PGType_world_boss_add_num = 1,
  PGType_boss_dup_add_num = 2,
  PGType_boss_nest_add_num = 3,
  PGType_boss_ghost_add_num = 4,
  PGType_level_dup_add_num = 5,
  PGType_deify_dup_add_num = 6,
  PGType_pet_dup_add_num = 7,
  PGType_bagua_dup_add_num = 8,
  PGType_dujie_dup_add_num = 9,
  PGType_equip_dup_add_num = 10
};
bool PGType_IsValid(int value);
const PGType PGType_MIN = PGType_world_boss_add_num;
const PGType PGType_MAX = PGType_equip_dup_add_num;
const int PGType_ARRAYSIZE = PGType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PGType_descriptor();
inline const ::std::string& PGType_Name(PGType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PGType_descriptor(), value);
}
inline bool PGType_Parse(
    const ::std::string& name, PGType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PGType>(
    PGType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::PingConfig>() {
  return ::proto_ff::PingConfig_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::ERoleSex>() {
  return ::proto_ff::ERoleSex_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::ERoleProf>() {
  return ::proto_ff::ERoleProf_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::CurrencyType>() {
  return ::proto_ff::CurrencyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::AreaType>() {
  return ::proto_ff::AreaType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::SamplePolyFlags>() {
  return ::proto_ff::SamplePolyFlags_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::MapDefine>() {
  return ::proto_ff::MapDefine_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::REGION_DEFINE>() {
  return ::proto_ff::REGION_DEFINE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::CharacterDefine>() {
  return ::proto_ff::CharacterDefine_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EItemType>() {
  return ::proto_ff::EItemType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EPackageType>() {
  return ::proto_ff::EPackageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EQuality>() {
  return ::proto_ff::EQuality_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EEquipPos>() {
  return ::proto_ff::EEquipPos_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EConst>() {
  return ::proto_ff::EConst_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::ERetCode>() {
  return ::proto_ff::ERetCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::LOGOUT_TYPE>() {
  return ::proto_ff::LOGOUT_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EMailType>() {
  return ::proto_ff::EMailType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::CHAT_CHANNEL>() {
  return ::proto_ff::CHAT_CHANNEL_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::FacadeType>() {
  return ::proto_ff::FacadeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EFacadeType>() {
  return ::proto_ff::EFacadeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::FunctionUnlock_ID_TYPE>() {
  return ::proto_ff::FunctionUnlock_ID_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EFacadeAttrType>() {
  return ::proto_ff::EFacadeAttrType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EDailyTaskPlayType>() {
  return ::proto_ff::EDailyTaskPlayType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::EDailyTaskBackType>() {
  return ::proto_ff::EDailyTaskBackType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto_ff::PGType>() {
  return ::proto_ff::PGType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ComDefine_2eproto__INCLUDED
