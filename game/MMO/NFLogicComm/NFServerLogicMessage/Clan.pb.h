// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Clan.proto

#ifndef PROTOBUF_Clan_2eproto__INCLUDED
#define PROTOBUF_Clan_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "Com.pb.h"
#include "ComDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace proto_ff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Clan_2eproto();
void protobuf_AssignDesc_Clan_2eproto();
void protobuf_ShutdownFile_Clan_2eproto();

class ClanLog;
class ClanComInfo;
class ApplyClanInfo;
class Clan3MemberInfo;
class ApplyClanListReq;
class NotifyApplyClanList;
class ApplyClanReq;
class ApplyClanRsp;
class ClanCreateReq;
class ClanCreateRsp;
class ClanDataReq;
class NotifyClan3Data;
class ModifyClanInfoReq;
class ModifyClanInfoRsp;
class ClanApplyOptReq;
class ClanApplyOptRsp;
class ClanRoleOptReq;
class ClanRoleOptRsp;
class ClanInviteInfoReq;
class NotifyClanInviteInfo;
class ClanInviteRoleReq;
class ClanInviteRoleRsp;
class NotifyAddClanInvite;
class InviteTargetOptReq;
class InviteTargetOptRsp;
class NotifyRoleClanRank;
class NotifyRoleJoinClan;
class ClanComInfoDB;
class Clan3InfoDB;
class Clan5InfoDB;
class ClanRoleComInfoDB;
class Clan3RoleInfoDB;
class Clan5RoleInfoDB;
class ClanSimple;
class ClanSysOptReq;
class NotifyClanSynRank;
class C2LModifyClanInfoReq;
class L2CModifyClanInfoRsp;

// ===================================================================

class ClanLog : public ::google::protobuf::Message {
 public:
  ClanLog();
  virtual ~ClanLog();

  ClanLog(const ClanLog& from);

  inline ClanLog& operator=(const ClanLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanLog& default_instance();

  void Swap(ClanLog* other);

  // implements Message ----------------------------------------------

  ClanLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanLog& from);
  void MergeFrom(const ClanLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 chat_id = 1;
  inline bool has_chat_id() const;
  inline void clear_chat_id();
  static const int kChatIdFieldNumber = 1;
  inline ::google::protobuf::int32 chat_id() const;
  inline void set_chat_id(::google::protobuf::int32 value);

  // repeated bytes text = 2;
  inline int text_size() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text(int index) const;
  inline ::std::string* mutable_text(int index);
  inline void set_text(int index, const ::std::string& value);
  inline void set_text(int index, const char* value);
  inline void set_text(int index, const void* value, size_t size);
  inline ::std::string* add_text();
  inline void add_text(const ::std::string& value);
  inline void add_text(const char* value);
  inline void add_text(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& text() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_text();

  // repeated uint64 params = 3;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 3;
  inline ::google::protobuf::uint64 params(int index) const;
  inline void set_params(int index, ::google::protobuf::uint64 value);
  inline void add_params(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      params() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_params();

  // optional uint64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ClanLog)
 private:
  inline void set_has_chat_id();
  inline void clear_has_chat_id();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> text_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > params_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::int32 chat_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanLog* default_instance_;
};
// -------------------------------------------------------------------

class ClanComInfo : public ::google::protobuf::Message {
 public:
  ClanComInfo();
  virtual ~ClanComInfo();

  ClanComInfo(const ClanComInfo& from);

  inline ClanComInfo& operator=(const ClanComInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanComInfo& default_instance();

  void Swap(ClanComInfo* other);

  // implements Message ----------------------------------------------

  ClanComInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanComInfo& from);
  void MergeFrom(const ClanComInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 clan_id = 1;
  inline bool has_clan_id() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clan_id() const;
  inline void set_clan_id(::google::protobuf::uint64 value);

  // optional bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 rank = 4;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 4;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // optional int32 zid = 5;
  inline bool has_zid() const;
  inline void clear_zid();
  static const int kZidFieldNumber = 5;
  inline ::google::protobuf::int32 zid() const;
  inline void set_zid(::google::protobuf::int32 value);

  // optional int32 badge_id = 6;
  inline bool has_badge_id() const;
  inline void clear_badge_id();
  static const int kBadgeIdFieldNumber = 6;
  inline ::google::protobuf::int32 badge_id() const;
  inline void set_badge_id(::google::protobuf::int32 value);

  // optional bytes badge_name = 7;
  inline bool has_badge_name() const;
  inline void clear_badge_name();
  static const int kBadgeNameFieldNumber = 7;
  inline const ::std::string& badge_name() const;
  inline void set_badge_name(const ::std::string& value);
  inline void set_badge_name(const char* value);
  inline void set_badge_name(const void* value, size_t size);
  inline ::std::string* mutable_badge_name();
  inline ::std::string* release_badge_name();
  inline void set_allocated_badge_name(::std::string* badge_name);

  // optional uint64 fight = 8;
  inline bool has_fight() const;
  inline void clear_fight();
  static const int kFightFieldNumber = 8;
  inline ::google::protobuf::uint64 fight() const;
  inline void set_fight(::google::protobuf::uint64 value);

  // optional bytes notice = 9;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 9;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const void* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  inline void set_allocated_notice(::std::string* notice);

  // repeated .proto_ff.ClanLog logs = 10;
  inline int logs_size() const;
  inline void clear_logs();
  static const int kLogsFieldNumber = 10;
  inline const ::proto_ff::ClanLog& logs(int index) const;
  inline ::proto_ff::ClanLog* mutable_logs(int index);
  inline ::proto_ff::ClanLog* add_logs();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanLog >&
      logs() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanLog >*
      mutable_logs();

  // optional int32 clan_join_num = 11;
  inline bool has_clan_join_num() const;
  inline void clear_clan_join_num();
  static const int kClanJoinNumFieldNumber = 11;
  inline ::google::protobuf::int32 clan_join_num() const;
  inline void set_clan_join_num(::google::protobuf::int32 value);

  // optional int32 clan_win_num = 12;
  inline bool has_clan_win_num() const;
  inline void clear_clan_win_num();
  static const int kClanWinNumFieldNumber = 12;
  inline ::google::protobuf::int32 clan_win_num() const;
  inline void set_clan_win_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ClanComInfo)
 private:
  inline void set_has_clan_id();
  inline void clear_has_clan_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_zid();
  inline void clear_has_zid();
  inline void set_has_badge_id();
  inline void clear_has_badge_id();
  inline void set_has_badge_name();
  inline void clear_has_badge_name();
  inline void set_has_fight();
  inline void clear_has_fight();
  inline void set_has_notice();
  inline void clear_has_notice();
  inline void set_has_clan_join_num();
  inline void clear_has_clan_join_num();
  inline void set_has_clan_win_num();
  inline void clear_has_clan_win_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 clan_id_;
  ::std::string* name_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 zid_;
  ::google::protobuf::int32 badge_id_;
  ::std::string* badge_name_;
  ::google::protobuf::uint64 fight_;
  ::std::string* notice_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanLog > logs_;
  ::google::protobuf::int32 clan_join_num_;
  ::google::protobuf::int32 clan_win_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanComInfo* default_instance_;
};
// -------------------------------------------------------------------

class ApplyClanInfo : public ::google::protobuf::Message {
 public:
  ApplyClanInfo();
  virtual ~ApplyClanInfo();

  ApplyClanInfo(const ApplyClanInfo& from);

  inline ApplyClanInfo& operator=(const ApplyClanInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyClanInfo& default_instance();

  void Swap(ApplyClanInfo* other);

  // implements Message ----------------------------------------------

  ApplyClanInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyClanInfo& from);
  void MergeFrom(const ApplyClanInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto_ff.ClanComInfo clan = 1;
  inline bool has_clan() const;
  inline void clear_clan();
  static const int kClanFieldNumber = 1;
  inline const ::proto_ff::ClanComInfo& clan() const;
  inline ::proto_ff::ClanComInfo* mutable_clan();
  inline ::proto_ff::ClanComInfo* release_clan();
  inline void set_allocated_clan(::proto_ff::ClanComInfo* clan);

  // optional int32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional bytes leader_name = 4;
  inline bool has_leader_name() const;
  inline void clear_leader_name();
  static const int kLeaderNameFieldNumber = 4;
  inline const ::std::string& leader_name() const;
  inline void set_leader_name(const ::std::string& value);
  inline void set_leader_name(const char* value);
  inline void set_leader_name(const void* value, size_t size);
  inline ::std::string* mutable_leader_name();
  inline ::std::string* release_leader_name();
  inline void set_allocated_leader_name(::std::string* leader_name);

  // @@protoc_insertion_point(class_scope:proto_ff.ApplyClanInfo)
 private:
  inline void set_has_clan();
  inline void clear_has_clan();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_leader_name();
  inline void clear_has_leader_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto_ff::ClanComInfo* clan_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 num_;
  ::std::string* leader_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ApplyClanInfo* default_instance_;
};
// -------------------------------------------------------------------

class Clan3MemberInfo : public ::google::protobuf::Message {
 public:
  Clan3MemberInfo();
  virtual ~Clan3MemberInfo();

  Clan3MemberInfo(const Clan3MemberInfo& from);

  inline Clan3MemberInfo& operator=(const Clan3MemberInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Clan3MemberInfo& default_instance();

  void Swap(Clan3MemberInfo* other);

  // implements Message ----------------------------------------------

  Clan3MemberInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Clan3MemberInfo& from);
  void MergeFrom(const Clan3MemberInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto_ff.RolePlayerMiniInfo mini = 1;
  inline bool has_mini() const;
  inline void clear_mini();
  static const int kMiniFieldNumber = 1;
  inline const ::proto_ff::RolePlayerMiniInfo& mini() const;
  inline ::proto_ff::RolePlayerMiniInfo* mutable_mini();
  inline ::proto_ff::RolePlayerMiniInfo* release_mini();
  inline void set_allocated_mini(::proto_ff::RolePlayerMiniInfo* mini);

  // optional uint64 last_join_time = 2;
  inline bool has_last_join_time() const;
  inline void clear_last_join_time();
  static const int kLastJoinTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 last_join_time() const;
  inline void set_last_join_time(::google::protobuf::uint64 value);

  // optional int32 win_num = 3;
  inline bool has_win_num() const;
  inline void clear_win_num();
  static const int kWinNumFieldNumber = 3;
  inline ::google::protobuf::int32 win_num() const;
  inline void set_win_num(::google::protobuf::int32 value);

  // optional int32 join_num = 4;
  inline bool has_join_num() const;
  inline void clear_join_num();
  static const int kJoinNumFieldNumber = 4;
  inline ::google::protobuf::int32 join_num() const;
  inline void set_join_num(::google::protobuf::int32 value);

  // optional int32 leader = 5;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 5;
  inline ::google::protobuf::int32 leader() const;
  inline void set_leader(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.Clan3MemberInfo)
 private:
  inline void set_has_mini();
  inline void clear_has_mini();
  inline void set_has_last_join_time();
  inline void clear_has_last_join_time();
  inline void set_has_win_num();
  inline void clear_has_win_num();
  inline void set_has_join_num();
  inline void clear_has_join_num();
  inline void set_has_leader();
  inline void clear_has_leader();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto_ff::RolePlayerMiniInfo* mini_;
  ::google::protobuf::uint64 last_join_time_;
  ::google::protobuf::int32 win_num_;
  ::google::protobuf::int32 join_num_;
  ::google::protobuf::int32 leader_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static Clan3MemberInfo* default_instance_;
};
// -------------------------------------------------------------------

class ApplyClanListReq : public ::google::protobuf::Message {
 public:
  ApplyClanListReq();
  virtual ~ApplyClanListReq();

  ApplyClanListReq(const ApplyClanListReq& from);

  inline ApplyClanListReq& operator=(const ApplyClanListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyClanListReq& default_instance();

  void Swap(ApplyClanListReq* other);

  // implements Message ----------------------------------------------

  ApplyClanListReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyClanListReq& from);
  void MergeFrom(const ApplyClanListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ApplyClanListReq)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 clan_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ApplyClanListReq* default_instance_;
};
// -------------------------------------------------------------------

class NotifyApplyClanList : public ::google::protobuf::Message {
 public:
  NotifyApplyClanList();
  virtual ~NotifyApplyClanList();

  NotifyApplyClanList(const NotifyApplyClanList& from);

  inline NotifyApplyClanList& operator=(const NotifyApplyClanList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyApplyClanList& default_instance();

  void Swap(NotifyApplyClanList* other);

  // implements Message ----------------------------------------------

  NotifyApplyClanList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyApplyClanList& from);
  void MergeFrom(const NotifyApplyClanList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // repeated .proto_ff.ApplyClanInfo info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::proto_ff::ApplyClanInfo& info(int index) const;
  inline ::proto_ff::ApplyClanInfo* mutable_info(int index);
  inline ::proto_ff::ApplyClanInfo* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ApplyClanInfo >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ApplyClanInfo >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:proto_ff.NotifyApplyClanList)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::ApplyClanInfo > info_;
  ::google::protobuf::int32 clan_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static NotifyApplyClanList* default_instance_;
};
// -------------------------------------------------------------------

class ApplyClanReq : public ::google::protobuf::Message {
 public:
  ApplyClanReq();
  virtual ~ApplyClanReq();

  ApplyClanReq(const ApplyClanReq& from);

  inline ApplyClanReq& operator=(const ApplyClanReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyClanReq& default_instance();

  void Swap(ApplyClanReq* other);

  // implements Message ----------------------------------------------

  ApplyClanReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyClanReq& from);
  void MergeFrom(const ApplyClanReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // repeated uint64 clan_id = 2;
  inline int clan_id_size() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 2;
  inline ::google::protobuf::uint64 clan_id(int index) const;
  inline void set_clan_id(int index, ::google::protobuf::uint64 value);
  inline void add_clan_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      clan_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_clan_id();

  // @@protoc_insertion_point(class_scope:proto_ff.ApplyClanReq)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > clan_id_;
  ::google::protobuf::int32 clan_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ApplyClanReq* default_instance_;
};
// -------------------------------------------------------------------

class ApplyClanRsp : public ::google::protobuf::Message {
 public:
  ApplyClanRsp();
  virtual ~ApplyClanRsp();

  ApplyClanRsp(const ApplyClanRsp& from);

  inline ApplyClanRsp& operator=(const ApplyClanRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyClanRsp& default_instance();

  void Swap(ApplyClanRsp* other);

  // implements Message ----------------------------------------------

  ApplyClanRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyClanRsp& from);
  void MergeFrom(const ApplyClanRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 clan_type = 2;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 2;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // repeated uint64 clan_id = 3;
  inline int clan_id_size() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 3;
  inline ::google::protobuf::uint64 clan_id(int index) const;
  inline void set_clan_id(int index, ::google::protobuf::uint64 value);
  inline void add_clan_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      clan_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_clan_id();

  // @@protoc_insertion_point(class_scope:proto_ff.ApplyClanRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_clan_type();
  inline void clear_has_clan_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > clan_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ApplyClanRsp* default_instance_;
};
// -------------------------------------------------------------------

class ClanCreateReq : public ::google::protobuf::Message {
 public:
  ClanCreateReq();
  virtual ~ClanCreateReq();

  ClanCreateReq(const ClanCreateReq& from);

  inline ClanCreateReq& operator=(const ClanCreateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanCreateReq& default_instance();

  void Swap(ClanCreateReq* other);

  // implements Message ----------------------------------------------

  ClanCreateReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanCreateReq& from);
  void MergeFrom(const ClanCreateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional bytes clan_name = 2;
  inline bool has_clan_name() const;
  inline void clear_clan_name();
  static const int kClanNameFieldNumber = 2;
  inline const ::std::string& clan_name() const;
  inline void set_clan_name(const ::std::string& value);
  inline void set_clan_name(const char* value);
  inline void set_clan_name(const void* value, size_t size);
  inline ::std::string* mutable_clan_name();
  inline ::std::string* release_clan_name();
  inline void set_allocated_clan_name(::std::string* clan_name);

  // @@protoc_insertion_point(class_scope:proto_ff.ClanCreateReq)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_clan_name();
  inline void clear_has_clan_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* clan_name_;
  ::google::protobuf::int32 clan_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanCreateReq* default_instance_;
};
// -------------------------------------------------------------------

class ClanCreateRsp : public ::google::protobuf::Message {
 public:
  ClanCreateRsp();
  virtual ~ClanCreateRsp();

  ClanCreateRsp(const ClanCreateRsp& from);

  inline ClanCreateRsp& operator=(const ClanCreateRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanCreateRsp& default_instance();

  void Swap(ClanCreateRsp* other);

  // implements Message ----------------------------------------------

  ClanCreateRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanCreateRsp& from);
  void MergeFrom(const ClanCreateRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 clan_type = 2;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 2;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional bytes clan_name = 3;
  inline bool has_clan_name() const;
  inline void clear_clan_name();
  static const int kClanNameFieldNumber = 3;
  inline const ::std::string& clan_name() const;
  inline void set_clan_name(const ::std::string& value);
  inline void set_clan_name(const char* value);
  inline void set_clan_name(const void* value, size_t size);
  inline ::std::string* mutable_clan_name();
  inline ::std::string* release_clan_name();
  inline void set_allocated_clan_name(::std::string* clan_name);

  // @@protoc_insertion_point(class_scope:proto_ff.ClanCreateRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_clan_name();
  inline void clear_has_clan_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 clan_type_;
  ::std::string* clan_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanCreateRsp* default_instance_;
};
// -------------------------------------------------------------------

class ClanDataReq : public ::google::protobuf::Message {
 public:
  ClanDataReq();
  virtual ~ClanDataReq();

  ClanDataReq(const ClanDataReq& from);

  inline ClanDataReq& operator=(const ClanDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanDataReq& default_instance();

  void Swap(ClanDataReq* other);

  // implements Message ----------------------------------------------

  ClanDataReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanDataReq& from);
  void MergeFrom(const ClanDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ClanDataReq)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 clan_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanDataReq* default_instance_;
};
// -------------------------------------------------------------------

class NotifyClan3Data : public ::google::protobuf::Message {
 public:
  NotifyClan3Data();
  virtual ~NotifyClan3Data();

  NotifyClan3Data(const NotifyClan3Data& from);

  inline NotifyClan3Data& operator=(const NotifyClan3Data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyClan3Data& default_instance();

  void Swap(NotifyClan3Data* other);

  // implements Message ----------------------------------------------

  NotifyClan3Data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyClan3Data& from);
  void MergeFrom(const NotifyClan3Data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto_ff.ClanComInfo info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::proto_ff::ClanComInfo& info() const;
  inline ::proto_ff::ClanComInfo* mutable_info();
  inline ::proto_ff::ClanComInfo* release_info();
  inline void set_allocated_info(::proto_ff::ClanComInfo* info);

  // repeated .proto_ff.Clan3MemberInfo members = 2;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 2;
  inline const ::proto_ff::Clan3MemberInfo& members(int index) const;
  inline ::proto_ff::Clan3MemberInfo* mutable_members(int index);
  inline ::proto_ff::Clan3MemberInfo* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::Clan3MemberInfo >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::Clan3MemberInfo >*
      mutable_members();

  // repeated int32 open_badges = 3;
  inline int open_badges_size() const;
  inline void clear_open_badges();
  static const int kOpenBadgesFieldNumber = 3;
  inline ::google::protobuf::int32 open_badges(int index) const;
  inline void set_open_badges(int index, ::google::protobuf::int32 value);
  inline void add_open_badges(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      open_badges() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_open_badges();

  // repeated .proto_ff.RolePlayerMiniInfo apply = 4;
  inline int apply_size() const;
  inline void clear_apply();
  static const int kApplyFieldNumber = 4;
  inline const ::proto_ff::RolePlayerMiniInfo& apply(int index) const;
  inline ::proto_ff::RolePlayerMiniInfo* mutable_apply(int index);
  inline ::proto_ff::RolePlayerMiniInfo* add_apply();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::RolePlayerMiniInfo >&
      apply() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::RolePlayerMiniInfo >*
      mutable_apply();

  // @@protoc_insertion_point(class_scope:proto_ff.NotifyClan3Data)
 private:
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto_ff::ClanComInfo* info_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::Clan3MemberInfo > members_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > open_badges_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::RolePlayerMiniInfo > apply_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static NotifyClan3Data* default_instance_;
};
// -------------------------------------------------------------------

class ModifyClanInfoReq : public ::google::protobuf::Message {
 public:
  ModifyClanInfoReq();
  virtual ~ModifyClanInfoReq();

  ModifyClanInfoReq(const ModifyClanInfoReq& from);

  inline ModifyClanInfoReq& operator=(const ModifyClanInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyClanInfoReq& default_instance();

  void Swap(ModifyClanInfoReq* other);

  // implements Message ----------------------------------------------

  ModifyClanInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyClanInfoReq& from);
  void MergeFrom(const ModifyClanInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional int32 opt_type = 2;
  inline bool has_opt_type() const;
  inline void clear_opt_type();
  static const int kOptTypeFieldNumber = 2;
  inline ::google::protobuf::int32 opt_type() const;
  inline void set_opt_type(::google::protobuf::int32 value);

  // optional bytes name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 badge_id = 4;
  inline bool has_badge_id() const;
  inline void clear_badge_id();
  static const int kBadgeIdFieldNumber = 4;
  inline ::google::protobuf::int32 badge_id() const;
  inline void set_badge_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ModifyClanInfoReq)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_opt_type();
  inline void clear_has_opt_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_badge_id();
  inline void clear_has_badge_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::int32 opt_type_;
  ::std::string* name_;
  ::google::protobuf::int32 badge_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ModifyClanInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class ModifyClanInfoRsp : public ::google::protobuf::Message {
 public:
  ModifyClanInfoRsp();
  virtual ~ModifyClanInfoRsp();

  ModifyClanInfoRsp(const ModifyClanInfoRsp& from);

  inline ModifyClanInfoRsp& operator=(const ModifyClanInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyClanInfoRsp& default_instance();

  void Swap(ModifyClanInfoRsp* other);

  // implements Message ----------------------------------------------

  ModifyClanInfoRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyClanInfoRsp& from);
  void MergeFrom(const ModifyClanInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 clan_type = 2;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 2;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional int32 opt_type = 3;
  inline bool has_opt_type() const;
  inline void clear_opt_type();
  static const int kOptTypeFieldNumber = 3;
  inline ::google::protobuf::int32 opt_type() const;
  inline void set_opt_type(::google::protobuf::int32 value);

  // optional bytes name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 badge_id = 5;
  inline bool has_badge_id() const;
  inline void clear_badge_id();
  static const int kBadgeIdFieldNumber = 5;
  inline ::google::protobuf::int32 badge_id() const;
  inline void set_badge_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ModifyClanInfoRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_opt_type();
  inline void clear_has_opt_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_badge_id();
  inline void clear_has_badge_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 clan_type_;
  ::std::string* name_;
  ::google::protobuf::int32 opt_type_;
  ::google::protobuf::int32 badge_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ModifyClanInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class ClanApplyOptReq : public ::google::protobuf::Message {
 public:
  ClanApplyOptReq();
  virtual ~ClanApplyOptReq();

  ClanApplyOptReq(const ClanApplyOptReq& from);

  inline ClanApplyOptReq& operator=(const ClanApplyOptReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanApplyOptReq& default_instance();

  void Swap(ClanApplyOptReq* other);

  // implements Message ----------------------------------------------

  ClanApplyOptReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanApplyOptReq& from);
  void MergeFrom(const ClanApplyOptReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional uint64 target_cid = 3;
  inline bool has_target_cid() const;
  inline void clear_target_cid();
  static const int kTargetCidFieldNumber = 3;
  inline ::google::protobuf::uint64 target_cid() const;
  inline void set_target_cid(::google::protobuf::uint64 value);

  // optional int32 flag = 4;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 4;
  inline ::google::protobuf::int32 flag() const;
  inline void set_flag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ClanApplyOptReq)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_target_cid();
  inline void clear_has_target_cid();
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::uint64 target_cid_;
  ::google::protobuf::int32 flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanApplyOptReq* default_instance_;
};
// -------------------------------------------------------------------

class ClanApplyOptRsp : public ::google::protobuf::Message {
 public:
  ClanApplyOptRsp();
  virtual ~ClanApplyOptRsp();

  ClanApplyOptRsp(const ClanApplyOptRsp& from);

  inline ClanApplyOptRsp& operator=(const ClanApplyOptRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanApplyOptRsp& default_instance();

  void Swap(ClanApplyOptRsp* other);

  // implements Message ----------------------------------------------

  ClanApplyOptRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanApplyOptRsp& from);
  void MergeFrom(const ClanApplyOptRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 clan_type = 2;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 2;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional uint64 target_cid = 4;
  inline bool has_target_cid() const;
  inline void clear_target_cid();
  static const int kTargetCidFieldNumber = 4;
  inline ::google::protobuf::uint64 target_cid() const;
  inline void set_target_cid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ClanApplyOptRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_target_cid();
  inline void clear_has_target_cid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::uint64 target_cid_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanApplyOptRsp* default_instance_;
};
// -------------------------------------------------------------------

class ClanRoleOptReq : public ::google::protobuf::Message {
 public:
  ClanRoleOptReq();
  virtual ~ClanRoleOptReq();

  ClanRoleOptReq(const ClanRoleOptReq& from);

  inline ClanRoleOptReq& operator=(const ClanRoleOptReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanRoleOptReq& default_instance();

  void Swap(ClanRoleOptReq* other);

  // implements Message ----------------------------------------------

  ClanRoleOptReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanRoleOptReq& from);
  void MergeFrom(const ClanRoleOptReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional uint64 target_cid = 3;
  inline bool has_target_cid() const;
  inline void clear_target_cid();
  static const int kTargetCidFieldNumber = 3;
  inline ::google::protobuf::uint64 target_cid() const;
  inline void set_target_cid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ClanRoleOptReq)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_target_cid();
  inline void clear_has_target_cid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::uint64 target_cid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanRoleOptReq* default_instance_;
};
// -------------------------------------------------------------------

class ClanRoleOptRsp : public ::google::protobuf::Message {
 public:
  ClanRoleOptRsp();
  virtual ~ClanRoleOptRsp();

  ClanRoleOptRsp(const ClanRoleOptRsp& from);

  inline ClanRoleOptRsp& operator=(const ClanRoleOptRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanRoleOptRsp& default_instance();

  void Swap(ClanRoleOptRsp* other);

  // implements Message ----------------------------------------------

  ClanRoleOptRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanRoleOptRsp& from);
  void MergeFrom(const ClanRoleOptRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 clan_type = 2;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 2;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional int32 opt = 3;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 3;
  inline ::google::protobuf::int32 opt() const;
  inline void set_opt(::google::protobuf::int32 value);

  // optional uint64 target_cid = 4;
  inline bool has_target_cid() const;
  inline void clear_target_cid();
  static const int kTargetCidFieldNumber = 4;
  inline ::google::protobuf::uint64 target_cid() const;
  inline void set_target_cid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ClanRoleOptRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_opt();
  inline void clear_has_opt();
  inline void set_has_target_cid();
  inline void clear_has_target_cid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::uint64 target_cid_;
  ::google::protobuf::int32 opt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanRoleOptRsp* default_instance_;
};
// -------------------------------------------------------------------

class ClanInviteInfoReq : public ::google::protobuf::Message {
 public:
  ClanInviteInfoReq();
  virtual ~ClanInviteInfoReq();

  ClanInviteInfoReq(const ClanInviteInfoReq& from);

  inline ClanInviteInfoReq& operator=(const ClanInviteInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanInviteInfoReq& default_instance();

  void Swap(ClanInviteInfoReq* other);

  // implements Message ----------------------------------------------

  ClanInviteInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanInviteInfoReq& from);
  void MergeFrom(const ClanInviteInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ClanInviteInfoReq)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanInviteInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class NotifyClanInviteInfo : public ::google::protobuf::Message {
 public:
  NotifyClanInviteInfo();
  virtual ~NotifyClanInviteInfo();

  NotifyClanInviteInfo(const NotifyClanInviteInfo& from);

  inline NotifyClanInviteInfo& operator=(const NotifyClanInviteInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyClanInviteInfo& default_instance();

  void Swap(NotifyClanInviteInfo* other);

  // implements Message ----------------------------------------------

  NotifyClanInviteInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyClanInviteInfo& from);
  void MergeFrom(const NotifyClanInviteInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated .proto_ff.RolePlayerMiniInfo infos = 3;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 3;
  inline const ::proto_ff::RolePlayerMiniInfo& infos(int index) const;
  inline ::proto_ff::RolePlayerMiniInfo* mutable_infos(int index);
  inline ::proto_ff::RolePlayerMiniInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::RolePlayerMiniInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::RolePlayerMiniInfo >*
      mutable_infos();

  // @@protoc_insertion_point(class_scope:proto_ff.NotifyClanInviteInfo)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::RolePlayerMiniInfo > infos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static NotifyClanInviteInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClanInviteRoleReq : public ::google::protobuf::Message {
 public:
  ClanInviteRoleReq();
  virtual ~ClanInviteRoleReq();

  ClanInviteRoleReq(const ClanInviteRoleReq& from);

  inline ClanInviteRoleReq& operator=(const ClanInviteRoleReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanInviteRoleReq& default_instance();

  void Swap(ClanInviteRoleReq* other);

  // implements Message ----------------------------------------------

  ClanInviteRoleReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanInviteRoleReq& from);
  void MergeFrom(const ClanInviteRoleReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated uint64 target_cids = 3;
  inline int target_cids_size() const;
  inline void clear_target_cids();
  static const int kTargetCidsFieldNumber = 3;
  inline ::google::protobuf::uint64 target_cids(int index) const;
  inline void set_target_cids(int index, ::google::protobuf::uint64 value);
  inline void add_target_cids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      target_cids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_target_cids();

  // @@protoc_insertion_point(class_scope:proto_ff.ClanInviteRoleReq)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > target_cids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanInviteRoleReq* default_instance_;
};
// -------------------------------------------------------------------

class ClanInviteRoleRsp : public ::google::protobuf::Message {
 public:
  ClanInviteRoleRsp();
  virtual ~ClanInviteRoleRsp();

  ClanInviteRoleRsp(const ClanInviteRoleRsp& from);

  inline ClanInviteRoleRsp& operator=(const ClanInviteRoleRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanInviteRoleRsp& default_instance();

  void Swap(ClanInviteRoleRsp* other);

  // implements Message ----------------------------------------------

  ClanInviteRoleRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanInviteRoleRsp& from);
  void MergeFrom(const ClanInviteRoleRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 clan_type = 2;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 2;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated uint64 target_cids = 4;
  inline int target_cids_size() const;
  inline void clear_target_cids();
  static const int kTargetCidsFieldNumber = 4;
  inline ::google::protobuf::uint64 target_cids(int index) const;
  inline void set_target_cids(int index, ::google::protobuf::uint64 value);
  inline void add_target_cids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      target_cids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_target_cids();

  // @@protoc_insertion_point(class_scope:proto_ff.ClanInviteRoleRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > target_cids_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanInviteRoleRsp* default_instance_;
};
// -------------------------------------------------------------------

class NotifyAddClanInvite : public ::google::protobuf::Message {
 public:
  NotifyAddClanInvite();
  virtual ~NotifyAddClanInvite();

  NotifyAddClanInvite(const NotifyAddClanInvite& from);

  inline NotifyAddClanInvite& operator=(const NotifyAddClanInvite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyAddClanInvite& default_instance();

  void Swap(NotifyAddClanInvite* other);

  // implements Message ----------------------------------------------

  NotifyAddClanInvite* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyAddClanInvite& from);
  void MergeFrom(const NotifyAddClanInvite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 send_cid = 1;
  inline bool has_send_cid() const;
  inline void clear_send_cid();
  static const int kSendCidFieldNumber = 1;
  inline ::google::protobuf::uint64 send_cid() const;
  inline void set_send_cid(::google::protobuf::uint64 value);

  // optional bytes send_name = 2;
  inline bool has_send_name() const;
  inline void clear_send_name();
  static const int kSendNameFieldNumber = 2;
  inline const ::std::string& send_name() const;
  inline void set_send_name(const ::std::string& value);
  inline void set_send_name(const char* value);
  inline void set_send_name(const void* value, size_t size);
  inline ::std::string* mutable_send_name();
  inline ::std::string* release_send_name();
  inline void set_allocated_send_name(::std::string* send_name);

  // optional int32 clan_type = 3;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 3;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional uint64 clan_id = 4;
  inline bool has_clan_id() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 4;
  inline ::google::protobuf::uint64 clan_id() const;
  inline void set_clan_id(::google::protobuf::uint64 value);

  // optional bytes clan_name = 5;
  inline bool has_clan_name() const;
  inline void clear_clan_name();
  static const int kClanNameFieldNumber = 5;
  inline const ::std::string& clan_name() const;
  inline void set_clan_name(const ::std::string& value);
  inline void set_clan_name(const char* value);
  inline void set_clan_name(const void* value, size_t size);
  inline ::std::string* mutable_clan_name();
  inline ::std::string* release_clan_name();
  inline void set_allocated_clan_name(::std::string* clan_name);

  // optional int32 clan_score = 6;
  inline bool has_clan_score() const;
  inline void clear_clan_score();
  static const int kClanScoreFieldNumber = 6;
  inline ::google::protobuf::int32 clan_score() const;
  inline void set_clan_score(::google::protobuf::int32 value);

  // optional int32 fight = 7;
  inline bool has_fight() const;
  inline void clear_fight();
  static const int kFightFieldNumber = 7;
  inline ::google::protobuf::int32 fight() const;
  inline void set_fight(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.NotifyAddClanInvite)
 private:
  inline void set_has_send_cid();
  inline void clear_has_send_cid();
  inline void set_has_send_name();
  inline void clear_has_send_name();
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_clan_id();
  inline void clear_has_clan_id();
  inline void set_has_clan_name();
  inline void clear_has_clan_name();
  inline void set_has_clan_score();
  inline void clear_has_clan_score();
  inline void set_has_fight();
  inline void clear_has_fight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 send_cid_;
  ::std::string* send_name_;
  ::google::protobuf::uint64 clan_id_;
  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::int32 clan_score_;
  ::std::string* clan_name_;
  ::google::protobuf::int32 fight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static NotifyAddClanInvite* default_instance_;
};
// -------------------------------------------------------------------

class InviteTargetOptReq : public ::google::protobuf::Message {
 public:
  InviteTargetOptReq();
  virtual ~InviteTargetOptReq();

  InviteTargetOptReq(const InviteTargetOptReq& from);

  inline InviteTargetOptReq& operator=(const InviteTargetOptReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InviteTargetOptReq& default_instance();

  void Swap(InviteTargetOptReq* other);

  // implements Message ----------------------------------------------

  InviteTargetOptReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InviteTargetOptReq& from);
  void MergeFrom(const InviteTargetOptReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional uint64 clan_id = 2;
  inline bool has_clan_id() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 2;
  inline ::google::protobuf::uint64 clan_id() const;
  inline void set_clan_id(::google::protobuf::uint64 value);

  // optional int32 opt_type = 3;
  inline bool has_opt_type() const;
  inline void clear_opt_type();
  static const int kOptTypeFieldNumber = 3;
  inline ::google::protobuf::int32 opt_type() const;
  inline void set_opt_type(::google::protobuf::int32 value);

  // optional int32 flag = 4;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 4;
  inline ::google::protobuf::int32 flag() const;
  inline void set_flag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.InviteTargetOptReq)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_clan_id();
  inline void clear_has_clan_id();
  inline void set_has_opt_type();
  inline void clear_has_opt_type();
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 clan_id_;
  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::int32 opt_type_;
  ::google::protobuf::int32 flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static InviteTargetOptReq* default_instance_;
};
// -------------------------------------------------------------------

class InviteTargetOptRsp : public ::google::protobuf::Message {
 public:
  InviteTargetOptRsp();
  virtual ~InviteTargetOptRsp();

  InviteTargetOptRsp(const InviteTargetOptRsp& from);

  inline InviteTargetOptRsp& operator=(const InviteTargetOptRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InviteTargetOptRsp& default_instance();

  void Swap(InviteTargetOptRsp* other);

  // implements Message ----------------------------------------------

  InviteTargetOptRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InviteTargetOptRsp& from);
  void MergeFrom(const InviteTargetOptRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 clan_type = 2;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 2;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional uint64 clan_id = 3;
  inline bool has_clan_id() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 3;
  inline ::google::protobuf::uint64 clan_id() const;
  inline void set_clan_id(::google::protobuf::uint64 value);

  // optional int32 opt_type = 4;
  inline bool has_opt_type() const;
  inline void clear_opt_type();
  static const int kOptTypeFieldNumber = 4;
  inline ::google::protobuf::int32 opt_type() const;
  inline void set_opt_type(::google::protobuf::int32 value);

  // optional int32 clan_score = 5;
  inline bool has_clan_score() const;
  inline void clear_clan_score();
  static const int kClanScoreFieldNumber = 5;
  inline ::google::protobuf::int32 clan_score() const;
  inline void set_clan_score(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.InviteTargetOptRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_clan_id();
  inline void clear_has_clan_id();
  inline void set_has_opt_type();
  inline void clear_has_opt_type();
  inline void set_has_clan_score();
  inline void clear_has_clan_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::uint64 clan_id_;
  ::google::protobuf::int32 opt_type_;
  ::google::protobuf::int32 clan_score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static InviteTargetOptRsp* default_instance_;
};
// -------------------------------------------------------------------

class NotifyRoleClanRank : public ::google::protobuf::Message {
 public:
  NotifyRoleClanRank();
  virtual ~NotifyRoleClanRank();

  NotifyRoleClanRank(const NotifyRoleClanRank& from);

  inline NotifyRoleClanRank& operator=(const NotifyRoleClanRank& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyRoleClanRank& default_instance();

  void Swap(NotifyRoleClanRank* other);

  // implements Message ----------------------------------------------

  NotifyRoleClanRank* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyRoleClanRank& from);
  void MergeFrom(const NotifyRoleClanRank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional int32 rank = 2;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 2;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.NotifyRoleClanRank)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_rank();
  inline void clear_has_rank();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::int32 rank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static NotifyRoleClanRank* default_instance_;
};
// -------------------------------------------------------------------

class NotifyRoleJoinClan : public ::google::protobuf::Message {
 public:
  NotifyRoleJoinClan();
  virtual ~NotifyRoleJoinClan();

  NotifyRoleJoinClan(const NotifyRoleJoinClan& from);

  inline NotifyRoleJoinClan& operator=(const NotifyRoleJoinClan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyRoleJoinClan& default_instance();

  void Swap(NotifyRoleJoinClan* other);

  // implements Message ----------------------------------------------

  NotifyRoleJoinClan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyRoleJoinClan& from);
  void MergeFrom(const NotifyRoleJoinClan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 clan_id = 1;
  inline bool has_clan_id() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clan_id() const;
  inline void set_clan_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.NotifyRoleJoinClan)
 private:
  inline void set_has_clan_id();
  inline void clear_has_clan_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 clan_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static NotifyRoleJoinClan* default_instance_;
};
// -------------------------------------------------------------------

class ClanComInfoDB : public ::google::protobuf::Message {
 public:
  ClanComInfoDB();
  virtual ~ClanComInfoDB();

  ClanComInfoDB(const ClanComInfoDB& from);

  inline ClanComInfoDB& operator=(const ClanComInfoDB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanComInfoDB& default_instance();

  void Swap(ClanComInfoDB* other);

  // implements Message ----------------------------------------------

  ClanComInfoDB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanComInfoDB& from);
  void MergeFrom(const ClanComInfoDB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 clan_id = 1;
  inline bool has_clan_id() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clan_id() const;
  inline void set_clan_id(::google::protobuf::uint64 value);

  // optional int32 zid = 2;
  inline bool has_zid() const;
  inline void clear_zid();
  static const int kZidFieldNumber = 2;
  inline ::google::protobuf::int32 zid() const;
  inline void set_zid(::google::protobuf::int32 value);

  // optional bytes name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 badge_id = 5;
  inline bool has_badge_id() const;
  inline void clear_badge_id();
  static const int kBadgeIdFieldNumber = 5;
  inline ::google::protobuf::int32 badge_id() const;
  inline void set_badge_id(::google::protobuf::int32 value);

  // optional bytes badge_name = 6;
  inline bool has_badge_name() const;
  inline void clear_badge_name();
  static const int kBadgeNameFieldNumber = 6;
  inline const ::std::string& badge_name() const;
  inline void set_badge_name(const ::std::string& value);
  inline void set_badge_name(const char* value);
  inline void set_badge_name(const void* value, size_t size);
  inline ::std::string* mutable_badge_name();
  inline ::std::string* release_badge_name();
  inline void set_allocated_badge_name(::std::string* badge_name);

  // optional bytes notice = 7;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 7;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const void* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  inline void set_allocated_notice(::std::string* notice);

  // repeated .proto_ff.ClanLog logs = 8;
  inline int logs_size() const;
  inline void clear_logs();
  static const int kLogsFieldNumber = 8;
  inline const ::proto_ff::ClanLog& logs(int index) const;
  inline ::proto_ff::ClanLog* mutable_logs(int index);
  inline ::proto_ff::ClanLog* add_logs();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanLog >&
      logs() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanLog >*
      mutable_logs();

  // optional uint64 leader_cid = 9;
  inline bool has_leader_cid() const;
  inline void clear_leader_cid();
  static const int kLeaderCidFieldNumber = 9;
  inline ::google::protobuf::uint64 leader_cid() const;
  inline void set_leader_cid(::google::protobuf::uint64 value);

  // repeated uint64 members = 10;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 10;
  inline ::google::protobuf::uint64 members(int index) const;
  inline void set_members(int index, ::google::protobuf::uint64 value);
  inline void add_members(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      members() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_members();

  // repeated uint64 refuse_list = 11;
  inline int refuse_list_size() const;
  inline void clear_refuse_list();
  static const int kRefuseListFieldNumber = 11;
  inline ::google::protobuf::uint64 refuse_list(int index) const;
  inline void set_refuse_list(int index, ::google::protobuf::uint64 value);
  inline void add_refuse_list(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      refuse_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_refuse_list();

  // repeated uint64 apply_list = 12;
  inline int apply_list_size() const;
  inline void clear_apply_list();
  static const int kApplyListFieldNumber = 12;
  inline ::google::protobuf::uint64 apply_list(int index) const;
  inline void set_apply_list(int index, ::google::protobuf::uint64 value);
  inline void add_apply_list(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      apply_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_apply_list();

  // optional uint64 update_score_time = 13;
  inline bool has_update_score_time() const;
  inline void clear_update_score_time();
  static const int kUpdateScoreTimeFieldNumber = 13;
  inline ::google::protobuf::uint64 update_score_time() const;
  inline void set_update_score_time(::google::protobuf::uint64 value);

  // optional int32 clan_join_num = 14;
  inline bool has_clan_join_num() const;
  inline void clear_clan_join_num();
  static const int kClanJoinNumFieldNumber = 14;
  inline ::google::protobuf::int32 clan_join_num() const;
  inline void set_clan_join_num(::google::protobuf::int32 value);

  // optional int32 clan_win_num = 15;
  inline bool has_clan_win_num() const;
  inline void clear_clan_win_num();
  static const int kClanWinNumFieldNumber = 15;
  inline ::google::protobuf::int32 clan_win_num() const;
  inline void set_clan_win_num(::google::protobuf::int32 value);

  // repeated int32 open_badge = 16;
  inline int open_badge_size() const;
  inline void clear_open_badge();
  static const int kOpenBadgeFieldNumber = 16;
  inline ::google::protobuf::int32 open_badge(int index) const;
  inline void set_open_badge(int index, ::google::protobuf::int32 value);
  inline void add_open_badge(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      open_badge() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_open_badge();

  // optional uint64 refresh_time = 17;
  inline bool has_refresh_time() const;
  inline void clear_refresh_time();
  static const int kRefreshTimeFieldNumber = 17;
  inline ::google::protobuf::uint64 refresh_time() const;
  inline void set_refresh_time(::google::protobuf::uint64 value);

  // optional uint64 fight = 18;
  inline bool has_fight() const;
  inline void clear_fight();
  static const int kFightFieldNumber = 18;
  inline ::google::protobuf::uint64 fight() const;
  inline void set_fight(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ClanComInfoDB)
 private:
  inline void set_has_clan_id();
  inline void clear_has_clan_id();
  inline void set_has_zid();
  inline void clear_has_zid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_badge_id();
  inline void clear_has_badge_id();
  inline void set_has_badge_name();
  inline void clear_has_badge_name();
  inline void set_has_notice();
  inline void clear_has_notice();
  inline void set_has_leader_cid();
  inline void clear_has_leader_cid();
  inline void set_has_update_score_time();
  inline void clear_has_update_score_time();
  inline void set_has_clan_join_num();
  inline void clear_has_clan_join_num();
  inline void set_has_clan_win_num();
  inline void clear_has_clan_win_num();
  inline void set_has_refresh_time();
  inline void clear_has_refresh_time();
  inline void set_has_fight();
  inline void clear_has_fight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 clan_id_;
  ::std::string* name_;
  ::google::protobuf::int32 zid_;
  ::google::protobuf::int32 score_;
  ::std::string* badge_name_;
  ::std::string* notice_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanLog > logs_;
  ::google::protobuf::uint64 leader_cid_;
  ::google::protobuf::int32 badge_id_;
  ::google::protobuf::int32 clan_join_num_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > members_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > refuse_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > apply_list_;
  ::google::protobuf::uint64 update_score_time_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > open_badge_;
  ::google::protobuf::uint64 refresh_time_;
  ::google::protobuf::uint64 fight_;
  ::google::protobuf::int32 clan_win_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanComInfoDB* default_instance_;
};
// -------------------------------------------------------------------

class Clan3InfoDB : public ::google::protobuf::Message {
 public:
  Clan3InfoDB();
  virtual ~Clan3InfoDB();

  Clan3InfoDB(const Clan3InfoDB& from);

  inline Clan3InfoDB& operator=(const Clan3InfoDB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Clan3InfoDB& default_instance();

  void Swap(Clan3InfoDB* other);

  // implements Message ----------------------------------------------

  Clan3InfoDB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Clan3InfoDB& from);
  void MergeFrom(const Clan3InfoDB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto_ff.ClanComInfoDB com = 1;
  inline bool has_com() const;
  inline void clear_com();
  static const int kComFieldNumber = 1;
  inline const ::proto_ff::ClanComInfoDB& com() const;
  inline ::proto_ff::ClanComInfoDB* mutable_com();
  inline ::proto_ff::ClanComInfoDB* release_com();
  inline void set_allocated_com(::proto_ff::ClanComInfoDB* com);

  // @@protoc_insertion_point(class_scope:proto_ff.Clan3InfoDB)
 private:
  inline void set_has_com();
  inline void clear_has_com();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto_ff::ClanComInfoDB* com_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static Clan3InfoDB* default_instance_;
};
// -------------------------------------------------------------------

class Clan5InfoDB : public ::google::protobuf::Message {
 public:
  Clan5InfoDB();
  virtual ~Clan5InfoDB();

  Clan5InfoDB(const Clan5InfoDB& from);

  inline Clan5InfoDB& operator=(const Clan5InfoDB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Clan5InfoDB& default_instance();

  void Swap(Clan5InfoDB* other);

  // implements Message ----------------------------------------------

  Clan5InfoDB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Clan5InfoDB& from);
  void MergeFrom(const Clan5InfoDB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto_ff.ClanComInfoDB com = 1;
  inline bool has_com() const;
  inline void clear_com();
  static const int kComFieldNumber = 1;
  inline const ::proto_ff::ClanComInfoDB& com() const;
  inline ::proto_ff::ClanComInfoDB* mutable_com();
  inline ::proto_ff::ClanComInfoDB* release_com();
  inline void set_allocated_com(::proto_ff::ClanComInfoDB* com);

  // @@protoc_insertion_point(class_scope:proto_ff.Clan5InfoDB)
 private:
  inline void set_has_com();
  inline void clear_has_com();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto_ff::ClanComInfoDB* com_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static Clan5InfoDB* default_instance_;
};
// -------------------------------------------------------------------

class ClanRoleComInfoDB : public ::google::protobuf::Message {
 public:
  ClanRoleComInfoDB();
  virtual ~ClanRoleComInfoDB();

  ClanRoleComInfoDB(const ClanRoleComInfoDB& from);

  inline ClanRoleComInfoDB& operator=(const ClanRoleComInfoDB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanRoleComInfoDB& default_instance();

  void Swap(ClanRoleComInfoDB* other);

  // implements Message ----------------------------------------------

  ClanRoleComInfoDB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanRoleComInfoDB& from);
  void MergeFrom(const ClanRoleComInfoDB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline ::google::protobuf::uint64 cid() const;
  inline void set_cid(::google::protobuf::uint64 value);

  // optional uint64 ban_time = 2;
  inline bool has_ban_time() const;
  inline void clear_ban_time();
  static const int kBanTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 ban_time() const;
  inline void set_ban_time(::google::protobuf::uint64 value);

  // repeated uint64 refuse_invite_list = 3;
  inline int refuse_invite_list_size() const;
  inline void clear_refuse_invite_list();
  static const int kRefuseInviteListFieldNumber = 3;
  inline ::google::protobuf::uint64 refuse_invite_list(int index) const;
  inline void set_refuse_invite_list(int index, ::google::protobuf::uint64 value);
  inline void add_refuse_invite_list(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      refuse_invite_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_refuse_invite_list();

  // optional uint64 update_time = 4;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 update_time() const;
  inline void set_update_time(::google::protobuf::uint64 value);

  // optional uint64 last_join_time = 5;
  inline bool has_last_join_time() const;
  inline void clear_last_join_time();
  static const int kLastJoinTimeFieldNumber = 5;
  inline ::google::protobuf::uint64 last_join_time() const;
  inline void set_last_join_time(::google::protobuf::uint64 value);

  // repeated uint64 invite_list = 6;
  inline int invite_list_size() const;
  inline void clear_invite_list();
  static const int kInviteListFieldNumber = 6;
  inline ::google::protobuf::uint64 invite_list(int index) const;
  inline void set_invite_list(int index, ::google::protobuf::uint64 value);
  inline void add_invite_list(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      invite_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_invite_list();

  // @@protoc_insertion_point(class_scope:proto_ff.ClanRoleComInfoDB)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_ban_time();
  inline void clear_has_ban_time();
  inline void set_has_update_time();
  inline void clear_has_update_time();
  inline void set_has_last_join_time();
  inline void clear_has_last_join_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cid_;
  ::google::protobuf::uint64 ban_time_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > refuse_invite_list_;
  ::google::protobuf::uint64 update_time_;
  ::google::protobuf::uint64 last_join_time_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > invite_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanRoleComInfoDB* default_instance_;
};
// -------------------------------------------------------------------

class Clan3RoleInfoDB : public ::google::protobuf::Message {
 public:
  Clan3RoleInfoDB();
  virtual ~Clan3RoleInfoDB();

  Clan3RoleInfoDB(const Clan3RoleInfoDB& from);

  inline Clan3RoleInfoDB& operator=(const Clan3RoleInfoDB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Clan3RoleInfoDB& default_instance();

  void Swap(Clan3RoleInfoDB* other);

  // implements Message ----------------------------------------------

  Clan3RoleInfoDB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Clan3RoleInfoDB& from);
  void MergeFrom(const Clan3RoleInfoDB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto_ff.ClanRoleComInfoDB com = 1;
  inline bool has_com() const;
  inline void clear_com();
  static const int kComFieldNumber = 1;
  inline const ::proto_ff::ClanRoleComInfoDB& com() const;
  inline ::proto_ff::ClanRoleComInfoDB* mutable_com();
  inline ::proto_ff::ClanRoleComInfoDB* release_com();
  inline void set_allocated_com(::proto_ff::ClanRoleComInfoDB* com);

  // optional int32 role_join_num = 2;
  inline bool has_role_join_num() const;
  inline void clear_role_join_num();
  static const int kRoleJoinNumFieldNumber = 2;
  inline ::google::protobuf::int32 role_join_num() const;
  inline void set_role_join_num(::google::protobuf::int32 value);

  // optional int32 role_win_num = 3;
  inline bool has_role_win_num() const;
  inline void clear_role_win_num();
  static const int kRoleWinNumFieldNumber = 3;
  inline ::google::protobuf::int32 role_win_num() const;
  inline void set_role_win_num(::google::protobuf::int32 value);

  // optional int32 role_cw_num = 4;
  inline bool has_role_cw_num() const;
  inline void clear_role_cw_num();
  static const int kRoleCwNumFieldNumber = 4;
  inline ::google::protobuf::int32 role_cw_num() const;
  inline void set_role_cw_num(::google::protobuf::int32 value);

  // optional int32 role_dead_num = 5;
  inline bool has_role_dead_num() const;
  inline void clear_role_dead_num();
  static const int kRoleDeadNumFieldNumber = 5;
  inline ::google::protobuf::int32 role_dead_num() const;
  inline void set_role_dead_num(::google::protobuf::int32 value);

  // optional int32 role_cl_num = 6;
  inline bool has_role_cl_num() const;
  inline void clear_role_cl_num();
  static const int kRoleClNumFieldNumber = 6;
  inline ::google::protobuf::int32 role_cl_num() const;
  inline void set_role_cl_num(::google::protobuf::int32 value);

  // optional int32 day_join_num = 7;
  inline bool has_day_join_num() const;
  inline void clear_day_join_num();
  static const int kDayJoinNumFieldNumber = 7;
  inline ::google::protobuf::int32 day_join_num() const;
  inline void set_day_join_num(::google::protobuf::int32 value);

  // repeated int32 day_recv_id = 8;
  inline int day_recv_id_size() const;
  inline void clear_day_recv_id();
  static const int kDayRecvIdFieldNumber = 8;
  inline ::google::protobuf::int32 day_recv_id(int index) const;
  inline void set_day_recv_id(int index, ::google::protobuf::int32 value);
  inline void add_day_recv_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      day_recv_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_day_recv_id();

  // optional int32 mvp_num = 9;
  inline bool has_mvp_num() const;
  inline void clear_mvp_num();
  static const int kMvpNumFieldNumber = 9;
  inline ::google::protobuf::int32 mvp_num() const;
  inline void set_mvp_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto_ff.Clan3RoleInfoDB)
 private:
  inline void set_has_com();
  inline void clear_has_com();
  inline void set_has_role_join_num();
  inline void clear_has_role_join_num();
  inline void set_has_role_win_num();
  inline void clear_has_role_win_num();
  inline void set_has_role_cw_num();
  inline void clear_has_role_cw_num();
  inline void set_has_role_dead_num();
  inline void clear_has_role_dead_num();
  inline void set_has_role_cl_num();
  inline void clear_has_role_cl_num();
  inline void set_has_day_join_num();
  inline void clear_has_day_join_num();
  inline void set_has_mvp_num();
  inline void clear_has_mvp_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto_ff::ClanRoleComInfoDB* com_;
  ::google::protobuf::int32 role_join_num_;
  ::google::protobuf::int32 role_win_num_;
  ::google::protobuf::int32 role_cw_num_;
  ::google::protobuf::int32 role_dead_num_;
  ::google::protobuf::int32 role_cl_num_;
  ::google::protobuf::int32 day_join_num_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > day_recv_id_;
  ::google::protobuf::int32 mvp_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static Clan3RoleInfoDB* default_instance_;
};
// -------------------------------------------------------------------

class Clan5RoleInfoDB : public ::google::protobuf::Message {
 public:
  Clan5RoleInfoDB();
  virtual ~Clan5RoleInfoDB();

  Clan5RoleInfoDB(const Clan5RoleInfoDB& from);

  inline Clan5RoleInfoDB& operator=(const Clan5RoleInfoDB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Clan5RoleInfoDB& default_instance();

  void Swap(Clan5RoleInfoDB* other);

  // implements Message ----------------------------------------------

  Clan5RoleInfoDB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Clan5RoleInfoDB& from);
  void MergeFrom(const Clan5RoleInfoDB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto_ff.ClanRoleComInfoDB com = 1;
  inline bool has_com() const;
  inline void clear_com();
  static const int kComFieldNumber = 1;
  inline const ::proto_ff::ClanRoleComInfoDB& com() const;
  inline ::proto_ff::ClanRoleComInfoDB* mutable_com();
  inline ::proto_ff::ClanRoleComInfoDB* release_com();
  inline void set_allocated_com(::proto_ff::ClanRoleComInfoDB* com);

  // @@protoc_insertion_point(class_scope:proto_ff.Clan5RoleInfoDB)
 private:
  inline void set_has_com();
  inline void clear_has_com();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto_ff::ClanRoleComInfoDB* com_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static Clan5RoleInfoDB* default_instance_;
};
// -------------------------------------------------------------------

class ClanSimple : public ::google::protobuf::Message {
 public:
  ClanSimple();
  virtual ~ClanSimple();

  ClanSimple(const ClanSimple& from);

  inline ClanSimple& operator=(const ClanSimple& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanSimple& default_instance();

  void Swap(ClanSimple* other);

  // implements Message ----------------------------------------------

  ClanSimple* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanSimple& from);
  void MergeFrom(const ClanSimple& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 clan_id = 1;
  inline bool has_clan_id() const;
  inline void clear_clan_id();
  static const int kClanIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clan_id() const;
  inline void set_clan_id(::google::protobuf::uint64 value);

  // optional int32 zid = 2;
  inline bool has_zid() const;
  inline void clear_zid();
  static const int kZidFieldNumber = 2;
  inline ::google::protobuf::int32 zid() const;
  inline void set_zid(::google::protobuf::int32 value);

  // optional bytes name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 badge_id = 5;
  inline bool has_badge_id() const;
  inline void clear_badge_id();
  static const int kBadgeIdFieldNumber = 5;
  inline ::google::protobuf::int32 badge_id() const;
  inline void set_badge_id(::google::protobuf::int32 value);

  // optional bytes badge_name = 6;
  inline bool has_badge_name() const;
  inline void clear_badge_name();
  static const int kBadgeNameFieldNumber = 6;
  inline const ::std::string& badge_name() const;
  inline void set_badge_name(const ::std::string& value);
  inline void set_badge_name(const char* value);
  inline void set_badge_name(const void* value, size_t size);
  inline ::std::string* mutable_badge_name();
  inline ::std::string* release_badge_name();
  inline void set_allocated_badge_name(::std::string* badge_name);

  // optional uint64 leader_cid = 7;
  inline bool has_leader_cid() const;
  inline void clear_leader_cid();
  static const int kLeaderCidFieldNumber = 7;
  inline ::google::protobuf::uint64 leader_cid() const;
  inline void set_leader_cid(::google::protobuf::uint64 value);

  // repeated uint64 members = 8;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 8;
  inline ::google::protobuf::uint64 members(int index) const;
  inline void set_members(int index, ::google::protobuf::uint64 value);
  inline void add_members(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      members() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_members();

  // optional uint64 update_score_time = 9;
  inline bool has_update_score_time() const;
  inline void clear_update_score_time();
  static const int kUpdateScoreTimeFieldNumber = 9;
  inline ::google::protobuf::uint64 update_score_time() const;
  inline void set_update_score_time(::google::protobuf::uint64 value);

  // optional uint64 fight = 10;
  inline bool has_fight() const;
  inline void clear_fight();
  static const int kFightFieldNumber = 10;
  inline ::google::protobuf::uint64 fight() const;
  inline void set_fight(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto_ff.ClanSimple)
 private:
  inline void set_has_clan_id();
  inline void clear_has_clan_id();
  inline void set_has_zid();
  inline void clear_has_zid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_badge_id();
  inline void clear_has_badge_id();
  inline void set_has_badge_name();
  inline void clear_has_badge_name();
  inline void set_has_leader_cid();
  inline void clear_has_leader_cid();
  inline void set_has_update_score_time();
  inline void clear_has_update_score_time();
  inline void set_has_fight();
  inline void clear_has_fight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 clan_id_;
  ::std::string* name_;
  ::google::protobuf::int32 zid_;
  ::google::protobuf::int32 score_;
  ::std::string* badge_name_;
  ::google::protobuf::uint64 leader_cid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > members_;
  ::google::protobuf::uint64 update_score_time_;
  ::google::protobuf::uint64 fight_;
  ::google::protobuf::int32 badge_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanSimple* default_instance_;
};
// -------------------------------------------------------------------

class ClanSysOptReq : public ::google::protobuf::Message {
 public:
  ClanSysOptReq();
  virtual ~ClanSysOptReq();

  ClanSysOptReq(const ClanSysOptReq& from);

  inline ClanSysOptReq& operator=(const ClanSysOptReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanSysOptReq& default_instance();

  void Swap(ClanSysOptReq* other);

  // implements Message ----------------------------------------------

  ClanSysOptReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanSysOptReq& from);
  void MergeFrom(const ClanSysOptReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 clan_type = 2;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 2;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // optional int32 zid = 3;
  inline bool has_zid() const;
  inline void clear_zid();
  static const int kZidFieldNumber = 3;
  inline ::google::protobuf::int32 zid() const;
  inline void set_zid(::google::protobuf::int32 value);

  // repeated .proto_ff.ClanSimple infos = 4;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 4;
  inline const ::proto_ff::ClanSimple& infos(int index) const;
  inline ::proto_ff::ClanSimple* mutable_infos(int index);
  inline ::proto_ff::ClanSimple* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanSimple >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanSimple >*
      mutable_infos();

  // repeated uint64 cids = 5;
  inline int cids_size() const;
  inline void clear_cids();
  static const int kCidsFieldNumber = 5;
  inline ::google::protobuf::uint64 cids(int index) const;
  inline void set_cids(int index, ::google::protobuf::uint64 value);
  inline void add_cids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      cids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_cids();

  // @@protoc_insertion_point(class_scope:proto_ff.ClanSysOptReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_clan_type();
  inline void clear_has_clan_type();
  inline void set_has_zid();
  inline void clear_has_zid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 clan_type_;
  ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanSimple > infos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > cids_;
  ::google::protobuf::int32 zid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static ClanSysOptReq* default_instance_;
};
// -------------------------------------------------------------------

class NotifyClanSynRank : public ::google::protobuf::Message {
 public:
  NotifyClanSynRank();
  virtual ~NotifyClanSynRank();

  NotifyClanSynRank(const NotifyClanSynRank& from);

  inline NotifyClanSynRank& operator=(const NotifyClanSynRank& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyClanSynRank& default_instance();

  void Swap(NotifyClanSynRank* other);

  // implements Message ----------------------------------------------

  NotifyClanSynRank* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyClanSynRank& from);
  void MergeFrom(const NotifyClanSynRank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clan_type = 1;
  inline bool has_clan_type() const;
  inline void clear_clan_type();
  static const int kClanTypeFieldNumber = 1;
  inline ::google::protobuf::int32 clan_type() const;
  inline void set_clan_type(::google::protobuf::int32 value);

  // repeated .proto_ff.ComPair64 rank = 2;
  inline int rank_size() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 2;
  inline const ::proto_ff::ComPair64& rank(int index) const;
  inline ::proto_ff::ComPair64* mutable_rank(int index);
  inline ::proto_ff::ComPair64* add_rank();
  inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ComPair64 >&
      rank() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ComPair64 >*
      mutable_rank();

  // @@protoc_insertion_point(class_scope:proto_ff.NotifyClanSynRank)
 private:
  inline void set_has_clan_type();
  inline void clear_has_clan_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto_ff::ComPair64 > rank_;
  ::google::protobuf::int32 clan_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static NotifyClanSynRank* default_instance_;
};
// -------------------------------------------------------------------

class C2LModifyClanInfoReq : public ::google::protobuf::Message {
 public:
  C2LModifyClanInfoReq();
  virtual ~C2LModifyClanInfoReq();

  C2LModifyClanInfoReq(const C2LModifyClanInfoReq& from);

  inline C2LModifyClanInfoReq& operator=(const C2LModifyClanInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const C2LModifyClanInfoReq& default_instance();

  void Swap(C2LModifyClanInfoReq* other);

  // implements Message ----------------------------------------------

  C2LModifyClanInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2LModifyClanInfoReq& from);
  void MergeFrom(const C2LModifyClanInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline ::google::protobuf::uint64 cid() const;
  inline void set_cid(::google::protobuf::uint64 value);

  // optional .proto_ff.ModifyClanInfoReq req = 2;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 2;
  inline const ::proto_ff::ModifyClanInfoReq& req() const;
  inline ::proto_ff::ModifyClanInfoReq* mutable_req();
  inline ::proto_ff::ModifyClanInfoReq* release_req();
  inline void set_allocated_req(::proto_ff::ModifyClanInfoReq* req);

  // @@protoc_insertion_point(class_scope:proto_ff.C2LModifyClanInfoReq)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cid_;
  ::proto_ff::ModifyClanInfoReq* req_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static C2LModifyClanInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class L2CModifyClanInfoRsp : public ::google::protobuf::Message {
 public:
  L2CModifyClanInfoRsp();
  virtual ~L2CModifyClanInfoRsp();

  L2CModifyClanInfoRsp(const L2CModifyClanInfoRsp& from);

  inline L2CModifyClanInfoRsp& operator=(const L2CModifyClanInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const L2CModifyClanInfoRsp& default_instance();

  void Swap(L2CModifyClanInfoRsp* other);

  // implements Message ----------------------------------------------

  L2CModifyClanInfoRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const L2CModifyClanInfoRsp& from);
  void MergeFrom(const L2CModifyClanInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional uint64 cid = 2;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 2;
  inline ::google::protobuf::uint64 cid() const;
  inline void set_cid(::google::protobuf::uint64 value);

  // optional .proto_ff.ModifyClanInfoReq req = 3;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 3;
  inline const ::proto_ff::ModifyClanInfoReq& req() const;
  inline ::proto_ff::ModifyClanInfoReq* mutable_req();
  inline ::proto_ff::ModifyClanInfoReq* release_req();
  inline void set_allocated_req(::proto_ff::ModifyClanInfoReq* req);

  // @@protoc_insertion_point(class_scope:proto_ff.L2CModifyClanInfoRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cid_;
  ::proto_ff::ModifyClanInfoReq* req_;
  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2eproto();
  friend void protobuf_AssignDesc_Clan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2eproto();

  void InitAsDefaultInstance();
  static L2CModifyClanInfoRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// ClanLog

// optional int32 chat_id = 1;
inline bool ClanLog::has_chat_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanLog::set_has_chat_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanLog::clear_has_chat_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanLog::clear_chat_id() {
  chat_id_ = 0;
  clear_has_chat_id();
}
inline ::google::protobuf::int32 ClanLog::chat_id() const {
  return chat_id_;
}
inline void ClanLog::set_chat_id(::google::protobuf::int32 value) {
  set_has_chat_id();
  chat_id_ = value;
}

// repeated bytes text = 2;
inline int ClanLog::text_size() const {
  return text_.size();
}
inline void ClanLog::clear_text() {
  text_.Clear();
}
inline const ::std::string& ClanLog::text(int index) const {
  return text_.Get(index);
}
inline ::std::string* ClanLog::mutable_text(int index) {
  return text_.Mutable(index);
}
inline void ClanLog::set_text(int index, const ::std::string& value) {
  text_.Mutable(index)->assign(value);
}
inline void ClanLog::set_text(int index, const char* value) {
  text_.Mutable(index)->assign(value);
}
inline void ClanLog::set_text(int index, const void* value, size_t size) {
  text_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanLog::add_text() {
  return text_.Add();
}
inline void ClanLog::add_text(const ::std::string& value) {
  text_.Add()->assign(value);
}
inline void ClanLog::add_text(const char* value) {
  text_.Add()->assign(value);
}
inline void ClanLog::add_text(const void* value, size_t size) {
  text_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClanLog::text() const {
  return text_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClanLog::mutable_text() {
  return &text_;
}

// repeated uint64 params = 3;
inline int ClanLog::params_size() const {
  return params_.size();
}
inline void ClanLog::clear_params() {
  params_.Clear();
}
inline ::google::protobuf::uint64 ClanLog::params(int index) const {
  return params_.Get(index);
}
inline void ClanLog::set_params(int index, ::google::protobuf::uint64 value) {
  params_.Set(index, value);
}
inline void ClanLog::add_params(::google::protobuf::uint64 value) {
  params_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ClanLog::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ClanLog::mutable_params() {
  return &params_;
}

// optional uint64 time = 4;
inline bool ClanLog::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanLog::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanLog::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanLog::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 ClanLog::time() const {
  return time_;
}
inline void ClanLog::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// ClanComInfo

// optional uint64 clan_id = 1;
inline bool ClanComInfo::has_clan_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanComInfo::set_has_clan_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanComInfo::clear_has_clan_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanComInfo::clear_clan_id() {
  clan_id_ = GOOGLE_ULONGLONG(0);
  clear_has_clan_id();
}
inline ::google::protobuf::uint64 ClanComInfo::clan_id() const {
  return clan_id_;
}
inline void ClanComInfo::set_clan_id(::google::protobuf::uint64 value) {
  set_has_clan_id();
  clan_id_ = value;
}

// optional bytes name = 2;
inline bool ClanComInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanComInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanComInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanComInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanComInfo::name() const {
  return *name_;
}
inline void ClanComInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanComInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanComInfo::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanComInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanComInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanComInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 score = 3;
inline bool ClanComInfo::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanComInfo::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanComInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanComInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 ClanComInfo::score() const {
  return score_;
}
inline void ClanComInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 rank = 4;
inline bool ClanComInfo::has_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanComInfo::set_has_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanComInfo::clear_has_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanComInfo::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 ClanComInfo::rank() const {
  return rank_;
}
inline void ClanComInfo::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional int32 zid = 5;
inline bool ClanComInfo::has_zid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClanComInfo::set_has_zid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClanComInfo::clear_has_zid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClanComInfo::clear_zid() {
  zid_ = 0;
  clear_has_zid();
}
inline ::google::protobuf::int32 ClanComInfo::zid() const {
  return zid_;
}
inline void ClanComInfo::set_zid(::google::protobuf::int32 value) {
  set_has_zid();
  zid_ = value;
}

// optional int32 badge_id = 6;
inline bool ClanComInfo::has_badge_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClanComInfo::set_has_badge_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClanComInfo::clear_has_badge_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClanComInfo::clear_badge_id() {
  badge_id_ = 0;
  clear_has_badge_id();
}
inline ::google::protobuf::int32 ClanComInfo::badge_id() const {
  return badge_id_;
}
inline void ClanComInfo::set_badge_id(::google::protobuf::int32 value) {
  set_has_badge_id();
  badge_id_ = value;
}

// optional bytes badge_name = 7;
inline bool ClanComInfo::has_badge_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClanComInfo::set_has_badge_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClanComInfo::clear_has_badge_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClanComInfo::clear_badge_name() {
  if (badge_name_ != &::google::protobuf::internal::kEmptyString) {
    badge_name_->clear();
  }
  clear_has_badge_name();
}
inline const ::std::string& ClanComInfo::badge_name() const {
  return *badge_name_;
}
inline void ClanComInfo::set_badge_name(const ::std::string& value) {
  set_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    badge_name_ = new ::std::string;
  }
  badge_name_->assign(value);
}
inline void ClanComInfo::set_badge_name(const char* value) {
  set_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    badge_name_ = new ::std::string;
  }
  badge_name_->assign(value);
}
inline void ClanComInfo::set_badge_name(const void* value, size_t size) {
  set_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    badge_name_ = new ::std::string;
  }
  badge_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanComInfo::mutable_badge_name() {
  set_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    badge_name_ = new ::std::string;
  }
  return badge_name_;
}
inline ::std::string* ClanComInfo::release_badge_name() {
  clear_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = badge_name_;
    badge_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanComInfo::set_allocated_badge_name(::std::string* badge_name) {
  if (badge_name_ != &::google::protobuf::internal::kEmptyString) {
    delete badge_name_;
  }
  if (badge_name) {
    set_has_badge_name();
    badge_name_ = badge_name;
  } else {
    clear_has_badge_name();
    badge_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 fight = 8;
inline bool ClanComInfo::has_fight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClanComInfo::set_has_fight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClanComInfo::clear_has_fight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClanComInfo::clear_fight() {
  fight_ = GOOGLE_ULONGLONG(0);
  clear_has_fight();
}
inline ::google::protobuf::uint64 ClanComInfo::fight() const {
  return fight_;
}
inline void ClanComInfo::set_fight(::google::protobuf::uint64 value) {
  set_has_fight();
  fight_ = value;
}

// optional bytes notice = 9;
inline bool ClanComInfo::has_notice() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClanComInfo::set_has_notice() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClanComInfo::clear_has_notice() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClanComInfo::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& ClanComInfo::notice() const {
  return *notice_;
}
inline void ClanComInfo::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void ClanComInfo::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void ClanComInfo::set_notice(const void* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanComInfo::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* ClanComInfo::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanComInfo::set_allocated_notice(::std::string* notice) {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice) {
    set_has_notice();
    notice_ = notice;
  } else {
    clear_has_notice();
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto_ff.ClanLog logs = 10;
inline int ClanComInfo::logs_size() const {
  return logs_.size();
}
inline void ClanComInfo::clear_logs() {
  logs_.Clear();
}
inline const ::proto_ff::ClanLog& ClanComInfo::logs(int index) const {
  return logs_.Get(index);
}
inline ::proto_ff::ClanLog* ClanComInfo::mutable_logs(int index) {
  return logs_.Mutable(index);
}
inline ::proto_ff::ClanLog* ClanComInfo::add_logs() {
  return logs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanLog >&
ClanComInfo::logs() const {
  return logs_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanLog >*
ClanComInfo::mutable_logs() {
  return &logs_;
}

// optional int32 clan_join_num = 11;
inline bool ClanComInfo::has_clan_join_num() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClanComInfo::set_has_clan_join_num() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClanComInfo::clear_has_clan_join_num() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClanComInfo::clear_clan_join_num() {
  clan_join_num_ = 0;
  clear_has_clan_join_num();
}
inline ::google::protobuf::int32 ClanComInfo::clan_join_num() const {
  return clan_join_num_;
}
inline void ClanComInfo::set_clan_join_num(::google::protobuf::int32 value) {
  set_has_clan_join_num();
  clan_join_num_ = value;
}

// optional int32 clan_win_num = 12;
inline bool ClanComInfo::has_clan_win_num() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClanComInfo::set_has_clan_win_num() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ClanComInfo::clear_has_clan_win_num() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ClanComInfo::clear_clan_win_num() {
  clan_win_num_ = 0;
  clear_has_clan_win_num();
}
inline ::google::protobuf::int32 ClanComInfo::clan_win_num() const {
  return clan_win_num_;
}
inline void ClanComInfo::set_clan_win_num(::google::protobuf::int32 value) {
  set_has_clan_win_num();
  clan_win_num_ = value;
}

// -------------------------------------------------------------------

// ApplyClanInfo

// optional .proto_ff.ClanComInfo clan = 1;
inline bool ApplyClanInfo::has_clan() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyClanInfo::set_has_clan() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyClanInfo::clear_has_clan() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyClanInfo::clear_clan() {
  if (clan_ != NULL) clan_->::proto_ff::ClanComInfo::Clear();
  clear_has_clan();
}
inline const ::proto_ff::ClanComInfo& ApplyClanInfo::clan() const {
  return clan_ != NULL ? *clan_ : *default_instance_->clan_;
}
inline ::proto_ff::ClanComInfo* ApplyClanInfo::mutable_clan() {
  set_has_clan();
  if (clan_ == NULL) clan_ = new ::proto_ff::ClanComInfo;
  return clan_;
}
inline ::proto_ff::ClanComInfo* ApplyClanInfo::release_clan() {
  clear_has_clan();
  ::proto_ff::ClanComInfo* temp = clan_;
  clan_ = NULL;
  return temp;
}
inline void ApplyClanInfo::set_allocated_clan(::proto_ff::ClanComInfo* clan) {
  delete clan_;
  clan_ = clan;
  if (clan) {
    set_has_clan();
  } else {
    clear_has_clan();
  }
}

// optional int32 state = 2;
inline bool ApplyClanInfo::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyClanInfo::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyClanInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyClanInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 ApplyClanInfo::state() const {
  return state_;
}
inline void ApplyClanInfo::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional int32 num = 3;
inline bool ApplyClanInfo::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyClanInfo::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyClanInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyClanInfo::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ApplyClanInfo::num() const {
  return num_;
}
inline void ApplyClanInfo::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional bytes leader_name = 4;
inline bool ApplyClanInfo::has_leader_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplyClanInfo::set_has_leader_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplyClanInfo::clear_has_leader_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplyClanInfo::clear_leader_name() {
  if (leader_name_ != &::google::protobuf::internal::kEmptyString) {
    leader_name_->clear();
  }
  clear_has_leader_name();
}
inline const ::std::string& ApplyClanInfo::leader_name() const {
  return *leader_name_;
}
inline void ApplyClanInfo::set_leader_name(const ::std::string& value) {
  set_has_leader_name();
  if (leader_name_ == &::google::protobuf::internal::kEmptyString) {
    leader_name_ = new ::std::string;
  }
  leader_name_->assign(value);
}
inline void ApplyClanInfo::set_leader_name(const char* value) {
  set_has_leader_name();
  if (leader_name_ == &::google::protobuf::internal::kEmptyString) {
    leader_name_ = new ::std::string;
  }
  leader_name_->assign(value);
}
inline void ApplyClanInfo::set_leader_name(const void* value, size_t size) {
  set_has_leader_name();
  if (leader_name_ == &::google::protobuf::internal::kEmptyString) {
    leader_name_ = new ::std::string;
  }
  leader_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplyClanInfo::mutable_leader_name() {
  set_has_leader_name();
  if (leader_name_ == &::google::protobuf::internal::kEmptyString) {
    leader_name_ = new ::std::string;
  }
  return leader_name_;
}
inline ::std::string* ApplyClanInfo::release_leader_name() {
  clear_has_leader_name();
  if (leader_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leader_name_;
    leader_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApplyClanInfo::set_allocated_leader_name(::std::string* leader_name) {
  if (leader_name_ != &::google::protobuf::internal::kEmptyString) {
    delete leader_name_;
  }
  if (leader_name) {
    set_has_leader_name();
    leader_name_ = leader_name;
  } else {
    clear_has_leader_name();
    leader_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Clan3MemberInfo

// optional .proto_ff.RolePlayerMiniInfo mini = 1;
inline bool Clan3MemberInfo::has_mini() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clan3MemberInfo::set_has_mini() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clan3MemberInfo::clear_has_mini() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clan3MemberInfo::clear_mini() {
  if (mini_ != NULL) mini_->::proto_ff::RolePlayerMiniInfo::Clear();
  clear_has_mini();
}
inline const ::proto_ff::RolePlayerMiniInfo& Clan3MemberInfo::mini() const {
  return mini_ != NULL ? *mini_ : *default_instance_->mini_;
}
inline ::proto_ff::RolePlayerMiniInfo* Clan3MemberInfo::mutable_mini() {
  set_has_mini();
  if (mini_ == NULL) mini_ = new ::proto_ff::RolePlayerMiniInfo;
  return mini_;
}
inline ::proto_ff::RolePlayerMiniInfo* Clan3MemberInfo::release_mini() {
  clear_has_mini();
  ::proto_ff::RolePlayerMiniInfo* temp = mini_;
  mini_ = NULL;
  return temp;
}
inline void Clan3MemberInfo::set_allocated_mini(::proto_ff::RolePlayerMiniInfo* mini) {
  delete mini_;
  mini_ = mini;
  if (mini) {
    set_has_mini();
  } else {
    clear_has_mini();
  }
}

// optional uint64 last_join_time = 2;
inline bool Clan3MemberInfo::has_last_join_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Clan3MemberInfo::set_has_last_join_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Clan3MemberInfo::clear_has_last_join_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Clan3MemberInfo::clear_last_join_time() {
  last_join_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_join_time();
}
inline ::google::protobuf::uint64 Clan3MemberInfo::last_join_time() const {
  return last_join_time_;
}
inline void Clan3MemberInfo::set_last_join_time(::google::protobuf::uint64 value) {
  set_has_last_join_time();
  last_join_time_ = value;
}

// optional int32 win_num = 3;
inline bool Clan3MemberInfo::has_win_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Clan3MemberInfo::set_has_win_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Clan3MemberInfo::clear_has_win_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Clan3MemberInfo::clear_win_num() {
  win_num_ = 0;
  clear_has_win_num();
}
inline ::google::protobuf::int32 Clan3MemberInfo::win_num() const {
  return win_num_;
}
inline void Clan3MemberInfo::set_win_num(::google::protobuf::int32 value) {
  set_has_win_num();
  win_num_ = value;
}

// optional int32 join_num = 4;
inline bool Clan3MemberInfo::has_join_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Clan3MemberInfo::set_has_join_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Clan3MemberInfo::clear_has_join_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Clan3MemberInfo::clear_join_num() {
  join_num_ = 0;
  clear_has_join_num();
}
inline ::google::protobuf::int32 Clan3MemberInfo::join_num() const {
  return join_num_;
}
inline void Clan3MemberInfo::set_join_num(::google::protobuf::int32 value) {
  set_has_join_num();
  join_num_ = value;
}

// optional int32 leader = 5;
inline bool Clan3MemberInfo::has_leader() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Clan3MemberInfo::set_has_leader() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Clan3MemberInfo::clear_has_leader() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Clan3MemberInfo::clear_leader() {
  leader_ = 0;
  clear_has_leader();
}
inline ::google::protobuf::int32 Clan3MemberInfo::leader() const {
  return leader_;
}
inline void Clan3MemberInfo::set_leader(::google::protobuf::int32 value) {
  set_has_leader();
  leader_ = value;
}

// -------------------------------------------------------------------

// ApplyClanListReq

// optional int32 clan_type = 1;
inline bool ApplyClanListReq::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyClanListReq::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyClanListReq::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyClanListReq::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ApplyClanListReq::clan_type() const {
  return clan_type_;
}
inline void ApplyClanListReq::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// -------------------------------------------------------------------

// NotifyApplyClanList

// optional int32 clan_type = 1;
inline bool NotifyApplyClanList::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyApplyClanList::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyApplyClanList::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyApplyClanList::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 NotifyApplyClanList::clan_type() const {
  return clan_type_;
}
inline void NotifyApplyClanList::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// repeated .proto_ff.ApplyClanInfo info = 2;
inline int NotifyApplyClanList::info_size() const {
  return info_.size();
}
inline void NotifyApplyClanList::clear_info() {
  info_.Clear();
}
inline const ::proto_ff::ApplyClanInfo& NotifyApplyClanList::info(int index) const {
  return info_.Get(index);
}
inline ::proto_ff::ApplyClanInfo* NotifyApplyClanList::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::proto_ff::ApplyClanInfo* NotifyApplyClanList::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ApplyClanInfo >&
NotifyApplyClanList::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ApplyClanInfo >*
NotifyApplyClanList::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// ApplyClanReq

// optional int32 clan_type = 1;
inline bool ApplyClanReq::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyClanReq::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyClanReq::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyClanReq::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ApplyClanReq::clan_type() const {
  return clan_type_;
}
inline void ApplyClanReq::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// repeated uint64 clan_id = 2;
inline int ApplyClanReq::clan_id_size() const {
  return clan_id_.size();
}
inline void ApplyClanReq::clear_clan_id() {
  clan_id_.Clear();
}
inline ::google::protobuf::uint64 ApplyClanReq::clan_id(int index) const {
  return clan_id_.Get(index);
}
inline void ApplyClanReq::set_clan_id(int index, ::google::protobuf::uint64 value) {
  clan_id_.Set(index, value);
}
inline void ApplyClanReq::add_clan_id(::google::protobuf::uint64 value) {
  clan_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ApplyClanReq::clan_id() const {
  return clan_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ApplyClanReq::mutable_clan_id() {
  return &clan_id_;
}

// -------------------------------------------------------------------

// ApplyClanRsp

// optional int32 ret = 1;
inline bool ApplyClanRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyClanRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyClanRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyClanRsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 ApplyClanRsp::ret() const {
  return ret_;
}
inline void ApplyClanRsp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 clan_type = 2;
inline bool ApplyClanRsp::has_clan_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyClanRsp::set_has_clan_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyClanRsp::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyClanRsp::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ApplyClanRsp::clan_type() const {
  return clan_type_;
}
inline void ApplyClanRsp::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// repeated uint64 clan_id = 3;
inline int ApplyClanRsp::clan_id_size() const {
  return clan_id_.size();
}
inline void ApplyClanRsp::clear_clan_id() {
  clan_id_.Clear();
}
inline ::google::protobuf::uint64 ApplyClanRsp::clan_id(int index) const {
  return clan_id_.Get(index);
}
inline void ApplyClanRsp::set_clan_id(int index, ::google::protobuf::uint64 value) {
  clan_id_.Set(index, value);
}
inline void ApplyClanRsp::add_clan_id(::google::protobuf::uint64 value) {
  clan_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ApplyClanRsp::clan_id() const {
  return clan_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ApplyClanRsp::mutable_clan_id() {
  return &clan_id_;
}

// -------------------------------------------------------------------

// ClanCreateReq

// optional int32 clan_type = 1;
inline bool ClanCreateReq::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanCreateReq::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanCreateReq::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanCreateReq::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ClanCreateReq::clan_type() const {
  return clan_type_;
}
inline void ClanCreateReq::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional bytes clan_name = 2;
inline bool ClanCreateReq::has_clan_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanCreateReq::set_has_clan_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanCreateReq::clear_has_clan_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanCreateReq::clear_clan_name() {
  if (clan_name_ != &::google::protobuf::internal::kEmptyString) {
    clan_name_->clear();
  }
  clear_has_clan_name();
}
inline const ::std::string& ClanCreateReq::clan_name() const {
  return *clan_name_;
}
inline void ClanCreateReq::set_clan_name(const ::std::string& value) {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  clan_name_->assign(value);
}
inline void ClanCreateReq::set_clan_name(const char* value) {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  clan_name_->assign(value);
}
inline void ClanCreateReq::set_clan_name(const void* value, size_t size) {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  clan_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanCreateReq::mutable_clan_name() {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  return clan_name_;
}
inline ::std::string* ClanCreateReq::release_clan_name() {
  clear_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clan_name_;
    clan_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanCreateReq::set_allocated_clan_name(::std::string* clan_name) {
  if (clan_name_ != &::google::protobuf::internal::kEmptyString) {
    delete clan_name_;
  }
  if (clan_name) {
    set_has_clan_name();
    clan_name_ = clan_name;
  } else {
    clear_has_clan_name();
    clan_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClanCreateRsp

// optional int32 ret = 1;
inline bool ClanCreateRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanCreateRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanCreateRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanCreateRsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 ClanCreateRsp::ret() const {
  return ret_;
}
inline void ClanCreateRsp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 clan_type = 2;
inline bool ClanCreateRsp::has_clan_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanCreateRsp::set_has_clan_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanCreateRsp::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanCreateRsp::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ClanCreateRsp::clan_type() const {
  return clan_type_;
}
inline void ClanCreateRsp::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional bytes clan_name = 3;
inline bool ClanCreateRsp::has_clan_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanCreateRsp::set_has_clan_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanCreateRsp::clear_has_clan_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanCreateRsp::clear_clan_name() {
  if (clan_name_ != &::google::protobuf::internal::kEmptyString) {
    clan_name_->clear();
  }
  clear_has_clan_name();
}
inline const ::std::string& ClanCreateRsp::clan_name() const {
  return *clan_name_;
}
inline void ClanCreateRsp::set_clan_name(const ::std::string& value) {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  clan_name_->assign(value);
}
inline void ClanCreateRsp::set_clan_name(const char* value) {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  clan_name_->assign(value);
}
inline void ClanCreateRsp::set_clan_name(const void* value, size_t size) {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  clan_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanCreateRsp::mutable_clan_name() {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  return clan_name_;
}
inline ::std::string* ClanCreateRsp::release_clan_name() {
  clear_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clan_name_;
    clan_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanCreateRsp::set_allocated_clan_name(::std::string* clan_name) {
  if (clan_name_ != &::google::protobuf::internal::kEmptyString) {
    delete clan_name_;
  }
  if (clan_name) {
    set_has_clan_name();
    clan_name_ = clan_name;
  } else {
    clear_has_clan_name();
    clan_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClanDataReq

// optional int32 clan_type = 1;
inline bool ClanDataReq::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanDataReq::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanDataReq::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanDataReq::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ClanDataReq::clan_type() const {
  return clan_type_;
}
inline void ClanDataReq::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// -------------------------------------------------------------------

// NotifyClan3Data

// optional .proto_ff.ClanComInfo info = 1;
inline bool NotifyClan3Data::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyClan3Data::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyClan3Data::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyClan3Data::clear_info() {
  if (info_ != NULL) info_->::proto_ff::ClanComInfo::Clear();
  clear_has_info();
}
inline const ::proto_ff::ClanComInfo& NotifyClan3Data::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::proto_ff::ClanComInfo* NotifyClan3Data::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::proto_ff::ClanComInfo;
  return info_;
}
inline ::proto_ff::ClanComInfo* NotifyClan3Data::release_info() {
  clear_has_info();
  ::proto_ff::ClanComInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void NotifyClan3Data::set_allocated_info(::proto_ff::ClanComInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// repeated .proto_ff.Clan3MemberInfo members = 2;
inline int NotifyClan3Data::members_size() const {
  return members_.size();
}
inline void NotifyClan3Data::clear_members() {
  members_.Clear();
}
inline const ::proto_ff::Clan3MemberInfo& NotifyClan3Data::members(int index) const {
  return members_.Get(index);
}
inline ::proto_ff::Clan3MemberInfo* NotifyClan3Data::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::proto_ff::Clan3MemberInfo* NotifyClan3Data::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::Clan3MemberInfo >&
NotifyClan3Data::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::Clan3MemberInfo >*
NotifyClan3Data::mutable_members() {
  return &members_;
}

// repeated int32 open_badges = 3;
inline int NotifyClan3Data::open_badges_size() const {
  return open_badges_.size();
}
inline void NotifyClan3Data::clear_open_badges() {
  open_badges_.Clear();
}
inline ::google::protobuf::int32 NotifyClan3Data::open_badges(int index) const {
  return open_badges_.Get(index);
}
inline void NotifyClan3Data::set_open_badges(int index, ::google::protobuf::int32 value) {
  open_badges_.Set(index, value);
}
inline void NotifyClan3Data::add_open_badges(::google::protobuf::int32 value) {
  open_badges_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NotifyClan3Data::open_badges() const {
  return open_badges_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NotifyClan3Data::mutable_open_badges() {
  return &open_badges_;
}

// repeated .proto_ff.RolePlayerMiniInfo apply = 4;
inline int NotifyClan3Data::apply_size() const {
  return apply_.size();
}
inline void NotifyClan3Data::clear_apply() {
  apply_.Clear();
}
inline const ::proto_ff::RolePlayerMiniInfo& NotifyClan3Data::apply(int index) const {
  return apply_.Get(index);
}
inline ::proto_ff::RolePlayerMiniInfo* NotifyClan3Data::mutable_apply(int index) {
  return apply_.Mutable(index);
}
inline ::proto_ff::RolePlayerMiniInfo* NotifyClan3Data::add_apply() {
  return apply_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::RolePlayerMiniInfo >&
NotifyClan3Data::apply() const {
  return apply_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::RolePlayerMiniInfo >*
NotifyClan3Data::mutable_apply() {
  return &apply_;
}

// -------------------------------------------------------------------

// ModifyClanInfoReq

// optional int32 clan_type = 1;
inline bool ModifyClanInfoReq::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyClanInfoReq::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyClanInfoReq::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyClanInfoReq::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ModifyClanInfoReq::clan_type() const {
  return clan_type_;
}
inline void ModifyClanInfoReq::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional int32 opt_type = 2;
inline bool ModifyClanInfoReq::has_opt_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyClanInfoReq::set_has_opt_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyClanInfoReq::clear_has_opt_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyClanInfoReq::clear_opt_type() {
  opt_type_ = 0;
  clear_has_opt_type();
}
inline ::google::protobuf::int32 ModifyClanInfoReq::opt_type() const {
  return opt_type_;
}
inline void ModifyClanInfoReq::set_opt_type(::google::protobuf::int32 value) {
  set_has_opt_type();
  opt_type_ = value;
}

// optional bytes name = 3;
inline bool ModifyClanInfoReq::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyClanInfoReq::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyClanInfoReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyClanInfoReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModifyClanInfoReq::name() const {
  return *name_;
}
inline void ModifyClanInfoReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModifyClanInfoReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModifyClanInfoReq::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyClanInfoReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModifyClanInfoReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyClanInfoReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 badge_id = 4;
inline bool ModifyClanInfoReq::has_badge_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyClanInfoReq::set_has_badge_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyClanInfoReq::clear_has_badge_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyClanInfoReq::clear_badge_id() {
  badge_id_ = 0;
  clear_has_badge_id();
}
inline ::google::protobuf::int32 ModifyClanInfoReq::badge_id() const {
  return badge_id_;
}
inline void ModifyClanInfoReq::set_badge_id(::google::protobuf::int32 value) {
  set_has_badge_id();
  badge_id_ = value;
}

// -------------------------------------------------------------------

// ModifyClanInfoRsp

// optional int32 ret = 1;
inline bool ModifyClanInfoRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyClanInfoRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyClanInfoRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyClanInfoRsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 ModifyClanInfoRsp::ret() const {
  return ret_;
}
inline void ModifyClanInfoRsp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 clan_type = 2;
inline bool ModifyClanInfoRsp::has_clan_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyClanInfoRsp::set_has_clan_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyClanInfoRsp::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyClanInfoRsp::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ModifyClanInfoRsp::clan_type() const {
  return clan_type_;
}
inline void ModifyClanInfoRsp::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional int32 opt_type = 3;
inline bool ModifyClanInfoRsp::has_opt_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyClanInfoRsp::set_has_opt_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyClanInfoRsp::clear_has_opt_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyClanInfoRsp::clear_opt_type() {
  opt_type_ = 0;
  clear_has_opt_type();
}
inline ::google::protobuf::int32 ModifyClanInfoRsp::opt_type() const {
  return opt_type_;
}
inline void ModifyClanInfoRsp::set_opt_type(::google::protobuf::int32 value) {
  set_has_opt_type();
  opt_type_ = value;
}

// optional bytes name = 4;
inline bool ModifyClanInfoRsp::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyClanInfoRsp::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyClanInfoRsp::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyClanInfoRsp::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModifyClanInfoRsp::name() const {
  return *name_;
}
inline void ModifyClanInfoRsp::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModifyClanInfoRsp::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModifyClanInfoRsp::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyClanInfoRsp::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModifyClanInfoRsp::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyClanInfoRsp::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 badge_id = 5;
inline bool ModifyClanInfoRsp::has_badge_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModifyClanInfoRsp::set_has_badge_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModifyClanInfoRsp::clear_has_badge_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModifyClanInfoRsp::clear_badge_id() {
  badge_id_ = 0;
  clear_has_badge_id();
}
inline ::google::protobuf::int32 ModifyClanInfoRsp::badge_id() const {
  return badge_id_;
}
inline void ModifyClanInfoRsp::set_badge_id(::google::protobuf::int32 value) {
  set_has_badge_id();
  badge_id_ = value;
}

// -------------------------------------------------------------------

// ClanApplyOptReq

// optional int32 clan_type = 1;
inline bool ClanApplyOptReq::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanApplyOptReq::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanApplyOptReq::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanApplyOptReq::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ClanApplyOptReq::clan_type() const {
  return clan_type_;
}
inline void ClanApplyOptReq::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional int32 type = 2;
inline bool ClanApplyOptReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanApplyOptReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanApplyOptReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanApplyOptReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ClanApplyOptReq::type() const {
  return type_;
}
inline void ClanApplyOptReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional uint64 target_cid = 3;
inline bool ClanApplyOptReq::has_target_cid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanApplyOptReq::set_has_target_cid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanApplyOptReq::clear_has_target_cid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanApplyOptReq::clear_target_cid() {
  target_cid_ = GOOGLE_ULONGLONG(0);
  clear_has_target_cid();
}
inline ::google::protobuf::uint64 ClanApplyOptReq::target_cid() const {
  return target_cid_;
}
inline void ClanApplyOptReq::set_target_cid(::google::protobuf::uint64 value) {
  set_has_target_cid();
  target_cid_ = value;
}

// optional int32 flag = 4;
inline bool ClanApplyOptReq::has_flag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanApplyOptReq::set_has_flag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanApplyOptReq::clear_has_flag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanApplyOptReq::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 ClanApplyOptReq::flag() const {
  return flag_;
}
inline void ClanApplyOptReq::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// ClanApplyOptRsp

// optional int32 ret = 1;
inline bool ClanApplyOptRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanApplyOptRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanApplyOptRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanApplyOptRsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 ClanApplyOptRsp::ret() const {
  return ret_;
}
inline void ClanApplyOptRsp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 clan_type = 2;
inline bool ClanApplyOptRsp::has_clan_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanApplyOptRsp::set_has_clan_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanApplyOptRsp::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanApplyOptRsp::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ClanApplyOptRsp::clan_type() const {
  return clan_type_;
}
inline void ClanApplyOptRsp::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional int32 type = 3;
inline bool ClanApplyOptRsp::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanApplyOptRsp::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanApplyOptRsp::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanApplyOptRsp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ClanApplyOptRsp::type() const {
  return type_;
}
inline void ClanApplyOptRsp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional uint64 target_cid = 4;
inline bool ClanApplyOptRsp::has_target_cid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanApplyOptRsp::set_has_target_cid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanApplyOptRsp::clear_has_target_cid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanApplyOptRsp::clear_target_cid() {
  target_cid_ = GOOGLE_ULONGLONG(0);
  clear_has_target_cid();
}
inline ::google::protobuf::uint64 ClanApplyOptRsp::target_cid() const {
  return target_cid_;
}
inline void ClanApplyOptRsp::set_target_cid(::google::protobuf::uint64 value) {
  set_has_target_cid();
  target_cid_ = value;
}

// -------------------------------------------------------------------

// ClanRoleOptReq

// optional int32 clan_type = 1;
inline bool ClanRoleOptReq::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanRoleOptReq::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanRoleOptReq::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanRoleOptReq::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ClanRoleOptReq::clan_type() const {
  return clan_type_;
}
inline void ClanRoleOptReq::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional int32 type = 2;
inline bool ClanRoleOptReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanRoleOptReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanRoleOptReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanRoleOptReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ClanRoleOptReq::type() const {
  return type_;
}
inline void ClanRoleOptReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional uint64 target_cid = 3;
inline bool ClanRoleOptReq::has_target_cid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanRoleOptReq::set_has_target_cid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanRoleOptReq::clear_has_target_cid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanRoleOptReq::clear_target_cid() {
  target_cid_ = GOOGLE_ULONGLONG(0);
  clear_has_target_cid();
}
inline ::google::protobuf::uint64 ClanRoleOptReq::target_cid() const {
  return target_cid_;
}
inline void ClanRoleOptReq::set_target_cid(::google::protobuf::uint64 value) {
  set_has_target_cid();
  target_cid_ = value;
}

// -------------------------------------------------------------------

// ClanRoleOptRsp

// optional int32 ret = 1;
inline bool ClanRoleOptRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanRoleOptRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanRoleOptRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanRoleOptRsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 ClanRoleOptRsp::ret() const {
  return ret_;
}
inline void ClanRoleOptRsp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 clan_type = 2;
inline bool ClanRoleOptRsp::has_clan_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanRoleOptRsp::set_has_clan_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanRoleOptRsp::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanRoleOptRsp::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ClanRoleOptRsp::clan_type() const {
  return clan_type_;
}
inline void ClanRoleOptRsp::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional int32 opt = 3;
inline bool ClanRoleOptRsp::has_opt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanRoleOptRsp::set_has_opt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanRoleOptRsp::clear_has_opt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanRoleOptRsp::clear_opt() {
  opt_ = 0;
  clear_has_opt();
}
inline ::google::protobuf::int32 ClanRoleOptRsp::opt() const {
  return opt_;
}
inline void ClanRoleOptRsp::set_opt(::google::protobuf::int32 value) {
  set_has_opt();
  opt_ = value;
}

// optional uint64 target_cid = 4;
inline bool ClanRoleOptRsp::has_target_cid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanRoleOptRsp::set_has_target_cid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanRoleOptRsp::clear_has_target_cid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanRoleOptRsp::clear_target_cid() {
  target_cid_ = GOOGLE_ULONGLONG(0);
  clear_has_target_cid();
}
inline ::google::protobuf::uint64 ClanRoleOptRsp::target_cid() const {
  return target_cid_;
}
inline void ClanRoleOptRsp::set_target_cid(::google::protobuf::uint64 value) {
  set_has_target_cid();
  target_cid_ = value;
}

// -------------------------------------------------------------------

// ClanInviteInfoReq

// optional int32 clan_type = 1;
inline bool ClanInviteInfoReq::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanInviteInfoReq::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanInviteInfoReq::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanInviteInfoReq::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ClanInviteInfoReq::clan_type() const {
  return clan_type_;
}
inline void ClanInviteInfoReq::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional int32 type = 2;
inline bool ClanInviteInfoReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanInviteInfoReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanInviteInfoReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanInviteInfoReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ClanInviteInfoReq::type() const {
  return type_;
}
inline void ClanInviteInfoReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// NotifyClanInviteInfo

// optional int32 clan_type = 1;
inline bool NotifyClanInviteInfo::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyClanInviteInfo::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyClanInviteInfo::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyClanInviteInfo::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 NotifyClanInviteInfo::clan_type() const {
  return clan_type_;
}
inline void NotifyClanInviteInfo::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional int32 type = 2;
inline bool NotifyClanInviteInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyClanInviteInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyClanInviteInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyClanInviteInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 NotifyClanInviteInfo::type() const {
  return type_;
}
inline void NotifyClanInviteInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated .proto_ff.RolePlayerMiniInfo infos = 3;
inline int NotifyClanInviteInfo::infos_size() const {
  return infos_.size();
}
inline void NotifyClanInviteInfo::clear_infos() {
  infos_.Clear();
}
inline const ::proto_ff::RolePlayerMiniInfo& NotifyClanInviteInfo::infos(int index) const {
  return infos_.Get(index);
}
inline ::proto_ff::RolePlayerMiniInfo* NotifyClanInviteInfo::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::proto_ff::RolePlayerMiniInfo* NotifyClanInviteInfo::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::RolePlayerMiniInfo >&
NotifyClanInviteInfo::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::RolePlayerMiniInfo >*
NotifyClanInviteInfo::mutable_infos() {
  return &infos_;
}

// -------------------------------------------------------------------

// ClanInviteRoleReq

// optional int32 clan_type = 1;
inline bool ClanInviteRoleReq::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanInviteRoleReq::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanInviteRoleReq::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanInviteRoleReq::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ClanInviteRoleReq::clan_type() const {
  return clan_type_;
}
inline void ClanInviteRoleReq::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional int32 type = 2;
inline bool ClanInviteRoleReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanInviteRoleReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanInviteRoleReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanInviteRoleReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ClanInviteRoleReq::type() const {
  return type_;
}
inline void ClanInviteRoleReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated uint64 target_cids = 3;
inline int ClanInviteRoleReq::target_cids_size() const {
  return target_cids_.size();
}
inline void ClanInviteRoleReq::clear_target_cids() {
  target_cids_.Clear();
}
inline ::google::protobuf::uint64 ClanInviteRoleReq::target_cids(int index) const {
  return target_cids_.Get(index);
}
inline void ClanInviteRoleReq::set_target_cids(int index, ::google::protobuf::uint64 value) {
  target_cids_.Set(index, value);
}
inline void ClanInviteRoleReq::add_target_cids(::google::protobuf::uint64 value) {
  target_cids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ClanInviteRoleReq::target_cids() const {
  return target_cids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ClanInviteRoleReq::mutable_target_cids() {
  return &target_cids_;
}

// -------------------------------------------------------------------

// ClanInviteRoleRsp

// optional int32 ret = 1;
inline bool ClanInviteRoleRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanInviteRoleRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanInviteRoleRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanInviteRoleRsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 ClanInviteRoleRsp::ret() const {
  return ret_;
}
inline void ClanInviteRoleRsp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 clan_type = 2;
inline bool ClanInviteRoleRsp::has_clan_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanInviteRoleRsp::set_has_clan_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanInviteRoleRsp::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanInviteRoleRsp::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ClanInviteRoleRsp::clan_type() const {
  return clan_type_;
}
inline void ClanInviteRoleRsp::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional int32 type = 3;
inline bool ClanInviteRoleRsp::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanInviteRoleRsp::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanInviteRoleRsp::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanInviteRoleRsp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ClanInviteRoleRsp::type() const {
  return type_;
}
inline void ClanInviteRoleRsp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated uint64 target_cids = 4;
inline int ClanInviteRoleRsp::target_cids_size() const {
  return target_cids_.size();
}
inline void ClanInviteRoleRsp::clear_target_cids() {
  target_cids_.Clear();
}
inline ::google::protobuf::uint64 ClanInviteRoleRsp::target_cids(int index) const {
  return target_cids_.Get(index);
}
inline void ClanInviteRoleRsp::set_target_cids(int index, ::google::protobuf::uint64 value) {
  target_cids_.Set(index, value);
}
inline void ClanInviteRoleRsp::add_target_cids(::google::protobuf::uint64 value) {
  target_cids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ClanInviteRoleRsp::target_cids() const {
  return target_cids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ClanInviteRoleRsp::mutable_target_cids() {
  return &target_cids_;
}

// -------------------------------------------------------------------

// NotifyAddClanInvite

// optional uint64 send_cid = 1;
inline bool NotifyAddClanInvite::has_send_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyAddClanInvite::set_has_send_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyAddClanInvite::clear_has_send_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyAddClanInvite::clear_send_cid() {
  send_cid_ = GOOGLE_ULONGLONG(0);
  clear_has_send_cid();
}
inline ::google::protobuf::uint64 NotifyAddClanInvite::send_cid() const {
  return send_cid_;
}
inline void NotifyAddClanInvite::set_send_cid(::google::protobuf::uint64 value) {
  set_has_send_cid();
  send_cid_ = value;
}

// optional bytes send_name = 2;
inline bool NotifyAddClanInvite::has_send_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyAddClanInvite::set_has_send_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyAddClanInvite::clear_has_send_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyAddClanInvite::clear_send_name() {
  if (send_name_ != &::google::protobuf::internal::kEmptyString) {
    send_name_->clear();
  }
  clear_has_send_name();
}
inline const ::std::string& NotifyAddClanInvite::send_name() const {
  return *send_name_;
}
inline void NotifyAddClanInvite::set_send_name(const ::std::string& value) {
  set_has_send_name();
  if (send_name_ == &::google::protobuf::internal::kEmptyString) {
    send_name_ = new ::std::string;
  }
  send_name_->assign(value);
}
inline void NotifyAddClanInvite::set_send_name(const char* value) {
  set_has_send_name();
  if (send_name_ == &::google::protobuf::internal::kEmptyString) {
    send_name_ = new ::std::string;
  }
  send_name_->assign(value);
}
inline void NotifyAddClanInvite::set_send_name(const void* value, size_t size) {
  set_has_send_name();
  if (send_name_ == &::google::protobuf::internal::kEmptyString) {
    send_name_ = new ::std::string;
  }
  send_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyAddClanInvite::mutable_send_name() {
  set_has_send_name();
  if (send_name_ == &::google::protobuf::internal::kEmptyString) {
    send_name_ = new ::std::string;
  }
  return send_name_;
}
inline ::std::string* NotifyAddClanInvite::release_send_name() {
  clear_has_send_name();
  if (send_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = send_name_;
    send_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifyAddClanInvite::set_allocated_send_name(::std::string* send_name) {
  if (send_name_ != &::google::protobuf::internal::kEmptyString) {
    delete send_name_;
  }
  if (send_name) {
    set_has_send_name();
    send_name_ = send_name;
  } else {
    clear_has_send_name();
    send_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 clan_type = 3;
inline bool NotifyAddClanInvite::has_clan_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyAddClanInvite::set_has_clan_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyAddClanInvite::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyAddClanInvite::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 NotifyAddClanInvite::clan_type() const {
  return clan_type_;
}
inline void NotifyAddClanInvite::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional uint64 clan_id = 4;
inline bool NotifyAddClanInvite::has_clan_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NotifyAddClanInvite::set_has_clan_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NotifyAddClanInvite::clear_has_clan_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NotifyAddClanInvite::clear_clan_id() {
  clan_id_ = GOOGLE_ULONGLONG(0);
  clear_has_clan_id();
}
inline ::google::protobuf::uint64 NotifyAddClanInvite::clan_id() const {
  return clan_id_;
}
inline void NotifyAddClanInvite::set_clan_id(::google::protobuf::uint64 value) {
  set_has_clan_id();
  clan_id_ = value;
}

// optional bytes clan_name = 5;
inline bool NotifyAddClanInvite::has_clan_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NotifyAddClanInvite::set_has_clan_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NotifyAddClanInvite::clear_has_clan_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NotifyAddClanInvite::clear_clan_name() {
  if (clan_name_ != &::google::protobuf::internal::kEmptyString) {
    clan_name_->clear();
  }
  clear_has_clan_name();
}
inline const ::std::string& NotifyAddClanInvite::clan_name() const {
  return *clan_name_;
}
inline void NotifyAddClanInvite::set_clan_name(const ::std::string& value) {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  clan_name_->assign(value);
}
inline void NotifyAddClanInvite::set_clan_name(const char* value) {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  clan_name_->assign(value);
}
inline void NotifyAddClanInvite::set_clan_name(const void* value, size_t size) {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  clan_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyAddClanInvite::mutable_clan_name() {
  set_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    clan_name_ = new ::std::string;
  }
  return clan_name_;
}
inline ::std::string* NotifyAddClanInvite::release_clan_name() {
  clear_has_clan_name();
  if (clan_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clan_name_;
    clan_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifyAddClanInvite::set_allocated_clan_name(::std::string* clan_name) {
  if (clan_name_ != &::google::protobuf::internal::kEmptyString) {
    delete clan_name_;
  }
  if (clan_name) {
    set_has_clan_name();
    clan_name_ = clan_name;
  } else {
    clear_has_clan_name();
    clan_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 clan_score = 6;
inline bool NotifyAddClanInvite::has_clan_score() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NotifyAddClanInvite::set_has_clan_score() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NotifyAddClanInvite::clear_has_clan_score() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NotifyAddClanInvite::clear_clan_score() {
  clan_score_ = 0;
  clear_has_clan_score();
}
inline ::google::protobuf::int32 NotifyAddClanInvite::clan_score() const {
  return clan_score_;
}
inline void NotifyAddClanInvite::set_clan_score(::google::protobuf::int32 value) {
  set_has_clan_score();
  clan_score_ = value;
}

// optional int32 fight = 7;
inline bool NotifyAddClanInvite::has_fight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NotifyAddClanInvite::set_has_fight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NotifyAddClanInvite::clear_has_fight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NotifyAddClanInvite::clear_fight() {
  fight_ = 0;
  clear_has_fight();
}
inline ::google::protobuf::int32 NotifyAddClanInvite::fight() const {
  return fight_;
}
inline void NotifyAddClanInvite::set_fight(::google::protobuf::int32 value) {
  set_has_fight();
  fight_ = value;
}

// -------------------------------------------------------------------

// InviteTargetOptReq

// optional int32 clan_type = 1;
inline bool InviteTargetOptReq::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteTargetOptReq::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteTargetOptReq::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteTargetOptReq::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 InviteTargetOptReq::clan_type() const {
  return clan_type_;
}
inline void InviteTargetOptReq::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional uint64 clan_id = 2;
inline bool InviteTargetOptReq::has_clan_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InviteTargetOptReq::set_has_clan_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InviteTargetOptReq::clear_has_clan_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InviteTargetOptReq::clear_clan_id() {
  clan_id_ = GOOGLE_ULONGLONG(0);
  clear_has_clan_id();
}
inline ::google::protobuf::uint64 InviteTargetOptReq::clan_id() const {
  return clan_id_;
}
inline void InviteTargetOptReq::set_clan_id(::google::protobuf::uint64 value) {
  set_has_clan_id();
  clan_id_ = value;
}

// optional int32 opt_type = 3;
inline bool InviteTargetOptReq::has_opt_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InviteTargetOptReq::set_has_opt_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InviteTargetOptReq::clear_has_opt_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InviteTargetOptReq::clear_opt_type() {
  opt_type_ = 0;
  clear_has_opt_type();
}
inline ::google::protobuf::int32 InviteTargetOptReq::opt_type() const {
  return opt_type_;
}
inline void InviteTargetOptReq::set_opt_type(::google::protobuf::int32 value) {
  set_has_opt_type();
  opt_type_ = value;
}

// optional int32 flag = 4;
inline bool InviteTargetOptReq::has_flag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InviteTargetOptReq::set_has_flag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InviteTargetOptReq::clear_has_flag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InviteTargetOptReq::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 InviteTargetOptReq::flag() const {
  return flag_;
}
inline void InviteTargetOptReq::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// InviteTargetOptRsp

// optional int32 ret = 1;
inline bool InviteTargetOptRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteTargetOptRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteTargetOptRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteTargetOptRsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 InviteTargetOptRsp::ret() const {
  return ret_;
}
inline void InviteTargetOptRsp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 clan_type = 2;
inline bool InviteTargetOptRsp::has_clan_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InviteTargetOptRsp::set_has_clan_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InviteTargetOptRsp::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InviteTargetOptRsp::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 InviteTargetOptRsp::clan_type() const {
  return clan_type_;
}
inline void InviteTargetOptRsp::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional uint64 clan_id = 3;
inline bool InviteTargetOptRsp::has_clan_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InviteTargetOptRsp::set_has_clan_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InviteTargetOptRsp::clear_has_clan_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InviteTargetOptRsp::clear_clan_id() {
  clan_id_ = GOOGLE_ULONGLONG(0);
  clear_has_clan_id();
}
inline ::google::protobuf::uint64 InviteTargetOptRsp::clan_id() const {
  return clan_id_;
}
inline void InviteTargetOptRsp::set_clan_id(::google::protobuf::uint64 value) {
  set_has_clan_id();
  clan_id_ = value;
}

// optional int32 opt_type = 4;
inline bool InviteTargetOptRsp::has_opt_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InviteTargetOptRsp::set_has_opt_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InviteTargetOptRsp::clear_has_opt_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InviteTargetOptRsp::clear_opt_type() {
  opt_type_ = 0;
  clear_has_opt_type();
}
inline ::google::protobuf::int32 InviteTargetOptRsp::opt_type() const {
  return opt_type_;
}
inline void InviteTargetOptRsp::set_opt_type(::google::protobuf::int32 value) {
  set_has_opt_type();
  opt_type_ = value;
}

// optional int32 clan_score = 5;
inline bool InviteTargetOptRsp::has_clan_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InviteTargetOptRsp::set_has_clan_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InviteTargetOptRsp::clear_has_clan_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InviteTargetOptRsp::clear_clan_score() {
  clan_score_ = 0;
  clear_has_clan_score();
}
inline ::google::protobuf::int32 InviteTargetOptRsp::clan_score() const {
  return clan_score_;
}
inline void InviteTargetOptRsp::set_clan_score(::google::protobuf::int32 value) {
  set_has_clan_score();
  clan_score_ = value;
}

// -------------------------------------------------------------------

// NotifyRoleClanRank

// optional int32 clan_type = 1;
inline bool NotifyRoleClanRank::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyRoleClanRank::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyRoleClanRank::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyRoleClanRank::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 NotifyRoleClanRank::clan_type() const {
  return clan_type_;
}
inline void NotifyRoleClanRank::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional int32 rank = 2;
inline bool NotifyRoleClanRank::has_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyRoleClanRank::set_has_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyRoleClanRank::clear_has_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyRoleClanRank::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 NotifyRoleClanRank::rank() const {
  return rank_;
}
inline void NotifyRoleClanRank::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// -------------------------------------------------------------------

// NotifyRoleJoinClan

// optional uint64 clan_id = 1;
inline bool NotifyRoleJoinClan::has_clan_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyRoleJoinClan::set_has_clan_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyRoleJoinClan::clear_has_clan_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyRoleJoinClan::clear_clan_id() {
  clan_id_ = GOOGLE_ULONGLONG(0);
  clear_has_clan_id();
}
inline ::google::protobuf::uint64 NotifyRoleJoinClan::clan_id() const {
  return clan_id_;
}
inline void NotifyRoleJoinClan::set_clan_id(::google::protobuf::uint64 value) {
  set_has_clan_id();
  clan_id_ = value;
}

// -------------------------------------------------------------------

// ClanComInfoDB

// optional uint64 clan_id = 1;
inline bool ClanComInfoDB::has_clan_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanComInfoDB::set_has_clan_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanComInfoDB::clear_has_clan_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanComInfoDB::clear_clan_id() {
  clan_id_ = GOOGLE_ULONGLONG(0);
  clear_has_clan_id();
}
inline ::google::protobuf::uint64 ClanComInfoDB::clan_id() const {
  return clan_id_;
}
inline void ClanComInfoDB::set_clan_id(::google::protobuf::uint64 value) {
  set_has_clan_id();
  clan_id_ = value;
}

// optional int32 zid = 2;
inline bool ClanComInfoDB::has_zid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanComInfoDB::set_has_zid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanComInfoDB::clear_has_zid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanComInfoDB::clear_zid() {
  zid_ = 0;
  clear_has_zid();
}
inline ::google::protobuf::int32 ClanComInfoDB::zid() const {
  return zid_;
}
inline void ClanComInfoDB::set_zid(::google::protobuf::int32 value) {
  set_has_zid();
  zid_ = value;
}

// optional bytes name = 3;
inline bool ClanComInfoDB::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanComInfoDB::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanComInfoDB::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanComInfoDB::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanComInfoDB::name() const {
  return *name_;
}
inline void ClanComInfoDB::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanComInfoDB::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanComInfoDB::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanComInfoDB::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanComInfoDB::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanComInfoDB::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 score = 4;
inline bool ClanComInfoDB::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanComInfoDB::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanComInfoDB::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanComInfoDB::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 ClanComInfoDB::score() const {
  return score_;
}
inline void ClanComInfoDB::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 badge_id = 5;
inline bool ClanComInfoDB::has_badge_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClanComInfoDB::set_has_badge_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClanComInfoDB::clear_has_badge_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClanComInfoDB::clear_badge_id() {
  badge_id_ = 0;
  clear_has_badge_id();
}
inline ::google::protobuf::int32 ClanComInfoDB::badge_id() const {
  return badge_id_;
}
inline void ClanComInfoDB::set_badge_id(::google::protobuf::int32 value) {
  set_has_badge_id();
  badge_id_ = value;
}

// optional bytes badge_name = 6;
inline bool ClanComInfoDB::has_badge_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClanComInfoDB::set_has_badge_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClanComInfoDB::clear_has_badge_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClanComInfoDB::clear_badge_name() {
  if (badge_name_ != &::google::protobuf::internal::kEmptyString) {
    badge_name_->clear();
  }
  clear_has_badge_name();
}
inline const ::std::string& ClanComInfoDB::badge_name() const {
  return *badge_name_;
}
inline void ClanComInfoDB::set_badge_name(const ::std::string& value) {
  set_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    badge_name_ = new ::std::string;
  }
  badge_name_->assign(value);
}
inline void ClanComInfoDB::set_badge_name(const char* value) {
  set_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    badge_name_ = new ::std::string;
  }
  badge_name_->assign(value);
}
inline void ClanComInfoDB::set_badge_name(const void* value, size_t size) {
  set_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    badge_name_ = new ::std::string;
  }
  badge_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanComInfoDB::mutable_badge_name() {
  set_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    badge_name_ = new ::std::string;
  }
  return badge_name_;
}
inline ::std::string* ClanComInfoDB::release_badge_name() {
  clear_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = badge_name_;
    badge_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanComInfoDB::set_allocated_badge_name(::std::string* badge_name) {
  if (badge_name_ != &::google::protobuf::internal::kEmptyString) {
    delete badge_name_;
  }
  if (badge_name) {
    set_has_badge_name();
    badge_name_ = badge_name;
  } else {
    clear_has_badge_name();
    badge_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes notice = 7;
inline bool ClanComInfoDB::has_notice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClanComInfoDB::set_has_notice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClanComInfoDB::clear_has_notice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClanComInfoDB::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& ClanComInfoDB::notice() const {
  return *notice_;
}
inline void ClanComInfoDB::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void ClanComInfoDB::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void ClanComInfoDB::set_notice(const void* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanComInfoDB::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* ClanComInfoDB::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanComInfoDB::set_allocated_notice(::std::string* notice) {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice) {
    set_has_notice();
    notice_ = notice;
  } else {
    clear_has_notice();
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto_ff.ClanLog logs = 8;
inline int ClanComInfoDB::logs_size() const {
  return logs_.size();
}
inline void ClanComInfoDB::clear_logs() {
  logs_.Clear();
}
inline const ::proto_ff::ClanLog& ClanComInfoDB::logs(int index) const {
  return logs_.Get(index);
}
inline ::proto_ff::ClanLog* ClanComInfoDB::mutable_logs(int index) {
  return logs_.Mutable(index);
}
inline ::proto_ff::ClanLog* ClanComInfoDB::add_logs() {
  return logs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanLog >&
ClanComInfoDB::logs() const {
  return logs_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanLog >*
ClanComInfoDB::mutable_logs() {
  return &logs_;
}

// optional uint64 leader_cid = 9;
inline bool ClanComInfoDB::has_leader_cid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClanComInfoDB::set_has_leader_cid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClanComInfoDB::clear_has_leader_cid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClanComInfoDB::clear_leader_cid() {
  leader_cid_ = GOOGLE_ULONGLONG(0);
  clear_has_leader_cid();
}
inline ::google::protobuf::uint64 ClanComInfoDB::leader_cid() const {
  return leader_cid_;
}
inline void ClanComInfoDB::set_leader_cid(::google::protobuf::uint64 value) {
  set_has_leader_cid();
  leader_cid_ = value;
}

// repeated uint64 members = 10;
inline int ClanComInfoDB::members_size() const {
  return members_.size();
}
inline void ClanComInfoDB::clear_members() {
  members_.Clear();
}
inline ::google::protobuf::uint64 ClanComInfoDB::members(int index) const {
  return members_.Get(index);
}
inline void ClanComInfoDB::set_members(int index, ::google::protobuf::uint64 value) {
  members_.Set(index, value);
}
inline void ClanComInfoDB::add_members(::google::protobuf::uint64 value) {
  members_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ClanComInfoDB::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ClanComInfoDB::mutable_members() {
  return &members_;
}

// repeated uint64 refuse_list = 11;
inline int ClanComInfoDB::refuse_list_size() const {
  return refuse_list_.size();
}
inline void ClanComInfoDB::clear_refuse_list() {
  refuse_list_.Clear();
}
inline ::google::protobuf::uint64 ClanComInfoDB::refuse_list(int index) const {
  return refuse_list_.Get(index);
}
inline void ClanComInfoDB::set_refuse_list(int index, ::google::protobuf::uint64 value) {
  refuse_list_.Set(index, value);
}
inline void ClanComInfoDB::add_refuse_list(::google::protobuf::uint64 value) {
  refuse_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ClanComInfoDB::refuse_list() const {
  return refuse_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ClanComInfoDB::mutable_refuse_list() {
  return &refuse_list_;
}

// repeated uint64 apply_list = 12;
inline int ClanComInfoDB::apply_list_size() const {
  return apply_list_.size();
}
inline void ClanComInfoDB::clear_apply_list() {
  apply_list_.Clear();
}
inline ::google::protobuf::uint64 ClanComInfoDB::apply_list(int index) const {
  return apply_list_.Get(index);
}
inline void ClanComInfoDB::set_apply_list(int index, ::google::protobuf::uint64 value) {
  apply_list_.Set(index, value);
}
inline void ClanComInfoDB::add_apply_list(::google::protobuf::uint64 value) {
  apply_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ClanComInfoDB::apply_list() const {
  return apply_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ClanComInfoDB::mutable_apply_list() {
  return &apply_list_;
}

// optional uint64 update_score_time = 13;
inline bool ClanComInfoDB::has_update_score_time() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ClanComInfoDB::set_has_update_score_time() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ClanComInfoDB::clear_has_update_score_time() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ClanComInfoDB::clear_update_score_time() {
  update_score_time_ = GOOGLE_ULONGLONG(0);
  clear_has_update_score_time();
}
inline ::google::protobuf::uint64 ClanComInfoDB::update_score_time() const {
  return update_score_time_;
}
inline void ClanComInfoDB::set_update_score_time(::google::protobuf::uint64 value) {
  set_has_update_score_time();
  update_score_time_ = value;
}

// optional int32 clan_join_num = 14;
inline bool ClanComInfoDB::has_clan_join_num() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ClanComInfoDB::set_has_clan_join_num() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ClanComInfoDB::clear_has_clan_join_num() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ClanComInfoDB::clear_clan_join_num() {
  clan_join_num_ = 0;
  clear_has_clan_join_num();
}
inline ::google::protobuf::int32 ClanComInfoDB::clan_join_num() const {
  return clan_join_num_;
}
inline void ClanComInfoDB::set_clan_join_num(::google::protobuf::int32 value) {
  set_has_clan_join_num();
  clan_join_num_ = value;
}

// optional int32 clan_win_num = 15;
inline bool ClanComInfoDB::has_clan_win_num() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ClanComInfoDB::set_has_clan_win_num() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ClanComInfoDB::clear_has_clan_win_num() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ClanComInfoDB::clear_clan_win_num() {
  clan_win_num_ = 0;
  clear_has_clan_win_num();
}
inline ::google::protobuf::int32 ClanComInfoDB::clan_win_num() const {
  return clan_win_num_;
}
inline void ClanComInfoDB::set_clan_win_num(::google::protobuf::int32 value) {
  set_has_clan_win_num();
  clan_win_num_ = value;
}

// repeated int32 open_badge = 16;
inline int ClanComInfoDB::open_badge_size() const {
  return open_badge_.size();
}
inline void ClanComInfoDB::clear_open_badge() {
  open_badge_.Clear();
}
inline ::google::protobuf::int32 ClanComInfoDB::open_badge(int index) const {
  return open_badge_.Get(index);
}
inline void ClanComInfoDB::set_open_badge(int index, ::google::protobuf::int32 value) {
  open_badge_.Set(index, value);
}
inline void ClanComInfoDB::add_open_badge(::google::protobuf::int32 value) {
  open_badge_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ClanComInfoDB::open_badge() const {
  return open_badge_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ClanComInfoDB::mutable_open_badge() {
  return &open_badge_;
}

// optional uint64 refresh_time = 17;
inline bool ClanComInfoDB::has_refresh_time() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ClanComInfoDB::set_has_refresh_time() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ClanComInfoDB::clear_has_refresh_time() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ClanComInfoDB::clear_refresh_time() {
  refresh_time_ = GOOGLE_ULONGLONG(0);
  clear_has_refresh_time();
}
inline ::google::protobuf::uint64 ClanComInfoDB::refresh_time() const {
  return refresh_time_;
}
inline void ClanComInfoDB::set_refresh_time(::google::protobuf::uint64 value) {
  set_has_refresh_time();
  refresh_time_ = value;
}

// optional uint64 fight = 18;
inline bool ClanComInfoDB::has_fight() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ClanComInfoDB::set_has_fight() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ClanComInfoDB::clear_has_fight() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ClanComInfoDB::clear_fight() {
  fight_ = GOOGLE_ULONGLONG(0);
  clear_has_fight();
}
inline ::google::protobuf::uint64 ClanComInfoDB::fight() const {
  return fight_;
}
inline void ClanComInfoDB::set_fight(::google::protobuf::uint64 value) {
  set_has_fight();
  fight_ = value;
}

// -------------------------------------------------------------------

// Clan3InfoDB

// optional .proto_ff.ClanComInfoDB com = 1;
inline bool Clan3InfoDB::has_com() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clan3InfoDB::set_has_com() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clan3InfoDB::clear_has_com() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clan3InfoDB::clear_com() {
  if (com_ != NULL) com_->::proto_ff::ClanComInfoDB::Clear();
  clear_has_com();
}
inline const ::proto_ff::ClanComInfoDB& Clan3InfoDB::com() const {
  return com_ != NULL ? *com_ : *default_instance_->com_;
}
inline ::proto_ff::ClanComInfoDB* Clan3InfoDB::mutable_com() {
  set_has_com();
  if (com_ == NULL) com_ = new ::proto_ff::ClanComInfoDB;
  return com_;
}
inline ::proto_ff::ClanComInfoDB* Clan3InfoDB::release_com() {
  clear_has_com();
  ::proto_ff::ClanComInfoDB* temp = com_;
  com_ = NULL;
  return temp;
}
inline void Clan3InfoDB::set_allocated_com(::proto_ff::ClanComInfoDB* com) {
  delete com_;
  com_ = com;
  if (com) {
    set_has_com();
  } else {
    clear_has_com();
  }
}

// -------------------------------------------------------------------

// Clan5InfoDB

// optional .proto_ff.ClanComInfoDB com = 1;
inline bool Clan5InfoDB::has_com() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clan5InfoDB::set_has_com() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clan5InfoDB::clear_has_com() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clan5InfoDB::clear_com() {
  if (com_ != NULL) com_->::proto_ff::ClanComInfoDB::Clear();
  clear_has_com();
}
inline const ::proto_ff::ClanComInfoDB& Clan5InfoDB::com() const {
  return com_ != NULL ? *com_ : *default_instance_->com_;
}
inline ::proto_ff::ClanComInfoDB* Clan5InfoDB::mutable_com() {
  set_has_com();
  if (com_ == NULL) com_ = new ::proto_ff::ClanComInfoDB;
  return com_;
}
inline ::proto_ff::ClanComInfoDB* Clan5InfoDB::release_com() {
  clear_has_com();
  ::proto_ff::ClanComInfoDB* temp = com_;
  com_ = NULL;
  return temp;
}
inline void Clan5InfoDB::set_allocated_com(::proto_ff::ClanComInfoDB* com) {
  delete com_;
  com_ = com;
  if (com) {
    set_has_com();
  } else {
    clear_has_com();
  }
}

// -------------------------------------------------------------------

// ClanRoleComInfoDB

// optional uint64 cid = 1;
inline bool ClanRoleComInfoDB::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanRoleComInfoDB::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanRoleComInfoDB::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanRoleComInfoDB::clear_cid() {
  cid_ = GOOGLE_ULONGLONG(0);
  clear_has_cid();
}
inline ::google::protobuf::uint64 ClanRoleComInfoDB::cid() const {
  return cid_;
}
inline void ClanRoleComInfoDB::set_cid(::google::protobuf::uint64 value) {
  set_has_cid();
  cid_ = value;
}

// optional uint64 ban_time = 2;
inline bool ClanRoleComInfoDB::has_ban_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanRoleComInfoDB::set_has_ban_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanRoleComInfoDB::clear_has_ban_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanRoleComInfoDB::clear_ban_time() {
  ban_time_ = GOOGLE_ULONGLONG(0);
  clear_has_ban_time();
}
inline ::google::protobuf::uint64 ClanRoleComInfoDB::ban_time() const {
  return ban_time_;
}
inline void ClanRoleComInfoDB::set_ban_time(::google::protobuf::uint64 value) {
  set_has_ban_time();
  ban_time_ = value;
}

// repeated uint64 refuse_invite_list = 3;
inline int ClanRoleComInfoDB::refuse_invite_list_size() const {
  return refuse_invite_list_.size();
}
inline void ClanRoleComInfoDB::clear_refuse_invite_list() {
  refuse_invite_list_.Clear();
}
inline ::google::protobuf::uint64 ClanRoleComInfoDB::refuse_invite_list(int index) const {
  return refuse_invite_list_.Get(index);
}
inline void ClanRoleComInfoDB::set_refuse_invite_list(int index, ::google::protobuf::uint64 value) {
  refuse_invite_list_.Set(index, value);
}
inline void ClanRoleComInfoDB::add_refuse_invite_list(::google::protobuf::uint64 value) {
  refuse_invite_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ClanRoleComInfoDB::refuse_invite_list() const {
  return refuse_invite_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ClanRoleComInfoDB::mutable_refuse_invite_list() {
  return &refuse_invite_list_;
}

// optional uint64 update_time = 4;
inline bool ClanRoleComInfoDB::has_update_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanRoleComInfoDB::set_has_update_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanRoleComInfoDB::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanRoleComInfoDB::clear_update_time() {
  update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_update_time();
}
inline ::google::protobuf::uint64 ClanRoleComInfoDB::update_time() const {
  return update_time_;
}
inline void ClanRoleComInfoDB::set_update_time(::google::protobuf::uint64 value) {
  set_has_update_time();
  update_time_ = value;
}

// optional uint64 last_join_time = 5;
inline bool ClanRoleComInfoDB::has_last_join_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClanRoleComInfoDB::set_has_last_join_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClanRoleComInfoDB::clear_has_last_join_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClanRoleComInfoDB::clear_last_join_time() {
  last_join_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_join_time();
}
inline ::google::protobuf::uint64 ClanRoleComInfoDB::last_join_time() const {
  return last_join_time_;
}
inline void ClanRoleComInfoDB::set_last_join_time(::google::protobuf::uint64 value) {
  set_has_last_join_time();
  last_join_time_ = value;
}

// repeated uint64 invite_list = 6;
inline int ClanRoleComInfoDB::invite_list_size() const {
  return invite_list_.size();
}
inline void ClanRoleComInfoDB::clear_invite_list() {
  invite_list_.Clear();
}
inline ::google::protobuf::uint64 ClanRoleComInfoDB::invite_list(int index) const {
  return invite_list_.Get(index);
}
inline void ClanRoleComInfoDB::set_invite_list(int index, ::google::protobuf::uint64 value) {
  invite_list_.Set(index, value);
}
inline void ClanRoleComInfoDB::add_invite_list(::google::protobuf::uint64 value) {
  invite_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ClanRoleComInfoDB::invite_list() const {
  return invite_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ClanRoleComInfoDB::mutable_invite_list() {
  return &invite_list_;
}

// -------------------------------------------------------------------

// Clan3RoleInfoDB

// optional .proto_ff.ClanRoleComInfoDB com = 1;
inline bool Clan3RoleInfoDB::has_com() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clan3RoleInfoDB::set_has_com() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clan3RoleInfoDB::clear_has_com() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clan3RoleInfoDB::clear_com() {
  if (com_ != NULL) com_->::proto_ff::ClanRoleComInfoDB::Clear();
  clear_has_com();
}
inline const ::proto_ff::ClanRoleComInfoDB& Clan3RoleInfoDB::com() const {
  return com_ != NULL ? *com_ : *default_instance_->com_;
}
inline ::proto_ff::ClanRoleComInfoDB* Clan3RoleInfoDB::mutable_com() {
  set_has_com();
  if (com_ == NULL) com_ = new ::proto_ff::ClanRoleComInfoDB;
  return com_;
}
inline ::proto_ff::ClanRoleComInfoDB* Clan3RoleInfoDB::release_com() {
  clear_has_com();
  ::proto_ff::ClanRoleComInfoDB* temp = com_;
  com_ = NULL;
  return temp;
}
inline void Clan3RoleInfoDB::set_allocated_com(::proto_ff::ClanRoleComInfoDB* com) {
  delete com_;
  com_ = com;
  if (com) {
    set_has_com();
  } else {
    clear_has_com();
  }
}

// optional int32 role_join_num = 2;
inline bool Clan3RoleInfoDB::has_role_join_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Clan3RoleInfoDB::set_has_role_join_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Clan3RoleInfoDB::clear_has_role_join_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Clan3RoleInfoDB::clear_role_join_num() {
  role_join_num_ = 0;
  clear_has_role_join_num();
}
inline ::google::protobuf::int32 Clan3RoleInfoDB::role_join_num() const {
  return role_join_num_;
}
inline void Clan3RoleInfoDB::set_role_join_num(::google::protobuf::int32 value) {
  set_has_role_join_num();
  role_join_num_ = value;
}

// optional int32 role_win_num = 3;
inline bool Clan3RoleInfoDB::has_role_win_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Clan3RoleInfoDB::set_has_role_win_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Clan3RoleInfoDB::clear_has_role_win_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Clan3RoleInfoDB::clear_role_win_num() {
  role_win_num_ = 0;
  clear_has_role_win_num();
}
inline ::google::protobuf::int32 Clan3RoleInfoDB::role_win_num() const {
  return role_win_num_;
}
inline void Clan3RoleInfoDB::set_role_win_num(::google::protobuf::int32 value) {
  set_has_role_win_num();
  role_win_num_ = value;
}

// optional int32 role_cw_num = 4;
inline bool Clan3RoleInfoDB::has_role_cw_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Clan3RoleInfoDB::set_has_role_cw_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Clan3RoleInfoDB::clear_has_role_cw_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Clan3RoleInfoDB::clear_role_cw_num() {
  role_cw_num_ = 0;
  clear_has_role_cw_num();
}
inline ::google::protobuf::int32 Clan3RoleInfoDB::role_cw_num() const {
  return role_cw_num_;
}
inline void Clan3RoleInfoDB::set_role_cw_num(::google::protobuf::int32 value) {
  set_has_role_cw_num();
  role_cw_num_ = value;
}

// optional int32 role_dead_num = 5;
inline bool Clan3RoleInfoDB::has_role_dead_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Clan3RoleInfoDB::set_has_role_dead_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Clan3RoleInfoDB::clear_has_role_dead_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Clan3RoleInfoDB::clear_role_dead_num() {
  role_dead_num_ = 0;
  clear_has_role_dead_num();
}
inline ::google::protobuf::int32 Clan3RoleInfoDB::role_dead_num() const {
  return role_dead_num_;
}
inline void Clan3RoleInfoDB::set_role_dead_num(::google::protobuf::int32 value) {
  set_has_role_dead_num();
  role_dead_num_ = value;
}

// optional int32 role_cl_num = 6;
inline bool Clan3RoleInfoDB::has_role_cl_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Clan3RoleInfoDB::set_has_role_cl_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Clan3RoleInfoDB::clear_has_role_cl_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Clan3RoleInfoDB::clear_role_cl_num() {
  role_cl_num_ = 0;
  clear_has_role_cl_num();
}
inline ::google::protobuf::int32 Clan3RoleInfoDB::role_cl_num() const {
  return role_cl_num_;
}
inline void Clan3RoleInfoDB::set_role_cl_num(::google::protobuf::int32 value) {
  set_has_role_cl_num();
  role_cl_num_ = value;
}

// optional int32 day_join_num = 7;
inline bool Clan3RoleInfoDB::has_day_join_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Clan3RoleInfoDB::set_has_day_join_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Clan3RoleInfoDB::clear_has_day_join_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Clan3RoleInfoDB::clear_day_join_num() {
  day_join_num_ = 0;
  clear_has_day_join_num();
}
inline ::google::protobuf::int32 Clan3RoleInfoDB::day_join_num() const {
  return day_join_num_;
}
inline void Clan3RoleInfoDB::set_day_join_num(::google::protobuf::int32 value) {
  set_has_day_join_num();
  day_join_num_ = value;
}

// repeated int32 day_recv_id = 8;
inline int Clan3RoleInfoDB::day_recv_id_size() const {
  return day_recv_id_.size();
}
inline void Clan3RoleInfoDB::clear_day_recv_id() {
  day_recv_id_.Clear();
}
inline ::google::protobuf::int32 Clan3RoleInfoDB::day_recv_id(int index) const {
  return day_recv_id_.Get(index);
}
inline void Clan3RoleInfoDB::set_day_recv_id(int index, ::google::protobuf::int32 value) {
  day_recv_id_.Set(index, value);
}
inline void Clan3RoleInfoDB::add_day_recv_id(::google::protobuf::int32 value) {
  day_recv_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Clan3RoleInfoDB::day_recv_id() const {
  return day_recv_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Clan3RoleInfoDB::mutable_day_recv_id() {
  return &day_recv_id_;
}

// optional int32 mvp_num = 9;
inline bool Clan3RoleInfoDB::has_mvp_num() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Clan3RoleInfoDB::set_has_mvp_num() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Clan3RoleInfoDB::clear_has_mvp_num() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Clan3RoleInfoDB::clear_mvp_num() {
  mvp_num_ = 0;
  clear_has_mvp_num();
}
inline ::google::protobuf::int32 Clan3RoleInfoDB::mvp_num() const {
  return mvp_num_;
}
inline void Clan3RoleInfoDB::set_mvp_num(::google::protobuf::int32 value) {
  set_has_mvp_num();
  mvp_num_ = value;
}

// -------------------------------------------------------------------

// Clan5RoleInfoDB

// optional .proto_ff.ClanRoleComInfoDB com = 1;
inline bool Clan5RoleInfoDB::has_com() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clan5RoleInfoDB::set_has_com() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clan5RoleInfoDB::clear_has_com() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clan5RoleInfoDB::clear_com() {
  if (com_ != NULL) com_->::proto_ff::ClanRoleComInfoDB::Clear();
  clear_has_com();
}
inline const ::proto_ff::ClanRoleComInfoDB& Clan5RoleInfoDB::com() const {
  return com_ != NULL ? *com_ : *default_instance_->com_;
}
inline ::proto_ff::ClanRoleComInfoDB* Clan5RoleInfoDB::mutable_com() {
  set_has_com();
  if (com_ == NULL) com_ = new ::proto_ff::ClanRoleComInfoDB;
  return com_;
}
inline ::proto_ff::ClanRoleComInfoDB* Clan5RoleInfoDB::release_com() {
  clear_has_com();
  ::proto_ff::ClanRoleComInfoDB* temp = com_;
  com_ = NULL;
  return temp;
}
inline void Clan5RoleInfoDB::set_allocated_com(::proto_ff::ClanRoleComInfoDB* com) {
  delete com_;
  com_ = com;
  if (com) {
    set_has_com();
  } else {
    clear_has_com();
  }
}

// -------------------------------------------------------------------

// ClanSimple

// optional uint64 clan_id = 1;
inline bool ClanSimple::has_clan_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanSimple::set_has_clan_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanSimple::clear_has_clan_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanSimple::clear_clan_id() {
  clan_id_ = GOOGLE_ULONGLONG(0);
  clear_has_clan_id();
}
inline ::google::protobuf::uint64 ClanSimple::clan_id() const {
  return clan_id_;
}
inline void ClanSimple::set_clan_id(::google::protobuf::uint64 value) {
  set_has_clan_id();
  clan_id_ = value;
}

// optional int32 zid = 2;
inline bool ClanSimple::has_zid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanSimple::set_has_zid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanSimple::clear_has_zid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanSimple::clear_zid() {
  zid_ = 0;
  clear_has_zid();
}
inline ::google::protobuf::int32 ClanSimple::zid() const {
  return zid_;
}
inline void ClanSimple::set_zid(::google::protobuf::int32 value) {
  set_has_zid();
  zid_ = value;
}

// optional bytes name = 3;
inline bool ClanSimple::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanSimple::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanSimple::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanSimple::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanSimple::name() const {
  return *name_;
}
inline void ClanSimple::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanSimple::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanSimple::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanSimple::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanSimple::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanSimple::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 score = 4;
inline bool ClanSimple::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanSimple::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanSimple::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanSimple::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 ClanSimple::score() const {
  return score_;
}
inline void ClanSimple::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 badge_id = 5;
inline bool ClanSimple::has_badge_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClanSimple::set_has_badge_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClanSimple::clear_has_badge_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClanSimple::clear_badge_id() {
  badge_id_ = 0;
  clear_has_badge_id();
}
inline ::google::protobuf::int32 ClanSimple::badge_id() const {
  return badge_id_;
}
inline void ClanSimple::set_badge_id(::google::protobuf::int32 value) {
  set_has_badge_id();
  badge_id_ = value;
}

// optional bytes badge_name = 6;
inline bool ClanSimple::has_badge_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClanSimple::set_has_badge_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClanSimple::clear_has_badge_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClanSimple::clear_badge_name() {
  if (badge_name_ != &::google::protobuf::internal::kEmptyString) {
    badge_name_->clear();
  }
  clear_has_badge_name();
}
inline const ::std::string& ClanSimple::badge_name() const {
  return *badge_name_;
}
inline void ClanSimple::set_badge_name(const ::std::string& value) {
  set_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    badge_name_ = new ::std::string;
  }
  badge_name_->assign(value);
}
inline void ClanSimple::set_badge_name(const char* value) {
  set_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    badge_name_ = new ::std::string;
  }
  badge_name_->assign(value);
}
inline void ClanSimple::set_badge_name(const void* value, size_t size) {
  set_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    badge_name_ = new ::std::string;
  }
  badge_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanSimple::mutable_badge_name() {
  set_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    badge_name_ = new ::std::string;
  }
  return badge_name_;
}
inline ::std::string* ClanSimple::release_badge_name() {
  clear_has_badge_name();
  if (badge_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = badge_name_;
    badge_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanSimple::set_allocated_badge_name(::std::string* badge_name) {
  if (badge_name_ != &::google::protobuf::internal::kEmptyString) {
    delete badge_name_;
  }
  if (badge_name) {
    set_has_badge_name();
    badge_name_ = badge_name;
  } else {
    clear_has_badge_name();
    badge_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 leader_cid = 7;
inline bool ClanSimple::has_leader_cid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClanSimple::set_has_leader_cid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClanSimple::clear_has_leader_cid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClanSimple::clear_leader_cid() {
  leader_cid_ = GOOGLE_ULONGLONG(0);
  clear_has_leader_cid();
}
inline ::google::protobuf::uint64 ClanSimple::leader_cid() const {
  return leader_cid_;
}
inline void ClanSimple::set_leader_cid(::google::protobuf::uint64 value) {
  set_has_leader_cid();
  leader_cid_ = value;
}

// repeated uint64 members = 8;
inline int ClanSimple::members_size() const {
  return members_.size();
}
inline void ClanSimple::clear_members() {
  members_.Clear();
}
inline ::google::protobuf::uint64 ClanSimple::members(int index) const {
  return members_.Get(index);
}
inline void ClanSimple::set_members(int index, ::google::protobuf::uint64 value) {
  members_.Set(index, value);
}
inline void ClanSimple::add_members(::google::protobuf::uint64 value) {
  members_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ClanSimple::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ClanSimple::mutable_members() {
  return &members_;
}

// optional uint64 update_score_time = 9;
inline bool ClanSimple::has_update_score_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClanSimple::set_has_update_score_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClanSimple::clear_has_update_score_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClanSimple::clear_update_score_time() {
  update_score_time_ = GOOGLE_ULONGLONG(0);
  clear_has_update_score_time();
}
inline ::google::protobuf::uint64 ClanSimple::update_score_time() const {
  return update_score_time_;
}
inline void ClanSimple::set_update_score_time(::google::protobuf::uint64 value) {
  set_has_update_score_time();
  update_score_time_ = value;
}

// optional uint64 fight = 10;
inline bool ClanSimple::has_fight() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClanSimple::set_has_fight() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClanSimple::clear_has_fight() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClanSimple::clear_fight() {
  fight_ = GOOGLE_ULONGLONG(0);
  clear_has_fight();
}
inline ::google::protobuf::uint64 ClanSimple::fight() const {
  return fight_;
}
inline void ClanSimple::set_fight(::google::protobuf::uint64 value) {
  set_has_fight();
  fight_ = value;
}

// -------------------------------------------------------------------

// ClanSysOptReq

// optional int32 type = 1;
inline bool ClanSysOptReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanSysOptReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanSysOptReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanSysOptReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ClanSysOptReq::type() const {
  return type_;
}
inline void ClanSysOptReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 clan_type = 2;
inline bool ClanSysOptReq::has_clan_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanSysOptReq::set_has_clan_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanSysOptReq::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanSysOptReq::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 ClanSysOptReq::clan_type() const {
  return clan_type_;
}
inline void ClanSysOptReq::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// optional int32 zid = 3;
inline bool ClanSysOptReq::has_zid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanSysOptReq::set_has_zid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanSysOptReq::clear_has_zid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanSysOptReq::clear_zid() {
  zid_ = 0;
  clear_has_zid();
}
inline ::google::protobuf::int32 ClanSysOptReq::zid() const {
  return zid_;
}
inline void ClanSysOptReq::set_zid(::google::protobuf::int32 value) {
  set_has_zid();
  zid_ = value;
}

// repeated .proto_ff.ClanSimple infos = 4;
inline int ClanSysOptReq::infos_size() const {
  return infos_.size();
}
inline void ClanSysOptReq::clear_infos() {
  infos_.Clear();
}
inline const ::proto_ff::ClanSimple& ClanSysOptReq::infos(int index) const {
  return infos_.Get(index);
}
inline ::proto_ff::ClanSimple* ClanSysOptReq::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::proto_ff::ClanSimple* ClanSysOptReq::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanSimple >&
ClanSysOptReq::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ClanSimple >*
ClanSysOptReq::mutable_infos() {
  return &infos_;
}

// repeated uint64 cids = 5;
inline int ClanSysOptReq::cids_size() const {
  return cids_.size();
}
inline void ClanSysOptReq::clear_cids() {
  cids_.Clear();
}
inline ::google::protobuf::uint64 ClanSysOptReq::cids(int index) const {
  return cids_.Get(index);
}
inline void ClanSysOptReq::set_cids(int index, ::google::protobuf::uint64 value) {
  cids_.Set(index, value);
}
inline void ClanSysOptReq::add_cids(::google::protobuf::uint64 value) {
  cids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ClanSysOptReq::cids() const {
  return cids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ClanSysOptReq::mutable_cids() {
  return &cids_;
}

// -------------------------------------------------------------------

// NotifyClanSynRank

// optional int32 clan_type = 1;
inline bool NotifyClanSynRank::has_clan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyClanSynRank::set_has_clan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyClanSynRank::clear_has_clan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyClanSynRank::clear_clan_type() {
  clan_type_ = 0;
  clear_has_clan_type();
}
inline ::google::protobuf::int32 NotifyClanSynRank::clan_type() const {
  return clan_type_;
}
inline void NotifyClanSynRank::set_clan_type(::google::protobuf::int32 value) {
  set_has_clan_type();
  clan_type_ = value;
}

// repeated .proto_ff.ComPair64 rank = 2;
inline int NotifyClanSynRank::rank_size() const {
  return rank_.size();
}
inline void NotifyClanSynRank::clear_rank() {
  rank_.Clear();
}
inline const ::proto_ff::ComPair64& NotifyClanSynRank::rank(int index) const {
  return rank_.Get(index);
}
inline ::proto_ff::ComPair64* NotifyClanSynRank::mutable_rank(int index) {
  return rank_.Mutable(index);
}
inline ::proto_ff::ComPair64* NotifyClanSynRank::add_rank() {
  return rank_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto_ff::ComPair64 >&
NotifyClanSynRank::rank() const {
  return rank_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto_ff::ComPair64 >*
NotifyClanSynRank::mutable_rank() {
  return &rank_;
}

// -------------------------------------------------------------------

// C2LModifyClanInfoReq

// optional uint64 cid = 1;
inline bool C2LModifyClanInfoReq::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2LModifyClanInfoReq::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2LModifyClanInfoReq::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2LModifyClanInfoReq::clear_cid() {
  cid_ = GOOGLE_ULONGLONG(0);
  clear_has_cid();
}
inline ::google::protobuf::uint64 C2LModifyClanInfoReq::cid() const {
  return cid_;
}
inline void C2LModifyClanInfoReq::set_cid(::google::protobuf::uint64 value) {
  set_has_cid();
  cid_ = value;
}

// optional .proto_ff.ModifyClanInfoReq req = 2;
inline bool C2LModifyClanInfoReq::has_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2LModifyClanInfoReq::set_has_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2LModifyClanInfoReq::clear_has_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2LModifyClanInfoReq::clear_req() {
  if (req_ != NULL) req_->::proto_ff::ModifyClanInfoReq::Clear();
  clear_has_req();
}
inline const ::proto_ff::ModifyClanInfoReq& C2LModifyClanInfoReq::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::proto_ff::ModifyClanInfoReq* C2LModifyClanInfoReq::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::proto_ff::ModifyClanInfoReq;
  return req_;
}
inline ::proto_ff::ModifyClanInfoReq* C2LModifyClanInfoReq::release_req() {
  clear_has_req();
  ::proto_ff::ModifyClanInfoReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void C2LModifyClanInfoReq::set_allocated_req(::proto_ff::ModifyClanInfoReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// -------------------------------------------------------------------

// L2CModifyClanInfoRsp

// optional int32 ret = 1;
inline bool L2CModifyClanInfoRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void L2CModifyClanInfoRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void L2CModifyClanInfoRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void L2CModifyClanInfoRsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 L2CModifyClanInfoRsp::ret() const {
  return ret_;
}
inline void L2CModifyClanInfoRsp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional uint64 cid = 2;
inline bool L2CModifyClanInfoRsp::has_cid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void L2CModifyClanInfoRsp::set_has_cid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void L2CModifyClanInfoRsp::clear_has_cid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void L2CModifyClanInfoRsp::clear_cid() {
  cid_ = GOOGLE_ULONGLONG(0);
  clear_has_cid();
}
inline ::google::protobuf::uint64 L2CModifyClanInfoRsp::cid() const {
  return cid_;
}
inline void L2CModifyClanInfoRsp::set_cid(::google::protobuf::uint64 value) {
  set_has_cid();
  cid_ = value;
}

// optional .proto_ff.ModifyClanInfoReq req = 3;
inline bool L2CModifyClanInfoRsp::has_req() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void L2CModifyClanInfoRsp::set_has_req() {
  _has_bits_[0] |= 0x00000004u;
}
inline void L2CModifyClanInfoRsp::clear_has_req() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void L2CModifyClanInfoRsp::clear_req() {
  if (req_ != NULL) req_->::proto_ff::ModifyClanInfoReq::Clear();
  clear_has_req();
}
inline const ::proto_ff::ModifyClanInfoReq& L2CModifyClanInfoRsp::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::proto_ff::ModifyClanInfoReq* L2CModifyClanInfoRsp::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::proto_ff::ModifyClanInfoReq;
  return req_;
}
inline ::proto_ff::ModifyClanInfoReq* L2CModifyClanInfoRsp::release_req() {
  clear_has_req();
  ::proto_ff::ModifyClanInfoReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void L2CModifyClanInfoRsp::set_allocated_req(::proto_ff::ModifyClanInfoReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto_ff

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Clan_2eproto__INCLUDED
