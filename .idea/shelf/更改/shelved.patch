Index: Install/FishBusPlugin/LoginServer.lua
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>require \"Common\"\t\t--\n\n--LoginServer 游戏服务器, 一般一个小区只有一个， 负责游戏非战斗的业务， 连接世界服务器\n--ServerId = \"15.100.4.1\" 15是世界服务ID， 范围1-15\n-- 100是区服务ID， 范围1-65536\n-- 4是服务器类型ID， 必须跟serverType一样 范围1-255\n-- 1服务器索引，范围1-255\nLoginServer = {\n   GameServer_1 = {\n      ServerName = \"LoginServer_1\",\n      ServerType = NF_ST_LOGIN_SERVER,\n      ServerId = NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_LOGIN_SERVER..\".1\",\t\t\t--对每一个服务器来说都是唯一的， 应用程序需要通过这个ServerId才能知道需要加载的配置是他\n      LinkMode = NF_LINK_MODE,\n      BusLength = NF_COMMON_BUS_LENGTH,     --20M共享内存\n      IdleSleepUS = 1000,\n      ServerIp = NF_INTER_SERVER_IP,\n      ServerPort = NF_INTER_SERVER_PORT+NF_ST_LOGIN_SERVER*10+1,\n      MaxConnectNum = NF_INTER_MAX_CONNECT,\n      NetThreadNum = 1,\n      WorkThreadNum = 1,\n      Security = false,\n      WebSocket = false,\n      MaxOnlinePlayerNum = NF_MAX_ONLINE_PLAYER_COUNT,\n      HandleMsgNumPerFrame = NF_NORMAL_SERVER_HANDLE_MSG_COUNT,\n      DefaultDBName = NF_MYSQL_DB_NAME,\n      RouteConfig = {\n         RouteAgent = NF_ROUTE_AGENT_ID,\n         --NamingHost = NF_NAMING_HOST,\n         --NamingPath = NF_NAMING_PATH,\n         MasterIp = NF_MASTER_IP,\n         MasterPort = NF_MASTER_PORT,\n      },\n   };\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Install/FishBusPlugin/LoginServer.lua b/Install/FishBusPlugin/LoginServer.lua
--- a/Install/FishBusPlugin/LoginServer.lua	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/Install/FishBusPlugin/LoginServer.lua	(date 1688634682937)
@@ -6,7 +6,7 @@
 -- 4是服务器类型ID， 必须跟serverType一样 范围1-255
 -- 1服务器索引，范围1-255
 LoginServer = {
-   GameServer_1 = {
+   LoginServer_1 = {
       ServerName = "LoginServer_1",
       ServerType = NF_ST_LOGIN_SERVER,
       ServerId = NF_ST_WORLD_ID.."."..NF_ST_ZONE_ID.."."..NF_ST_LOGIN_SERVER..".1",			--对每一个服务器来说都是唯一的， 应用程序需要通过这个ServerId才能知道需要加载的配置是他
Index: game/Fish/NFFishRobot/NFTestRobot.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"NFTestRobot.h\"\n#include \"NFComm/NFCore/NFRandom.hpp\"\n#include \"NFComm/NFCore/NFMD5.h\"\n#include \"ClientServerCmd.pb.h\"\n#include \"CSLogin.pb.h\"\n\nenum RobotTimer\n{\n    ENUM_ROBOT_TIMER_PLAZE = 1,\n    ENUM_ROBOT_TIMER_GAME = 2,\n};\n\nint NFTestRobot::OnTimer(uint32_t nTimerID)\n{\n    if (nTimerID == ENUM_ROBOT_TIMER_PLAZE)\n    {\n        OnHandlePlazeStatus();\n    }\n    return 0;\n}\n\nint NFTestRobot::ConnectServer(const std::string& url)\n{\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n\tmStatus = NF_TEST_ROBOT_START_CONNECT;\n    m_proxyLinkId = FindModule<NFIMessageModule>()->ConnectServer(NF_ST_GAME_SERVER, url, PACKET_PARSE_TYPE_EXTERNAL);\n\tCHECK_EXPR(m_proxyLinkId > 0, -1, \"ConnectServer url:{} failed!\", url);\n    m_loginLinkId = m_proxyLinkId;\n\n    FindModule<NFIMessageModule>()->AddEventCallBack(NF_ST_GAME_SERVER, m_proxyLinkId, this, &NFTestRobot::OnProxyServerSocketEvent);\n    FindModule<NFIMessageModule>()->AddOtherCallBack(NF_ST_GAME_SERVER, m_proxyLinkId, this, &NFTestRobot::OnHandleProxyOtherMessage);\n\n\tSetTimer(ENUM_ROBOT_TIMER_PLAZE, 1000, 0);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n\treturn 0;\n}\n\nint NFTestRobot::OnProxyServerSocketEvent(eMsgType nEvent, uint64_t unLinkId)\n{\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n\tif (nEvent == eMsgType_CONNECTED)\n\t{\n\t\tmStatus = NF_TEST_ROBOT_CONNECT_SUCCESS;\n\t\tNFLogDebug(NF_LOG_SYSTEMLOG, 0, \"rebot:{} connect login success!\", m_robotId);\n\t}\n\telse if (nEvent == eMsgType_DISCONNECTED)\n\t{\n\t\tmStatus = NF_TEST_ROBOT_CONNECT_FAILE;\n\t\tNFLogError(NF_LOG_SYSTEMLOG, 0, \"robot:{} disconnect login\", m_robotId);\n\t}\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n\treturn 0;\n}\n\nint NFTestRobot::OnHandleProxyOtherMessage(uint64_t unLinkId, NFDataPackage &packet)\n{\n    uint32_t nMsgId = packet.nMsgId;\n\tif (nMsgId == proto_ff::NF_SC_MSG_AccountLoginRsp)\n    {\n\t    OnHandleAccountLogin(unLinkId, packet);\n    }\n\telse if (nMsgId == proto_ff::NF_SC_Msg_HeartBeat_RSP)\n    {\n\n    }\n\telse\n    {\n    }\n\treturn 0;\n}\n\nint NFTestRobot::OnHandleAccountLogin(uint64_t unLinkId, NFDataPackage &packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n\n    proto_ff::Proto_SCAccountLoginRsp gcMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, gcMsg);\n\n    NFLogError(NF_LOG_SYSTEMLOG, 0, \"account login use time:{}\", NFGetTime() - m_accoutLoginTime);\n    if (gcMsg.result() == 0)\n    {\n        m_playerId = gcMsg.user_id();\n        m_loginTime = gcMsg.login_time();\n        m_token = gcMsg.token();\n        mStatus = NF_TEST_ROBOT_LOGIN_SUCCESS;\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"robot:{} account login success\", m_robotId);\n        if (gcMsg.server_ip_list_size() > 0)\n        {\n            //int index = NFRandInt(0, gcMsg.server_ip_list_size());\n            //ConnectGameServer(gcMsg.server_ip_list(index).ip(), gcMsg.server_ip_list(index).port());\n        }\n    } else {\n        mStatus = NF_TEST_ROBOT_LOGIN_FAILED;\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"robot:{} account login failed\", m_robotId);\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFTestRobot::SendBeatHeart()\n{\n    proto_ff::Proto_CSHeartBeatReq cgMsg;\n    if (m_proxyLinkId > 0)\n    {\n        FindModule<NFIMessageModule>()->Send(m_proxyLinkId, proto_ff::NF_CS_Msg_HeartBeat_REQ, cgMsg, 0);\n    }\n\n    if (m_loginLinkId > 0)\n    {\n        FindModule<NFIMessageModule>()->Send(m_loginLinkId, proto_ff::NF_CS_Msg_HeartBeat_REQ, cgMsg, 0);\n    }\n\n    return 0;\n}\n\nint NFTestRobot::OnHandlePlazeStatus()\n{\n\tif (mStatus == NF_TEST_ROBOT_CONNECT_SUCCESS)\n\t{\n\t\tLoginServer();\n\t}\n\n\tif (mStatus >= NF_TEST_ROBOT_CONNECT_SUCCESS)\n    {\n\t    SendBeatHeart();\n    }\n\n    if (mStatus == NF_TEST_ROBOT_CONNECT_GAME_SUCCESS)\n    {\n    }\n\n\tif (mStatus >= NF_TEST_ROBOT_LOGIN_USER_SUCCESS)\n    {\n\t    if (mStatus == NF_TEST_ROBOT_DISCONNECT_USER)\n        {\n        }\n        else if (mStatus == NF_TEST_ROBOT_RECONNECT_SUCCESS)\n        {\n        }\n        else if (mStatus == NF_TEST_ROBOT_SEND_RECONNECT)\n        {\n\n        }\n        else\n        {\n\n        }\n    }\n\treturn 0;\n}\n\nint NFTestRobot::SendMsgToServer(uint32_t nMsgId, const google::protobuf::Message &xData)\n{\n    FindModule<NFIMessageModule>()->Send(m_proxyLinkId, nMsgId, xData);\n    return 0;\n}\n\nint NFTestRobot::LoginServer()\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    mStatus = NF_TEST_ROBOT_START_LOGIN;\n    m_account = \"robot_\" + NFCommon::tostr(m_robotId);\n    m_password = \"robot_\" + NFCommon::tostr(m_robotId);\n\n    m_accoutLoginTime = NFGetTime();\n    proto_ff::Proto_CSAccountLoginReq xMsg;\n    xMsg.set_account(m_account);\n    xMsg.set_password(m_password);\n    xMsg.set_login_type(proto_ff::E_VISITOR);\n\n    SendMsgToServer(proto_ff::NF_CS_MSG_AccountLoginReq, xMsg);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFFishRobot/NFTestRobot.cpp b/game/Fish/NFFishRobot/NFTestRobot.cpp
--- a/game/Fish/NFFishRobot/NFTestRobot.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/Fish/NFFishRobot/NFTestRobot.cpp	(date 1688633962644)
@@ -92,6 +92,7 @@
     } else {
         mStatus = NF_TEST_ROBOT_LOGIN_FAILED;
         NFLogError(NF_LOG_SYSTEMLOG, 0, "robot:{} account login failed", m_robotId);
+        RegisterAccount();
     }
 
     NFLogTrace(NF_LOG_SYSTEMLOG, 0, "-- end --");
@@ -118,7 +119,8 @@
 {
 	if (mStatus == NF_TEST_ROBOT_CONNECT_SUCCESS)
 	{
-		LoginServer();
+        //VisitorLogin();
+        AccountLogin();
 	}
 
 	if (mStatus >= NF_TEST_ROBOT_CONNECT_SUCCESS)
@@ -156,12 +158,12 @@
     return 0;
 }
 
-int NFTestRobot::LoginServer()
+int NFTestRobot::VisitorLogin()
 {
     NFLogTrace(NF_LOG_SYSTEMLOG, 0, "-- begin --");
     mStatus = NF_TEST_ROBOT_START_LOGIN;
-    m_account = "robot_" + NFCommon::tostr(m_robotId);
-    m_password = "robot_" + NFCommon::tostr(m_robotId);
+    m_account = "robot_visitor_" + NFCommon::tostr(m_robotId);
+    m_password = "robot_visitor_" + NFCommon::tostr(m_robotId);
 
     m_accoutLoginTime = NFGetTime();
     proto_ff::Proto_CSAccountLoginReq xMsg;
@@ -172,4 +174,38 @@
     SendMsgToServer(proto_ff::NF_CS_MSG_AccountLoginReq, xMsg);
     NFLogTrace(NF_LOG_SYSTEMLOG, 0, "-- end --");
     return 0;
+}
+
+int NFTestRobot::AccountLogin()
+{
+    NFLogTrace(NF_LOG_SYSTEMLOG, 0, "-- begin --");
+    mStatus = NF_TEST_ROBOT_START_LOGIN;
+    m_account = "robot_acc_" + NFCommon::tostr(m_robotId);
+    m_password = "robot_acc_" + NFCommon::tostr(m_robotId);
+
+    m_accoutLoginTime = NFGetTime();
+    proto_ff::Proto_CSAccountLoginReq xMsg;
+    xMsg.set_account(m_account);
+    xMsg.set_password(m_password);
+    xMsg.set_login_type(proto_ff::E_ACCOUNT);
+
+    SendMsgToServer(proto_ff::NF_CS_MSG_AccountLoginReq, xMsg);
+    NFLogTrace(NF_LOG_SYSTEMLOG, 0, "-- end --");
+    return 0;
+}
+
+int NFTestRobot::RegisterAccount()
+{
+    NFLogTrace(NF_LOG_SYSTEMLOG, 0, "-- begin --");
+    mStatus = NF_TEST_ROBOT_START_LOGIN;
+    m_account = "robot_acc_" + NFCommon::tostr(m_robotId);
+    m_password = "robot_acc_" + NFCommon::tostr(m_robotId);
+
+    proto_ff::Proto_CSRegisterAccountReq xMsg;
+    xMsg.set_account(m_account);
+    xMsg.set_password(m_password);
+
+    SendMsgToServer(proto_ff::NF_CS_MSG_RegisterAccountReq, xMsg);
+    NFLogTrace(NF_LOG_SYSTEMLOG, 0, "-- end --");
+    return 0;
 }
\ No newline at end of file
Index: game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by gaoyi on 2022/9/21.\n//\n\n#include \"NFLogicCommon.h\"\n\nNFLogicCommon::NFLogicCommon()\n{\n\n}\n\nNFLogicCommon::~NFLogicCommon()\n{\n\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.cpp b/game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.cpp
--- a/game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.cpp	(date 1688630830982)
@@ -3,6 +3,8 @@
 //
 
 #include "NFLogicCommon.h"
+#include "NFComm/NFCore/NFCommon.h"
+#include "NFComm/NFCore/NFMD5.h"
 
 NFLogicCommon::NFLogicCommon()
 {
@@ -14,3 +16,8 @@
 
 }
 
+std::string NFLogicCommon::GetLoginToken(const std::string& account, uint64_t userId, uint64_t time, const std::string& specialStr)
+{
+    std::string token = account + NFCommon::tostr(userId) + NFCommon::tostr(time) + specialStr;
+    return NFMD5::md5str(token);
+}
\ No newline at end of file
Index: Install/FishBusPlugin/Plugin.lua
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>require \"Common\"\n\nLoadPlugin =\n{\n\tTestServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFTestPlugin\",\n\t\t};\n\t\tServerType = NF_ST_NONE;\n\t},\n\n\tRobotServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFRobotPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t};\n\t\tServerType = NF_ST_NONE;\n\t},\n\n\tAllServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t--\"NFTestPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFShmPlugin\",\n\n\t\t\t\"NFServerCommonPlugin\",\n\t\t\t\"NFDescStorePlugin\",\n\t\t\t\"NFCommLogicPlugin\",\n\t\t\t--\"NFLuaScriptPlugin\",\n\n\t\t\t--\"NFMasterServerPlugin\",\n\t\t\t--\"NFRouteServerPlugin\",\n\t\t\t--\"NFRouteAgentServerPlugin\",\n\n\t\t\t--\"NFStoreServerPlugin\",\n\n\t\t\t--\"NFProxyServerPlugin\",\n\t\t\t--\"NFProxyClientPlugin\",\n\t\t\t--\"NFProxyPlayerPlugin\",\n\t\t\t--\"NFProxyAgentServerPlugin\",\n\n\t\t\t--\"NFLoginServerPlugin\",\n\t\t\t--\"NFLoginServerPlayerPlugin\",\n\n\t\t\t--\"NFGameServerPlugin\",\n\t\t\t--\"NFBattlePlugin\",\n\n\t\t\t--\"NFWorldServerPlugin\",\n\t\t\t--\"NFWorldServerPlayerPlugin\",\n\n\t\t\t--\"NFSnsServerPlugin\",\n\t\t\t--\"NFSnsServerPlayerPlugin\",\n\n\t\t\t--\"NFLogicServerPlugin\",\n\t\t\t--\"NFLogicServerPlayerPlugin\",\n\n\t\t\t--\"NFWebServerPlugin\",\n\t\t\t--\"NFWebServerLogicPlugin\",\n\n\t\t\t--\"NFMonitorServerPlugin\",\n\t\t};\n\t\tServerType = NF_ST_NONE;\n\t\tServerList = {\n\t\t\t{Server=\"MasterServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_MASTER_SERVER..\".1\", ServerType=NF_ST_MASTER_SERVER},\n\t\t\t{Server=\"ProxyServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_PROXY_SERVER..\".1\", ServerType=NF_ST_PROXY_SERVER},\n\t\t\t{Server=\"ProxyAgentServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_PROXY_AGENT_SERVER..\".1\", ServerType=NF_ST_PROXY_AGENT_SERVER},\n\t\t\t{Server=\"RouteAgentServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_ROUTE_AGENT_SERVER..\".1\", ServerType=NF_ST_ROUTE_AGENT_SERVER},\n\t\t\t{Server=\"RouteServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_ROUTE_SERVER..\".1\", ServerType=NF_ST_ROUTE_SERVER},\n\t\t\t{Server=\"GameServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_GAME_SERVER..\".1\", ServerType=NF_ST_GAME_SERVER},\n\t\t\t{Server=\"StoreServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_STORE_SERVER..\".1\", ServerType=NF_ST_STORE_SERVER},\n\t\t\t{Server=\"WorldServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_WORLD_SERVER..\".1\", ServerType=NF_ST_WORLD_SERVER},\n\t\t\t{Server=\"LoginServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_LOGIN_SERVER..\".1\", ServerType=NF_ST_LOGIN_SERVER},\n\t\t\t{Server=\"LogicServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_LOGIC_SERVER..\".1\", ServerType=NF_ST_LOGIC_SERVER},\n\t\t\t{Server=\"SnsServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_SNS_SERVER..\".1\", ServerType=NF_ST_SNS_SERVER},\n\t\t\t{Server=\"WebServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_WEB_SERVER..\".1\", ServerType=NF_ST_WEB_SERVER},\n\t\t\t--{Server=\"MonitorServer\", ID=NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_MONITOR_SERVER..\".1\", ServerType=NF_ST_MONITOR_SERVER},\n\t\t};\n\t},\n\tMasterServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\t\t\t\"NFMasterServerPlugin\",\n\t\t};\n\t\tServerType = NF_ST_MASTER_SERVER;\n\t},\n\n\tProxyServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\n\t\t\t\"NFProxyServerPlugin\",\n\t\t\t\"NFProxyClientPlugin\",\n\t\t};\n\t\tServerType = NF_ST_PROXY_SERVER;\n\t},\n\n\tProxyAgentServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\n\t\t\t\"NFProxyAgentServerPlugin\",\n\t\t};\n\t\tServerType = NF_ST_PROXY_AGENT_SERVER;\n\t},\n\n\tGameServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFShmPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\t\t\t\"NFDescStorePlugin\",\n\t\t\t\"NFCommLogicPlugin\",\n\n\n\t\t\t\"NFGameServerPlugin\",\n\t\t\t\"NFBattlePlugin\",\n\t\t};\n\t\tServerType = NF_ST_GAME_SERVER;\n\t},\n\n\tLoginServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFShmPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\t\t\t\"NFDescStorePlugin\",\n\t\t\t\"NFCommLogicPlugin\",\n\n\t\t\t\"NFLoginServerPlugin\",\n\t\t\t--\"NFLoginServerPlayerPlugin\",\n\t\t};\n\t\tServerType = NF_ST_LOGIN_SERVER;\n\t},\n\n\tWorldServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFShmPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\t\t\t\"NFDescStorePlugin\",\n\t\t\t\"NFCommLogicPlugin\",\n\n\t\t\t\"NFWorldServerPlugin\",\n\t\t\t\"NFWorldServerPlayerPlugin\",\n\t\t};\n\t\tServerType = NF_ST_WORLD_SERVER;\n\t},\n\n\tStoreServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\n\t\t\t\"NFStoreServerPlugin\",\n\t\t};\n\t\tServerType = NF_ST_STORE_SERVER;\n\t},\n\n\tLogicServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFShmPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\t\t\t\"NFDescStorePlugin\",\n\t\t\t\"NFCommLogicPlugin\",\n\n\t\t\t\"NFLogicServerPlugin\",\n\t\t\t\"NFLogicServerPlayerPlugin\",\n\t\t};\n\t\tServerType = NF_ST_LOGIC_SERVER;\n\t},\n\n\tSnsServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFShmPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\n\t\t\t\"NFSnsServerPlugin\",\n\t\t\t--\"NFSnsServerPlayerPlugin\",\n\t\t};\n\t\tServerType = NF_ST_SNS_SERVER;\n\t},\n\n\tWebServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\n\t\t\t\"NFWebServerPlugin\",\n\t\t\t--\"NFWebServerLogicPlugin\",\n\t\t};\n\t\tServerType = NF_ST_WEB_SERVER;\n\t},\n\n\tRouteAgentServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\n\t\t\t\"NFRouteAgentServerPlugin\",\n\t\t};\n\t\tServerType = NF_ST_ROUTE_AGENT_SERVER;\n\t},\n\n\tRouteServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\n\t\t\t\"NFRouteServerPlugin\",\n\t\t};\n\t\tServerType = NF_ST_ROUTE_SERVER;\n\t},\n\n\tMonitorServer = {\n\t\tServerPlugins = {\n\t\t\t-------------------------\n\t\t\t-----基础框架引擎-------------\n\t\t\t\"NFKernelPlugin\",\n\t\t\t\"NFNetPlugin\",\n\t\t\t\"NFServerCommonPlugin\",\n\t\t\t\"NFMonitorServerPlugin\",\n\t\t};\n\t\tServerType = NF_ST_MONITOR_SERVER;\n\t},\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Install/FishBusPlugin/Plugin.lua b/Install/FishBusPlugin/Plugin.lua
--- a/Install/FishBusPlugin/Plugin.lua	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/Install/FishBusPlugin/Plugin.lua	(date 1688612438865)
@@ -28,43 +28,40 @@
 			-------------------------
 			-----基础框架引擎-------------
 			"NFKernelPlugin",
-			--"NFTestPlugin",
 			"NFNetPlugin",
 			"NFShmPlugin",
 
 			"NFServerCommonPlugin",
 			"NFDescStorePlugin",
-			"NFCommLogicPlugin",
+			--"NFCommLogicPlugin",
 			--"NFLuaScriptPlugin",
 
-			--"NFMasterServerPlugin",
-			--"NFRouteServerPlugin",
-			--"NFRouteAgentServerPlugin",
+			"NFFishRobotPlugin",
+
+			"NFMasterServerPlugin",
+			"NFRouteServerPlugin",
+			"NFRouteAgentServerPlugin",
 
-			--"NFStoreServerPlugin",
+			"NFStoreServerPlugin",
 
-			--"NFProxyServerPlugin",
-			--"NFProxyClientPlugin",
-			--"NFProxyPlayerPlugin",
-			--"NFProxyAgentServerPlugin",
+			"NFProxyServerPlugin",
+			"NFProxyClientPlugin",
+			"NFFishProxyPlayerPlugin",
 
-			--"NFLoginServerPlugin",
-			--"NFLoginServerPlayerPlugin",
+			"NFProxyAgentServerPlugin",
+
+			"NFLoginServerPlugin",
+			"NFFishLoginPlayerPlugin"
 
 			--"NFGameServerPlugin",
-			--"NFBattlePlugin",
 
 			--"NFWorldServerPlugin",
-			--"NFWorldServerPlayerPlugin",
 
 			--"NFSnsServerPlugin",
-			--"NFSnsServerPlayerPlugin",
 
 			--"NFLogicServerPlugin",
-			--"NFLogicServerPlayerPlugin",
 
 			--"NFWebServerPlugin",
-			--"NFWebServerLogicPlugin",
 
 			--"NFMonitorServerPlugin",
 		};
Index: src/NFComm/NFPluginModule/NFServerDefine.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFServerDefine.h\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFPluginModule\n//\n// -------------------------------------------------------------------------\n#pragma once\n\n#include <functional>\n#include <string>\n#include <vector>\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFCore/NFSlice.hpp\"\n#include \"NFComm/NFCore/NFBuffer.h\"\n#include \"NFComm/NFKernelMessage/proto_kernel.pb.h\"\n\n\n\n#define MAX_CLIENT_INDEX 1000000                  //客户端掩码 一百万\n#define MAX_CLIENT_MASK 0xfffff                   //0x000 00000000 fffff 后20位，5个f，给客户端索引用, 客户端掩码20位, 最大1048576 > 一百万 1000000\n#define MAX_BUS_ID_MASK 0xffffffff00000           //0x0 00 ffffffff 00000 中间32位， 从21位到52位，给服务器的唯一ID，busId用， 需要左移位20\n#define MAX_SERVER_TYPE_MASK 0x0ff0000000000000   //0x0 ff 00000000 00000从53到60位， 给服务器类型用，需要左移位52\n#define MAX_IS_SERVER_MASK 0xf000000000000000     //0xf 00 00000000 00000从61到64位， 是什么类型的， 网络net, 共享内存bus\n\n#define NF_IS_NONE 0\n#define NF_IS_NET 1\n#define NF_IS_BUS 2\n\n#define GetUnLinkId(linkMode, serverType, busId, serverIndex)    ((((uint64_t)serverIndex) & MAX_CLIENT_MASK) | ((((uint64_t)busId) << 20) & MAX_BUS_ID_MASK)  | ((((uint64_t)serverType) << 52) & MAX_SERVER_TYPE_MASK) | ((((uint64_t)linkMode << 60) & MAX_IS_SERVER_MASK)));\n#define GetServerTypeFromUnlinkId(UnlinkId)        ((((uint64_t)UnlinkId) & MAX_SERVER_TYPE_MASK) >> 52);\n#define GetServerLinkModeFromUnlinkId(UnlinkId)        ((((uint64_t)UnlinkId) & MAX_IS_SERVER_MASK) >> 60);\n#define GetServerIndexFromUnlinkId(UnlinkId)    (((uint64_t)UnlinkId) & MAX_CLIENT_MASK);\n#define GetBusIdFromUnlinkId(UnlinkId)    ((((uint64_t)UnlinkId) & MAX_BUS_ID_MASK) >> 20);\n\n#define CLIENT_MSG_PROCESS_NO_PRINTF(xPacket, xMsg)                 \\\n    if (!xMsg.ParseFromArray(xPacket.GetBuffer(), xPacket.GetSize()))                \\\n    {                                                    \\\n        NFLogError(NF_LOG_PROTOBUF_PARSE, 0, \"Protobuf Parse Message Failed, packet:{}\", xPacket.ToString()); \\\n        return -1;                                        \\\n    }\n\n#define CLIENT_MSG_PROCESS_WITH_PRINTF(xPacket, xMsg)                 \\\n    if (!xMsg.ParseFromArray(xPacket.GetBuffer(), xPacket.GetSize()))                \\\n    {                                                    \\\n        NFLogError(NF_LOG_PROTOBUF_PARSE, 0, \"Protobuf Parse Message Failed, packet:{}\", xPacket.ToString()); \\\n        return -1;                                        \\\n    }\\\n    if (NFLogTraceEnable(NF_LOG_RECV_MSG_JSON_PRINTF, xPacket.nParam1))\\\n    {\\\n        NFLogTrace(NF_LOG_RECV_MSG_JSON_PRINTF, xPacket.nParam1, \"recv packet:{}, json:{}\", xPacket.ToString(), xMsg.Utf8DebugString()); \\\n    }\\\n\n#define WEB_MSG_PROCESS_WITH_PRINTF(xMsg, reqHandle) \\\n            \\\n    if (reqHandle.GetType() == NF_HTTP_REQ_GET)      \\\n    {                                                \\\n        if (NFProtobufCommon::GetMessageFromGetHttp(&xMsg, reqHandle) != 0)\\\n        {                                            \\\n            data.set_request_id(req.GetRequestId());                                          \\\n            NFLogError(NF_LOG_PROTOBUF_PARSE, 0, \"Protobuf Parse Message Failed Fromn Http Get, get uri:{}\", req.GetOriginalUri()); \\\n            return false;                               \\\n        }                                            \\\n        data.set_request_id(req.GetRequestId());                                              \\\n        if (NFLogTraceEnable(NF_LOG_RECV_MSG_JSON_PRINTF, 0))\\\n        {\\\n            NFLogInfo(NF_LOG_RECV_MSG_JSON_PRINTF, 0, \"url:{}\", reqHandle.GetOriginalUri()); \\\n        }\\\n    }                                                \\\n    else                                             \\\n    {                                                \\\n        std::string error;                                                 \\\n        if (!NFProtobufCommon::JsonToProtoMessage(reqHandle.GetBody(), &xMsg, &error))                \\\n        {                                            \\\n            data.set_request_id(req.GetRequestId());                                          \\\n            NFLogError(NF_LOG_PROTOBUF_PARSE, 0, \"Protobuf Parse Message Failed Fromn Http Post Json, json:{}, error:{}\", reqHandle.GetBody(), error); \\\n            return false;                                        \\\n        }                                            \\\n        data.set_request_id(req.GetRequestId());                                              \\\n        if (NFLogTraceEnable(NF_LOG_RECV_MSG_JSON_PRINTF, 0))\\\n        {\\\n            NFLogInfo(NF_LOG_RECV_MSG_JSON_PRINTF, 0, \"json:{}\", reqHandle.GetBody()); \\\n        }                                                        \\\n    }\\\n\n// (uint16) 如果修改增加此处大小，需要修改接受缓冲区大小，与客户端 NetDefine.cs 中的定义一直\nconst uint16_t MAX_CLIENT_NET_PACK_LENGTH = 1024 * 48;\nconst uint32_t MAX_SERVER_NET_PACK_LENGTH = 1024 * 512;\nconst uint32_t INNER_SENDBUF_DEFAULT_SIZE = 1024 * 1024 * 2;\nconst uint32_t INNER_RECVBUF_DEFAULT_SIZE = 1024 * 1024 * 2;\nconst uint32_t MAX_WEB_NET_PACK_LENGTH\t  = 1024 * 512;\n\n#define WG_INT_MAX32 0x7FFFFFFFL\n\nenum NF_SERVER_TYPES\n{\n    NF_ST_NONE = 0,            // NONE\n    NF_ST_MASTER_SERVER = 1,\n    NF_ST_ROUTE_SERVER = 2, //路由集群服务器 负责不同机子服务器数据之间的转发\n    NF_ST_ROUTE_AGENT_SERVER = 3, //路由代理服务器  负责同一台机子服务器数据之间的转发\n    NF_ST_PROXY_SERVER = 4,\n    NF_ST_PROXY_AGENT_SERVER = 5, //Proxy 路由代理服务器 负责同一台机子客户端与服务器数据之间的转发\n    NF_ST_STORE_SERVER = 6, //DB服务器\n    NF_ST_LOGIN_SERVER = 7,\n    NF_ST_WORLD_SERVER = 8,\n    NF_ST_LOGIC_SERVER = 9, //Logic服务器\n    NF_ST_GAME_SERVER = 10,\n    NF_ST_SNS_SERVER = 11, //SNS服务器\n    NF_ST_WEB_SERVER = 12, //Web服务器\n    NF_ST_MONITOR_SERVER = 18, //Monitor服务器\n    NF_ST_MAX = 50,\n};\n\nenum NF_MODULE_TYPE\n{\n    NF_MODULE_SERVER= 0, //服务器内网通讯\n    NF_MODULE_CLIENT = 1, //客户端外部协议\n    NF_MODULE_MAX = 2,\n};\n\n#define NF_NET_MAX_MSG_ID 10000\n\nenum PacketParseType\n{\n    PACKET_PARSE_TYPE_INTERNAL = 0,        //内网协议\n    PACKET_PARSE_TYPE_EXTERNAL = 1,        //默认外部协议\n    PACKET_PARSE_TYPE_OLD_EXTERNAL = 2,        //老的外部协议\n};\n\nenum\n{\n    APP_INIT_STATUS_SERVER_CONNECT = 0,\n    APP_INIT_STATUS_SERVER_LOAD_DESC_STORE = 1,\n    APP_INIT_STATUS_SERVER_LOAD_OBJ_FROM_DB = 2,\n};\n\nenum\n{\n    APP_INIT_NONE,\n    //\n    APP_INIT_CONNECT_MASTER,\n    APP_INIT_CONNECT_ROUTE_AGENT_SERVER,\n    APP_INIT_CONNECT_ROUTE_SERVER,\n    APP_INIT_NEED_STORE_SERVER,\n    APP_INIT_NEED_WORLD_SERVER,\n    APP_INIT_REGISTER_WORLD_SERVER,\n\n    //\n    APP_INIT_DESC_STORE_LOAD,\n    //\n\n    APP_INIT_LOAD_RANK_FROM_DB,\n    APP_INIT_LOAD_GAME_ROBOT_FROM_DB,\n    APP_INIT_LOAD_SYSTEM_STAT_DB,\n\n    APP_INIT_MAX,\n};\n\n#define NF_JSON_MSG_ID 0\n#define NF_SERVER_TO_SERVER_HEART_BEAT 1 //心跳协议\n#define NF_SERVER_TO_SERVER_HEART_BEAT_RSP 2 //心跳协议\n\n#define NF_SERVER_TO_SERVER_BUS_CONNECT_REQ 3 //BUS Connect 协议\n#define NF_SERVER_TO_SERVER_BUS_CONNECT_RSP 4 //BUS CONNECT RSP 协议\n\n#define NF_CLIENT_TO_SERVER_HEART_BEAT 10\n#define NF_CLIENT_TO_SERVER_HEART_BEAT_RSP 11\n\n#define NF_NO_FIX_FAME_HANDLE_MAX_MSG_COUNT 10000\n#define NF_FIX_FRAME_HANDLE_MAX_MSG_COUNT 2000    //release test handle 2000 msg => cpu 20%\n\nconst std::string gArrayServer[NF_ST_MAX] = {\n        \"NoneServer\",\n        \"MasterServer\", //1\n        \"RouteServer\", //2\n        \"RouteAgentServer\", //3\n        \"ProxyServer\", //4\n        \"ProxyAgentServer\", //5\n        \"StoreServer\", //6\n        \"LoginServer\", //7\n        \"WorldServer\", //8\n        \"LogicServer\", //9\n        \"GameServer\", //10\n        \"SnsServer\", //11\n        \"WebServer\", //12\n        \"NoneServer\", //13\n        \"NoneServer\", //14\n        \"NoneServer\", //15\n        \"NoneServer\", //16\n        \"NoneServer\", //17\n        \"MonitorServer\", //18\n        \"NoneServer\", //19\n};\n\nstd::string GetServerName(NF_SERVER_TYPES serverId);\n\nenum eMsgType\n{\n    eMsgType_Num = 0,\n    eMsgType_CONNECTED = 1,\n    eMsgType_DISCONNECTED = 2,\n    eMsgType_RECIVEDATA = 3,\n    eMsgType_SENDBUFFER = 4,\n};\n\nenum eAccountEventType\n{\n    eAccountEventType_Num = 0,\n    eAccountEventType_CONNECTED = 1,\n    eAccountEventType_DISCONNECTED = 2,\n    eAccountEventType_RECONNECTED = 3,\n};\n\nconst uint32_t s_compressBitPos = 15;\n\nstruct NFDataPackage\n{\n    NFDataPackage()\n    {\n        Clear();\n    }\n\n    virtual ~NFDataPackage()\n    {\n\n    }\n\n    NFDataPackage(const NFDataPackage& data)\n    {\n        if (this != &data)\n        {\n            mModuleId = data.mModuleId;\n            nMsgId = data.nMsgId;\n            nParam1 = data.nParam1;\n            nParam2 = data.nParam2;\n            nSrcId = data.nSrcId;\n            nDstId = data.nDstId;\n            nSendBusLinkId = data.nSendBusLinkId;\n            bCompress = data.bCompress;\n            nServerLinkId = data.nServerLinkId;\n            nObjectLinkId = data.nObjectLinkId;\n            nPacketParseType = data.nPacketParseType;\n            isSecurity = data.isSecurity;\n            nBuffer = data.nBuffer;\n            nMsgLen = data.nMsgLen;\n        }\n    }\n\n    std::string ToString() const\n    {\n        return NF_FORMAT(\"(mdouleId:{} msgId:{} param1:{} param2:{} nMsgLen:{})\", mModuleId, nMsgId, nParam1, nParam2, nMsgLen);\n    }\n\n    virtual void Clear()\n    {\n        mModuleId = 0;\n        nMsgId = 0;\n        nParam1 = 0;\n        nParam2 = 0;\n        nSrcId = 0;\n        nDstId = 0;\n        nSendBusLinkId = 0;\n        bCompress = false;\n        nServerLinkId = 0;\n        nObjectLinkId = 0;\n        nPacketParseType = 0;\n        isSecurity = false;\n        nBuffer = NULL;\n        nMsgLen = 0;\n    }\n\n    const char* GetBuffer() const\n    {\n        return nBuffer;\n    }\n\n    std::string GetData() const\n    {\n        return std::string(nBuffer, nMsgLen);\n    }\n\n    uint64_t GetSize() const\n    {\n        return nMsgLen;\n    }\n\n    uint64_t GetParam1() const\n    {\n        return nParam1;\n    }\n\n    uint64_t GetParam2() const\n    {\n        return nParam2;\n    }\n\n    uint64_t GetSrcId() const\n    {\n        return nSrcId;\n    }\n\n    uint64_t GetDstId() const\n    {\n        return nDstId;\n    }\n\n    uint64_t GetServerType() const\n    {\n        return GetServerTypeFromUnlinkId(nObjectLinkId);\n    }\n\n    uint64_t GetObjectLinkId() const\n    {\n        return nObjectLinkId;\n    }\n\n    uint64_t GetMsgId() const\n    {\n        return nMsgId;\n    }\n\n    uint32_t mModuleId;\n    uint32_t nMsgId;\n    uint64_t nParam1;\n    uint64_t nParam2;\n    uint64_t nSrcId;\n    uint64_t nDstId;\n    uint64_t nSendBusLinkId;\n    bool bCompress;\n    uint64_t nServerLinkId;\n    uint64_t nObjectLinkId;\n    uint32_t nPacketParseType;\n    bool isSecurity;\n    char* nBuffer;\n    uint64_t nMsgLen;\n};\n\ntypedef std::function<int(uint64_t serverLinkId, uint64_t objectLinkId, NFDataPackage &packet)> NET_CALLBACK_RECEIVE_FUNCTOR;\n\ntypedef std::function<int(uint64_t unLinkId, NFDataPackage &packet)> NET_RECEIVE_FUNCTOR;\n\ntypedef std::function<int(eMsgType nEvent, uint64_t unLinkId)> NET_EVENT_FUNCTOR;\n\ntypedef std::function<int(eMsgType nEvent, uint64_t serverLinkId, uint64_t objectLinkId)> NET_CALLBACK_EVENT_FUNCTOR;\n\ntypedef std::function<void(int iRet, google::protobuf::Message &message)> RPC_TRANS_DESC_STORE_CB;\n\ntypedef std::function<int(uint64_t userId, const google::protobuf::Message *message)> LOG_BEHAVIOR_CALLBAK_FUNCTOR;\n\n/**\n* @brief log打印配置\n*\n* @param  mLogId log配置ID\n* @param  mDisplay 是否打印这个LOG\n* @param  mLevel 输出等级\n* @param  mLogName 显示名字\n* @param  mGuid 0表示打印所有玩家LOG，玩家ID表示只打印这个玩家的LOG\n*/\nclass LogInfoConfig\n{\npublic:\n    LogInfoConfig()\n    {\n        mLogId = 0;\n        mDisplay = false;\n        mLevel = 0;\n    }\n\n    bool Exist(uint64_t guid)\n    {\n        for (size_t i = 0; i < mVecGuid.size(); i++)\n        {\n            if (mVecGuid[i] == guid)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    uint32_t mLogId;\n    bool mDisplay;\n    uint32_t mLevel;\n    std::string mLogName;\n    std::vector<uint64_t> mVecGuid;\n};\n\n//////////////////////////////////////////////////////////////////////////\nclass NFServerData\n{\npublic:\n    NFServerData()\n    {\n        mUnlinkId = 0;\n        mRouteAgentBusId = 0;\n    }\n\n    ~NFServerData()\n    {\n        mUnlinkId = 0;\n        mRouteAgentBusId = 0;\n    }\n\n    uint64_t mUnlinkId;\n    uint32_t mRouteAgentBusId;\n    proto_ff::ServerInfoReport mServerInfo;\n};\n\ntypedef struct tagUidAndIndex\n{\n    uint64_t m_ullUid;\n    int32_t m_iIdx;\n} TUidAndIndex;\n\nint UidCompare(const TUidAndIndex *pstLeft, const TUidAndIndex *pstRight);\n\nint UidHash(const TUidAndIndex *pstKey);\n\nstruct TUid2Uid\n{\n    uint64_t m_ullUid;\n    uint64_t m_ullTargetUid;\n};\n\nint Uid2Compare(const TUid2Uid *pstLeft, const TUid2Uid *pstRight);\n\nint Uid2Hash(const TUid2Uid *pstKey);\n\nconst int MAX_NAME_STR_LEN = 32;\ntypedef struct tagStrAndID\n{\n    char m_szName[MAX_NAME_STR_LEN];\n    int m_iID;\n} TStrAndID;\n\nint StrCompare(const TStrAndID *pstLeft, const TStrAndID *pstRight);\n\nint StrHash(const TStrAndID *pstKey);\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/NFComm/NFPluginModule/NFServerDefine.h b/src/NFComm/NFPluginModule/NFServerDefine.h
--- a/src/NFComm/NFPluginModule/NFServerDefine.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/src/NFComm/NFPluginModule/NFServerDefine.h	(date 1688633828063)
@@ -179,7 +179,7 @@
         "ProxyServer", //4
         "ProxyAgentServer", //5
         "StoreServer", //6
-        "LoginServer", //7
+        "VisitorLogin", //7
         "WorldServer", //8
         "LogicServer", //9
         "GameServer", //10
Index: game/Fish/NFFishRobot/NFTestRobot.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\n\n#include \"NFComm/NFPluginModule/NFIDynamicModule.h\"\n\nenum NFTestRobotStatus\n{\n\tNF_TEST_ROBOT_NONE_STATUS = 0,\n\tNF_TEST_ROBOT_START_CONNECT,\n    NF_TEST_ROBOT_CONNECT_FAILE,\n\tNF_TEST_ROBOT_CONNECT_SUCCESS,\n\tNF_TEST_ROBOT_START_LOGIN,\n\tNF_TEST_ROBOT_LOGIN_FAILED,\n\tNF_TEST_ROBOT_LOGIN_SUCCESS,\n    NF_TEST_ROBOT_START_GAME_CONNECT,\n    NF_TEST_ROBOT_CONNECT_GAME_FAILE,\n    NF_TEST_ROBOT_CONNECT_GAME_SUCCESS,\n\tNF_TEST_ROBOT_START_USER_LOGIN,\n    NF_TEST_ROBOT_LOGIN_USER_FAILED,\n    NF_TEST_ROBOT_LOGIN_USER_SUCCESS,\n    NF_TEST_ROBOT_DISCONNECT_USER,\n    NF_TEST_ROBOT_RECONNECT_SUCCESS,\n    NF_TEST_ROBOT_SEND_RECONNECT,\n\tNF_TEST_MAX_STATUS,\n};\n\nclass StatusAction;\nclass NFTestRobot : public NFIDynamicModule\n{\npublic:\n\tNFTestRobot(NFIPluginManager* p):NFIDynamicModule(p)\n\t{\n        m_playerId = 0;\n        m_proxyLinkId = 0;\n        m_gameId = 0;\n        m_robotId = 0;\n        m_deskId = 0;\n        m_loginTime = 0;\n\t\tmStatus = NF_TEST_ROBOT_NONE_STATUS;\n        m_phonenum = 0;\n        m_loginLinkId = 0;\n\t}\n\n\tint ConnectServer(const std::string& url);\n\tint OnProxyServerSocketEvent(eMsgType nEvent, uint64_t unLinkId);\n\tint OnHandleProxyOtherMessage(uint64_t unLinkId, NFDataPackage &packet);\n    int OnHandleAccountLogin(uint64_t unLinkId, NFDataPackage &packet);\n\tint LoginServer();\n    int SendBeatHeart();\n\n    int OnTimer(uint32_t nTimerID);\n    int SendMsgToServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n    int OnHandlePlazeStatus();\npublic:\n    uint64_t m_phonenum;\n\tstd::string m_account;\n\tstd::string m_password;\n\tuint64_t m_playerId;\n\tuint64_t m_loginTime;\n\tstd::string m_token;\n\tuint32_t m_gameId;\n\tuint32_t m_robotId;\n\tuint32_t m_deskId;\n\tNFTestRobotStatus mStatus;\n\tuint64_t m_proxyLinkId;\n    uint64_t m_loginLinkId;\n\tstd::string m_proxyIp;\n\tuint32_t m_port;\n\n\tuint64_t m_accoutLoginTime;\n\tuint64_t m_userLoginTime;\n\tstd::vector<StatusAction*> m_statusAction;\n};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFFishRobot/NFTestRobot.h b/game/Fish/NFFishRobot/NFTestRobot.h
--- a/game/Fish/NFFishRobot/NFTestRobot.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/Fish/NFFishRobot/NFTestRobot.h	(date 1688633841676)
@@ -44,13 +44,36 @@
 	int OnProxyServerSocketEvent(eMsgType nEvent, uint64_t unLinkId);
 	int OnHandleProxyOtherMessage(uint64_t unLinkId, NFDataPackage &packet);
     int OnHandleAccountLogin(uint64_t unLinkId, NFDataPackage &packet);
-	int LoginServer();
-    int SendBeatHeart();
+
 
     int OnTimer(uint32_t nTimerID);
     int SendMsgToServer(uint32_t nMsgId, const google::protobuf::Message &xData);
     int OnHandlePlazeStatus();
 public:
+    /**
+     * @brief 游客直接登录
+     * @return
+     */
+    int VisitorLogin();
+
+    /**
+     * @brief 账号登录
+     * @return
+     */
+    int AccountLogin();
+
+    /**
+     * @brief 注册账号
+     * @return
+     */
+    int RegisterAccount();
+
+    /**
+     * @brief 发心跳包
+     * @return
+     */
+    int SendBeatHeart();
+public:
     uint64_t m_phonenum;
 	std::string m_account;
 	std::string m_password;
Index: game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFCProxyClientModule.cpp\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFCProxyClientModule\n//\n// -------------------------------------------------------------------------\n\n#include <NFComm/NFCore/NFTime.h>\n#include <Com.pb.h>\n#include <ComDefine.pb.h>\n#include <ClientServerCmd.pb.h>\n#include <ClientServer.pb.h>\n#include <NFComm/NFPluginModule/NFCheck.h>\n#include <NFServerComm/NFServerCommon/NFIServerMessageModule.h>\n#include <ServerInternalCmd.pb.h>\n#include \"NFProxyPlayerModule.h\"\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include \"NFComm/NFPluginModule/NFIConfigModule.h\"\n#include \"NFServerComm/NFServerCommon/NFIProxyServerModule.h\"\n#include \"NFComm/NFCore/NFRandom.hpp\"\n#include \"NFComm/NFPluginModule/NFCommLogic.h\"\n#include \"ServerInternal.pb.h\"\n#include \"CSLogin.pb.h\"\n\nNFCProxyPlayerModule::NFCProxyPlayerModule(NFIPluginManager *p) : NFIProxyPlayerModule(p)\n{\n}\n\nNFCProxyPlayerModule::~NFCProxyPlayerModule()\n{\n}\n\nbool NFCProxyPlayerModule::Awake()\n{\n    m_packetConfig.LoadConfig(m_pObjPluginManager->GetConfigPath() + \"/Server\", \"ProxyServer\");\n    SetTimer(NF_PROXY_CLIENT_TIMER_ID, NF_PROXY_CLIENT_INTERVAL_TIME);\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //////来自客户端的协议////////////////////////////////////////\n    RegisterClientMessage(NF_ST_PROXY_SERVER, proto_ff::NF_CS_MSG_AccountLoginReq);\n\n\n    /////////来自Login Server返回的协议//////////////////////////////////////////////////\n    /////来自World Server返回的协议////////////////////////////////////////\n    RegisterServerMessage(NF_ST_PROXY_SERVER, proto_ff::NF_SERVER_REDIRECT_MSG_TO_PROXY_SERVER_CMD);\n\n    return true;\n}\n\nbool NFCProxyPlayerModule::Init()\n{\n    NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_PROXY_SERVER);\n    if (pConfig)\n    {\n        uint64_t proxyClientLinkId = FindModule<NFIMessageModule>()->GetClientLinkId(NF_ST_PROXY_SERVER);\n        if (proxyClientLinkId > 0)\n        {\n            /*\n            注册服务器事件\n            */\n            FindModule<NFIMessageModule>()->AddEventCallBack(NF_ST_PROXY_SERVER, proxyClientLinkId, this,\n                                                             &NFCProxyPlayerModule::OnProxyClientSocketEvent);\n            FindModule<NFIMessageModule>()->AddOtherCallBack(NF_ST_PROXY_SERVER, proxyClientLinkId, this,\n                                                             &NFCProxyPlayerModule::OnHandleProxyClientOtherMessage);\n        }\n        else\n        {\n            NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"Get NF_ST_PROXY_SERVER ClientLinkId Failed!\");\n            return false;\n        }\n\n        uint64_t proxyServerLinkId = FindModule<NFIMessageModule>()->GetServerLinkId(NF_ST_PROXY_SERVER);\n        if (proxyServerLinkId > 0)\n        {\n            /*\n            注册服务器事件\n            */\n            FindModule<NFIMessageModule>()->AddOtherCallBack(NF_ST_PROXY_SERVER, proxyServerLinkId, this,\n                                                             &NFCProxyPlayerModule::OnHandleOtherServerToClientMsg);\n        }\n        else\n        {\n            NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"Get NF_ST_PROXY_SERVER ClientLinkId Failed!\");\n            return false;\n        }\n    }\n    else\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"I Can't get the Proxy Server config!\");\n        return false;\n    }\n\n    return true;\n}\n\nbool NFCProxyPlayerModule::Execute()\n{\n    return true;\n}\n\nbool NFCProxyPlayerModule::OnDynamicPlugin()\n{\n    return true;\n}\n\nint NFCProxyPlayerModule::OnTimer(uint32_t nTimerID)\n{\n    if (nTimerID == NF_PROXY_CLIENT_TIMER_ID)\n    {\n        HandleProxyClientTick();\n        HandlePlayerTick();\n    }\n    return 0;\n}\n\nint NFCProxyPlayerModule::OnHandleClientMessage(uint64_t unLinkId, NFDataPackage &packet)\n{\n    if (!m_pObjPluginManager->IsInited())\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, packet.nParam1, \"Proxy Server not inited, drop client msg:{}\", packet.ToString());\n        return -1;\n    }\n\n    if (m_pObjPluginManager->IsServerStopping())\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, packet.nParam1, \"Proxy Server is Stopping, drop client msg:{}\", packet.ToString());\n        return -1;\n    }\n\n    switch (packet.nMsgId)\n    {\n        case proto_ff::NF_CS_Msg_HeartBeat_REQ:\n        {\n            OnHandleClientHeartBeat(unLinkId, packet);\n            break;\n        }\n        case proto_ff::NF_CS_MSG_AccountLoginReq:\n        {\n            OnHandleAccountLoginFromClient(unLinkId, packet);\n            break;\n        }\n        default:\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"Client MsgId:{} Register, But Not Handle, Package:{}\", packet.nMsgId, packet.ToString());\n            break;\n        }\n    }\n    return 0;\n}\n\n\nint NFCProxyPlayerModule::OnHandleServerMessage(uint64_t unLinkId, NFDataPackage &packet)\n{\n    if (!m_pObjPluginManager->IsInited())\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, packet.nParam1, \"World Server not inited, drop client msg:{}\", packet.ToString());\n        return -1;\n    }\n\n    if (m_pObjPluginManager->IsServerStopping())\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, packet.nParam1, \"World Server is Stopping, drop client msg:{}\", packet.ToString());\n        return -1;\n    }\n\n    switch (packet.nMsgId)\n    {\n        case proto_ff::NF_SERVER_REDIRECT_MSG_TO_PROXY_SERVER_CMD:\n        {\n            OnHandleRedirectMsg(unLinkId, packet);\n            break;\n        }\n        default:\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"Server MsgId:{} Register, But Not Handle, Package:{}\", packet.nMsgId, packet.ToString());\n            break;\n        }\n    }\n    return 0;\n}\n\n/*\n\t处理客户端链接事件\n*/\nint NFCProxyPlayerModule::OnProxyClientSocketEvent(eMsgType nEvent, uint64_t unLinkId)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    if (nEvent == eMsgType_CONNECTED)\n    {\n        std::string ip = FindModule<NFIMessageModule>()->GetLinkIp(unLinkId);\n        uint32_t port = FindModule<NFIMessageModule>()->GetPort(unLinkId);\n        NFLogDebug(NF_LOG_SYSTEMLOG, 0, \"client ip:{} port:{} linkId:{} connected proxy server success!\", ip, port, unLinkId);\n\n        NF_SHARE_PTR<NFProxySession> pLinkInfo = mClientLinkInfo.GetElement(unLinkId);\n        CHECK_EXPR_ASSERT(pLinkInfo == NULL, -1, \"unLinkId:{} Exist\", unLinkId);\n        if (pLinkInfo == nullptr)\n        {\n            pLinkInfo = NF_SHARE_PTR<NFProxySession>(NF_NEW NFProxySession());\n            pLinkInfo->SetLinkId(unLinkId);\n            pLinkInfo->SetIpAddr(ip);\n            pLinkInfo->SetPort(port);\n            pLinkInfo->SetLastActiveTime(NFTime::Now().UnixSec());\n            mClientLinkInfo.AddElement(unLinkId, pLinkInfo);\n        }\n    }\n    else if (nEvent == eMsgType_DISCONNECTED)\n    {\n        std::string ip = FindModule<NFIMessageModule>()->GetLinkIp(unLinkId);\n        uint32_t port = FindModule<NFIMessageModule>()->GetPort(unLinkId);\n        NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"client ip:{} port:{} link:{} disconnected proxy server!\", ip, port, unLinkId);\n        OnHandleClientDisconnect(unLinkId);\n    }\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\n/*\n\t处理客户端未注册协议\n*/\nint NFCProxyPlayerModule::OnHandleProxyClientOtherMessage(uint64_t unLinkId, NFDataPackage &packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n\n    std::string ip = FindModule<NFIMessageModule>()->GetLinkIp(unLinkId);\n\n    NF_SHARE_PTR<NFProxySession> pLinkInfo = mClientLinkInfo.GetElement(unLinkId);\n    if (pLinkInfo == nullptr)\n    {\n        NFLogWarning(NF_LOG_SYSTEMLOG, 0, \"can't find the link, ip:{} packet:{}\",\n                     ip, packet.ToString());\n\n        FindModule<NFIMessageModule>()->CloseLinkId(unLinkId);\n        return 0;\n    }\n\n    NF_SHARE_PTR<NFProxyPlayerInfo> pPlayerInfo = mPlayerLinkInfo.GetElement(pLinkInfo->GetUid());\n    if (pPlayerInfo == nullptr)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"can't find the clientId:{} 's playerId:{}, drop msg:{}\", unLinkId, pLinkInfo->GetUid(), packet.ToString());\n        return 0;\n    }\n\n    pPlayerInfo->SetOnline(true);\n\n    int count = 0;\n    int interval = 0;\n    uint64_t roleID = 0;\n    pLinkInfo->AddPkgStatistic(packet.nMsgId, pLinkInfo->GetUid(), unLinkId);\n    int ret = pLinkInfo->CheckPkgRate(&m_packetConfig, packet.nMsgId, count, interval);\n    if (ret != 0)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"pkg check and kick player:{| linkId:{} count:{} interval:{} ret:{} packet:{}\", roleID, unLinkId, count,\n                   interval, ret, packet.ToString());\n        return 0;\n    }\n\n    {\n        if (!pPlayerInfo->IsLogin())\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"the clientId:{} 's playerId:{} not login, drop msg:{}\", unLinkId, pLinkInfo->GetUid(),\n                       packet.ToString());\n            return 0;\n        }\n\n        uint32_t serverType = FindModule<NFIProxyServerModule>()->GetClientMsgServer(packet.nMsgId);\n        if (serverType == NF_ST_WORLD_SERVER)\n        {\n            NF_SHARE_PTR<NFServerData> pWorldServer = FindModule<NFIMessageModule>()->GetSuitServerByServerType(NF_ST_PROXY_SERVER,\n                                                                                                                NF_ST_WORLD_SERVER,\n                                                                                                                pPlayerInfo->GetUid());\n            if (pWorldServer)\n            {\n                NFLogDebug(NF_LOG_SYSTEMLOG, pPlayerInfo->GetUid(), \"recv packet = {}, transfer to world server\", packet.ToString());\n                if (pPlayerInfo->GetUid() > 0)\n                {\n                    FindModule<NFIServerMessageModule>()->SendProxyMsgByBusId(NF_ST_PROXY_SERVER, pWorldServer->mServerInfo.bus_id(),\n                                                                              NF_MODULE_CLIENT, packet.nMsgId,\n                                                                              packet.GetBuffer(), packet.GetSize(), pPlayerInfo->GetUid(),\n                                                                              pPlayerInfo->GetUid());\n                }\n                else\n                {\n                    FindModule<NFIServerMessageModule>()->SendProxyMsgByBusId(NF_ST_PROXY_SERVER, pWorldServer->mServerInfo.bus_id(),\n                                                                              NF_MODULE_CLIENT, packet.nMsgId,\n                                                                              packet.GetBuffer(), packet.GetSize(), pPlayerInfo->GetUid(),\n                                                                              unLinkId);\n                }\n            }\n            else\n            {\n                NFLogWarning(NF_LOG_SYSTEMLOG, pLinkInfo->GetUid(),\n                             \"can't find the player:{} info, the cmd don't find the trans to world server, world server not exist, ip:{} packet:{}\",\n                             pLinkInfo->GetUid(), ip, packet.ToString());\n            }\n        }\n        else if (serverType == NF_ST_LOGIC_SERVER)\n        {\n            if (pPlayerInfo->GetLogicBusId() > 0)\n            {\n                NFLogDebug(NF_LOG_SYSTEMLOG, pPlayerInfo->GetUid(), \"recv packet = {}, transfer to logic server\", packet.ToString());\n                FindModule<NFIServerMessageModule>()->SendProxyMsgByBusId(NF_ST_PROXY_SERVER, pPlayerInfo->GetLogicBusId(), NF_MODULE_CLIENT,\n                                                                          packet.nMsgId,\n                                                                          packet.GetBuffer(), packet.GetSize(), pPlayerInfo->GetUid(),\n                                                                          pPlayerInfo->GetUid());\n            }\n            else\n            {\n                NFLogError(NF_LOG_SYSTEMLOG, pPlayerInfo->GetUid(), \"recv nMsgId = {}, not transfer to logic server\", packet.ToString());\n            }\n        }\n        else if (serverType == NF_ST_GAME_SERVER)\n        {\n            if (pPlayerInfo->GetGameBusId() > 0)\n            {\n                NFLogDebug(NF_LOG_SYSTEMLOG, pPlayerInfo->GetUid(), \"recv packet = {}, transfer to game server\", packet.ToString());\n                FindModule<NFIServerMessageModule>()->SendProxyMsgByBusId(NF_ST_PROXY_SERVER, pPlayerInfo->GetGameBusId(), NF_MODULE_CLIENT,\n                                                                          packet.nMsgId,\n                                                                          packet.GetBuffer(), packet.GetSize(), pPlayerInfo->GetUid(),\n                                                                          pPlayerInfo->GetUid());\n            }\n            else\n            {\n                NFLogError(NF_LOG_SYSTEMLOG, pPlayerInfo->GetUid(), \"recv nMsgId = {}, not transfer to game server\", packet.ToString());\n            }\n        }\n        else if (serverType == NF_ST_SNS_SERVER)\n        {\n            NF_SHARE_PTR<NFServerData> pSnsServer = FindModule<NFIMessageModule>()->GetSuitServerByServerType(NF_ST_PROXY_SERVER,\n                                                                                                              NF_ST_SNS_SERVER,\n                                                                                                              pPlayerInfo->GetUid());\n            if (pSnsServer)\n            {\n                NFLogDebug(NF_LOG_SYSTEMLOG, pPlayerInfo->GetUid(), \"recv packet = {}, transfer to sns server\", packet.ToString());\n                FindModule<NFIServerMessageModule>()->SendProxyMsgByBusId(NF_ST_PROXY_SERVER, pSnsServer->mServerInfo.bus_id(), NF_MODULE_CLIENT,\n                                                                          packet.nMsgId,\n                                                                          packet.GetBuffer(), packet.GetSize(), pPlayerInfo->GetUid(),\n                                                                          pPlayerInfo->GetUid());\n            }\n            else\n            {\n                NFLogWarning(NF_LOG_SYSTEMLOG, pLinkInfo->GetUid(),\n                             \"can't find the player:{} info, the cmd don't find the trans to sns server, sns server not exist, ip:{} packet:{}\",\n                             pLinkInfo->GetUid(), ip, packet.ToString());\n            }\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, pPlayerInfo->GetUid(), \"no server handle the msg, drop msg:{}\", packet.ToString());\n        }\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCProxyPlayerModule::OnHandleClientDisconnect(uint64_t unLinkId)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    NF_SHARE_PTR<NFProxySession> pLinkInfo = mClientLinkInfo.GetElement(unLinkId);\n    if (pLinkInfo)\n    {\n        if (pLinkInfo->GetUid() > 0)\n        {\n            NF_SHARE_PTR<NFProxyPlayerInfo> pPlayerInfo = mPlayerLinkInfo.GetElement(pLinkInfo->GetUid());\n            if (pPlayerInfo && pPlayerInfo->GetLinkId() == unLinkId)\n            {\n            }\n        }\n        mClientLinkInfo.RemoveElement(unLinkId);\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\n\nint NFCProxyPlayerModule::OnHandleClientHeartBeat(uint64_t unLinkId, NFDataPackage &packet)\n{\n    NF_SHARE_PTR<NFProxySession> pLinkInfo = mClientLinkInfo.GetElement(unLinkId);\n    if (pLinkInfo == NULL)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, unLinkId, \"can't find unLinkId:{}\", unLinkId);\n        FindModule<NFIMessageModule>()->CloseLinkId(unLinkId);\n        return -1;\n    }\n\n    pLinkInfo->SetLastActiveTime(NFTime::Now().UnixSec());\n\n    proto_ff::Proto_SCHeartBeatRsp xData;\n    xData.set_result(0);\n    FindModule<NFIMessageModule>()->Send(unLinkId, proto_ff::NF_SC_Msg_HeartBeat_RSP, xData);\n\n    return 0;\n}\n\nint NFCProxyPlayerModule::HandleProxyClientTick()\n{\n    auto pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_PROXY_SERVER);\n    CHECK_EXPR(pConfig, -1, \"pConfig == NULL\");\n\n    auto pProxyClient = mClientLinkInfo.First();\n    while (pProxyClient)\n    {\n        if (pProxyClient->GetUid() <= 0 && pProxyClient->GetLastActiveTime() > 0 &&\n            NFTime::Now().UnixSec() - pProxyClient->GetLastActiveTime() >= pConfig->HeartBeatTimeout)\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"check heart beat timeout........., disconnect link:{} \", pProxyClient->GetLinkId());\n            FindModule<NFIMessageModule>()->CloseLinkId(pProxyClient->GetLinkId());\n        }\n\n        if (pProxyClient->GetUid() > 0 && pProxyClient->GetLastActiveTime() > 0 &&\n            NFTime::Now().UnixSec() - pProxyClient->GetLastActiveTime() >= pConfig->ClientKeepAliveTimeout)\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, pProxyClient->GetUid(), \"check player keep alive timeout........., disconnect link:{} playerId:{}\",\n                       pProxyClient->GetLinkId(), pProxyClient->GetUid());\n            FindModule<NFIMessageModule>()->CloseLinkId(pProxyClient->GetLinkId());\n        }\n\n        pProxyClient = mClientLinkInfo.Next();\n    }\n    return 0;\n}\n\nint NFCProxyPlayerModule::OnHandleOtherServerToClientMsg(uint64_t unLinkId, NFDataPackage &packet)\n{\n    uint64_t playerId = packet.nParam1;\n    uint64_t clientId = packet.nParam2;\n    NF_SHARE_PTR<NFProxyPlayerInfo> pPlayerInfo = mPlayerLinkInfo.GetElement(playerId);\n    if (pPlayerInfo && clientId == pPlayerInfo->GetLinkId())\n    {\n        NF_SHARE_PTR<NFProxySession> pLinkInfo = mClientLinkInfo.GetElement(pPlayerInfo->GetLinkId());\n        if (pLinkInfo == NULL)\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, unLinkId, \"can't find player linkId, player disconnect:{}\", unLinkId);\n            return -1;\n        }\n\n        uint32_t srcBusId = packet.nSrcId;\n        auto pServerData = FindModule<NFIMessageModule>()->GetServerByServerId(NF_ST_PROXY_SERVER, srcBusId);\n        if (pServerData)\n        {\n            NFLogDebug(NF_LOG_SYSTEMLOG, pPlayerInfo->GetUid(), \"trans {} msg to client, packet:{}\", pServerData->mServerInfo.server_name(),\n                       packet.ToString());\n        }\n        FindModule<NFIMessageModule>()->Send(pPlayerInfo->GetLinkId(), NF_MODULE_CLIENT, packet.nMsgId, (const char*)packet.GetBuffer(), (uint32_t)packet.GetSize());\n    }\n    else\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"can't find player:{} info or clientId change, other server msg:{} not handle\", playerId, packet.ToString());\n    }\n\n    return 0;\n}\n\nint NFCProxyPlayerModule::OnHandleRedirectMsg(uint64_t unLinkId, NFDataPackage &packet)\n{\n    proto_ff::Proto_SvrPkg xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    const ::proto_ff::Proto_RedirectInfo &redirectInfo = xMsg.redirect_info();\n    for (int i = 0; i < (int) redirectInfo.id_size(); i++)\n    {\n        uint64_t playerId = redirectInfo.id(i);\n        NF_SHARE_PTR<NFProxyPlayerInfo> pPlayerInfo = mPlayerLinkInfo.GetElement(playerId);\n        if (pPlayerInfo)\n        {\n            NF_SHARE_PTR<NFProxySession> pLinkInfo = mClientLinkInfo.GetElement(pPlayerInfo->GetLinkId());\n            if (pLinkInfo == NULL)\n            {\n                NFLogError(NF_LOG_SYSTEMLOG, unLinkId, \"can't find player linkId, player disconnect:{}\", unLinkId);\n                return -1;\n            }\n\n            FindModule<NFIMessageModule>()->Send(pPlayerInfo->GetLinkId(), (uint32_t) xMsg.msg_id(), xMsg.msg_data());\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"can't find player:{} info, other server msg:{} not handle\", playerId, packet.ToString());\n        }\n    }\n\n    return 0;\n}\n\nint NFCProxyPlayerModule::HandlePlayerTick()\n{\n    std::vector<uint64_t> vec;\n    auto pPlayerInfo = mPlayerLinkInfo.First();\n    while (pPlayerInfo)\n    {\n        if (pPlayerInfo->IsOnline() == false)\n        {\n/*            if (NFTime::Now().UnixSec() - pPlayerInfo->GetDisconnectTime() >= PLAYER_MAX_DISCONNECT_EXIST_TIME)\n            {\n                vec.push_back(pPlayerInfo->GetUid());\n            }\n\n            if (pPlayerInfo->IsLogin())\n            {\n                if (NFTime::Now().UnixSec() - pPlayerInfo->GetDisconnectTime() >= PLAYER_MAX_DISCONNECT_RECONNECT_TIME)\n                {\n                    pPlayerInfo->SetIsLogin(false);\n                    NFLogError(NF_LOG_SYSTEMLOG, 0, \"player disconnect 60s, islogin = false:{}\", pPlayerInfo->GetUid());\n                }\n            }*/\n        }\n        pPlayerInfo = mPlayerLinkInfo.Next();\n    }\n\n    for (int i = 0; i < (int) vec.size(); i++)\n    {\n        mPlayerLinkInfo.RemoveElement(vec[i]);\n    }\n    return 0;\n}\n\nint NFCProxyPlayerModule::OnHandleAccountLoginFromClient(uint64_t unLinkId, NFDataPackage &packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::Proto_CSAccountLoginReq cgMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, cgMsg);\n\n    NF_SHARE_PTR<NFProxySession> pLinkInfo = mClientLinkInfo.GetElement(unLinkId);\n    CHECK_NULL(pLinkInfo);\n\n    std::string ip = FindModule<NFIMessageModule>()->GetLinkIp(unLinkId);\n\n    auto pServerData = FindModule<NFIMessageModule>()->GetSuitServerByServerType(NF_ST_PROXY_SERVER,\n                                                                                 NF_ST_LOGIN_SERVER, cgMsg.account());\n    if (pServerData)\n    {\n        uint32_t loginId = pServerData->mServerInfo.bus_id();\n\n        FindModule<NFIServerMessageModule>()->SendProxyMsgByBusId(NF_ST_PROXY_SERVER, loginId, packet.nMsgId, cgMsg, unLinkId);\n    }\n    else\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"Get Login Server Bus Id Failed\");\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp b/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp
--- a/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp	(date 1688632479902)
@@ -8,10 +8,7 @@
 // -------------------------------------------------------------------------
 
 #include <NFComm/NFCore/NFTime.h>
-#include <Com.pb.h>
-#include <ComDefine.pb.h>
 #include <ClientServerCmd.pb.h>
-#include <ClientServer.pb.h>
 #include <NFComm/NFPluginModule/NFCheck.h>
 #include <NFServerComm/NFServerCommon/NFIServerMessageModule.h>
 #include <ServerInternalCmd.pb.h>
@@ -20,9 +17,8 @@
 #include "NFComm/NFPluginModule/NFIConfigModule.h"
 #include "NFServerComm/NFServerCommon/NFIProxyServerModule.h"
 #include "NFComm/NFCore/NFRandom.hpp"
-#include "NFComm/NFPluginModule/NFCommLogic.h"
-#include "ServerInternal.pb.h"
 #include "CSLogin.pb.h"
+#include "NFLogicCommon/NFLogicBindRpcService.h"
 
 NFCProxyPlayerModule::NFCProxyPlayerModule(NFIPluginManager *p) : NFIProxyPlayerModule(p)
 {
@@ -38,8 +34,9 @@
     SetTimer(NF_PROXY_CLIENT_TIMER_ID, NF_PROXY_CLIENT_INTERVAL_TIME);
     ////////////////////////////////////////////////////////////////////////////////////////////////////////////
     //////来自客户端的协议////////////////////////////////////////
-    RegisterClientMessage(NF_ST_PROXY_SERVER, proto_ff::NF_CS_MSG_AccountLoginReq);
-
+    RegisterClientMessage(NF_ST_PROXY_SERVER, proto_ff::NF_CS_MSG_AccountLoginReq, true);
+    RegisterClientMessage(NF_ST_PROXY_SERVER, proto_ff::NF_CS_Msg_HeartBeat_REQ);
+    RegisterClientMessage(NF_ST_PROXY_SERVER, NF_SERVER_TO_SERVER_HEART_BEAT);
 
     /////////来自Login Server返回的协议//////////////////////////////////////////////////
     /////来自World Server返回的协议////////////////////////////////////////
@@ -130,6 +127,11 @@
 
     switch (packet.nMsgId)
     {
+        case NF_SERVER_TO_SERVER_HEART_BEAT:
+        {
+            FindModule<NFIMessageModule>()->Send(unLinkId, NF_SERVER_TO_SERVER_HEART_BEAT_RSP, NULL, 0);
+
+        }
         case proto_ff::NF_CS_Msg_HeartBeat_REQ:
         {
             OnHandleClientHeartBeat(unLinkId, packet);
@@ -531,14 +533,39 @@
     if (pServerData)
     {
         uint32_t loginId = pServerData->mServerInfo.bus_id();
+        proto_ff::Proto_SCAccountLoginRsp respone;
+        int iRet = FindModule<NFIMessageModule>()->GetRpcService<proto_ff::NF_CS_MSG_AccountLoginReq>(NF_ST_PROXY_SERVER, NF_ST_LOGIN_SERVER, loginId, cgMsg, respone);
+        if (iRet != 0)
+        {
+            NFLogError(NF_LOG_SYSTEMLOG, 0, "GetRpcService proto_ff::NF_RPC_SERVICE_GET_SERVER_INFO_REQ Failed!");
+            return 0;
+        }
 
-        FindModule<NFIServerMessageModule>()->SendProxyMsgByBusId(NF_ST_PROXY_SERVER, loginId, packet.nMsgId, cgMsg, unLinkId);
+        pLinkInfo = mClientLinkInfo.GetElement(unLinkId);
+        if (pLinkInfo == nullptr)
+        {
+            NFLogWarning(NF_LOG_SYSTEMLOG, 0, "clientLinkId:{} not exist, client maybe disconnect!", unLinkId);
+            return 0;
+        }
+
+        FindModule<NFIMessageModule>()->Send(unLinkId, proto_ff::NF_SC_MSG_AccountLoginRsp, respone);
     }
     else
     {
+        KickPlayer(unLinkId);
         NFLogError(NF_LOG_SYSTEMLOG, 0, "Get Login Server Bus Id Failed");
     }
 
     NFLogTrace(NF_LOG_SYSTEMLOG, 0, "-- end --");
     return 0;
+}
+
+int NFCProxyPlayerModule::KickPlayer(uint64_t unLinkId)
+{
+    NFLogInfo(NF_LOG_SYSTEMLOG, 0, "kick linkId:{}", unLinkId);
+    proto_ff::Proto_SCKetPlayerNotify kitMsg;
+    kitMsg.set_result(0);
+    FindModule<NFIMessageModule>()->Send(unLinkId, proto_ff::NF_SC_Msg_KitPlayer_Notify, kitMsg);
+    FindModule<NFIMessageModule>()->CloseLinkId(unLinkId);
+    return 0;
 }
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"CMakePresetLoader\">{\n  &quot;useNewFormat&quot;: true\n}</component>\n  <component name=\"CMakeReloadState\">\n    <option name=\"reloaded\" value=\"true\" />\n  </component>\n  <component name=\"CMakeRunConfigurationManager\">\n    <generated>\n      <config projectName=\"ShmNFrame\" targetName=\"NFLuaScriptPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"evpp\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFServerMessage\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFKernelPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFLogicServerPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFSnsServerPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFPluginLoader\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFRouteAgentServerPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFLogicCommon\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFGameServerPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFProxyServerPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFShmPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFWorldServerPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFNetPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFProxyClientPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFServerLogicMessage\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFRouteServerPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFServerCommon\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFProxyAgentServerPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFMasterServerPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFFishRobotPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFStoreServerPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFDescStorePlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFTestPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"Sqlite3\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFDescStore\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFFishProxyPlayerPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFLoginServerPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFServerCommonPlugin\" />\n      <config projectName=\"ShmNFrame\" targetName=\"mysqlpp\" />\n      <config projectName=\"ShmNFrame\" targetName=\"NFWebServerPlugin\" />\n    </generated>\n  </component>\n  <component name=\"CMakeSettings\">\n    <configurations>\n      <configuration PROFILE_NAME=\"Debug\" ENABLED=\"true\" GENERATION_DIR=\"Build\" CONFIG_NAME=\"Debug\" GENERATION_OPTIONS=\"-DCMAKE_BUILD_TYPE=DynamicDebug\" NO_GENERATOR=\"true\" />\n    </configurations>\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"b1adcfc4-cb29-4816-844f-be9c46975368\" name=\"更改\" comment=\"\">\n      <change afterPath=\"$PROJECT_DIR$/game/Fish/NFFishRobot/CMakeLists.txt\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/game/Fish/NFFishRobot/NFFishRobotPlugin.cpp\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/game/Fish/NFFishRobot/NFFishRobotPlugin.h\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/game/Fish/NFFishRobot/NFRobotModule.cpp\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/game/Fish/NFFishRobot/NFRobotModule.h\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/game/Fish/NFFishRobot/NFStatusAction.h\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/game/Fish/NFFishRobot/NFTestRobot.cpp\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/game/Fish/NFFishRobot/NFTestRobot.h\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/game/Fish/NFLogicComm/Message/proto_cs/CSLogin.proto\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/NFShmServer.iml\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/codeStyles/codeStyleConfig.xml\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/deployment.xml\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/dianwan.iml\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/inspectionProfiles/Project_Default.xml\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/mmo-nfshm-server.iml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/mmo-nfshm-server.iml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/_2022_11_6_3_27____.xml\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/在进行更新之前于_2022_10_8_上午11_31_取消提交了变更_[默认变更列表]/shelved.patch\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/在进行更新之前于_2022_11_15_下午10_19_取消提交了变更_[默认变更列表]/shelved.patch\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/在进行更新之前于_2022_11_6_下午3_27_取消提交了变更_[默认变更列表]/shelved.patch\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/在进行更新之前于_2022_11_6_下午3_27_取消提交了变更_[默认变更列表]1/shelved.patch\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/在进行更新之前于_2022_9_27_下午11_10_取消提交了变更_[默认变更列表]/shelved.patch\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/在进行更新之前于_22-10-31_上午8_42_取消提交了变更_[默认变更列表]/MMO\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/在进行更新之前于_22-11-14_上午8_25_取消提交了变更_[默认变更列表]/MMO\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/在进行更新之前于_22-11-14_上午8_25_取消提交了变更_[默认变更列表]1/MMO\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/在进行更新之前于_22-11-14_上午8_25_取消提交了变更_[默认变更列表]2/MMO\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/在进行更新之前于_22-11-7_上午8_32_取消提交了变更_[默认变更列表]/MMO\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/在进行更新之前于_22-12-6_上午10_15_取消提交了变更_[默认变更列表]/MMO\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Install/Config/Fish/Sql/CommonLogic.proto.ds\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Install/Config/Fish/Sql/CommonLogic.proto.ds\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/game/Fish/CMakeLists.txt\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/game/Fish/CMakeLists.txt\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/game/Fish/NFLogicComm/Message/common/ComDefine.proto\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/game/Fish/NFLogicComm/Message/common/ComDefine.proto\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/game/Fish/NFLogicComm/NFServerLogicMessage/ComDefine.pb.cc\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/game/Fish/NFLogicComm/NFServerLogicMessage/ComDefine.pb.cc\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/game/Fish/NFLogicComm/NFServerLogicMessage/ComDefine.pb.h\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/game/Fish/NFLogicComm/NFServerLogicMessage/ComDefine.pb.h\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/CMakeLists.txt\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/CMakeLists.txt\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.h\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.h\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerPlugin.cpp\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFFishProxyPlayerPlugin.cpp\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerPlugin.h\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFFishProxyPlayerPlugin.h\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"ClangdSettings\">\n    <option name=\"formatViaClangd\" value=\"false\" />\n  </component>\n  <component name=\"ExecutionTargetManager\" SELECTED_TARGET=\"CMakeBuildProfile:Debug\" />\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"OCResolveContextSettings\">\n    <option name=\"configuration\" value=\"0-DynamicDebug-NFFishProxyPlayerPlugin\" />\n  </component>\n  <component name=\"ProjectApplicationVersion\">\n    <option name=\"ide\" value=\"CLion\" />\n    <option name=\"majorVersion\" value=\"2022\" />\n    <option name=\"minorVersion\" value=\"3\" />\n  </component>\n  <component name=\"ProjectId\" id=\"2Rxpmftku9zAAeWgEzNys6bjB8Y\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\"><![CDATA[{\n  \"keyToString\": {\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\n    \"RunOnceActivity.cidr.known.project.marker\": \"true\",\n    \"WebServerToolWindowFactoryState\": \"false\",\n    \"cf.first.check.clang-format\": \"false\",\n    \"cidr.known.project.marker\": \"true\",\n    \"last_opened_file_path\": \"/home/gaoyi/mmo-nfshm-server/Install\",\n    \"node.js.detected.package.eslint\": \"true\",\n    \"node.js.detected.package.tslint\": \"true\",\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\n    \"nodejs_package_manager_path\": \"npm\",\n    \"settings.editor.selected.configurable\": \"CMakeSettings\",\n    \"structure.view.defaults.are.configured\": \"true\",\n    \"vue.rearranger.settings.migration\": \"true\"\n  }\n}]]></component>\n  <component name=\"RecentsManager\">\n    <key name=\"CopyFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/Install\" />\n      <recent name=\"$PROJECT_DIR$/game/Fish/NFFishRobot\" />\n    </key>\n  </component>\n  <component name=\"RunManager\" selected=\"CMake 应用程序.NFPluginLoader\">\n    <configuration default=\"true\" type=\"CLionExternalRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\">\n      <method v=\"2\">\n        <option name=\"CLION.EXTERNAL.BUILD\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFDescStore\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFDescStore\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFDescStorePlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFDescStorePlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFFishProxyPlayerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFFishProxyPlayerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFFishRobotPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFFishRobotPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFGameServerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFGameServerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFKernelPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFKernelPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFLogicCommon\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFLogicCommon\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFLogicServerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFLogicServerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFLoginServerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFLoginServerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFLuaScriptPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFLuaScriptPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFMasterServerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFMasterServerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFNetPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFNetPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFPluginLoader\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFPluginLoader\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"ShmNFrame\" RUN_TARGET_NAME=\"NFPluginLoader\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFProxyAgentServerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFProxyAgentServerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFProxyClientPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFProxyClientPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFProxyServerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFProxyServerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFRouteAgentServerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFRouteAgentServerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFRouteServerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFRouteServerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFServerCommon\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFServerCommon\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFServerCommonPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFServerCommonPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFServerLogicMessage\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFServerLogicMessage\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFServerMessage\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFServerMessage\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFShmPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFShmPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFSnsServerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFSnsServerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFStoreServerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFStoreServerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFTestPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFTestPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFWebServerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFWebServerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"NFWorldServerPlugin\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"NFWorldServerPlugin\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"Sqlite3\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"Sqlite3\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"evpp\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"evpp\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"mysqlpp\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ShmNFrame\" TARGET_NAME=\"mysqlpp\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <list>\n      <item itemvalue=\"CMake 应用程序.NFFishRobotPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFDescStore\" />\n      <item itemvalue=\"CMake 应用程序.NFLogicCommon\" />\n      <item itemvalue=\"CMake 应用程序.NFServerLogicMessage\" />\n      <item itemvalue=\"CMake 应用程序.NFFishProxyPlayerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFKernelPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFNetPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFShmPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFLuaScriptPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFPluginLoader\" />\n      <item itemvalue=\"CMake 应用程序.NFGameServerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFLogicServerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFLoginServerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFMasterServerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFProxyAgentServerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFProxyClientPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFProxyServerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFRouteAgentServerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFRouteServerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFSnsServerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFStoreServerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFWebServerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFWorldServerPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFDescStorePlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFServerCommon\" />\n      <item itemvalue=\"CMake 应用程序.NFServerCommonPlugin\" />\n      <item itemvalue=\"CMake 应用程序.NFServerMessage\" />\n      <item itemvalue=\"CMake 应用程序.NFTestPlugin\" />\n      <item itemvalue=\"CMake 应用程序.evpp\" />\n      <item itemvalue=\"CMake 应用程序.mysqlpp\" />\n      <item itemvalue=\"CMake 应用程序.Sqlite3\" />\n    </list>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"应用程序级\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"默认任务\">\n      <changelist id=\"b1adcfc4-cb29-4816-844f-be9c46975368\" name=\"更改\" comment=\"\" />\n      <created>1688201746781</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1688201746781</updated>\n      <workItem from=\"1688201751342\" duration=\"972000\" />\n      <workItem from=\"1688204299548\" duration=\"45000\" />\n      <workItem from=\"1688345617726\" duration=\"6159000\" />\n    </task>\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/.idea/workspace.xml	(date 1688633828647)
@@ -26,6 +26,7 @@
       <config projectName="ShmNFrame" targetName="NFWorldServerPlugin" />
       <config projectName="ShmNFrame" targetName="NFNetPlugin" />
       <config projectName="ShmNFrame" targetName="NFProxyClientPlugin" />
+      <config projectName="ShmNFrame" targetName="NFFishLoginPlayerPlugin" />
       <config projectName="ShmNFrame" targetName="NFServerLogicMessage" />
       <config projectName="ShmNFrame" targetName="NFRouteServerPlugin" />
       <config projectName="ShmNFrame" targetName="NFServerCommon" />
@@ -50,45 +51,116 @@
     </configurations>
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="b1adcfc4-cb29-4816-844f-be9c46975368" name="更改" comment="">
-      <change afterPath="$PROJECT_DIR$/game/Fish/NFFishRobot/CMakeLists.txt" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFFishRobotPlugin.cpp" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFFishRobotPlugin.h" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFRobotModule.cpp" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFRobotModule.h" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFStatusAction.h" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFTestRobot.cpp" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFTestRobot.h" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/game/Fish/NFLogicComm/Message/proto_cs/CSLogin.proto" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/NFShmServer.iml" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/codeStyles/codeStyleConfig.xml" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/deployment.xml" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/dianwan.iml" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/inspectionProfiles/Project_Default.xml" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/mmo-nfshm-server.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/mmo-nfshm-server.iml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/_2022_11_6_3_27____.xml" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/在进行更新之前于_2022_10_8_上午11_31_取消提交了变更_[默认变更列表]/shelved.patch" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/在进行更新之前于_2022_11_15_下午10_19_取消提交了变更_[默认变更列表]/shelved.patch" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/在进行更新之前于_2022_11_6_下午3_27_取消提交了变更_[默认变更列表]/shelved.patch" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/在进行更新之前于_2022_11_6_下午3_27_取消提交了变更_[默认变更列表]1/shelved.patch" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/在进行更新之前于_2022_9_27_下午11_10_取消提交了变更_[默认变更列表]/shelved.patch" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/在进行更新之前于_22-10-31_上午8_42_取消提交了变更_[默认变更列表]/MMO" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/在进行更新之前于_22-11-14_上午8_25_取消提交了变更_[默认变更列表]/MMO" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/在进行更新之前于_22-11-14_上午8_25_取消提交了变更_[默认变更列表]1/MMO" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/在进行更新之前于_22-11-14_上午8_25_取消提交了变更_[默认变更列表]2/MMO" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/在进行更新之前于_22-11-7_上午8_32_取消提交了变更_[默认变更列表]/MMO" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/在进行更新之前于_22-12-6_上午10_15_取消提交了变更_[默认变更列表]/MMO" beforeDir="false" />
+    <list default="true" id="b1adcfc4-cb29-4816-844f-be9c46975368" name="更改" comment="fish login">
+      <change afterPath="$PROJECT_DIR$/Install/Config/Fish/Server/Common.lua" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Install/Config/Fish/Server/GameServer.lua" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Install/Config/Fish/Server/ProxyServer.lua" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Install/Config/Fish/Server/WorldServer.lua" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFLogicComm/Message/common/DBProto.proto" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFLogicCommon/NFLogicBindRpcService.h" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFLogicCommon/NFLogicError.cpp" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFLogicCommon/NFLogicError.h" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFLogicCommon/NFLogicShmTypeDefines.h" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFLogicCommon/NFLoginDefine.h" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFLoginServer/CMakeLists.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/CMakeLists.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.cpp" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.h" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginModule.cpp" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginModule.h" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFFishLoginPlayerPlugin.cpp" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFFishLoginPlayerPlugin.h" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Install/Config/Fish/Sql/CommonLogic.proto.ds" beforeDir="false" afterPath="$PROJECT_DIR$/Install/Config/Fish/Sql/CommonLogic.proto.ds" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/game/Fish/CMakeLists.txt" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/CMakeLists.txt" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/game/Fish/NFLogicComm/Message/common/ComDefine.proto" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFLogicComm/Message/common/ComDefine.proto" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFServerLogicMessage/ComDefine.pb.cc" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFServerLogicMessage/ComDefine.pb.cc" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFServerLogicMessage/ComDefine.pb.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFServerLogicMessage/ComDefine.pb.h" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/CMakeLists.txt" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/CMakeLists.txt" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Install/FishBusPlugin/Plugin.lua" beforeDir="false" afterPath="$PROJECT_DIR$/Install/FishBusPlugin/Plugin.lua" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Install/FishBusPlugin/ProxyServer.lua" beforeDir="false" afterPath="$PROJECT_DIR$/Install/FishBusPlugin/ProxyServer.lua" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Install/FishBusPlugin/StoreServer.lua" beforeDir="false" afterPath="$PROJECT_DIR$/Install/FishBusPlugin/StoreServer.lua" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFRobotModule.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFRobotModule.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFTestRobot.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFTestRobot.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFTestRobot.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFFishRobot/NFTestRobot.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/Fish/NFServerLogic/CMakeLists.txt" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/CMakeLists.txt" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.h" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerPlugin.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFFishProxyPlayerPlugin.cpp" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerPlugin.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFFishProxyPlayerPlugin.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFAttr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFAttr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFAttrMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFAttrMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFFuncUnLockDescStoreEx.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFFuncUnLockDescStoreEx.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFGrowDescStoreEx.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFGrowDescStoreEx.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFItemDescStoreEx.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFItemDescStoreEx.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFMissionDescStoreEx.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFMissionDescStoreEx.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFRoleDescStoreEx.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFLogicComm/DescStoreEx/NFRoleDescStoreEx.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestObj.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestObj.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFBattlePlayer.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFBattlePlayer.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreature.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreature.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureVisionData.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureVisionData.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMap.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMap.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMapMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMapMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFNavMeshInfo.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFNavMeshInfo.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/NFGameConfig.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/NFGameConfig.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFBattlePart.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFBattlePart.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFMovePart.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFMovePart.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFPath.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFPath.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFGrid.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFGrid.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFScene.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFScene.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFSceneMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFSceneMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Base/NFTransPlayerBase.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Base/NFTransPlayerBase.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Login/NFLoginModule.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Login/NFLoginModule.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Item/NFItemMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Item/NFItemMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFMissionPart.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFMissionPart.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFPart.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFPart.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFTitlePart.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFTitlePart.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Package/NFBagPage.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Package/NFBagPage.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayer.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayer.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerBase.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerBase.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransCreateRole.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransCreateRole.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRole.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRole.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRoleList.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRoleList.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransSaveRoleDetail.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransSaveRoleDetail.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransTransScene.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransTransScene.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFBindPhoneTrans.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFBindPhoneTrans.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFGetAccountTrans.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFGetAccountTrans.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFPhoneAutoCodeMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFPhoneAutoCodeMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFRegisterAccountTrans.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFRegisterAccountTrans.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFCacheMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFCacheMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleDetail.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleDetail.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleSimple.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleSimple.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheData.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheData.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheDataInfo.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheDataInfo.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/NFSnsServerPlayerPlugin.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/NFSnsServerPlayerPlugin.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Part/NFSnsPart.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Part/NFSnsPart.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPart.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPart.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPlayer.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPlayer.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationTeam.hpp" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationTeam.hpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFQueryRole.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFQueryRole.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransCacheBase.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransCacheBase.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleDetail.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleDetail.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleSimple.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleSimple.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransRoleLogin.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransRoleLogin.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldCreateRole.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldCreateRole.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldEnterGame.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldEnterGame.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldGetRoleList.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldGetRoleList.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldTransScene.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldTransScene.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldConfig.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldConfig.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayer.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayer.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayerMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayerMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSceneMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSceneMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSession.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSession.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSessionMgr.h" beforeDir="false" afterPath="$PROJECT_DIR$/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSessionMgr.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/NFComm/NFCore/NFSingleton.hpp" beforeDir="false" afterPath="$PROJECT_DIR$/src/NFComm/NFCore/NFSingleton.hpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/NFComm/NFPluginModule/NFServerDefine.h" beforeDir="false" afterPath="$PROJECT_DIR$/src/NFComm/NFPluginModule/NFServerDefine.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/NFComm/NFShmCore/NFShmObj.h" beforeDir="false" afterPath="$PROJECT_DIR$/src/NFComm/NFShmCore/NFShmObj.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/NFComm/NFShmStl/NFShmString.h" beforeDir="false" afterPath="$PROJECT_DIR$/src/NFComm/NFShmStl/NFShmString.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/NFCommPlugin/NFKernelPlugin/NFCMessageModule.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/src/NFCommPlugin/NFKernelPlugin/NFCMessageModule.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/NFCommPlugin/NFKernelPlugin/NFCMysqlDriver.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/src/NFCommPlugin/NFKernelPlugin/NFCMysqlDriver.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/NFCommPlugin/NFNetPlugin/Evpp/NFEvppNetMessage.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/src/NFCommPlugin/NFNetPlugin/Evpp/NFEvppNetMessage.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/NFServer/NFMasterServer/NFMasterServerPlugin/NFMasterServerModule.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/src/NFServer/NFMasterServer/NFMasterServerPlugin/NFMasterServerModule.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/NFServerComm/NFServerCommon/NFIServerMessageModule.h" beforeDir="false" afterPath="$PROJECT_DIR$/src/NFServerComm/NFServerCommon/NFIServerMessageModule.h" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -123,7 +195,7 @@
     "WebServerToolWindowFactoryState": "false",
     "cf.first.check.clang-format": "false",
     "cidr.known.project.marker": "true",
-    "last_opened_file_path": "/home/gaoyi/mmo-nfshm-server/Install",
+    "last_opened_file_path": "/home/gaoyi/mmo-nfshm-server/game/Fish/NFLogicComm/NFLogicCommon",
     "node.js.detected.package.eslint": "true",
     "node.js.detected.package.tslint": "true",
     "node.js.selected.package.eslint": "(autodetect)",
@@ -136,6 +208,9 @@
 }]]></component>
   <component name="RecentsManager">
     <key name="CopyFile.RECENT_KEYS">
+      <recent name="$PROJECT_DIR$/game/Fish/NFLogicComm/NFLogicCommon" />
+      <recent name="$PROJECT_DIR$/game/Fish/NFServerLogic" />
+      <recent name="$PROJECT_DIR$/Install/Config/Fish" />
       <recent name="$PROJECT_DIR$/Install" />
       <recent name="$PROJECT_DIR$/game/Fish/NFFishRobot" />
     </key>
@@ -152,6 +227,11 @@
       </method>
     </configuration>
     <configuration name="NFDescStorePlugin" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" USE_EXTERNAL_CONSOLE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="ShmNFrame" TARGET_NAME="NFDescStorePlugin" CONFIG_NAME="Debug">
+      <method v="2">
+        <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="NFFishLoginPlayerPlugin" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" USE_EXTERNAL_CONSOLE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="ShmNFrame" TARGET_NAME="NFFishLoginPlayerPlugin" CONFIG_NAME="Debug">
       <method v="2">
         <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
       </method>
@@ -206,7 +286,7 @@
         <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
       </method>
     </configuration>
-    <configuration name="NFPluginLoader" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" USE_EXTERNAL_CONSOLE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="ShmNFrame" TARGET_NAME="NFPluginLoader" CONFIG_NAME="Debug" RUN_TARGET_PROJECT_NAME="ShmNFrame" RUN_TARGET_NAME="NFPluginLoader">
+    <configuration name="NFPluginLoader" type="CMakeRunConfiguration" factoryName="Application" PROGRAM_PARAMS="--Server=AllServer --ID=1.13.1.1 --Config=../../Config/Fish --Plugin=../../FishBusPlugin --restart" REDIRECT_INPUT="false" ELEVATE="false" USE_EXTERNAL_CONSOLE="false" WORKING_DIR="file://$PROJECT_DIR$/Install/Bin/Dynamic_Debug" PASS_PARENT_ENVS_2="true" PROJECT_NAME="ShmNFrame" TARGET_NAME="NFPluginLoader" CONFIG_NAME="Debug" RUN_TARGET_PROJECT_NAME="ShmNFrame" RUN_TARGET_NAME="NFPluginLoader">
       <method v="2">
         <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
       </method>
@@ -306,6 +386,7 @@
       <item itemvalue="CMake 应用程序.NFDescStore" />
       <item itemvalue="CMake 应用程序.NFLogicCommon" />
       <item itemvalue="CMake 应用程序.NFServerLogicMessage" />
+      <item itemvalue="CMake 应用程序.NFFishLoginPlayerPlugin" />
       <item itemvalue="CMake 应用程序.NFFishProxyPlayerPlugin" />
       <item itemvalue="CMake 应用程序.NFKernelPlugin" />
       <item itemvalue="CMake 应用程序.NFNetPlugin" />
@@ -345,11 +426,67 @@
       <updated>1688201746781</updated>
       <workItem from="1688201751342" duration="972000" />
       <workItem from="1688204299548" duration="45000" />
-      <workItem from="1688345617726" duration="6159000" />
+      <workItem from="1688345617726" duration="8668000" />
+      <workItem from="1688431623429" duration="2561000" />
+      <workItem from="1688534824699" duration="5255000" />
+      <workItem from="1688605064474" duration="24720000" />
     </task>
+    <task id="LOCAL-00001" summary="fish login">
+      <created>1688353683964</created>
+      <option name="number" value="00001" />
+      <option name="presentableId" value="LOCAL-00001" />
+      <option name="project" value="LOCAL" />
+      <updated>1688353683964</updated>
+    </task>
+    <option name="localTasksCounter" value="2" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
     <option name="version" value="3" />
   </component>
+  <component name="VcsManagerConfiguration">
+    <MESSAGE value="fish login" />
+    <option name="LAST_COMMIT_MESSAGE" value="fish login" />
+  </component>
+  <component name="XDebuggerManager">
+    <breakpoint-manager>
+      <breakpoints>
+        <line-breakpoint enabled="true" type="com.jetbrains.cidr.execution.debugger.OCBreakpointType">
+          <url>file://$PROJECT_DIR$/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginModule.cpp</url>
+          <line>55</line>
+          <option name="timeStamp" value="33" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="com.jetbrains.cidr.execution.debugger.OCBreakpointType">
+          <url>file://$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp</url>
+          <line>521</line>
+          <option name="timeStamp" value="35" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="com.jetbrains.cidr.execution.debugger.OCBreakpointType">
+          <url>file://$PROJECT_DIR$/src/NFServerComm/NFServerCommon/NFWorkServerModule.cpp</url>
+          <line>258</line>
+          <option name="timeStamp" value="36" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="com.jetbrains.cidr.execution.debugger.OCBreakpointType">
+          <url>file://$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp</url>
+          <line>536</line>
+          <option name="timeStamp" value="40" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="com.jetbrains.cidr.execution.debugger.OCBreakpointType">
+          <url>file://$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp</url>
+          <line>537</line>
+          <option name="timeStamp" value="51" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="com.jetbrains.cidr.execution.debugger.OCBreakpointType">
+          <url>file://$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp</url>
+          <line>543</line>
+          <option name="timeStamp" value="55" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="com.jetbrains.cidr.execution.debugger.OCBreakpointType">
+          <url>file://$PROJECT_DIR$/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.cpp</url>
+          <line>550</line>
+          <option name="timeStamp" value="56" />
+        </line-breakpoint>
+      </breakpoints>
+    </breakpoint-manager>
+  </component>
 </project>
\ No newline at end of file
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/NFGameConfig.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFGameConfig.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-14\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFGameConfig\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"common_logic_s.h\"\n\nclass NFGameConfig : public NFShmObj\n{\npublic:\n    NFGameConfig();\n\n    virtual ~NFGameConfig();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    /**\n     * @brief 加载Server/WorldServer.lua中的WolrdServer配置，\n     *        通过common_logic.proto中的protobuf结构WorldServerConfig来解析，注意field要与lua的自动大小写完全一致\n     *        lua:                                   proto:\n     *        WorldServer = {                        message WorldExternalConfig {\n                    TokenTimeCheck = True;   ====>      optional bool TokenTimeCheck = 1[(yd_fieldoptions.field_use_stl)=true];\n              };                                    };\n     *\n     * @param luaMgr\n     * @return\n     */\n    int LoadConfig(NFILuaLoader luaMgr);\n\n    /**\n     * @brief 获取配置\n     * @return\n     */\n    const proto_ff_s::GameExternalConfig_s *GetConfig() const;\n\nprivate:\n    proto_ff_s::GameExternalConfig_s m_config;\nDECLARE_IDCREATE(NFGameConfig)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/NFGameConfig.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/NFGameConfig.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/NFGameConfig.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/NFGameConfig.h	(date 1688616543291)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "common_logic_s.h"
 
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMapMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFMapMgr.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-10\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFMapMgr\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLogicCommon/NFSceneDefine.h\"\n#include \"NFComm/NFShmCore/NFShmString.h\"\n#include \"NFNavMeshInfo.h\"\n#include \"NFComm/NFShmCore/NFShmOldHashMap.h\"\n\n#define GAME_SERVER_MAX_BATTLE_MAP_SIZE 100\n\nclass NFMap;\nclass NFMapMgr : public NFShmObj\n{\npublic:\n    NFMapMgr();\n\n    virtual ~NFMapMgr();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    /**\n     * @brief\n     * @param navName\n     * @return\n     */\n    NFNavMeshInfo* AddNavMeshInfo(const std::string& navName);\n\n    /**\n     * @brief\n     * @param navName\n     * @return\n     */\n    NFNavMeshInfo* GetNavMeshInfo(const std::string& navName);\n\npublic:\n    /**\n     * @brief 在指定坐标点周围随机一个坐标\n     * @param mapId\n     * @param pos\n     * @param nRadius\n     * @return\n     */\n    NFPoint3<float> RandPosAroundPos(uint64_t mapId, const NFPoint3<float>& pos, uint32_t nRadius);\npublic:\n    /**\n     * @brief\n     * @return\n     */\n    int LoadConfig();\n\npublic:\n    /**\n     * @brief\n     * @param mapId\n     * @return\n     */\n    NFMap *GetMap(uint64_t mapId);\n\n    /**\n     * @brief\n     * @param mapId\n     * @return\n     */\n    NFMap *CreateMap(uint64_t mapId);\n\n    /**\n     * @brief\n     * @param pMap\n     * @return\n     */\n    int DeleteMap(NFMap *pMap);\n\n    /**\n     * @brief\n     * @return\n     */\n    int ClearAllMap();\nprivate:\n    NFShmOldHashMap<NFShmString<MAP_NAME_MAX_LENGHT>, NFNavMeshInfo, GAME_SERVER_MAX_BATTLE_MAP_SIZE> m_mapNavMesh;\nDECLARE_IDCREATE(NFMapMgr)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMapMgr.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMapMgr.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMapMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMapMgr.h	(date 1688616543320)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFLogicCommon/NFSceneDefine.h"
 #include "NFComm/NFShmCore/NFShmString.h"
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMap.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFMap.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-10\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFMap\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n\n#include \"Detour/Include/DetourNavMesh.h\"\n#include \"Detour/Include/DetourNavMeshQuery.h\"\n\n#include \"NFLogicCommon/NFSceneDefine.h\"\n#include \"NFComm/NFShmCore/NFShmString.h\"\n#include \"NFLogicCommon/NFRoleDefine.h\"\n#include \"ComDefine.pb.h\"\n#include \"map_s.h\"\n\nclass NFMap : public NFShmObj\n{\npublic:\n    NFMap();\n\n    virtual ~NFMap();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    uint64_t GetMapId() const;\n\n    uint32_t GetWidth() const;\n\n    uint32_t GetHeight() const;\n\n    bool IsDynamic() const;\n\npublic:\n    /**\n     * @brief\n     * @return\n     */\n    const proto_ff_s::E_MapMap_s *GetMapCfg();\n\n    /**\n     * @brief\n     * @param srcPos\n     * @param dstPos\n     * @param path\n     * @param flgs\n     * @return\n     */\n    int GetNavPath(const float *srcPos, const float *dstPos, VEC_POINT3 &path, VEC_FLAGS &flgs);\n\n    /**\n     * @brief\n     * @param srcPos\n     * @param dstPos\n     * @param IntPath\n     * @return\n     */\n    int GetIntNavPath(const float *srcPos, const float *dstPos, VEC_PATH &IntPath);\n\n    /**\n     * @brief\n     * @param posX\n     * @param posY\n     * @param posH\n     * @param extents\n     * @param nearPoint\n     * @return\n     */\n    dtPolyRef GetNearestPoly(float posX, float posY, float posH, float *extents, float *nearPoint);\n\n    /**\n     * @brief\n     * @param posX\n     * @param posY\n     * @param posH\n     * @param rsPosX\n     * @param rsPosY\n     * @param rsPosH\n     * @param rsPolyRef\n     * @return\n     */\n    int FindNearestPos(float posX, float posY, float posH, float *rsPosX, float *rsPosY, float *rsPosH, dtPolyRef *rsPolyRef);\n\n    /**\n     * @brief\n     * @param startPos\n     * @param dir\n     * @param length\n     * @param hitParam\n     * @return\n     */\n    int Raycast(float *startPos, float dir, float length, HitWallParam *hitParam);\n\n    /**\n     * @brief\n     * @param hitX\n     * @param hitY\n     * @param hitH\n     * @param dir\n     * @param rsTangentDir\n     * @return\n     */\n    int GetHitWallTangentAngle(float hitX, float hitY, float hitH, float dir, float *rsTangentDir);\n\n    /**\n     * @brief\n     * @param polyRef\n     * @param posX\n     * @param posY\n     * @param height\n     * @return\n     */\n    int GetPolyHeight(dtPolyRef polyRef, float posX, float posY, float *height);\n\n    /**\n     * @brief\n     * @param polyRef\n     * @param flag\n     * @return\n     */\n    int CheckPolyFlag(dtPolyRef polyRef, proto_ff::SamplePolyFlags flag);\n\n    /**\n     * @brief\n     * @return\n     */\n    dtNavMesh *GetNavMesh() { return m_navMesh; }\n\n    /**\n     * @brief\n     * @param ref\n     * @param flags\n     */\n    void GetPolyFlags(dtPolyRef ref, uint_least16_t *flags);\n\n    /**\n     * @brief\n     * @param nPos\n     * @return\n     */\n    bool IsInSafeArea(NFPoint3<float> &nPos);\n\npublic:\n    /**\n     * @brief\n     * @param mapId\n     * @return\n     */\n    int Init(uint64_t mapId);\n\n    /**\n     * @brief\n     * @return\n     */\n    int Init();\n\nprivate:\n    /**\n     * @brief\n     * @param name\n     * @return\n     */\n    int LoadNavMesh(const std::string &name);\n\n    /**\n     * @brief 获取忽略高度值的最近poly，返回值的nearestPt带有高度\n     * @param posX\n     * @param posY\n     * @param extents\n     * @param nearestPt\n     * @return\n     */\n    dtPolyRef GetNearestPoly2D(float posX, float posY, float *extents, float *nearestPt);\n\nprotected:\n\n\nprotected:\n    uint64_t m_mapId;\n    uint32_t m_width;\n    uint32_t m_height;\n    bool m_isDynamic;\nprotected:\n    dtNavMesh *m_navMesh;\n    dtNavMeshQuery *m_navMeshQuery;\n    dtPolyRef m_pathPolys[proto_ff::MAX_NAV_POLYS];\n    float m_straightPathPoints[proto_ff::MAX_NAV_POINT_VALUE];\n    NFShmString<MAP_NAME_MAX_LENGHT> m_name;\n    dtQueryFilter *m_normalFilter;\nDECLARE_IDCREATE(NFMap)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMap.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMap.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMap.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFMap.h	(date 1688616543381)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 
 #include "Detour/Include/DetourNavMesh.h"
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFNavMeshInfo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFNavMeshInfo.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-10\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFNavMeshInfo\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"Detour/Include/DetourNavMesh.h\"\n#include \"Detour/Include/DetourNavMeshQuery.h\"\n\nclass NFNavMeshInfo\n{\npublic:\n    NFNavMeshInfo();\n\n    virtual ~NFNavMeshInfo();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    dtNavMesh* pdtNavMesh;\n    dtNavMeshQuery* pdtNavMeshQuery;\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFNavMeshInfo.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFNavMeshInfo.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFNavMeshInfo.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Map/NFNavMeshInfo.h	(date 1688616543253)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "Detour/Include/DetourNavMesh.h"
 #include "Detour/Include/DetourNavMeshQuery.h"
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFBattlePart.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFBattlePart.h\n//    @Author           :    gaoyi\n//    @Date             :    23-2-25\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFBattlePart\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFShmPtr.h\"\n#include \"DBProto2.pb.h\"\n#include \"NFComm/NFShmCore/NFSeqOP.h\"\n\nclass NFCreature;\n\nclass NFBattlePart : public NFShmObj, public NFSeqOP\n{\npublic:\n    NFBattlePart();\n\n    virtual ~NFBattlePart();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    int InitBase(NFCreature *pMaster, uint32_t partType);\npublic:\n    virtual int Init(const proto_ff::RoleEnterSceneData &data);\n\n    virtual int UnInit();\n\npublic:\n    virtual uint32_t GetCurRoleDetailSeq() const;\npublic:\n    /**\n     * @brief 处理客户端消息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleClientMessage(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 处理来自服务器的信息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleServerMessage(uint32_t msgId, NFDataPackage &packet);\npublic:\n    static int RegisterClientPartMsg(NFIPluginManager *pPluginManager, uint32_t nMsgID, uint32_t partType);\n\n    static int RegisterServerPartMsg(NFIPluginManager *pPluginManager, uint32_t nMsgID, uint32_t partType);\npublic:\n    virtual int BroadCast(uint32_t nMsgId, const google::protobuf::Message &xData, bool IncludeMyself = false);\n\n    virtual int SendMsgToClient(uint32_t nMsgId, const google::protobuf::Message &xData);\n\n    virtual int SendMsgToSnsServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n\n    virtual int SendMsgToWorldServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n\n    virtual int SendMsgToLogicServer(uint32_t nMsgId, const google::protobuf::Message &xData);\npublic:\n    /**\n     * @brief 登陆入口\n     * @return\n     */\n    virtual int OnLogin() { return 0; }\n\n    /**\n     * @brief 登出入口\n     * @return\n     */\n    virtual int OnLogout() { return 0; }\n\n    /**\n     * @brief 掉线入口\n     * @return\n     */\n    virtual int OnDisconnect() { return 0; }\n\n    /**\n     * @brief 重连入口\n     * @return\n     */\n    virtual int OnReconnect() { return 0; }\n\npublic:\n    ////////////////////////////////// 每日每周刷新接口 ///////////////////////////////////\n    /**\n     * @brief 每日刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int DailyUpdate(uint64_t unixSec) { return 0; }\n\n    /**\n     * @brief 每周刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int WeekUpdate(uint64_t unixSec) { return 0; }\n    ////////////////////////////////// 每日零点 每周一零点 刷新接口 ///////////////////////////////////\n    /**\n     * @brief 每日零点 刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int DailyZeroUpdate(uint64_t unixSec) { return 0; }\n\n    /**\n     * @brief 每日零点 刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int WeekZeroUpdate(uint64_t unixSec) { return 0; }\n\npublic:\n    /**\n     * @brief update\n     * @param tick\n     */\n    virtual int Update(uint64_t tick) { return 0; }\n\n\npublic:\n    //部件类型\n    uint32_t PartType() { return m_partType; }\n\npublic:\n    NFCreature* GetMaster();\nprotected:\n    int m_masterCid;\n    uint32_t m_partType;\n\nprivate:\nDECLARE_IDCREATE(NFBattlePart)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFBattlePart.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFBattlePart.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFBattlePart.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFBattlePart.h	(date 1688616542961)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFShmPtr.h"
 #include "DBProto2.pb.h"
Index: game/Fish/NFLogicComm/NFLogicCommon/NFLoginDefine.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFLogicComm/NFLogicCommon/NFLoginDefine.h b/game/Fish/NFLogicComm/NFLogicCommon/NFLoginDefine.h
new file mode 100644
--- /dev/null	(date 1688631263021)
+++ b/game/Fish/NFLogicComm/NFLogicCommon/NFLoginDefine.h	(date 1688631263021)
@@ -0,0 +1,22 @@
+// -------------------------------------------------------------------------
+//    @FileName         :    NFLoginDefine.h
+//    @Author           :    gaoyi
+//    @Date             :    23-7-6
+//    @Email			:    445267987@qq.com
+//    @Module           :    NFLoginDefine
+//
+// -------------------------------------------------------------------------
+
+#pragma once
+
+#include "NFLogicCommon.h"
+
+//一个登录服最大同时登录账号数
+#define ONE_LOGIN_SERVER_MAX_LOGIN_ACCOUNT 10000
+#define LOGIN_TOKEN "ShmNFrame"
+
+/**
+ * @brief 账号存在最大时间
+ */
+#define MAX_ACCOUNT_EXIST_TIME 300
+
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFPath.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFPath.h\n//    @Author           :    gaoyi\n//    @Date             :    23-3-1\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFPath\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLogicCommon/NFRoleDefine.h\"\n#include \"NFComm/NFShmStl/NFShmVector.h\"\n\n#define MAX_PATH_POINT_COUNT 50\n\nclass NFPath\n{\npublic:\n    NFPath();\n\n    virtual ~NFPath();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    bool Init(VEC_POINT3 &path, NFPoint3<float> &curPos);\n\n    bool GetLeftPath(VEC_POINT3 &leftPath);\n\n    void UnInit();\n\n    void Clear();\n\n    bool MapPathDistanceToPoint(float setpDistance, NFPoint3<float> &retPos);\n\npublic:\n    NFShmVector<NFPoint3<float>, MAX_PATH_POINT_COUNT> m_path;                        //路径\n    uint32_t m_nextIndex;                   //下一步的路径点下标\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFPath.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFPath.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFPath.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFPath.h	(date 1688616543397)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFLogicCommon/NFRoleDefine.h"
 #include "NFComm/NFShmStl/NFShmVector.h"
Index: game/MMO/NFLogicComm/DescStoreEx/NFMissionDescStoreEx.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFMissionDescStoreEx.h\n//    @Author           :    gaoyi\n//    @Date             :    23-2-16\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFMissionDescStoreEx\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFServerComm/NFDescStorePlugin/NFIDescStore.h\"\n#include \"NFLogicCommon/NFDescStoreTypeDefines.h\"\n\n#include \"NFComm/NFShmStl/NFShmHashMap.h\"\n#include \"NFComm/NFShmStl/NFShmHashSet.h\"\n\n#include \"NFLogicCommon/NFMissionDefine.h\"\n#include \"DescStore/TaskdynamicTaskdynamicDesc.h\"\n#include \"DescStore/TaskrewardTaskrewardDesc.h\"\n#include \"DescStore/TaskdynamicTaskcomcondDesc.h\"\n#include \"DescStore/TaskTaskDesc.h\"\n#include \"DescStore/TaskdynamicTasktextDesc.h\"\n\n//通过移位组合动态任务text表条件 text 表中 目标场景(最多11位十进制数字，对应的二进制位是 37bit)+任务类型(6bit)+完成条件(20bit)\n#define DY_MISSION_TEXT_KEY(type, cond) ((type << 20) | cond )\n#define DY_MISSION_TEXT_TYPE(key) (key >> 20)\n#define DY_MISSION_TEXT_COND(key) ( key & 0xFFFFF)\n\n//动态任务奖励组合key\n#define DY_MISSION_REWARD_KEY(type, lv) ((lv << 8) | type)\n\n#define NF_MISSION_TYPE_MAX_COUNT 20\n#define NF_MISSION_TYPE_MAX_MISSION_COUNT (MAX_TASK_TASK_NUM+MAX_TASKDYNAMIC_TASKDYNAMIC_NUM)\n\nclass NFMissionDescStoreEx : public NFIDescStore\n{\npublic:\n    typedef NFShmHashMap<uint64_t, DyMissionInfo, MAX_TASKDYNAMIC_TASKDYNAMIC_NUM> DyMissionInfoMap;\n    typedef NFShmHashMap<uint64_t, DyConditionInfo, MAX_TASKDYNAMIC_TASKCOMCOND_NUM> DyCondtionInfoMap;\n    typedef NFShmHashMap<uint64_t, MissionInfo, MAX_TASK_TASK_NUM> MissionInfoMap;\n    //动态任务奖励 key是玩家等级(32 - 9)+任务类型(8 - 1) 组合\n    typedef NFShmHashMap<uint32_t, TASK_REWARD, MAX_TASKREWARD_TASKREWARD_NUM> DyTaskRewardMap;\n    typedef NFShmHashMap<int32_t, NFShmHashSet<uint64_t, MAX_TASK_TASK_NUM>, NF_MISSION_TYPE_MAX_COUNT> FirstMissionMap;\n    typedef NFShmHashMap<int32_t, NFShmHashSet<uint64_t, MAX_TASKDYNAMIC_TASKDYNAMIC_NUM>, NF_MISSION_TYPE_MAX_COUNT> DyMissionTypeMap;\npublic:\n    NFMissionDescStoreEx();\n\n    virtual ~NFMissionDescStoreEx();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    bool ProcessDyMission();//处理动态任务配置\n    bool ProcessDyCondition();//处理动态条件\n    bool ProcessDyText();    //处理动态任务前端显示\n    bool ProcessReward();    //处理动态任务奖励\n    bool ProcessTask();\n\npublic:\n    const DyMissionInfo *GetDyMissionCfgInfo(uint64_t missionId);\n\n    const DyConditionInfo *GetDyConditionCfgInfo(uint64_t condId);\n\n    MissionInfo *GetMissionCfgInfo(uint64_t missionId);\n\npublic:\n    bool ParseMissionCond(MissionInfo *pMissionInfo, const std::string &strParam);              //解析任务接取条件\n    bool ParseTaskExecute(MissionInfo *pMissionInfo, const std::string &sExecute);      //解析任务完成条件\n    bool ParseTaskReceAdd(MissionInfo *pMissionInfo, const std::string &sReceAdd);\n\n    bool ParseTaskSubAward(MissionInfo *pMissionInfo, int64_t sSubAward);\n\npublic:\n    //解析接取条件(公用接口)\n    bool ParseAcceptCond(AcceptInfo &accept, const std::string &strAcceptParam, SParaseAcceptParam &param);\n    //解析完成条件(公用接口)\n    bool ParseFinishCond(InterExecute &conds, const std::string &strFinish, SParseFinishParam &param);\n    //校验完成条件(公用接口)\n    bool CheckFinishCond(InterItemPair &item, SParseFinishParam &param);\n\n    bool CheckRewardParam(uint64_t missionId, uint32_t type, uint64_t id);\n\npublic:\n    uint64_t ComposeTextKey(int32_t missionType, int32_t condType); //组装text表的key\n    uint32_t ComposeDyRewardKey(int32_t taskType, int32_t level);//组装动态任务奖励key\npublic:\n    //获取每条线的第一个任务\n    const FirstMissionMap &GetFirstMission() { return _missionFirstMap; }\n\n    const NFShmHashSet<uint64_t, MAX_TASKDYNAMIC_TASKDYNAMIC_NUM> *GetDyMissionLstByType(int32_t missionType) const;\n\n    const NFShmHashSet<uint64_t, MAX_TASK_TASK_NUM> *GetPreAcceptMission(uint64_t missionId);\n\n    uint64_t GetDyTextId(uint64_t key);\n\n    uint64_t GetDyTextId(int32_t missionType, uint32_t condType);\n\n    //获取动态任务奖励\n    const TASK_REWARD *GetDyMissionReward(int32_t missionType, int32_t level);\nprivate:\n    DyMissionTypeMap m_dymissionTypeMap;                    //动态任务类型map\n    DyMissionInfoMap m_dymissionInfoMap;                    //动态任务配置\n    DyCondtionInfoMap m_dycondtionInfoMap;                    //动态条件配置\n    MissionInfoMap m_missionInfoMap;                    //任务配置列表\n    DyTaskRewardMap m_mapDyReward;                        //动态任务奖励\n    FirstMissionMap _missionFirstMap;                    //任务类型对应的第一个任务列表\n    NFShmHashMap<int32_t, NFShmHashSet<uint64_t, 100>, 1000> m_mapLevMission;                    //等级任务\n\n    NFShmHashMap<uint64_t, NFShmHashSet<uint64_t, MAX_TASK_TASK_NUM>, MAX_TASK_TASK_NUM> m_mapPreOrAcceptMap;                //任务配置中的前置任务或条件\n    NFShmHashMap<uint64_t, NFShmHashSet<uint64_t, MAX_TASK_TASK_NUM>, MAX_TASK_TASK_NUM> m_mapPreAndAcceptMap;                //任务配置中的前置任务与条件\n    NFShmHashMap<uint64_t, NFShmHashSet<uint64_t, MAX_TASK_TASK_NUM>, MAX_TASK_TASK_NUM> m_mapPreAcceptMap;                    //接取条件中前置任务完成可接取的任务\n\n    NFShmHashMap<uint64_t, NFShmHashSet<uint64_t, 100>, MAX_TASKDYNAMIC_TASKTEXT_NUM> _dymissionTextMap;                    //动态任务前端显示配置\nprivate:\nDECLARE_IDCREATE(NFMissionDescStoreEx)\n\nIMPL_RES_SIMPLE_DESC(NFMissionDescStoreEx);\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFLogicComm/DescStoreEx/NFMissionDescStoreEx.h b/game/MMO/NFLogicComm/DescStoreEx/NFMissionDescStoreEx.h
--- a/game/MMO/NFLogicComm/DescStoreEx/NFMissionDescStoreEx.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFLogicComm/DescStoreEx/NFMissionDescStoreEx.h	(date 1688616542980)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFServerComm/NFDescStorePlugin/NFIDescStore.h"
 #include "NFLogicCommon/NFDescStoreTypeDefines.h"
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFMovePart.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFMovePart.h\n//    @Author           :    gaoyi\n//    @Date             :    23-3-1\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFMovePart\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFBattlePart.h\"\n#include \"NFLogicCommon/NFPoint3.h\"\n#include \"NFPath.h\"\n#include \"Move.pb.h\"\n\nclass NFScene;\n\nclass NFMovePart : public NFBattlePart\n{\n    enum\n    {\n        INTERVAL_MOVE_TIME = 100,//模拟行走定时器间隔\n\n        INTERVAL_CLIENT_MOVE_TIMEOUT = 3000, //客户端移动同步超时时间\n\n        INTERVAL_LOAD_MAP_TIMEOUT = 20000, //加载地图超时时间\n    };\npublic:\n    NFMovePart();\n\n    virtual ~NFMovePart();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    virtual int Init(const proto_ff::RoleEnterSceneData &data);\n\n    virtual int UnInit();\n\n    virtual int OnTimer(int timeId, int callcount);\n\npublic:\n    //移动定时器\n    int OnMoveTimer();\n\n    //通过路径移动 intertick: 间隔时间，单位：毫秒\n    int MoveByPath(int64_t intertick, bool stopFlag = false);\n\n    //模拟客户端移动(玩家移动) intertick: 间隔时间，单位：毫秒,  stopFlag:是否停止移动\n    int MoveBySimulate(int64_t intertick, bool stopFlag = false);\n\n    //计算朝向\n    NFPoint3<float> CalDir(const NFPoint3<float> &dstpos, const NFPoint3<float> &srcpos);\n\n    //根据计算单位朝向\n    NFPoint3<float> CalDotByDir(const NFPoint3<float> &dir);\n\n    //根据朝向点计算速度  dot:朝向点， fsec:间隔时间，单位：秒，  fspeed：速度，单位：m/s\n    NFPoint3<float> CalSpeedByDot(const NFPoint3<float> &dot, float fsec, float fspeed);\n\npublic:\n    //能否移动\n    int CanMove();\n\n    //移动到目标坐标，注意：这个接口只允许人物以外的生物调用，人物的移动是前端驱动的\n    int MoveTo(const NFPoint3<float> &dstPos);\n\n    //是否正在移动\n    int IsMoving() const;\n\n    //停止移动\n    int StopMove();\n\npublic:\n    /**\n     * @brief 处理客户端消息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleClientMessage(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 处理来自服务器的信息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleServerMessage(uint32_t msgId, NFDataPackage &packet);\n\npublic:\n    static int RegisterClientMessage(NFIPluginManager *pPluginManager);\n\n    static int RetisterServerMessage(NFIPluginManager *pPluginManager);\n\npublic:\n    int ClientMoveReq(uint32_t msgId, NFDataPackage &packet);\n\n    int ClientLoadMapFinshReq(uint32_t msgId, NFDataPackage &packet);\n\n    int ClientSeatReq(uint32_t msgId, NFDataPackage &packet);\n\npublic:\n    //设置客户端速度\n    void SetClientSpeed(const NFPoint3<float> &speed);\n\n    //广播移动\n    int BroadcastMove(uint64_t cid, const NFPoint3<float> &pos, const NFPoint3<float> &speed, const NFPoint3<float> &dir, bool selfFlag = false);\n\n    //传送(场景内传送、切场景传送,跨逻辑服传送)\n    int TransScene(uint64_t sceneId, const NFPoint3<float> &dstPos, uint64_t mapId, STransParam &transParam);\n\n    //瞬间移动，只限于当前地图之内 dstPos:目标坐标  type:瞬移类型  checkpos:是否需要校验坐标，如果外部可以保证坐标的有效性可以不用校验，外部不能保证坐标的有效性，必须要校验\n    int Teleporting(const NFPoint3<float> dstPos, int32_t type = (int32_t) proto_ff::MoveTeleportRsp_Type_common, bool checkpos = true);\n\n    //传送成功的处理\n    int OnTransSuccess(STransParam &transParam);\n\n    //同一个逻辑服之间的场景传送\n    int TransSceneInLogic(NFScene *pDstScene, NFPoint3<float> transPos, STransParam &transParam);\n\nprivate:\n    /**\n     * @brief 客户端最近一次发到服务器的坐标\n     */\n    NFPoint3<float> m_lastClientPos;\n\n    /**\n     * @brief 客户端最近一次发送移动消息的时间, 用于处理移动同步超时的情况， 单位：毫秒\n     */\n    uint64_t m_lastclientMoveTick;\n\n    /**\n     * @brief 客户端移动速度(矢量坐标，计算用的)\n     */\n    NFPoint3<float> m_clientSpeed;\n\n    /**\n     * @brief 客户端速度的单位向量\n     */\n    NFPoint3<float> m_clientUnitVector;\n\n    /**\n     * @brief 最近一次正确的坐标，用于出错时回退上上一次正确坐标的位置\n     */\n    NFPoint3<float> m_lastrightpos;\n\n    /**\n     * @brief 最近一次生物的朝向\n     */\n    NFPoint3<float> m_lastDir;\n\n    /**\n     * @brief 最近一次的朝向点，用来比较怪物两次行走中朝向是否有改变\n     */\n    NFPoint3<float> m_lastDirDot;\n\n    /**\n     * @brief 路径\n     */\n    NFPath m_curMovePath;\n\n\n    /**\n     * @brief 最近一次移动的时间点，模拟走用，单位：毫秒\n     */\n    uint64_t m_moveTick;\n\n    /**\n     * @brief 等待客户端加载地图完成的消息\n     */\n    uint64_t m_waitLoadMapId;\npublic:\n    int m_timerIdMove;\n    int m_timerIdLoadMapTimeout;\nDECLARE_IDCREATE(NFMovePart)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFMovePart.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFMovePart.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFMovePart.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Part/NFMovePart.h	(date 1688616543158)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFBattlePart.h"
 #include "NFLogicCommon/NFPoint3.h"
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFSceneMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFSceneMgr.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-14\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFSceneMgr\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include <set>\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmStl/NFShmHashMap.h\"\n#include \"NFLogicCommon/NFPoint2.h\"\n#include \"NFLogicCommon/NFPoint3.h\"\n#include \"ServerInternal2.pb.h\"\n\n#define GAME_SERVER_MAX_BATTLE_SCENE_SIZE 1000\n#define MAX_LAYER 5  //搜索最大层数\n\nclass NFScene;\nclass NFSceneMgr : public NFShmObj\n{\npublic:\n    typedef NFShmVector<NFPoint2<int32_t>, (1+(MAX_LAYER-1)*2)*(1+(MAX_LAYER-1)*2)> OneLayer;\n    typedef NFShmVector<OneLayer, MAX_LAYER+1> NineGridLayer;\npublic:\n    NFSceneMgr();\n\n    virtual ~NFSceneMgr();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    virtual int OnExecute(uint32_t serverType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message* pMessage) override;\npublic:\n    /**\n     * @brief\n     * @param mapIds\n     * @return\n     */\n    int InitScene(const std::set<uint64_t>& mapIds);\n\npublic:\n    /**\n     * @brief\n     * @param mapId\n     * @param sceneId\n     * @return\n     */\n    NFScene* CreateScene(uint64_t mapId, uint64_t sceneId);\n\n    /**\n     * @brief\n     * @param sceneId\n     * @return\n     */\n    NFScene* GetScene(uint64_t sceneId);\n\n    /**\n     * @brief\n     * @param pScene\n     * @return\n     */\n    int DeleteScene(NFScene* pScene);\npublic:\n    /**\n     * @brief 是否关闭\n     * @param sceneId\n     * @return\n     */\n    bool IsClosed(uint64_t sceneId);\n\n    //获取层数对应格子计算数组\n    const OneLayer* GetLayerPoint(uint32_t nlayer);\npublic:\n    int EnterScene(uint64_t roleId, uint64_t mapId, uint64_t sceneId, const NFPoint3<float>& pos);\n    int LeaveScene(uint64_t roleId, uint64_t mapId, uint64_t sceneId);\nprivate:\n    //场景销毁缓存表 sceneid - tick\n    NFShmHashMap<uint64_t, uint64_t, 1000> m_delCacheMap;\n    //每层映射搜索位置信息(最大5层)\n    NineGridLayer m_nineGridLayer;\nprivate:\nDECLARE_IDCREATE(NFSceneMgr)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFSceneMgr.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFSceneMgr.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFSceneMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFSceneMgr.h	(date 1688616543164)
@@ -14,7 +14,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmStl/NFShmHashMap.h"
 #include "NFLogicCommon/NFPoint2.h"
Index: src/NFComm/NFCore/NFSingleton.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFSingleton.h\n//    @Author           :    LvSheng.Huang\n//    @Date             :   2022-09-18\n//    @Module           :    NFSingleton\n//\n// -------------------------------------------------------------------------\n\n#ifndef NF_SINGLETON_H\n#define NF_SINGLETON_H\n\n#include <iostream>\n\ntemplate <class T>\nclass NFSingleton\n{\npublic:\n\n\tNFSingleton()\n\t{\n\t\t//assert( !m_instance );\n\n#if defined( _MSC_VER ) && _MSC_VER < 1200\n\t\tint offset = (int)(T*)1 - (int)(Singleton <T>*)(T*)1;\n\t\tm_pInstance = (T*)((int)this + offset);\n#else\n\t\tm_pInstance = static_cast<T*>(this);\n#endif\n\t}\n\n\tvirtual ~NFSingleton()\n\t{\n\t}\n\npublic:\n\n\tstatic T* GetSingletonPtr()\n\t{\n\t\tif (nullptr == m_pInstance)\n\t\t{\n\t\t\tm_pInstance = new T;\n\t\t}\n\n\t\treturn m_pInstance;\n\t}\n\n\tstatic T& GetSingletonRef()\n\t{\n\t\treturn *GetSingletonPtr();\n\t}\n\n\tstatic T* Instance()\n\t{\n\t\treturn GetSingletonPtr();\n\t}\n\n\tstatic T& InstanceRef()\n\t{\n\t\treturn GetSingletonRef();\n\t}\n\n\tstatic void ReleaseInstance()\n\t{\n\t\tif (m_pInstance)\n\t\t{\n\t\t\tdelete m_pInstance;\n\t\t\tm_pInstance = NULL;\n\t\t}\n\t}\n\n    static void SetSingletonPtr(T* pNewInstance)\n    {\n        if (m_pInstance)\n        {\n            NF_SAFE_RELEASE(m_pInstance);\n        }\n\n        m_pInstance = pNewInstance;\n    }\nprivate:\n\tstatic T* m_pInstance;\n};\n\ntemplate <class T>\nT* NFSingleton<T>::m_pInstance = nullptr;\n\n#endif\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/NFComm/NFCore/NFSingleton.hpp b/src/NFComm/NFCore/NFSingleton.hpp
--- a/src/NFComm/NFCore/NFSingleton.hpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/src/NFComm/NFCore/NFSingleton.hpp	(date 1688628466132)
@@ -72,7 +72,7 @@
     {
         if (m_pInstance)
         {
-            NF_SAFE_RELEASE(m_pInstance);
+            NF_SAFE_DELETE(m_pInstance);
         }
 
         m_pInstance = pNewInstance;
Index: game/MMO/NFLogicComm/DescStoreEx/NFItemDescStoreEx.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFItemDescStoreEx.h\n//    @Author           :    gaoyi\n//    @Date             :    22-12-2\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFItemDescStoreEx\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFComm/NFShmCore/NFShmOldHashMap.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFServerComm/NFDescStorePlugin/NFIDescStore.h\"\n#include \"NFLogicCommon/NFDescStoreTypeDefines.h\"\n#include \"NFLogicCommon/NFComTypeDefine.h\"\n#include \"DescStore/EquipEquipDesc.h\"\n#include \"DescStore/ItemItemDesc.h\"\n#include \"NFComm/NFShmCore/NFArray.h\"\n\ntypedef NFShmOldHashMap<uint64_t, NFArray<int64_t, 10>, MAX_ITEM_ITEM_NUM>  ITEM_FUNC_MAP;\ntypedef NFShmOldHashMap<uint64_t, NFShmOldHashMap<int32_t, bool, 10>, MAX_EQUIP_EQUIP_NUM>  ITEM_PROF_LIMIT_MAP;\ntypedef NFShmOldHashMap<uint64_t, NFShmOldHashMap<int64_t, bool, 10>, MAX_ITEM_ITEM_NUM>  ITEM_MAP_LIMIT_MAP;\ntypedef NFShmOldHashMap<uint64_t, NFShmOldHashMap<int32_t, bool, 10>, MAX_ITEM_ITEM_NUM>  ITEM_CD_GROUP_MAP;\ntypedef NFShmOldHashMap<uint64_t, bool, MAX_ITEM_ITEM_NUM>  SET_NATURAL_MAP;\ntypedef NFShmOldHashMap<uint64_t, int32_t, MAX_ITEM_ITEM_NUM>  MAP_VIRTUAL_ITEM_ATTR_MAP;\ntypedef NFShmOldHashMap<int32_t, uint64_t, MAX_ITEM_ITEM_NUM>  MAP_ATTR_ITEM_VIRTUAL_MAP;\ntypedef NFShmOldHashMap<uint64_t, NFShmOldHashMap<uint64_t, uint64_t, 10>, MAX_ITEM_ITEM_NUM>  MAP_FIX_MAP;\ntypedef NFShmOldHashMap<uint64_t, NFShmOldHashMap<int64_t, bool, 10>, MAX_ITEM_ITEM_NUM>  MAP_ITEM_USE_COND_ITEM;\ntypedef NFShmOldHashMap<uint64_t, int64_t, MAX_ITEM_ITEM_NUM>  ITEM_ADD_MISSION_MAP;\ntypedef NFShmOldHashMap<uint64_t, NFShmOldHashMap<int64_t, bool, 10>, MAX_EQUIP_EQUIP_NUM*5>  MAP_DECOMPOSE_MAP;\ntypedef NFShmOldHashMap<uint64_t, NFShmOldHashMap<uint64_t, uint64_t, 10>, MAX_EQUIP_EQUIP_NUM>  MAP_EQUIP_SMELT;\n\nclass NFItemDescStoreEx : public NFIDescStore\n{\n    //单双命星和命星品质组合成一个key\n#define STAR_UPGRADE_KEY(single,qua) (single * 100 + qua)\n//装备分级   星级、阶级、品质、职业、部位  组合成一个key，key对应的列表里面是满足key条件的装备ID\n#define DE_COMPOSE_KEY(star,rank,qua,prof,pos) ((star << 32) | (rank << 24)| (qua << 16) | (prof << 8) | pos)\npublic:\n    NFItemDescStoreEx();\n\n    virtual ~NFItemDescStoreEx();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    int ProcessItem();\npublic:\n    //根据物品ID获取对应的属性ID\n    uint32_t AttrIdByItem(uint64_t itemId);\n    //根据属性ID 获取对应的物品ID\n    uint64_t ItemIdByAttrId(uint32_t attrId);\nprivate:\n    ITEM_FUNC_MAP m_mapItemFunc;\t\t\t\t\t//物品表功能参数解析\n    ITEM_PROF_LIMIT_MAP m_mapItemProfLimit;\t\t\t//物品的职业限制\n    ITEM_MAP_LIMIT_MAP m_mapItemMapLimit;\t\t\t\t//物品地图限制\n    ITEM_CD_GROUP_MAP  m_mapItemOrCdGroup;\t\t\t\t//物品或CD组 的cd\n    SET_NATURAL_MAP m_setNaturalBind;\t\t\t\t\t\t//天然绑定的物品，不能有非绑定的状态\n    MAP_VIRTUAL_ITEM_ATTR_MAP m_mapVirtualItemAttr;\t\t\t\t//虚拟物品增加的属性ID  itemid - attrid\n    MAP_ATTR_ITEM_VIRTUAL_MAP m_mapAttrVirtualItem;\t\t\t\t//属性ID对应的虚拟物品ID attrid - itemid\n    MAP_FIX_MAP m_mapFixAttr;\t\t\t//物品加永久属性\n    MAP_ITEM_USE_COND_ITEM m_mapItemUseCond;\t\t\t\t//物品使用条件\n    ITEM_ADD_MISSION_MAP  m_mapItemAddMissionCheck;\t\t\t//使用物品获得任务，需要校验的物品对应的任务ID\n    MAP_DECOMPOSE_MAP m_mapDecompose;\t\t\t\t//分解需要的数据\n    MAP_EQUIP_SMELT  m_mapEquipSmelt;\t\t//装备熔炼配置\nDECLARE_IDCREATE(NFItemDescStoreEx)\nIMPL_RES_SIMPLE_DESC(NFItemDescStoreEx);\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFLogicComm/DescStoreEx/NFItemDescStoreEx.h b/game/MMO/NFLogicComm/DescStoreEx/NFItemDescStoreEx.h
--- a/game/MMO/NFLogicComm/DescStoreEx/NFItemDescStoreEx.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFLogicComm/DescStoreEx/NFItemDescStoreEx.h	(date 1688616543354)
@@ -14,7 +14,7 @@
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
 #include "NFComm/NFShmCore/NFShmOldHashMap.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFServerComm/NFDescStorePlugin/NFIDescStore.h"
 #include "NFLogicCommon/NFDescStoreTypeDefines.h"
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFGrid.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFGrid.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-11\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFGrid\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFShmStaticList.hpp\"\n#include \"NFLogicCommon/NFPoint2.h\"\n#include \"NFComm/NFShmCore/NFShmNodeList.h\"\n\n#define NF_SCENE_GRID_MAX_CREATURE_NUM 20\n\nclass NFCreature;\nclass NFGrid\n{\npublic:\n    NFGrid();\n\n    NFGrid(const NFGrid& grid);\n\n    virtual ~NFGrid();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    int UnInit(NFIPluginManager *pPluginManager);\npublic:\n    /**\n     * @brief\n     * @param pCreature\n     */\n    int AddCreature(NFIPluginManager *pPluginManager, NFCreature* pCreature);\n\n    /**\n     * @brief\n     * @param pCreature\n     */\n    int RemoveCreature(NFIPluginManager *pPluginManager, NFCreature* pCreature);\n\npublic:\n    void SetGridPos(NFPoint2<uint32_t> gridPos) { m_gridPos = gridPos; }\n    bool IsSame(NFPoint2<uint32_t> pos) { return pos == m_gridPos; }\n    const NFPoint2<uint32_t>& GetGridPos() const { return m_gridPos; }\n    NFShmNodeObjMultiList<NFCreature>& GetCidList() { return m_cidList; }\nprivate:\n    NFShmNodeObjMultiList<NFCreature> m_cidList;\n    NFPoint2<uint32_t> m_gridPos;\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFGrid.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFGrid.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFGrid.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFGrid.h	(date 1688616543248)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFShmStaticList.hpp"
 #include "NFLogicCommon/NFPoint2.h"
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFScene.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFScene.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-11\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFScene\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFGrid.h\"\n#include \"NFComm/NFShmCore/NFShmOldHashMap.h\"\n#include \"NFComm/NFShmCore/NFShmPtr.h\"\n#include \"NFLogicCommon/NFSceneDefine.h\"\n#include \"NFComm/NFShmCore/NFArray.h\"\n#include \"NFComm/NFShmStl/NFShmVector.h\"\n#include \"NFLogicCommon/NFComTypeDefine.h\"\n#include \"NFLogicCommon/NFSkillDefine.h\"\n\n#define NF_SCENE_MAX_GRID_NUM 200\n#define NF_SCENE_MAX_CREATURE_NUM 1000\n\nclass NFMap;\n\nclass NFScene : public NFShmObj\n{\npublic:\n    NFScene();\n\n    virtual ~NFScene();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    virtual int Init(uint64_t mapId, uint64_t sceneId);\n\n    virtual int UnInit();\n\n    virtual int\n    OnExecute(uint32_t serverType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message *pMessage) override;\n\n    virtual int OnTimer(int timeId, int callcount) override;\n\npublic:\n    uint64_t GetMapId() const { return m_mapId; }\n\n    uint64_t GetSceneId() const { return m_sceneId; }\n\n    bool IsDynamic() const;\n\n    NFMap *GetMap() const;\npublic:\n    /**\n     * @brief\n     * @param pCreature\n     * @param pos\n     * @param transParam\n     * @return\n     */\n    virtual NFGrid *EnterScene(NFCreature *pCreature, const NFPoint3<float> &pos, STransParam &transParam);\n\n    /**\n     * @brief\n     * @param Cid\n     * @param pGrid\n     * @param pos\n     * @param isSameGrid\n     * @return\n     */\n    virtual NFGrid *MoveInScene(NFCreature *pCreature, const NFPoint3<float> &pos, bool &isSameGrid);\n\n    /**\n     * @brief\n     * @param pCreature\n     * @return\n     */\n    virtual int LeaveScene(NFCreature *pCreature);\n\npublic:\n    bool BroadCast(uint32_t cmd, const google::protobuf::Message &msg);\n\n    bool BroadCast(const SET_UINT64 &setcid, uint16_t cmd, const google::protobuf::Message &msg);\n\npublic:\n    int FindCreatureInScene(LIST_UINT64 &clist, const NFPoint3<float> &srcPos, float flength, uint32_t creatureCount = 0);\n\n    int FindCreatureInScene(SET_Creature &setcreature, const NFPoint3<float> &srcPos, float flength, uint32_t creatureCount = 0);\n\n    int FindCreatureInCircle(LIST_UINT64 &clist, const NFPoint3<float> &srcPos, float flength, uint32_t creatureCount = 0);\n\n    int FindCreatureInCircle(SET_Creature &setcreature, const NFPoint3<float> &srcPos, float flength, uint32_t creatureCount = 0);\n\n    int FindCreatureInSector(LIST_UINT64 &clist, const NFPoint3<float> &center, NFPoint3<float> &dir, float angle, float sectorR,\n                             uint32_t creatureCount = 0);\n\n    //srcPos是玩家位置，srcDir是玩家移动方向\n    int FindCreatureInRect(LIST_UINT64 &clist, const NFPoint3<float> &srcPos, NFPoint3<float> &srcDir, float flength, float fwidth,\n                           uint32_t creatureCount = 0);\n\n    int FindCreatureInRect(LIST_UINT64 &clist, const NFPoint3<float> &center, const NFPoint3<float> &dir, const NFPoint3<float> &searchpos,\n                           float flength, float fwidth, uint32_t creatureCount = 0);\n\n    int FindCreatureInRect(SET_Creature &setcreature, const NFPoint3<float> &srcPos, NFPoint3<float> &srcDir, float flength, float fwidth,\n                           uint32_t creatureCount = 0);\n\n    //圆形范围内 查找敌人\n    int FindEnemyInCircle(NFCreature *psrc, SET_Creature &setcreature, float fradius, uint32_t creatureCount = 0);\n\n    //矩形范围内 查找技能目标\n    void FindSkillTargetInRect(NFCreature *psrc, SET_Creature &setpriority, SET_Creature &setother, const NFPoint3<float> &srcPos,\n                               const NFPoint3<float> &srcDir, float flength, float fwidth, const SearchSkillTargetParam &param);\n\n    //圆形范围内 查找技能目标\n    void FindSkillTargetInCircle(NFCreature *psrc, SET_Creature &setpriority, SET_Creature &setother, const NFPoint3<float> &srcPos, float fradius,\n                                 const SearchSkillTargetParam &param);\n\n    //扇形范围内 查找技能目标\n    void FindSkillTargetInSector(NFCreature *psrc, SET_Creature &setpriority, SET_Creature &setother, const NFPoint3<float> &srcPos,\n                                 const NFPoint3<float> &srcDir, float fradius, float fangle, const SearchSkillTargetParam &param);\n\n    //获取中点周围矩形范围内的坐标点\n    void FindPointLstInRect(const NFPoint3<float> &center, VecPoint3 &vecPos, float fwidth, float fhigh, int32_t pointCnt, uint32_t beginidx = 0);\n\n\n    int FindSeeLstInNineGrid(NFCreature *pSrc, std::vector<NFCreature *> *clist, const NFPoint3<float> &srcPos);\n\n    int FindDoubleSeeLstInNineGrid(NFCreature *pSrc, std::vector<NFCreature *> &clist, const NFPoint3<float> &srcPos);\n\n    int GridCreaturesWithCircle(LIST_UINT64 &clist, NFGrid *pGrid, const NFPoint3<float> &srcPos, float flength,\n                                uint32_t creatureCount = 0);\n\n    int GridCreaturesWithCircle(SET_Creature &setcreature, NFGrid *pGrid, const NFPoint3<float> &srcPos, float flength,\n                                uint32_t creatureCount = 0);\n\n    int GridCreaturesWithSector(LIST_UINT64 &clist, const NFPoint3<float> &center, NFPoint3<float> &vdir, NFGrid *pGrid, float cosAngle,\n                                float sectorR, uint32_t creatureCount = 0);\n\n    int GridCreaturesWithRect(LIST_UINT64 &clist, NFGrid *pGrid, const NFPoint3<float> &center, const NFPoint3<float> &dir, float flength,\n                              float fwidth, uint32_t creatureCount = 0);\n\n    int GridCreaturesWithRect(SET_Creature &setcreature, NFGrid *pGrid, const NFPoint3<float> &center, const NFPoint3<float> &dir,\n                              float flength, float fwidth, uint32_t creatureCount = 0);\n\npublic:\n    int AddRangeLstCids(LIST_UINT64 &clist, const NFPoint3<float> &srcPos, NFCreature *pTarget, uint32_t creatureCount);\n\n    int AddRangeLstCids(SET_Creature &setcreature, const NFPoint3<float> &srcPos, NFCreature *pTarget, uint32_t creatureCount);\n\npublic:\n    /**\n     * @brief\n     * @param pCreature\n     */\n    int AddMonster(NFCreature *pCreature);\n\n    /**\n     * @brief\n     * @param pCreature\n     */\n    int RemoveMonster(NFCreature *pCreature);\n\n    /**\n     * @brief\n     * @param pCreature\n     */\n    int AddPlayer(NFCreature *pCreature);\n\n    /**\n     * @brief\n     * @param pCreature\n     */\n    int RemovePlayer(NFCreature *pCreature);\n\n    /**\n     * @brief\n     * @param pCreature\n     */\n    int AddCreature(NFCreature *pCreature);\n\n    /**\n     * @brief\n     * @param pCreature\n     */\n    int RemoveCreature(NFCreature *pCreature);\n\n    /**\n     * @brief\n     * @param cid\n     * @return\n     */\n    NFCreature *GetCreature(uint64_t cid);\n\npublic:\n    NFGrid *GetGrid(uint32_t w, uint32_t h);\n\n    virtual void GetNineGrid(const NFPoint3<float> &pos, std::vector<NFGrid *> &vecGrid);\n\n    virtual void GetLayerGrid(uint32_t layer, const NFPoint3<float> &pos, std::vector<NFGrid *> &vecGrid);\n\n    virtual uint32_t GetGridLayer(uint32_t gridX, uint32_t gridZ, const NFPoint3<float> &srcPos, float flength);\n\n    virtual void GetLayerGrid(const NFPoint3<float> &srcPos, float flength, std::vector<NFGrid *> &vecGrid);\n\npublic:\n\n\nprivate:\n    uint64_t m_mapId;\n    int m_mapGlobalId;\n    uint64_t m_sceneId;\n    uint32_t m_gridMaxWidth;\n    uint32_t m_gridMaxHeight;\n    NFShmVector<NFShmVector<NFGrid, NF_SCENE_MAX_GRID_NUM>, NF_SCENE_MAX_GRID_NUM> m_gridList;\nprivate:\n    NFShmNodeObjMultiList<NFCreature> m_creatureList;\n    NFShmNodeObjMultiList<NFCreature> m_playerList;\nDECLARE_IDCREATE(NFScene)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFScene.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFScene.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFScene.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Scene/NFScene.h	(date 1688616543325)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFGrid.h"
 #include "NFComm/NFShmCore/NFShmOldHashMap.h"
Index: game/MMO/NFLogicComm/DescStoreEx/NFAttr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFAttr.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-19\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFAttr\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"Com.pb.h\"\n#include \"NFLogicCommon/NFComTypeDefine.h\"\n#include <unordered_map>\n\n#pragma pack(push)\n#pragma pack(1)\n\n//通用 战斗属性结束ID\nconst uint32_t COMMON_FIGHT_ATTR_END = 73;\n//通用 战斗属性组结束ID\nconst uint32_t COMMON_FIGHT_ATTR_GROUP_END = 4;\n\n//通用 普通属性结束ID\nconst uint32_t COMMON_ATTR_END = 20;\n\n\n//角色 战斗属性结束ID\nconst uint32_t ROLE_FIGHT_ATTR_END = 201;\n//角色 战斗属性 结束组ID\nconst uint32_t ROLE_FIGHT_ATTR_GROUP_END = (uint32_t) proto_ff::EAttrGroup_ARRAYSIZE;\n\n\n//角色 普通属性结束ID\nconst uint32_t ROLE_ATTR_END = 200;\n\n//属性类型\nenum class EAttrType\n{\n    none = 0,        //无\n    common = 1,        //通用属性\n    role = 2,        //角色属性\n};\n\nclass IFightAttr : public NFShmObj\n{\npublic:\n    virtual ~IFightAttr() {}\n\n    virtual EAttrType GetType() { return EAttrType::none; }\n\n    //是否有效的战斗属性ID\n    virtual bool ValidAttr(uint32_t ANum) = 0;\n\n    //是否是有效的属性数组索引\n    virtual bool ValidIndex(uint8_t index) = 0;\n\n    //是否是有效的战斗属性组ID\n    virtual bool ValidAttrGroup(uint32_t groupid) = 0;\n\n    //获取总属性值\n    virtual int64_t GetAttr(uint32_t ANum) = 0;\n\n    //获取所有的总属性\n    virtual void GetAttr(MAP_UINT32_INT64 &mapattr) = 0;\n\n    //计算总属性值\n    virtual void CalcAttr(MAP_UINT32_INT64 &mapchg) = 0;\n\n    //计算指定ID的总属性值\n    virtual bool CalcAttr(uint32_t ANum, bool *chgflag = nullptr) = 0;\n\n    //获取指定属性组中指定ID的属性值\n    virtual int64_t GetAttrGroup(uint32_t groupid, uint32_t ANum) = 0;\n\n    //获取指定属性组中所有的属性值\n    virtual bool GetAttrGroup(uint32_t groupid, MAP_UINT32_INT64 &mapattr) = 0;\n\n    //增加指定属性组中指定ID的属性值\n    virtual bool AddAttrGroup(uint32_t groupid, uint32_t ANum, int64_t val, bool *chgflag = nullptr) = 0;\n\n    //设置指定属性组中指定ID的属性值\n    virtual bool SetAttrGroup(uint32_t groupid, uint32_t ANum, int64_t val, bool *chgflag = nullptr) = 0;\n\n    //清空指定属性组的属性值\n    virtual bool ClearAttrGroup(uint32_t groupid, bool *chgflag = nullptr) = 0;\n\n    //获取计算战力的属性值\n    virtual void GetFightAttr(MAP_UINT32_INT64 &mapattr) = 0;\n\n    //获取计算战力的标记\n    virtual bool GetFightChg() = 0;\n\n    //清除计算战力的标记\n    virtual void ClearFightChg() = 0;\n};\n\n\n//通用战斗属性\nclass ComFightAttr : public IFightAttr\n{\npublic:\n    ComFightAttr();\n\n    virtual ~ComFightAttr();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    virtual EAttrType GetType() { return EAttrType::common; }\n\n    virtual bool ValidAttr(uint32_t ANum);\n\n    virtual bool ValidAttrGroup(uint32_t groupid);\n\n    virtual bool ValidIndex(uint8_t index);\n\n    virtual int64_t GetAttr(uint32_t ANum);\n\n    virtual void GetAttr(std::unordered_map<uint32_t, int64_t> &mapattr);\n\n    virtual void CalcAttr(std::unordered_map<uint32_t, int64_t> &mapchg);\n\n    virtual bool CalcAttr(uint32_t ANum, bool *chgflag = nullptr);\n\n    virtual int64_t GetAttrGroup(uint32_t groupid, uint32_t ANum);\n\n    virtual bool GetAttrGroup(uint32_t groupid, MAP_UINT32_INT64 &mapattr);\n\n    virtual bool AddAttrGroup(uint32_t groupid, uint32_t ANum, int64_t val, bool *chgflag = nullptr);\n\n    virtual bool SetAttrGroup(uint32_t groupid, uint32_t ANum, int64_t val, bool *chgflag = nullptr);\n\n    virtual bool ClearAttrGroup(uint32_t groupid, bool *chgflag = nullptr);\n\n    //\n    virtual void GetFightAttr(MAP_UINT32_INT64 &mapattr) {}\n\n    virtual bool GetFightChg() { return false; }\n\n    virtual void ClearFightChg() {};\nprivate:\n    //战斗属性, ID为0的属性组表示总属性\n    int64_t m_attr[COMMON_FIGHT_ATTR_GROUP_END][COMMON_FIGHT_ATTR_END];\nDECLARE_IDCREATE(ComFightAttr)\n};\n\n\n//角色战斗属性\nclass RoleFightAttr : public IFightAttr\n{\npublic:\n    RoleFightAttr();\n\n    virtual ~RoleFightAttr();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    virtual EAttrType GetType() { return EAttrType::role; }\n\n    virtual bool ValidAttr(uint32_t ANum);\n\n    virtual bool ValidIndex(uint8_t index);\n\n    virtual bool ValidAttrGroup(uint32_t groupid);\n\n    virtual int64_t GetAttr(uint32_t ANum);\n\n    virtual void GetAttr(std::unordered_map<uint32_t, int64_t> &mapattr);\n\n    virtual void CalcAttr(std::unordered_map<uint32_t, int64_t> &mapchg);\n\n    virtual bool CalcAttr(uint32_t ANum, bool *chgflag = nullptr);\n\n    virtual int64_t GetAttrGroup(uint32_t groupid, uint32_t ANum);\n\n    virtual bool GetAttrGroup(uint32_t groupid, MAP_UINT32_INT64 &mapattr);\n\n    virtual bool AddAttrGroup(uint32_t groupid, uint32_t ANum, int64_t val, bool *chgflag = nullptr);\n\n    virtual bool SetAttrGroup(uint32_t groupid, uint32_t ANum, int64_t val, bool *chgflag = nullptr);\n\n    virtual bool ClearAttrGroup(uint32_t groupid, bool *chgflag = nullptr);\n\n    virtual void GetFightAttr(MAP_UINT32_INT64 &mapattr);\n\n    virtual bool GetFightChg() { return m_fightchg; }\n\n    virtual void ClearFightChg() { m_fightchg = false; }\n\nprivate:\n    bool IsFightAttrGroup(uint32_t groupid);\n\nprivate:\n    //战斗属性, ID为0的属性组表示总属性\n    int64_t m_attr[ROLE_FIGHT_ATTR_GROUP_END][ROLE_FIGHT_ATTR_END];\n    //用于计算战力的属性\n    int64_t m_fightattr[ROLE_FIGHT_ATTR_END];\n    //计算战力属性是否有改变\n    bool m_fightchg;\nDECLARE_IDCREATE(RoleFightAttr)\n};\n\nclass IAttr : public NFShmObj\n{\npublic:\n    virtual ~IAttr() {};\n\n    virtual EAttrType GetType() { return EAttrType::none; }\n\n    //是否有效的属性ID\n    virtual bool ValidAttr(uint32_t ANum) = 0;\n\n    //是否是有效的属性数组索引\n    virtual bool ValidIndex(uint16_t index) = 0;\n\n    //获取属性值\n    virtual int64_t GetAttr(uint32_t ANum) = 0;\n\n    //增加属性值\n    virtual bool AddAttr(uint32_t ANum, int64_t val, bool *chgflag = nullptr) = 0;\n\n    //设置属性值\n    virtual bool SetAttr(uint32_t ANum, int64_t val, bool *chgflag = nullptr) = 0;\n};\n\n//通用属性\nclass ComAttr : public IAttr\n{\npublic:\n    ComAttr();\n\n    virtual ~ComAttr();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    virtual EAttrType GetType() { return EAttrType::common; }\n\n    virtual bool ValidAttr(uint32_t ANum);\n\n    virtual bool ValidIndex(uint16_t index);\n\n    virtual int64_t GetAttr(uint32_t ANum);\n\n    virtual bool AddAttr(uint32_t ANum, int64_t val, bool *chgflag = nullptr);\n\n    virtual bool SetAttr(uint32_t ANum, int64_t val, bool *chgflag = nullptr);\n\nprivate:\n    int64_t m_attr[COMMON_ATTR_END];\nDECLARE_IDCREATE(ComAttr)\n};\n\n\n//角色属性\nclass RoleAttr : public IAttr\n{\npublic:\n    RoleAttr();\n\n    virtual ~RoleAttr();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    virtual EAttrType GetType() { return EAttrType::role; }\n\n    virtual bool ValidAttr(uint32_t ANum);\n\n    virtual bool ValidIndex(uint16_t index);\n\n    virtual int64_t GetAttr(uint32_t ANum);\n\n    virtual bool AddAttr(uint32_t ANum, int64_t val, bool *chgflag = nullptr);\n\n    virtual bool SetAttr(uint32_t ANum, int64_t val, bool *chgflag = nullptr);\n\nprivate:\n    int64_t m_attr[ROLE_ATTR_END];\nDECLARE_IDCREATE(RoleAttr)\n};\n\n#pragma pack(pop)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFLogicComm/DescStoreEx/NFAttr.h b/game/MMO/NFLogicComm/DescStoreEx/NFAttr.h
--- a/game/MMO/NFLogicComm/DescStoreEx/NFAttr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFLogicComm/DescStoreEx/NFAttr.h	(date 1688616543106)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "Com.pb.h"
 #include "NFLogicCommon/NFComTypeDefine.h"
Index: game/MMO/NFLogicComm/DescStoreEx/NFGrowDescStoreEx.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFGrowDescStoreEx.h\n//    @Author           :    gaoyi\n//    @Date             :    23-3-14\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFGrowDescStoreEx\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFServerComm/NFDescStorePlugin/NFIDescStore.h\"\n#include \"NFLogicCommon/NFComTypeDefine.h\"\n#include \"NFComm/NFShmStl/NFShmHashSet.h\"\n#include \"fashion_s.h\"\n#include \"DescStore/FashionFashionDesc.h\"\n#include \"headPortrait_s.h\"\n#include \"DescStore/HeadportraitHeadDesc.h\"\n#include \"DescStore/DecorateDecorateDesc.h\"\n#include \"DescStore/FootprintFootprintDesc.h\"\n#include \"DescStore/MeditationMeditationDesc.h\"\n#include \"DescStore/HaloHaloDesc.h\"\n\n//养成配置信息\nstruct GrowInfoCfg\n{\n    GrowInfoCfg()\n    {\n        if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode())\n        {\n            CreateInit();\n        }\n        else\n        {\n            ResumeInit();\n        }\n    }\n\n    int CreateInit()\n    {\n        id = 0;\n        type = 0;\n        activationItem =0;\n        activationNum = 0;\n        startItem =0;\n        starBar = 0;\n        return 0;\n    }\n\n    int ResumeInit()\n    {\n        return 0;\n    }\n\n    int64_t id;\t\t\t\t\t\t//ID\n    int32_t type;\t\t\t\t\t//类型\n    NFShmHashSet<uint32_t, proto_ff::ERoleProf_MAX> profLimits;\t\t\t//职业限制\n    int64_t activationItem;\t\t//激活道具ID\n    int32_t activationNum;\t\t//激活道具数量\n    int32_t startItem;\t\t\t//升星道具id\n    NFShmHashMap<int32_t, int32_t, 100> lvMap;\t\t\t//升星消耗道具数量\n    int32_t starBar;\t\t\t//每次升星属性增加的百分比值\n    NFShmHashMap<int32_t, int32_t, DEFINE_E_HEADPORTRAITHEAD_M_ATTRIBUTE_MAX_NUM> attrsMap;\t\t//属性加成 key->value attrid->attrvalue\n    NFShmHashMap<int32_t, int32_t, DEFINE_E_FASHIONFASHION_M_ACTIVEATTRIBUTE_MAX_NUM> activeAttrMap;\t//激活加成的属性\n    bool LimitProf(int32_t prof);\n    int32_t GetStarLvNum(int32_t lv);\n};\n\ntypedef NFShmHashMap<int64_t, GrowInfoCfg, 100> GrowCfgMap;\ntypedef NFShmHashMap<int32_t, GrowCfgMap, proto_ff::GrowType_MAX> GrowTypeMap;\n\nclass NFGrowDescStoreEx : public NFIDescStore\n{\npublic:\n    NFGrowDescStoreEx();\n\n    virtual ~NFGrowDescStoreEx();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    virtual bool IsNeedReload();\n\n    virtual int PrepareReload();\npublic:\n    GrowInfoCfg* GetGrowCfg(int64_t id);\nprivate:\n    bool Process();\n    bool ProcessLvMap(MAP_INT32_INT32& lvMap, const std::string& cfg);\nprivate:\n    bool ProcessFashion();\t\t\t//处理时装\n    bool ProcessDecorate();\t\t\t//处理首饰\n    bool ProcessFootPrint();\t\t//处理足迹\n    bool ProcessMeditation();\t\t//处理打坐\n    bool ProcessHalo();\t\t\t\t//处理光环\n    bool ProcessHead();\t\t\t\t//处理头像\n\n    bool addId(int64_t id, int32_t type); //对ID处理\nprivate:\n    GrowTypeMap\t\tm_typeGrowMap;\n    NFShmHashMap<int64_t, int32_t, MAX_FASHION_FASHION_NUM+MAX_HEADPORTRAIT_HEAD_NUM+MAX_DECORATE_DECORATE_NUM+MAX_FOOTPRINT_FOOTPRINT_NUM+MAX_MEDITATION_MEDITATION_NUM+MAX_HALO_HALO_NUM> m_id2typeMap;\t//所有配置表ID不能重复\nprivate:\nDECLARE_IDCREATE(NFGrowDescStoreEx)\nIMPL_RES_SIMPLE_DESC(NFGrowDescStoreEx);\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFLogicComm/DescStoreEx/NFGrowDescStoreEx.h b/game/MMO/NFLogicComm/DescStoreEx/NFGrowDescStoreEx.h
--- a/game/MMO/NFLogicComm/DescStoreEx/NFGrowDescStoreEx.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFLogicComm/DescStoreEx/NFGrowDescStoreEx.h	(date 1688616543405)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFServerComm/NFDescStorePlugin/NFIDescStore.h"
 #include "NFLogicCommon/NFComTypeDefine.h"
Index: game/MMO/NFLogicComm/DescStoreEx/NFFuncUnLockDescStoreEx.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFFuncUnLockDescStoreEx.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-30\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFFuncUnLockDescStoreEx\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFComm/NFShmStl/NFShmHashMap.h\"\n#include \"NFComm/NFShmStl/NFShmHashSet.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFServerComm/NFDescStorePlugin/NFIDescStore.h\"\n#include \"NFLogicCommon/NFDescStoreTypeDefines.h\"\n#include \"NFLogicCommon/NFComTypeDefine.h\"\n\n#define MAX_FUNC_UNLOCK_OPEN_TYPE_NUMBER 10\n#define MAX_FUNC_UNLOCK_OPEN_VAL_NUMBER 100\n#define MAX_FUNC_UNLOCK_OPEN_VAL_FUNC_NUM 500\n\nclass NFFuncUnLockDescStoreEx : public NFIDescStore\n{\npublic:\n    NFFuncUnLockDescStoreEx();\n\n    virtual ~NFFuncUnLockDescStoreEx();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    virtual bool IsNeedReload();\n\n    virtual int PrepareReload();\npublic:\n    //根据解锁类型和解锁值 获取对应的功能列表\n    NFShmHashSet<uint64_t, MAX_FUNC_UNLOCK_OPEN_VAL_FUNC_NUM>* GetUnlockFunctionList(uint32_t nType, uint64_t nValue, bool externFlag = false);\nprivate:\n    //任务解锁的 分类数据  map<解锁类型，map<解锁值，set<功能ID> > >\n    NFShmHashMap<uint32_t, NFShmHashMap<uint64_t, NFShmHashSet<uint64_t, MAX_FUNC_UNLOCK_OPEN_VAL_FUNC_NUM>, MAX_FUNC_UNLOCK_OPEN_VAL_NUMBER>, MAX_FUNC_UNLOCK_OPEN_TYPE_NUMBER> m_mapUnlockCfg;\nDECLARE_IDCREATE(NFFuncUnLockDescStoreEx)\nIMPL_RES_SIMPLE_DESC(NFFuncUnLockDescStoreEx);\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFLogicComm/DescStoreEx/NFFuncUnLockDescStoreEx.h b/game/MMO/NFLogicComm/DescStoreEx/NFFuncUnLockDescStoreEx.h
--- a/game/MMO/NFLogicComm/DescStoreEx/NFFuncUnLockDescStoreEx.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFLogicComm/DescStoreEx/NFFuncUnLockDescStoreEx.h	(date 1688616543004)
@@ -15,7 +15,7 @@
 #include "NFComm/NFShmCore/NFShmMgr.h"
 #include "NFComm/NFShmStl/NFShmHashMap.h"
 #include "NFComm/NFShmStl/NFShmHashSet.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFServerComm/NFDescStorePlugin/NFIDescStore.h"
 #include "NFLogicCommon/NFDescStoreTypeDefines.h"
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFCreatureMgr.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-11\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFCreatureMgr\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n\nclass NFCreature;\nclass NFBattlePlayer;\nclass NFCreatureMgr : public NFShmObj\n{\npublic:\n    NFCreatureMgr();\n\n    virtual ~NFCreatureMgr();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    int OnTimer(int timeId, int callcount);\n\n    int Update();\npublic:\n    /**\n     * @brief 需要查找NFShmObj之间继承关系， 只有NFCreature的子类才能获得对象\n     * @param cid\n     * @return\n     */\n    NFCreature* GetCreature(uint64_t cid);\n\n\n    /**\n     * @brief\n     * @param kindType\n     * @param id\n     * @return\n     */\n    NFCreature* CreateCreature(uint32_t kindType, uint64_t id = 0);\n\n    /**\n     * @brief\n     * @param pCreature\n     */\n    int  DestroyCreature(NFCreature* pCreature);\npublic:\n    /**\n     * @brief\n     * @param roleId\n     * @return\n     */\n    NFBattlePlayer* GetBattlePlayer(uint64_t roleId);\nprivate:\n    int m_creatureTickTimer;\nDECLARE_IDCREATE(NFCreatureMgr)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureMgr.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureMgr.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureMgr.h	(date 1688616543042)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 
 class NFCreature;
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFBattlePlayer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFBattlePlayer.h\n//    @Author           :    gaoyi\n//    @Date             :    23-2-28\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFBattlePlayer\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFCreature.h\"\n#include \"DBProto2.pb.h\"\n#include \"NFComm/NFShmCore/NFSeqOP.h\"\n#include \"Com_s.h\"\n#include \"NFLogicCommon/NFLogicCommonDefine.h\"\n#include \"Move.pb.h\"\n#include \"CSPlayer.pb.h\"\n\nclass NFBattlePlayer : public NFCreature, public NFSeqOP\n{\npublic:\n    NFBattlePlayer();\n\n    virtual ~NFBattlePlayer();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    virtual int Init(const proto_ff::RoleEnterSceneData &data);\n\n    virtual int Init(uint32_t gateId, uint64_t clientId, uint32_t logicId, const proto_ff::RoleEnterSceneData &data);\n\n    virtual int Update(uint64_t tick);\n\n    virtual int ReadBaseData(const ::proto_ff::RoleDBBaseData &dbData);\n\n    virtual int ReadViewAttrData(const ::proto_ff::AttrDBData &dbData);\n\n    //视野数据\n    virtual void GetVisibleDataToClient(proto_ff::CreatureCreateData &CvData);\n\n    virtual int OnTimer(int timeId, int callcount);\n\n    virtual int OnExecute(uint32_t serverType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message* pMessage);\npublic:\n    int SyncFacade(const proto_ff::RoleFacadeProto* pEvent);\n    int SyncAttr(const proto_ff::CreatureAttrSyn* pEvent);\n    int SyncBroadAttr(const proto_ff::CreatureAttrBroadRsp* pEvent);\npublic:\n    int OnDisconnect();\n\n    int OnLogout();\npublic:\n    virtual uint64_t GetUid() { return m_uid; }\n\n    virtual uint64_t GetRoleId() { return m_roleId; }\n\n    virtual uint32_t GetChannId() { return m_channId; }\n\n    virtual uint32_t GetZid() { return m_zid; }\n\n    virtual uint32_t GetProxyId() { return m_proxyId; }\n\n    virtual uint64_t GetClientId() { return m_clientId; }\n\n    virtual uint32_t GetLogicId() { return m_logicId; }\n\n    PLAYER_STATUS GetPlayerStatus() const { return m_playerStatus; }\n\n    void SetPlayerStatus(PLAYER_STATUS status) { m_playerStatus = status; }\n\n    /**\n     * @brief\n     * @return\n     */\n    uint64_t GetCreateTime() const;\n\n    /**\n     * @brief\n     * @param createTime\n     */\n    void SetCreateTime(uint64_t createTime);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint64_t GetLastDiconnectTime() const;\n\n    /**\n     * @brief\n     * @param lastDiconnectTime\n     */\n    void SetLastDiconnectTime(uint64_t lastDiconnectTime);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint64_t GetLastLogoutTime() const;\n\n    /**\n     * @brief\n     * @param lastLogoutTime\n     */\n    void SetLastLogoutTime(uint64_t lastLogoutTime);\n\npublic:\n    /**\n     * @brief\n     * @return\n     */\n    bool IsDisconnect() const;\n\n    /**\n     * @brief\n     * @param isDisConnect\n     */\n    void SetIsDisconnect(bool isDisConnect);\n\npublic:\n    /**\n     * @brief 强制传送(场景内传送、切场景传送)\n     * @param scenceId 目标场景ID（唯一ID，静态地图场景ID和地图ID相同）\n     * @param dstPos 目标场景坐标\n     * @param mapId 地图ID\n     * @param transParam 传送参数\n     * @return\n     */\n    virtual int TransScene(uint64_t scenceId, const NFPoint3<float> &dstPos, uint64_t mapId, STransParam &transParam);\n\n    virtual int CanTrans(uint64_t dstSceneId, uint64_t dstMapId, const NFPoint3<float> &dstPos, NFPoint3<float> &outPos, STransParam &transParam, bool checkPosFlag = true);\npublic:\n    //移动到目标坐标\n    virtual int MoveTo(const NFPoint3<float>& dstPos);\n    //停止当前移动\n    virtual int StopMove();\n    //瞬间移动\n    virtual int Teleporting(const NFPoint3<float>& dstPos, int32_t type = proto_ff::MoveTeleportRsp_Type_common);\npublic:\n    //进入战斗状态\n    virtual bool EnterFightState();\n    //离开战斗状态\n    virtual bool LeaveFigthState();\n\n    //取消打坐状态\n    virtual bool EnterSeatState();\n    virtual bool LeaveSeatState();\npublic:\n    NFBattlePart *CreatePart(uint32_t partType, const ::proto_ff::RoleEnterSceneData &data);\n    int RecylePart(NFBattlePart *pPart);\n    //获取对应部件指针\n    virtual NFBattlePart *GetPart(uint32_t partType);\npublic:\n    //是否处于疲劳状态\n    bool IsTired() { return false; }\nprivate:\n    /**\n     * @brief 玩家数据是否初始化\n     */\n    bool m_isInited;\n\n    /**\n     * @brief\n     */\n    uint64_t m_uid;\n\n    /**\n     * @brief\n     */\n    uint64_t m_roleId;\n\n    /**\n     * @brief\n     */\n    NFShmString<64> m_name;\n\n    /**\n     * @brief\n     */\n    uint32_t m_channId;\n\n    /*\n     *\n     */\n    uint32_t m_zid;\n\n    /**\n     * @brief\n     */\n    uint32_t m_proxyId;\n\n    uint64_t m_clientId;\n\n    /**\n     * @brief\n     */\n    uint32_t m_logicId;\n\n    /**\n     * @brief\n     */\n    proto_ff_s::RoleFacadeProto_s m_facade;\n\n    /**\n     * @brief 玩家头顶显示掉落归属标记\n     */\n    int8_t m_headFlag;\npublic:\n    /**\n     * @brief\n     */\n    PLAYER_STATUS m_playerStatus;\n\n    /**\n     * @brief\n     */\n    uint64_t m_createTime;\n\n    /**\n     * @brief\n     */\n    uint64_t m_lastDiconnectTime;\n\n    /**\n     * @brief\n     */\n    uint64_t m_lastLogoutTime;\n\n    /**\n     * @brief\n     */\n    bool m_isDisconnect;\npublic:\n    int m_timerId_FightState;\npublic:\n    NFShmVector<int, BATTLE_PART_MAX> m_pPart;\nDECLARE_IDCREATE(NFBattlePlayer)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFBattlePlayer.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFBattlePlayer.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFBattlePlayer.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFBattlePlayer.h	(date 1688616543418)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFCreature.h"
 #include "DBProto2.pb.h"
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreature.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFCreature.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-11\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFCreature\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFShmPtr.h\"\n#include \"NFComm/NFShmCore/NFShmNodeList.h\"\n#include \"NFLogicCommon/NFPoint3.h\"\n#include \"NFLogicCommon/NFPoint2.h\"\n#include \"DescStoreEx/NFAttr.h\"\n#include \"NFLogicCommon/NFRoleDefine.h\"\n#include \"NFLogicCommon/NFComTypeDefine.h\"\n#include \"NFLogicCommon/NFLogDefine.h\"\n#include \"NFComm/NFShmStl/NFShmHashMap.h\"\n#include \"NFLogicCommon/NFAccountDefine.h\"\n#include \"NFComm/NFShmStl/NFShmList.h\"\n#include \"NFCreatureVisionData.h\"\n#include \"Part/NFBattlePart.h\"\n#include \"View.pb.h\"\n\nclass NFScene;\n\nclass NFGrid;\n\nclass NFCreature;\n\nclass NFBattlePart;\n\nenum\n{\n    NF_CREATURE_NODE_LIST_GRID_INDEX = 0,\n    NF_CREATURE_NODE_LIST_SCENE_INDEX = 1,\n    NF_CREATURE_NODE_LIST_MAX_TYPE_INDEX = 2,\n};\n\n//生物状态\nclass CreatureState\n{\npublic:\n    CreatureState()\n    {\n        if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode())\n        {\n            CreateInit();\n        }\n        else\n        {\n            ResumeInit();\n        }\n    }\n\n    ~CreatureState()\n    {\n\n    }\n\n    int CreateInit()\n    {\n        m_curstate = 0;\n        m_laststate = 0;\n        return 0;\n    }\n\n    int ResumeInit()\n    {\n        return 0;\n    }\n\n    bool BState(proto_ff::ECState state)\n    {\n        return (state == m_curstate);\n    }\n\n    uint8_t GetState()\n    {\n        return m_curstate;\n    }\n\n    void SetState(proto_ff::ECState state)\n    {\n        m_curstate = state;\n    }\n\n    bool EnterState(NFCreature *pCreature, proto_ff::ECState state);\n\nprotected:\n    uint8_t m_curstate;\n    uint8_t m_laststate;\n};\n\n\nclass NFCreature : public NFShmObj, public NFMultiListNodeObjWithGlobalID<NFCreature, EOT_GAME_CREATURE_ID, NF_CREATURE_NODE_LIST_MAX_TYPE_INDEX>\n{\npublic:\n    NFCreature();\n\n    virtual ~NFCreature();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    virtual int Init();\n\n    virtual int UnInit();\n\n    virtual int Update(uint64_t tick);\n\npublic:\n    virtual bool IsDestory() { return m_destory; }\n\n    virtual void SetDestory() { m_destory = true; }\n\n    virtual AccountGameState GetAccountState() { return ACCOUNT_GAME_STATE_NULL; }\n\n    virtual bool IsDead() { return BState(proto_ff::state_dead); }\n\n    virtual uint64_t GetCfgId() { return 0; } //获取生物对应实例配置表Id\n    void SetPos(const NFPoint3<float> &pos);\n\n    NFPoint3<float> &GetPos() { return m_pos; }\n\n    void SetDir(const NFPoint3<float> &point);\n\n    NFPoint3<float> &GetDir() { return m_dir; }\n\n    NFGrid *GetGrid();\n\n    void SetGrid(NFGrid *pGrid);\n\n    NFScene *GetScene();\n\n    uint64_t GetSceneId() const { return m_sceneId; };\n\n    void SetSceneId(uint64_t sceneId) { m_sceneId = sceneId; }\n\n    uint64_t GetMapId() const { return m_mapId; }\n\n    void SetMapId(uint64_t mapId) { m_mapId = mapId; }\n\n    virtual uint8_t Kind() const { return m_kind; };\n\n    uint64_t Cid() const { return m_cid; }\n\n    float GetSpeed();\n\n    float GetSightRange() const { return m_sightRange; }\n\n    virtual uint64_t GetUid() { return 0; }\n\n    virtual uint64_t GetRoleId() { return 0; }\n\n    virtual uint32_t GetChannId() { return 0; }\n\n    virtual uint32_t GetZid() { return 0; }\n\n    virtual uint32_t GetProxyId() { return 0; }\n\n    virtual uint64_t GetClientId() { return 0; }\n\n    virtual uint32_t GetLogicId() { return 0; }\n\n    //获取怪物模型半径, 长度单位m\n    virtual float GetModelRadius() { return m_fRadius; };\npublic:\n    /**\n     * @brief 强制传送(场景内传送、切场景传送)\n     * @param scenceId 目标场景ID（唯一ID，静态地图场景ID和地图ID相同）\n     * @param dstPos 目标场景坐标\n     * @param mapId 地图ID\n     * @param transParam 传送参数\n     * @return\n     */\n    virtual int TransScene(uint64_t scenceId, const NFPoint3<float> &dstPos, uint64_t mapId, STransParam &transParam) { return 0; }\n\n    //进入场景(这个接口只给移动部件和生物内部自身调用，其他请调用transScene)\n    virtual int EnterScene(uint64_t sceneId, const NFPoint3<float> &enterPos, STransParam &transParam);\n\n    //离开场景\n    virtual int LeaveScene();\n\n    virtual int CanTrans(uint64_t dstSceneId, uint64_t dstMapId, const NFPoint3<float> &dstPos, NFPoint3<float> &outPos, STransParam &transParam, bool checkPosFlag = true) { return 0; }\npublic:\n    //状态\n    virtual bool EnterNormalState();\n\n    virtual bool EnterDeadState();\n\n    virtual bool EnterReliveState();\n\n    virtual bool EnterSeatState();\n\n    virtual bool LeaveSeatState();\n\n    virtual bool EnterFightState();\n\n    virtual bool LeaveFigthState();\n\n    virtual bool LeaveState();\n\n    virtual bool BState(proto_ff::ECState state);\n\n    uint8_t GetState();\n\n    void SetState(proto_ff::ECState state);\n\n    //状态改变\n    virtual void OnChangeState(uint8_t curstate, uint8_t laststate);\n\npublic:\n    //是否有战力压制\n    virtual bool HasFightSuppress() { return true; }\n\n    //是否是组队机器人\n    virtual bool IsTeamRobot() { return false; }\n\n    virtual void OnDead(uint64_t killerCid, bool isSync = false, int64_t lastDamage = 0);\n\n    virtual void OnCorpse() {}; //尸体停留阶段\n\n    virtual void OnRevive(int64_t curhp = 0);\n\n    virtual NFCreature *GetOwner() { return nullptr; }\n\n    virtual void SetOwner(NFCreature *powner) {}\n\npublic:\n    virtual void FindCreatureInScene(LIST_UINT64 &clist);\n\n    virtual void FindCreatureInScene(SET_Creature &setcreature);\n\n    virtual void FindSeeListInNineGride(NFCreature *pSrc, std::vector<NFCreature *> *clist, NFPoint3<float> &sorPos);\n\n    virtual void FindDoubleSeeListInNineGride(NFCreature *pSrc, std::vector<NFCreature *> &clist, NFPoint3<float> &sorPos);\n\n    //将对方加入到自己的视野中\n    virtual void SimpleAddPVPSeeLst(int releation, NFCreature *pOther);\n\n    virtual void SimplePVMAddSeeLst(NFCreature *pOther);\n\n    virtual void ReplacePVPSeeList(int releation, NFCreature *pOther, std::vector<NFCreature *> &vecBeen);\n\n    virtual void AddPVPSeeLst(int releation, NFCreature *pOther, std::vector<NFCreature *> &vecBeen);\n\n    virtual void AddPVMSeeLst(NFCreature *pOther, std::vector<NFCreature *> &vecBeen);\n\n    virtual int DelPVMSeeLst(int delpos, NFCreature *pOther);\n\n    virtual int DelPVPSeeLst(int delpos, NFCreature *pOther);\n\n    //视野裁剪接口 后面需要做更复杂的视野裁剪那么子类继承去实现\n    virtual bool ViewFliter(NFCreature *pCreature, float dict);\n\n    virtual void OnDelPVPSeeLst(NFCreature *pOther) {}\n\n    virtual void GetSeeLst(std::vector<uint64_t> &);\n\n    virtual void GetCreatureList(std::vector<NFCreature *> &vec);\n\n    virtual NFCreatureVisionData &GetVisionData() { return m_visionData; }\n\n    virtual const NFCreatureVisionData &GetVisionData() const { return m_visionData; }\n\n    //视野类接口\n    virtual void UpdateSeeLst();\n\n    virtual void UpdateNineGridLst();\n\n    virtual void GetVisibleDataToClient(proto_ff::CreatureCreateData &cvData) {};  //获取客户端可见数据\n\n    //更新生物视野数据(生物视野数据变更，需要通知周围已经看到了他们的玩家)\n    virtual void UpdateViewData() {};\n\n    //用于重连上后，再重新发送一次全体视野信息。\n    void SendAllSeeCreatureListToClient();\n\n    void NoticeNineGridLeave();\n\npublic:\n    //判断是否能发送消息\n    bool IsCanSendMessage();\n\n    //设置能否被看见\n    void SetCanBeSeenFlag(bool isCanBeSeen);\n\n    //获取能否被看见\n    bool GetCanBeSeenFlag();\n\npublic:\n    //////////////////////////////////////////////////////////////////////////\n    //增加属性 主要是为了增加虚拟物品相关的属性 costFlag:是否是扣除属性\n    virtual void AddVirAttr(MAP_UINT32_INT64 &mapAttr, bool costFlag = false, SCommonSource *pSource = nullptr, bool syn = false) {};\n\n    //属性是否足够，主要是为了属性虚拟物品的判断\n    virtual bool EnoughVirAttr(MAP_UINT32_INT64 &mapAttr) { return false; };\n\n    //增加属性\n    virtual bool AddAttr(uint32_t ANum, int64_t attrValue, SCommonSource *pSource = nullptr, bool syn = false);\n\n    //增加属性 不同步到客户端\n    virtual bool AddAttrCache(uint32_t ANum, int64_t attrValue, SCommonSource *pSource = nullptr);\n\n    //能否增加属性\n    virtual bool CanAddAttr(uint32_t ANum, int64_t attrValue, SCommonSource *pSource = nullptr) { return true; };\n\n    //增加属性处理\n    virtual void OnAddAttr(uint32_t ANum, int64_t oldVal, int64_t attrValue, int64_t newVal, SCommonSource *pSource = nullptr) {};\n\n    //设置属性\n    virtual bool SetAttr(uint32_t ANum, int64_t attrValue, SCommonSource *pSource = nullptr, bool syn = false);\n\n    //设置属性 不同步客户端\n    virtual bool SetAttrCache(uint32_t ANum, int64_t attrValue, SCommonSource *pSource = nullptr);\n\n    //能否设置属性\n    virtual bool CanSetAttr(uint32_t ANum, int64_t attrValue, SCommonSource *pSource = nullptr) { return true; };\n\n    //设置属性处理\n    virtual void OnSetAttr(uint32_t ANum, int64_t oldVal, int64_t attrValue, int64_t newVal, SCommonSource *pSource = nullptr) {};\n\n\n    //获取该组属性值\n    virtual int64_t GetAttrGroup(uint32_t attrGroup, uint32_t ANum);\n\n    //获取该组所有属性值\n    virtual void GetAttrGroup(uint32_t attrGroup, MAP_UINT32_INT64 &mapattr);\n\n    //清除某一组属性\n    virtual bool ClearAttrGroup(uint32_t attrGroup, SCommonSource *pSource = nullptr, bool syn = false);\n\n    virtual bool ClearAttrGroupCache(uint32_t attrGroup, SCommonSource *pSource = nullptr);\n\n    //增加属性组属性\n    virtual bool AddAttrGroup(uint32_t attrGroup, uint32_t ANum, int64_t val, SCommonSource *pSource = nullptr, bool syn = false);\n\n    virtual bool AddAttrGroupCache(uint32_t attrGroup, uint32_t ANum, int64_t val, SCommonSource *pSource = nullptr);\n\n    //设置属性组属性\n    virtual bool SetAttrGroup(uint32_t attrGroup, uint32_t ANum, int64_t val, SCommonSource *pSource = nullptr, bool syn = false);\n\n    virtual bool SetAttrGroupCache(uint32_t attrGroup, uint32_t ANum, int64_t val, SCommonSource *pSource = nullptr);\n\n\n    //计算属性\n    virtual void CalcAttr(uint32_t ANum);\n\n    //计算属性组属性 主要是把属性组中的属性汇总到总属性中 ANum:属性组中的属性ID\n    virtual void CalcAttrGroup(uint32_t attrgroup, uint32_t ANum, MAP_UINT32_INT64 &mapchg);\n\n    //获取属性值\n    virtual int64_t GetAttr(uint32_t ANum);\n\n    //属性改变\n    virtual void OnAttrChange(int32_t ANum, int64_t oldVal, int64_t newVal, SCommonSource *pSource = nullptr);\n\n    //同步属性\n    virtual void SynAttrToClient();\n\npublic:\n    //是否可以添加新看到的生物\n    virtual bool CanAddSeeNewCreature(NFCreature *pCreature, int64_t hateValue);\n\npublic:\n    //获取对应部件指针\n    virtual NFBattlePart *GetPart(uint32_t partType) { return nullptr; }\n\npublic:\n    //****************消息发送接口*****************\n    virtual int BroadCast(uint32_t nMsgId, const google::protobuf::Message &xData, bool IncludeMyself = false);\n\n    virtual int SendRedirectMsgToClient(uint32_t zid, uint32_t gateId, const std::unordered_set<uint64_t> &set, uint32_t nMsgId,\n                                        const google::protobuf::Message &xData);\n\n    virtual int SendMsgToClient(uint32_t nMsgId, const google::protobuf::Message &xData);\n\n    virtual int SendMsgToSnsServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n    virtual int SendTransToSnsServer(uint32_t nMsgId, const google::protobuf::Message &xData, uint32_t reqTransId = 0, uint32_t rspTransId = 0);\n\n    virtual int SendMsgToWorldServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n    virtual int SendTransToWorldServer(uint32_t nMsgId, const google::protobuf::Message &xData, uint32_t reqTransId = 0, uint32_t rspTransId = 0);\n\n    virtual int SendMsgToLogicServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n    virtual int SendTransToLogicServer(uint32_t nMsgId, const google::protobuf::Message &xData, uint32_t reqTransId = 0, uint32_t rspTransId = 0);\n\n    virtual int FireLogic(uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message &message, bool self = false);\n\nprotected:\n    uint64_t m_cid;     //生物实例id\n    uint32_t m_kind;     //实体类型\n\n    NFPoint3<float> m_pos;                   //当前生物坐标\n    uint64_t m_sceneId;                //场景id\n    uint64_t m_mapId;                  //地图模板id\n\n    NFCreatureVisionData m_visionData;    //视野数据\n    float m_sightRange;                //可见视野范围长度\n    float m_fRadius;                    //人物半径\n\n    uint32_t m_seeInterval;                //视野更新间隔(毫秒)\n    uint64_t m_lastSeeTime;                //上次更新视野时间\n    uint64_t m_lastUpdateNineTime;        //上次更新9宫格时间\n\n\n    NFPoint2<uint32_t> m_gridPos;             //生物在地图中的格子\n    NFPoint2<uint32_t> m_littleGrid;\n\n    NFPoint3<float> m_dir;                    //运动方向,单位向量\n    bool m_destory;            //是否要回收\n    bool m_bCanBeSeen;        //是否被见\n    CreatureState m_state;                    //状态\n\n    NFShmPtr<IFightAttr> m_pFightAttr;        //战斗属性\n    NFShmPtr<IAttr> m_pAttr;                //普通属性\n\n    NFShmHashMap<uint32_t, int64_t, 100> m_attrCache;            //需要同步单个客户端属性缓存\n    NFShmHashMap<uint32_t, int64_t, 100> m_attrBroadCache;        //需要广播属性缓存\nDECLARE_IDCREATE(NFCreature)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreature.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreature.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreature.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreature.h	(date 1688616543226)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFShmPtr.h"
 #include "NFComm/NFShmCore/NFShmNodeList.h"
Index: game/MMO/NFLogicComm/DescStoreEx/NFRoleDescStoreEx.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFRoleDescStoreEx.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-30\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFRoleDescStoreEx\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFServerComm/NFDescStorePlugin/NFIDescStore.h\"\n#include \"NFLogicCommon/NFDescStoreTypeDefines.h\"\n\nclass NFRoleDescStoreEx : public NFIDescStore\n{\npublic:\n    NFRoleDescStoreEx();\n\n    virtual ~NFRoleDescStoreEx();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    //获取最大等级\n    uint32_t MaxLevel() { return m_maxLevel; }\nprivate:\n    uint32_t m_maxLevel;\nDECLARE_IDCREATE(NFRoleDescStoreEx)\nIMPL_RES_SIMPLE_DESC(NFRoleDescStoreEx);\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFLogicComm/DescStoreEx/NFRoleDescStoreEx.h b/game/MMO/NFLogicComm/DescStoreEx/NFRoleDescStoreEx.h
--- a/game/MMO/NFLogicComm/DescStoreEx/NFRoleDescStoreEx.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFLogicComm/DescStoreEx/NFRoleDescStoreEx.h	(date 1688616542969)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFServerComm/NFDescStorePlugin/NFIDescStore.h"
 #include "NFLogicCommon/NFDescStoreTypeDefines.h"
Index: game/MMO/NFLogicComm/DescStoreEx/NFAttrMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFAttrMgr.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-19\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFAttrMgr\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFShmStaticList.hpp\"\n#include \"NFComm/NFShmStl/NFShmHashSet.h\"\n#include \"Com.pb.h\"\n#include \"NFAttr.h\"\n\nclass NFAttrMgr : public NFShmObj\n{\npublic:\n    NFAttrMgr();\n\n    virtual ~NFAttrMgr();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    bool Init();   //初始化\n    bool UnInit();\npublic:\n    //是否是战斗属性ID\n    bool ValidFightAttrId(uint32_t ANum);\n\n    //是否是普通属性ID\n    bool ValidCommonAttrId(uint32_t ANum);\n\n\n    //是否是 通用战斗属性ID\n    bool IsComFightAttr(uint32_t ANum);\n\n    //是否是通用的战斗属性组ID\n    bool IsComFightAttrGroup(uint32_t groupid);\n\n    //根据 战斗属性ID获取 通用战斗属性数组的索引\n    uint8_t GetComFightIndex(uint32_t ANum);\n\n    //根据 通用战斗属性数组的索引 获取 战斗属性ID\n    uint32_t GetComFightAttr(uint8_t index);\n\n\n    //是否是 角色战斗属性ID\n    bool IsRoleFightAttr(uint32_t ANum);\n\n    //是否是 角色战斗属性组ID\n    bool IsRoleFightAttrGroup(uint32_t groupid);\n\n    //根据 战斗属性ID获取 角色战斗属性数组的索引\n    uint8_t GetRoleFightIndex(uint32_t ANum);\n\n    //根据 角色战斗属性数组的索引 获取 战斗属性ID\n    uint32_t GetRoleFightAttr(uint8_t index);\n\n    //是否是通用  普通属性ID\n    bool IsComAttr(uint32_t ANum);\n\n    //根据属性ID 获取普通属性数组的索引\n    uint16_t GetComIndex(uint32_t ANum);\n\n    //根据 普通属性数组的索引 获取属性ID\n    uint32_t GetComAttr(uint16_t index);\n\n\n    //是否是角色  普通属性ID\n    bool IsRoleAttr(uint32_t ANum);\n\n    //根据属性ID 获取角色 普通属性数组的索引\n    uint16_t GetRoleIndex(uint32_t ANum);\n\n    //根据 角色普通属性数组的索引 获取属性ID\n    uint32_t GetRoleAttr(uint16_t index);\n\n    //\n    IFightAttr *MakeFightAttrObj(EAttrType type);\n\n    void FreeFightAttrObj(IFightAttr *obj);\n\n    IAttr *MakeAttrObj(EAttrType type);\n\n    void FreeAttrObj(IAttr *obj);\n\npublic:\n    //是否需要同步到客户端的属性\n    bool IsSynClient(uint32_t ANum);\n\n    //是否需要广播到客户端\n    bool IsBroadClient(uint32_t ANum);\n\n    //获取玩家视野数据中用到的属性ID\n    const NFShmHashSet<int32_t, proto_ff::A_COMMON_END> &PlayerViewAttr();\n\n    //获取怪物视野数据中用到的属性ID\n    const NFShmHashSet<int32_t, proto_ff::A_COMMON_END> &MonViewAttr();\n\n    //伙伴视野数据中用到的属性ID\n    const NFShmHashSet<int32_t, proto_ff::A_COMMON_END> &PartnerViewAttr();\n\n    //需要同步给的战斗服务器属性用到的 属性ID\n    const NFShmHashSet<int32_t, proto_ff::A_COMMON_END> &GameSyncAttr();\npublic:\n    //初始化战斗属性和索引之间的映射\n    bool InitFightAttrToIndex();\n\nprivate:\nprotected:\n    //同步到客户端的属性\n    //对应属性索引所在元素值为0表示不需要同步到客户端, 为1表示需要同步到客户端\n    int8_t m_arySynClient[proto_ff::A_COMMON_END];\n    //需要广播到客户端的属性\n    int8_t m_aryBroadClient[proto_ff::A_COMMON_END];\n    //玩家视野数据中用到的 属性ID\n    NFShmHashSet<int32_t, proto_ff::A_COMMON_END> m_setPlayerViewAttr;\n    //怪物视野数据中用到的 属性ID\n    NFShmHashSet<int32_t, proto_ff::A_COMMON_END> m_setMonsViewAttr;\n    //伙伴视野数据中用到的 属性ID\n    NFShmHashSet<int32_t, proto_ff::A_COMMON_END> m_setPartnerViewAttr;\n    //需要同步给的战斗服务器属性用到的 属性ID\n    NFShmHashSet<int32_t, proto_ff::A_COMMON_END> m_setGameSyncAttr;\n\n    //通用的 配置表中的 战斗属性ID 和 程序中使用的 通用战斗属性数组的索引 之间的映射\n    uint8_t m_comIdToIndex[proto_ff::A_FIGHT_END];\n    uint8_t m_comIndexToId[proto_ff::A_FIGHT_END];\n\n    //配置表中的 战斗属性 和 程序中使用的 角色战斗属性数组的索引 之间的映射\n    uint8_t m_roleIdToIndex[proto_ff::A_FIGHT_END];\n    uint8_t m_roleIndexToId[proto_ff::A_FIGHT_END];\n\n    //通用的 配置表中的 普通属性ID 和 程序中使用的 通用普通属性数组的索引 之间的映射\n    uint16_t m_comNormal_IdToIndex[proto_ff::A_COMMON_END];\n    uint16_t m_comNormal_IndexToId[proto_ff::A_COMMON_END];\n\n    //配置表中的 普通属性ID 和 程序中使用的 角色普通属性数组的索引 之间的映射\n    uint16_t m_roleNormal_IdToIndex[proto_ff::A_COMMON_END];\n    uint16_t m_roleNormal_IndexToId[proto_ff::A_COMMON_END];\nDECLARE_IDCREATE(NFAttrMgr)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFLogicComm/DescStoreEx/NFAttrMgr.h b/game/MMO/NFLogicComm/DescStoreEx/NFAttrMgr.h
--- a/game/MMO/NFLogicComm/DescStoreEx/NFAttrMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFLogicComm/DescStoreEx/NFAttrMgr.h	(date 1688616543317)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFShmStaticList.hpp"
 #include "NFComm/NFShmStl/NFShmHashSet.h"
Index: game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureVisionData.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFCreatureVisionData.h\n//    @Author           :    gaoyi\n//    @Date             :    23-2-25\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFCreatureVisionData\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFShmPtr.h\"\n#include \"NFComm/NFShmStl/NFShmList.h\"\n\nclass NFCreature;\n\n//视野标记\nenum class EVisionFlag\n{\n    NONE = 0,\t\t\t\t//无\n    ALREADY,\t\t\t\t//已经在视野里\n};\n\nenum\n{\n    NEW_SEE_VISION_NONE = 0,\n    NEW_SEE_VISION_SPECIAL_RELATIONSHIP = 1,\n    NEW_SEE_VISION_LESS_HALF_OF_HALF_MAX_SIGHT_RANGE = 2,\n    NEW_SEE_VISION_LESS_HALF_OF_MAX_SIGHT_RANGE = 3,\n    NEW_SEE_VISION_THAN_HALF_OF_MAX_SIGHT_RANGE = 4,\n    NEW_SEE_VISION_MAX,\n};\n\n//生物功能类型\nenum class ECreatureFunc\n{\n    Monster = 101,\t\t\t\t\t//怪物\n    Npc = 201,\t\t\t\t\t\t//常驻NPC\n    TaskNpc = 202,\t\t\t\t\t//任务NPC\n    Collect = 301,\t\t\t\t\t//采集物\n    Collect_Box = 302,\t\t\t\t//采集物 宝箱\n    Collect_Buff = 304,\t\t\t\t//带BUFF的采集物\n    UseThing = 401,\t\t\t\t\t//可使用物件\n    DartCar = 501,\t\t\t\t\t//镖车\n    Transfer = 601,\t\t\t\t\t//传送门\n};\n\n#define MAX_SEE_CREATURE_COUNT_IN_THE_VISION 100\n\nclass NFCreatureVisionDataNode\n{\npublic:\n    NFCreatureVisionDataNode();\n\n    virtual ~NFCreatureVisionDataNode();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    uint64_t creatureCid;\n    int nMeInHisVisionPos;\n};\n\nclass NFCreatureVisionData\n{\npublic:\n    NFCreatureVisionData();\n\n    virtual ~NFCreatureVisionData();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    int AddPVPSeeList(NFCreature* pCreature);\n    int AddPVMSeeList(NFCreature* pCreature);\n    bool DelPVMSeeList(int pos);\n    bool DelPVPSeeList(int pos);\npublic:\n    NFShmList<NFCreatureVisionDataNode, MAX_SEE_CREATURE_COUNT_IN_THE_VISION>\tm_doublePVPSeeLst;\t\t\t\t\t\t\t\t//人和人的视野处理\n    NFShmList<NFCreatureVisionDataNode, MAX_SEE_CREATURE_COUNT_IN_THE_VISION>\tm_doublePVMSeeLst;\t\t\t\t\t\t\t\t//这里只处理人和其他非人生物之间的视野管理， 怪物或NPC必须所有人都能看到\n    int8_t\tchVisionUnitType;\t\t//用于记录此角色视野单元在进入别人视野处理的标记\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureVisionData.h b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureVisionData.h
--- a/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureVisionData.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFGameServer/NFBattlePlugin/Creature/NFCreatureVisionData.h	(date 1688616543188)
@@ -12,7 +12,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFShmPtr.h"
 #include "NFComm/NFShmStl/NFShmList.h"
Index: game/Fish/NFLogicComm/NFLogicCommon/NFLogicShmTypeDefines.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFLogicComm/NFLogicCommon/NFLogicShmTypeDefines.h b/game/Fish/NFLogicComm/NFLogicCommon/NFLogicShmTypeDefines.h
new file mode 100644
--- /dev/null	(date 1688607720892)
+++ b/game/Fish/NFLogicComm/NFLogicCommon/NFLogicShmTypeDefines.h	(date 1688607720892)
@@ -0,0 +1,53 @@
+// -------------------------------------------------------------------------
+//    @FileName         :    NFServerFrameTypeDefines.h
+//    @Author           :    Gao.Yi
+//    @Date             :   2022-09-18
+//    @Email			:    445267987@qq.com
+//    @Module           :    NFPluginModule
+//
+// -------------------------------------------------------------------------
+
+#pragma once
+
+#include "NFComm/NFShmCore/NFTypeDefines.h"
+
+
+typedef enum
+{
+	EOT_SF_BEGIN_ID = EOT_SERVER_FRAME_BEGIN_ID,
+    ////////////////////////////server common////////////////////////////////////////////////
+
+    ////////////////////////////server common////////////////////////////////////////////////
+
+	////////////////////////////sns server/////////////////////////////
+
+    ////////////////////////////sns trans server/////////////////////////////
+
+    ////////////////////////////sns server/////////////////////////////
+
+	////////////////////////////sns server/////////////////////////////
+
+	////////////////////////////logic server/////////////////////////////
+
+    //////////////////////////logic part////////////////////////
+
+    //////////////////////////logic trans////////////////////////
+
+	////////////////////////////logic server/////////////////////////////
+
+	////////////////////////////login server/////////////////////////////
+    EOT_ACCOUNTLOGIN_HASHTABLE_ID,
+	////////////////////////////login server/////////////////////////////
+	////////////////////////////world server/////////////////////////////
+
+    ////////////////////////////world server trans/////////////////////////////
+
+    ////////////////////////////world server trans/////////////////////////////
+	////////////////////////////world server/////////////////////////////
+
+	////////////////////////////game server/////////////////////////////
+
+    ////////////////////////////game server/////////////////////////////
+	///////////////////////////////////////////////////////////
+	EOT_SF_END_ID = EOT_SERVER_FRAME_END_ID,
+} EN_SERVERFRAME_SHMOBJ_TYPE;
Index: game/Fish/NFServerLogic/NFLoginServer/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFServerLogic/NFLoginServer/CMakeLists.txt b/game/Fish/NFServerLogic/NFLoginServer/CMakeLists.txt
new file mode 100644
--- /dev/null	(date 1669600775613)
+++ b/game/Fish/NFServerLogic/NFLoginServer/CMakeLists.txt	(date 1669600775613)
@@ -0,0 +1,3 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
+
+ADD_SUBDIRECTORY("NFLoginServerPlayerPlugin")
Index: game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/CMakeLists.txt b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/CMakeLists.txt
new file mode 100644
--- /dev/null	(date 1688609641652)
+++ b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/CMakeLists.txt	(date 1688609641652)
@@ -0,0 +1,23 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
+PROJECT(NFFishLoginPlayerPlugin)
+
+AUX_SOURCE_DIRECTORY(. SRC)
+
+if (CMAKE_BUILD_TYPE STREQUAL "Release")
+	SET(LIBRARY_OUTPUT_PATH "${CMAKE_SOURCE_DIR}/Build/Lib/Release")
+	ADD_LIBRARY( ${PROJECT_NAME} STATIC ${SRC} )
+elseif(CMAKE_BUILD_TYPE STREQUAL "Debug")
+	SET(LIBRARY_OUTPUT_PATH "${CMAKE_SOURCE_DIR}/Build/Lib/Debug")
+	ADD_LIBRARY( ${PROJECT_NAME} STATIC ${SRC} )
+elseif (CMAKE_BUILD_TYPE STREQUAL "DynamicRelease")
+	SET(LIBRARY_OUTPUT_PATH "${CMAKE_SOURCE_DIR}/Install/Bin/Dynamic_Release")
+	ADD_LIBRARY( ${PROJECT_NAME} SHARED ${SRC} )
+	TARGET_LINK_LIBRARIES(${PROJECT_NAME} NFServerMessage NFServerCommon NFServerLogicMessage NFLogicCommon NFDescStore)
+elseif(CMAKE_BUILD_TYPE STREQUAL "DynamicDebug")
+	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Werror")
+	SET(LIBRARY_OUTPUT_PATH "${CMAKE_SOURCE_DIR}/Install/Bin/Dynamic_Debug")
+	ADD_LIBRARY( ${PROJECT_NAME} SHARED ${SRC} )
+	TARGET_LINK_LIBRARIES(${PROJECT_NAME} NFServerMessage NFServerCommon NFServerLogicMessage NFLogicCommon NFDescStore)
+endif()
+
+
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Base/NFTransPlayerBase.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransPlayerBase.cpp\n//    @Author           :    gaoyi\n//    @Date             :    2022/10/14\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransPlayerBase\n//\n// -------------------------------------------------------------------------\n\n#include <proto_svr_logic_error.pb.h>\n#include \"NFTransPlayerBase.h\"\n\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include \"NFComm/NFKernelMessage/storesvr_sqldata.pb.h\"\n#include \"NFLogicCommon/NFICommLogicModule.h\"\n#include \"Player/NFPlayer.h\"\n#include \"Player/NFPlayerMgr.h\"\n#include \"ServerInternalCmd2.pb.h\"\n\nIMPLEMENT_IDCREATE_WITHTYPE(NFTransPlayerBase, EOT_TRANS_LOGIC_PLAYER_BASE, NFTransBase)\n\nNFTransPlayerBase::NFTransPlayerBase() : NFTransBase()\n{\n    if (NFShmMgr::Instance()->GetCreateMode() == EN_OBJ_MODE_INIT)\n    {\n        CreateInit();\n    }\n    else\n    {\n        ResumeInit();\n    }\n}\n\nNFTransPlayerBase::~NFTransPlayerBase()\n{\n\n}\n\nint NFTransPlayerBase::CreateInit()\n{\n    m_uid = 0;\n    m_roleId = 0;\n    m_cmd = 0;\n    m_fromBusId = 0;\n    m_bHasIncreasedCount = false;\n    m_reqTransId = 0;\n    return 0;\n}\n\nint NFTransPlayerBase::ResumeInit()\n{\n    return 0;\n}\n\nint NFTransPlayerBase::Init(uint64_t roleId, uint64_t uid, uint32_t cmd, uint32_t fromBusId, uint32_t reqTransId)\n{\n    m_uid = uid;\n    return Init(roleId, cmd, fromBusId, reqTransId);\n}\n\nint NFTransPlayerBase::Init(uint64_t roleId, uint32_t cmd, uint32_t fromBusId, uint32_t reqTransId)\n{\n    m_roleId = roleId;\n    m_cmd = cmd;\n    m_fromBusId = fromBusId;\n    m_reqTransId = reqTransId;\n\n    if (!m_bHasIncreasedCount)\n    {\n        NFPlayer *pPlayer = GetPlayer();\n        if (pPlayer)\n        {\n            pPlayer->IncreaseTransNum();\n            m_bHasIncreasedCount = true;\n        }\n    }\n    return 0;\n}\n\nint NFTransPlayerBase::Init(NFPlayer *pPlayer, uint32_t cmd, uint32_t fromBusId, uint32_t reqTransId)\n{\n    CHECK_NULL(pPlayer);\n\n    m_uid = pPlayer->GetUid();\n    m_roleId = pPlayer->GetRoleId();\n    m_cmd = cmd;\n    m_fromBusId = fromBusId;\n    m_reqTransId = reqTransId;\n\n    if (!m_bHasIncreasedCount)\n    {\n        pPlayer->IncreaseTransNum();\n        m_bHasIncreasedCount = true;\n    }\n    return 0;\n}\n\nNFPlayer *NFTransPlayerBase::GetPlayer()\n{\n    return NFPlayerMgr::Instance(m_pObjPluginManager)->GetPlayer(m_roleId);\n}\n\nint NFTransPlayerBase::OnTimeOut()\n{\n    NFPlayer *pPlayer = GetPlayer();\n    if (pPlayer && m_bHasIncreasedCount)\n    {\n        pPlayer->DecreaseTransNum();\n        m_bHasIncreasedCount = false;\n    }\n\n    SetFinished(proto_ff::ERR_CODE_SVR_SYSTEM_TIMEOUT);\n\n    NFLogError(NF_LOG_SYSTEMLOG, m_uid, \"NFTransPlayerBase timeout, playerId:{}, roleId:{} cmd:{}, transid:{}\",\n               m_uid, m_roleId, m_cmd, m_reqTransId);\n    return 0;\n}\n\nint NFTransPlayerBase::OnTransFinished(int iRunLogicRetCode)\n{\n    NFPlayer *pPlayer = GetPlayer();\n    if (!pPlayer)\n    {\n        if (m_cmd != proto_ff::WORLD_TO_LOGIC_GET_ROLE_LIST_REQ &&\n            m_cmd != proto_ff::WORLD_TO_LOGIC_CREATE_ROLE_INFO_REQ &&\n            m_cmd != 0)\n        {\n            NFLogInfo(NF_LOG_SYSTEMLOG, m_uid, \"GetPlayerByUid, this player may off line! cmd:{}\", m_cmd);\n        }\n        return 0;\n    }\n\n    if (m_bHasIncreasedCount)\n    {\n        pPlayer->DecreaseTransNum();\n        m_bHasIncreasedCount = false;\n    }\n\n    if (0 == iRunLogicRetCode)\n    {\n        return 0;\n    }\n\n    NFLogDebug(NF_LOG_SYSTEMLOG, m_uid, \"playerId:{} roleId:{} failed errcode={}, msgid={} info:{}\", m_uid, m_roleId,\n               iRunLogicRetCode, m_cmd, DebugString());\n\n    if (0 == m_cmd)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, m_uid,\n                   \"Server should not call this function because request head uninitialized, playerId:{} roleId:{} info:{}\", m_uid, m_roleId, DebugString());\n\n        return -1;\n    }\n\n    if (iRunLogicRetCode && iRunLogicRetCode != -1)\n    {\n        //pPlayer->SendErrToClient(m_cmd, (proto_ff::Proto_CS_ErrorCode)iRunLogicRetCode);\n    }\n\n    return 0;\n}\n\nstd::string NFTransPlayerBase::DebugString() const\n{\n    return NF_FORMAT(\"uid:{} roleId:{} cmd:{} NFTransBase:{}\", m_uid, m_roleId, m_cmd, NFTransBase::DebugString());\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Base/NFTransPlayerBase.cpp b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Base/NFTransPlayerBase.cpp
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Base/NFTransPlayerBase.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Base/NFTransPlayerBase.cpp	(date 1688616543079)
@@ -10,7 +10,7 @@
 #include <proto_svr_logic_error.pb.h>
 #include "NFTransPlayerBase.h"
 
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFPluginModule/NFLogMgr.h"
 #include "NFComm/NFPluginModule/NFCheck.h"
 #include "NFComm/NFPluginModule/NFIMessageModule.h"
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFPart.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFPart.h\n//    @Author           :    gaoyi\n//    @Date             :    22-10-31\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFPart\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFSeqOP.h\"\n#include \"NFComm/NFCore/NFTime.h\"\n#include \"DBProto.pb.h\"\n#include \"CSPlayer.pb.h\"\n#include \"NFComm/NFShmCore/NFShmPtr.h\"\n#include \"DBProto2.pb.h\"\n\nclass NFPlayer;\n\nclass NFPart : public NFShmObj, public NFSeqOP\n{\npublic:\n    NFPart();\n\n    virtual ~NFPart();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    //******************part调用生物接口******************\n    //生物init调用\n    virtual int Init(NFPlayer *pMaster, uint32_t partType, const proto_ff::RoleDBData &dbData);\n\n    //生物uint调用\n    virtual int UnInit();\n\npublic:\n    /**\n     * @brief 存储DB部件入口\n     * @param proto\n     * @return\n     */\n    virtual int SaveDB(proto_ff::RoleDBData &dbData) { return 0; }\n\n    /**\n     * @brief 登陆入口\n     * @return\n     */\n    virtual int OnLogin() { return 0; }\n\n    /**\n     * @brief  登陆入口\n     * @param playerInfo\n     * @return\n     */\n    virtual int OnLogin(proto_ff::PlayerInfoRsp &playerInfo) { return 0; };\n\n    /**\n     * @brief 登出入口\n     * @return\n     */\n    virtual int OnLogout() { return 0; }\n\n    /**\n     * @brief 掉线入口\n     * @return\n     */\n    virtual int OnDisconnect() { return 0; }\n\n    /**\n     * @brief 重连入口\n     * @return\n     */\n    virtual int OnReconnect() { return 0; }\n\n    /**\n     * @brief\n     * @param outproto\n     */\n    virtual void SetFacadeProto(proto_ff::RoleFacadeProto &outproto) {}\n\n    /**\n     * @brief 进入场景携带的数据\n     * @param outproto\n     */\n    virtual void SetEnterSceneProto(proto_ff::RoleEnterSceneData& outproto) { }\n\n    ////////////////////////////////// 每日每周刷新接口 ///////////////////////////////////\n    /**\n     * @brief 每日刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int DailyUpdate(uint64_t unixSec) { return 0; }\n\n    /**\n     * @brief 每周刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int WeekUpdate(uint64_t unixSec) { return 0; }\n    ////////////////////////////////// 每日零点 每周一零点 刷新接口 ///////////////////////////////////\n    /**\n     * @brief 每日零点 刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int DailyZeroUpdate(uint64_t unixSec) { return 0; }\n\n    /**\n     * @brief 每日零点 刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int WeekZeroUpdate(uint64_t unixSec) { return 0; }\n\npublic:\n    /**\n     * @brief update\n     * @param tick\n     */\n    virtual int Update(uint64_t tick) { return 0; }\n\npublic:\n    /**\n     * @brief 处理客户端消息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleClientMessage(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 处理来自服务器的信息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleServerMessage(uint32_t msgId, NFDataPackage &packet);\n\npublic:\n    static int RegisterClientPartMsg(NFIPluginManager *pPluginManager, uint32_t nMsgID, uint32_t partType);\n\n    static int RegisterServerPartMsg(NFIPluginManager *pPluginManager, uint32_t nMsgID, uint32_t partType);\n\npublic:\n    //部件类型\n    uint32_t PartType() { return m_partType; }\npublic:\n    virtual uint32_t GetCurRoleDetailSeq() const;\nprotected:\n    NFShmPtr<NFPlayer> m_pMaster;\n    uint32_t m_partType;\nprivate:\nDECLARE_IDCREATE(NFPart)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFPart.h b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFPart.h
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFPart.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFPart.h	(date 1688616542989)
@@ -15,7 +15,7 @@
 #include "NFComm/NFShmCore/NFShmMgr.h"
 
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFSeqOP.h"
 #include "NFComm/NFCore/NFTime.h"
 #include "DBProto.pb.h"
Index: game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.h b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.h
new file mode 100644
--- /dev/null	(date 1688629233446)
+++ b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.h	(date 1688629233446)
@@ -0,0 +1,75 @@
+// -------------------------------------------------------------------------
+//    @FileName         :    NFAccountLoginMgr.h
+//    @Author           :    gaoyi
+//    @Date             :    23-7-6
+//    @Email			:    445267987@qq.com
+//    @Module           :    NFAccountLoginMgr
+//
+// -------------------------------------------------------------------------
+
+#pragma once
+
+#include "NFComm/NFShmCore/NFShmObj.h"
+#include "NFComm/NFShmCore/NFShmString.h"
+#include "NFComm/NFShmStl/NFShmHashMapWithList.h"
+#include "NFLogicCommon/NFLoginDefine.h"
+
+
+class NFAccountLogin
+{
+public:
+	NFAccountLogin();
+	virtual ~NFAccountLogin();
+    int CreateInit();
+    int ResumeInit();
+
+public:
+    NFCommonStr  mAccount;
+    NFCommonStr  mPassword;
+    NFCommonStr  mDeviceId;
+    uint64_t mPhoneNum;
+	uint64_t mPlayerId;
+	uint64_t mLastLoginTime;
+	uint32_t mAccountType;
+};
+
+class NFAccountLoginMgr: public NFShmObj
+{
+public:
+	NFAccountLoginMgr();
+
+	virtual ~NFAccountLoginMgr();
+
+	int CreateInit();
+	int ResumeInit();
+
+    //must be virtual
+    virtual int OnTimer(int timeId, int callcount);
+
+    int Tick();
+
+    int ClearOne();
+
+    /**
+     * @brief 查找账号数据
+     * @param account
+     * @return
+     */
+    NFAccountLogin* FindAccount(const std::string& account);
+
+    /**
+     * @brief 创建账号
+     * @param account
+     * @param password
+     * @param playerId
+     * @param accountType
+     * @param deviceId
+     * @param phonenum
+     * @return
+     */
+    NFAccountLogin *CreateAccount(const std::string& account, const std::string& password, uint64_t playerId, uint32_t accountType, const std::string& deviceId, uint64_t phonenum);
+private:
+    int m_timerId;
+    NFShmHashMapWithList<NFCommonStr, NFAccountLogin, ONE_LOGIN_SERVER_MAX_LOGIN_ACCOUNT> m_accountMap;
+	DECLARE_IDCREATE(NFAccountLoginMgr)
+};
Index: game/Fish/NFServerLogic/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)\n\nADD_SUBDIRECTORY(\"NFProxyServer\")\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFServerLogic/CMakeLists.txt b/game/Fish/NFServerLogic/CMakeLists.txt
--- a/game/Fish/NFServerLogic/CMakeLists.txt	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/Fish/NFServerLogic/CMakeLists.txt	(date 1688605207957)
@@ -1,6 +1,7 @@
 CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
 
 ADD_SUBDIRECTORY("NFProxyServer")
+ADD_SUBDIRECTORY("NFLoginServer")
 
 
 
Index: game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.cpp b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.cpp
new file mode 100644
--- /dev/null	(date 1688631321515)
+++ b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.cpp	(date 1688631321515)
@@ -0,0 +1,159 @@
+// -------------------------------------------------------------------------
+//    @FileName         :    NFAccountLoginMgr.h
+//    @Author           :    gaoyi
+//    @Date             :    23-7-6
+//    @Email			:    445267987@qq.com
+//    @Module           :    NFAccountLoginMgr
+//
+// -------------------------------------------------------------------------
+
+#include "NFAccountLoginMgr.h"
+#include "NFComm/NFCore/NFHash.hpp"
+#include "NFComm/NFCore/NFTime.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
+
+IMPLEMENT_IDCREATE_WITHTYPE(NFAccountLoginMgr, EOT_ACCOUNTLOGIN_HASHTABLE_ID, NFShmObj)
+
+NFAccountLogin::NFAccountLogin()
+{
+    if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode())
+    {
+        CreateInit();
+    }
+    else
+    {
+        ResumeInit();
+    }
+}
+
+NFAccountLogin::~NFAccountLogin()
+{
+
+}
+
+int NFAccountLogin::CreateInit()
+{
+    mPlayerId = 0;
+    mLastLoginTime = NFTime::Now().UnixSec();
+    mAccountType = 0;
+    mPhoneNum = 0;
+    return 0;
+}
+
+
+int NFAccountLogin::ResumeInit()
+{
+    return 0;
+}
+
+NFAccountLoginMgr::NFAccountLoginMgr()
+{
+	if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode())
+	{
+		CreateInit();
+	}
+	else
+	{
+		ResumeInit();
+	}
+}
+
+NFAccountLoginMgr::~NFAccountLoginMgr()
+{
+    if (m_timerId != INVALID_ID)
+    {
+        DeleteTimer(m_timerId);
+        m_timerId = INVALID_ID;
+    }
+}
+
+int NFAccountLoginMgr::CreateInit()
+{
+    m_timerId = INVALID_ID;
+
+    m_timerId = SetTimer(100, 0, 0, 0, 10, 0);
+
+	return 0;
+}
+
+
+int NFAccountLoginMgr::ResumeInit()
+{
+	return 0;
+}
+
+int NFAccountLoginMgr::OnTimer(int timeId, int callcount)
+{
+    Tick();
+    return 0;
+}
+
+int NFAccountLoginMgr::Tick()
+{
+    uint64_t now = NFTime::Now().UnixSec();
+    for(auto iter = m_accountMap.begin(); iter != m_accountMap.end(); )
+    {
+        if (now - iter->second.mLastLoginTime >= MAX_ACCOUNT_EXIST_TIME)
+        {
+            iter = m_accountMap.erase(iter);
+        }
+        else {
+            iter++;
+        }
+    }
+    return 0;
+}
+
+int NFAccountLoginMgr::ClearOne()
+{
+    m_accountMap.auto_erase(1);
+    return 0;
+}
+
+NFAccountLogin* NFAccountLoginMgr::FindAccount(const std::string& account)
+{
+    auto iter = m_accountMap.find(account);
+    if (iter != m_accountMap.end())
+    {
+        return &iter->second;
+    }
+    return nullptr;
+}
+
+NFAccountLogin *NFAccountLoginMgr::CreateAccount(const std::string& account, const std::string& password, uint64_t playerId, uint32_t accountType, const std::string& deviceId, uint64_t phonenum)
+{
+    NFCommonStr strAccount;
+    strAccount = account;
+
+    if (m_accountMap.full())
+    {
+        ClearOne();
+    }
+
+    if (m_accountMap.full())
+    {
+        NFLogError(NF_LOG_SYSTEMLOG, 0, "m_accountMap full! CreateAccount:{} Failed!", account);
+        return NULL;
+    }
+
+    auto iter =  m_accountMap.emplace_hint(strAccount, NFAccountLogin());
+    if (iter == m_accountMap.end())
+    {
+        NFLogError(NF_LOG_SYSTEMLOG, 0, "m_accountMap.emplace_hint account:{} Failed", account);
+        return NULL;
+    }
+
+    NFAccountLogin* pLogin = &iter->second;
+
+    pLogin->mAccount = account;
+    pLogin->mPassword = password;
+    pLogin->mPlayerId = playerId;
+    pLogin->mAccountType = accountType;
+    pLogin->mLastLoginTime = NFTime::Now().UnixSec();
+    pLogin->mDeviceId = deviceId;
+    pLogin->mPhoneNum = phonenum;
+
+    return pLogin;
+}
+
+
Index: game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginModule.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginModule.h b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginModule.h
new file mode 100644
--- /dev/null	(date 1688621242167)
+++ b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginModule.h	(date 1688621242167)
@@ -0,0 +1,46 @@
+// -------------------------------------------------------------------------
+//    @FileName         :    NFCAccountLoginModule.h
+//    @Author           :    gaoyi
+//    @Date             :    23-7-6
+//    @Email			:    445267987@qq.com
+//    @Module           :    NFCAccountLoginModule
+//
+// -------------------------------------------------------------------------
+
+#pragma once
+
+#include "NFComm/NFPluginModule/NFIDynamicModule.h"
+#include "CSLogin.pb.h"
+
+class NFCAccountLoginModule : public NFIDynamicModule
+{
+public:
+	explicit NFCAccountLoginModule(NFIPluginManager* p);
+	virtual ~NFCAccountLoginModule();
+
+	virtual bool Awake() override;
+
+	virtual bool Execute() override;
+
+	virtual bool OnDynamicPlugin() override;
+
+    virtual int OnTimer(uint32_t nTimerID) override;
+public:
+    /**
+     * @brief 处理客户端消息
+     * @param unLinkId
+     * @param packet
+     * @return
+     */
+    virtual int OnHandleClientMessage(uint64_t unLinkId, NFDataPackage &packet) override;
+
+    /**
+     * @brief 处理来自服务器的信息
+     * @param unLinkId
+     * @param packet
+     * @return
+     */
+    virtual int OnHandleServerMessage(uint64_t unLinkId, NFDataPackage& packet) override;
+public:
+    int OnRpcServiceAccountLogin(proto_ff::Proto_CSAccountLoginReq& request, proto_ff::Proto_SCAccountLoginRsp& respone);
+};
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFMissionPart.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFMissionPart.h\n//    @Author           :    gaoyi\n//    @Date             :    23-2-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFMissionPart\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFPart.h\"\n#include \"NFLogicCommon/NFMissionDefine.h\"\n#include \"NFComm/NFShmStl/NFShmHashMap.h\"\n#include \"NFComm/NFShmStl/NFShmHashSet.h\"\n#include \"DescStoreEx/NFMissionDescStoreEx.h\"\n#include \"Part/Item/NFGridItem.h\"\n#include \"NFLogicCommon/NFComTypeDefine.h\"\n\n#define PLAYER_TRACK_MISSION_MAX_MISSION_COUNT MISSION_MAX_ACCEPT_NUM*2\n\nclass NFMissionPart : public NFPart\n{\npublic:\n    // eventtype - level - dynamicid\n    typedef NFShmHashMap<uint32_t, NFShmHashMap<int32_t, NFShmHashSet<uint64_t, PLAYER_TRACK_MISSION_MAX_MISSION_COUNT>,\n            PLAYER_TRACK_MISSION_MAX_MISSION_COUNT>, 10> EventTabal;\n\n\n    typedef NFShmHashMap<uint64_t, MissionTrack, PLAYER_TRACK_MISSION_MAX_MISSION_COUNT> PlayerTrackMissionMap;\n    typedef NFShmHashMap<int32_t, DyMissionTrack, NF_MISSION_TYPE_MAX_COUNT> PlayerDyMissionTrackMap;\npublic:\n    NFMissionPart();\n\n    virtual ~NFMissionPart();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    static int RegisterClientMessage(NFIPluginManager *pPluginManager);\n\n    static int RegisterServerMessage(NFIPluginManager *pPluginManager);\n\npublic:\npublic:\n    //******************part调用生物接口******************\n    //生物init调用\n    virtual int Init(NFPlayer *pMaster, uint32_t partType, const proto_ff::RoleDBData &dbData);\n\n    //生物uint调用\n    virtual int UnInit();\n\n    /**\n     * @brief 存储DB部件入口\n     * @param proto\n     * @return\n     */\n    virtual int SaveDB(proto_ff::RoleDBData &dbData);\n\n    /**\n     * @brief 登陆入口\n     * @return\n     */\n    virtual int OnLogin();\n\n    /**\n     * @brief  登陆入口\n     * @param playerInfo\n     * @return\n     */\n    virtual int OnLogin(proto_ff::PlayerInfoRsp &playerInfo);\n\npublic:\n    /**\n     * @brief 处理客户端消息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleClientMessage(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 处理来自服务器的信息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleServerMessage(uint32_t msgId, NFDataPackage &packet);\n\npublic:\n    /**\n     * @brief 检查主线任务\n     * @param notify\n     */\n    void CheckTrunkMission(bool notify = true);\n\npublic: //消息回调接口\n    /**\n     * @brief NPC接取任务\n     * @param msgId\n     * @param packet\n     */\n    int HandleNpcAcceptMission(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 提交任务\n     * @param msgId\n     * @param packet\n     */\n    int HandleSubmitMission(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief NPC对话,寻人接口\n     * @param msgId\n     * @param packet\n     */\n    int HandleTalkWithNpc(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 提交任务物品\n     * @param msgId\n     * @param packet\n     */\n    int HandleSubmitMissionGoods(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 一键完成任务\n     * @param msgId\n     * @param packet\n     */\n    int HandleOnekeyFinishMission(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 立即完成\n     * @param msgId\n     * @param packet\n     */\n    int HandleOnceFinishMission(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 领取特殊奖励\n     * @param msgId\n     * @param packet\n     */\n    int HandleMissionRecvSpecialReward(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 推送任务列表信息\n     * @param msgId\n     * @param packet\n     */\n    int SendMissionList(uint32_t msgId, NFDataPackage &packet);\n\n    void SendMissionInfo();\npublic:\n    /**\n     * @brief 接取任务\n     * @param missionId\n     * @param notify\n     * @return\n     */\n    int32_t OnAccept(uint64_t missionId, bool notify);\n\n    /** 接取任务\n     * @brief\n     * @param missionId\n     * @param kind\n     */\n    void OnAcceptType(uint64_t missionId, uint32_t kind);\n\n    /**\n     * @brief 获取可接任务列表(主支线)\n     * @param missionId\n     * @return\n     */\n    int32_t CanAccept(uint64_t missionId);\n\n    /**\n     * @brief 是否匹配接取任务的条件\n     * @param cond\n     * @param param\n     * @return\n     */\n    int32_t CanMatchAcceptCond(MissionInfo *pMissionInfo);\n\npublic:\n    /**\n     * @brief 接取动态任务\n     * @param missionId\n     * @param notify\n     * @return\n     */\n    int32_t OnAcceptDy(uint64_t missionId, bool notify);\n\n    /**\n     * @brief 接取任务(动态任务)\n     * @param dymissionId\n     * @param missionType\n     */\n    void OnAcceptDyType(uint64_t dymissionId, int32_t missionType);\n\n    /**\n     * @brief 是否能接取动态任务 dyCfgId:动态任务的配置ID\n     * @param dyCfgId\n     * @return\n     */\n    int32_t CanAcceptDy(uint64_t dyCfgId);\n\n    /**\n     * @brief\n     * @param pDyMissionInfo\n     * @return\n     */\n    int32_t CanAcceptDy(const DyMissionInfo *pDyMissionInfo);\n\n    /**\n     * @brief 添加动态任务接取次数\n     * @param missionType\n     * @param count\n     */\n    void OnAddAcceptDyCount(int32_t missionType, uint32_t count);\n\npublic:\n    /////////////////////////////////////////普通任务接口/////////////////////////////////////////////\n    /**\n     * @brief 通过任务类型接取任务\n     * @param missionType\n     * @param notify\n     * @return\n     */\n    int32_t AcceptMissionByType(int32_t missionType, bool notify);\n\n    /**\n     * @brief 能否通过任务类型接取任务\n     * @param missionType\n     * @return\n     */\n    int32_t CanAcceptMissionByType(int32_t missionType);\n\n    /**\n     * @brief 通过任务类型清除任务,返回清除的任务数量 notify：是否需要通知客户端删除任务\n     * @param missionType\n     * @param notify\n     * @return\n     */\n    int32_t ClearMissionByType(int32_t missionType, bool notify);\n\n\npublic:\n    /**\n     * @brief 获取任务最大环数\n     * @param missionType\n     * @param level\n     * @return\n     */\n    int32_t DyMaxCount(int32_t missionType, int32_t level);\n\n    /**\n     * @brief 根据任务类型获取动态任务已经接取次数\n     * @param missionType\n     * @return\n     */\n    uint32_t GetDyMissionAceeptCnt(int32_t missionType);\n\n    /**\n     * @brief 完成任务(动态任务)\n     * @param dymissionId\n     * @param dymissionType\n     */\n    void OnFinishDy(uint64_t dymissionId, uint32_t dymissionType);\n\n    /**\n     * @brief 根据任务类型获取动态任务记录信息\n     * @param missionType\n     * @return\n     */\n    DyMissionTrack *GetDyMissionTrack(int32_t missionType);\n\n    /**\n     * @brief 动态任务奖励\n     * @param missionType\n     * @param missionId\n     * @param missionReward\n     * @return\n     */\n    int32_t OnAddDyMissionReward(int32_t missionType, uint64_t missionId, SMissionReward &missionReward);\n\n    /**\n     * @brief 更新动态任务接取次数\n     * @param setMissionType\n     */\n    void NotifyDyAcceptCount(SET_UINT32 &setMissionType);\n\n    /**\n     * @brief 是否是有效的动态任务ID\n     * @param dyMissionId\n     * @return\n     */\n    bool ValidDyMissionId(uint64_t dyMissionId);\n\n    /**\n     * @brief 分配一个动态任务ID\n     * @return\n     */\n    uint64_t AllocNewDyMisssionId();\n\n    /**\n     * @brief 回收一个动态任务ID\n     * @param dyMissionId\n     */\n    void FreeDyMissionId(uint64_t dyMissionId);\n\n    /**\n     * @brief 根据任务类型随机一个任务ID\n     * @param missionType\n     * @return\n     */\n    uint64_t DyRandMissionId(int32_t missionType);\n\npublic:\n    /** 最近提交列表里面是否有指定类型的任务\n     * @brief\n     * @param missionType\n     * @return\n     */\n    bool HaveRecentSubmit(int32_t missionType);\n\n    /**\n     * @brief  根据任务类型获取当前任务列表中存在的数量\n     * @param missionType\n     * @return\n     */\n    int32_t MissionNumByType(int32_t missionType);\n\n    /**\n     * @brief 该任务是否已经接收过了\n     * @param missionId\n     * @return\n     */\n    bool HaveAccept(const uint64_t &missionId);\n\n    /**\n     * @brief 是否已经提交过的任务\n     * @param missionId\n     * @return\n     */\n    bool HaveSubmited(uint64_t missionId);\n\npublic:\n    int32_t OnExtractCond(MissionInfo *pMissionInfo, MissionTrack *pMissionTrack);\n\n    /**\n     * @brief 条件预判断(有些条件接取任务时就已经完成了)\n     * @param cond\n     */\n    void OnPreUpdateProgress(ItemInfo &cond);\n\n    /**\n     * @brief 更新条件进度\n     * @param data\n     * @param cond\n     * @param notify\n     */\n    void OnUpdateCondProcess(const ExecuteData &data, ItemInfo &cond, bool &notify);\n\n    /**\n     * @brief 提取动态任务条件\n     * @param pMissionInfo\n     * @param pMissionTrack\n     * @param preUpdate\n     * @return\n     */\n    int32_t OnExtractDyCond(const DyMissionInfo *pMissionInfo, MissionTrack *pMissionTrack, bool preUpdate = true);\n\n    /**\n     * @brief 生成任务条件\n     * @param pDyMissionInfo\n     * @param pDyConditionInfo\n     * @param cond\n     * @param textId\n     * @return\n     */\n    int32_t OnGeneralCond(const DyMissionInfo *pDyMissionInfo, const DyConditionInfo *pDyConditionInfo, ItemInfo &cond, uint64_t &textId);\n\n    /**\n     * @brief 提取动态任务属性奖励\n     * @param pNewMissinTrack\n     * @return\n     */\n    int32_t OnExtractDyAttrReward(MissionTrack *pNewMissinTrack);\n\npublic:\n    /**\n     * @brief 增加发任务时的物品奖励\n     * @param pMissionTrack\n     * @return\n     */\n    int32_t AddReward(uint64_t missionId, int32_t kind, TASK_REWARD &reward, float ration = 1);\n\n    /**\n     * @brief 是否能增加任务奖励\n     * @param pPlayer\n     * @param reward\n     * @param param\n     * @param lstOutItem\n     * @return\n     */\n    bool CanAddReward(uint64_t missionId, int32_t kind, TASK_REWARD &reward, LIST_ITEM &lstOutItem);\n\npublic:\n    /**\n     * @brief 移除任务\n     * @param pMissionInfo\n     * @return\n     */\n    int32_t RemoveMission(MissionInfo *pMissionInfo);\n\n    /**\n     * @brief 移除任务\n     * @param pMissinTrack\n     * @param pMissionInfo\n     * @return\n     */\n    int32_t RemoveMission(MissionTrack *pMissinTrack, MissionInfo *pMissionInfo);\n\n    /**\n     * @brief 移除动态任务\n     * @param dymissionId\n     * @param notify\n     * @return\n     */\n    int32_t RemoveDyMission(uint64_t dymissionId, bool notify);\n\npublic:\n    /**\n     * @brief 更新进度\n     * @param missionId\n     * @param data\n     * @return\n     */\n    int32_t OnUpdateProgress(uint64_t missionId, const ExecuteData &data);\n\n    /**\n     * @brief 更新任务进度\n     * @param missionId\n     */\n    void UpdateMissionProgress(uint64_t missionId);\n\n    /** 删除任务\n     * @brief\n     * @param dymissionId\n     */\n    void NotifyDelMission(uint64_t dymissionId);\n\n    /**\n     * @brief 移除任务物品\n     * @param pMissionTrack\n     * @return\n     */\n    int32_t OnDelMissionItem(MissionTrack *pMissionTrack);\n\npublic:\n    /**\n     * @brief 添加任务掉落\n     * @param pMissionTrack\n     * @param progressLev\n     * @return\n     */\n    int32_t OnAddMissionDrop(MissionTrack *pMissionTrack, int32_t progressLev);\n\n    /**\n     * @brief 添加任务掉落\n     * @param dymissionId\n     * @param monsId\n     * @param dropId\n     * @param boxId\n     * @param progressLev\n     * @return\n     */\n    bool AddMissionDrop(uint64_t dymissionId, uint64_t monsId, uint64_t dropId, uint64_t boxId, int32_t progressLev);\n\n    /**\n     * @brief 删除任务掉落\n     * @param dymissionId\n     * @param monsId\n     * @return\n     */\n    bool DelMissionDrop(uint64_t dymissionId, uint64_t monsId);\n\n    /**\n     * @brief 获取任务掉落\n     * @param monsterId\n     * @return\n     */\n    MissionDropMap *GetMissionDrop(uint64_t monsterId);\n\n    /**\n     * @brief 移除任务掉落\n     * @param pMissionTrack\n     * @return\n     */\n    int32_t OnDelMissionDrop(MissionTrack *pMissionTrack);\n\npublic:\n    /**\n     * @brief 移除任务中间物品\n     * @param pMissionTrack\n     */\n    int RemoveReward(MissionTrack *pMissionTrack);\n\n    /**\n     * @brief 移除接取任务时发放的物品\n     * @param pPlayer\n     * @param missionId\n     * @param reward\n     * @return\n     */\n    int RemoveReward(uint64_t missionId, TASK_REWARD &reward);\n\npublic://任务事件处理接口\n    /**\n     * @brief 注册监听事件，接任务成功后注册\n     * @param eventType\n     * @param missionId\n     * @param progressLev\n     */\n    void RegisterEvent(uint32_t eventType, uint64_t missionId, int32_t progressLev);\n\n    /**\n     * @brief 移除这个任务注册的所有事件\n     * @param missionId\n     */\n    void RemoveEvent(uint64_t missionId);\n\n    /**\n     * @brief 发送任务事件，阻塞\n     * @param eventType\n     * @param data\n     * @param dynamicId\n     */\n    void OnEvent(uint32_t eventType, const ExecuteData &data, uint64_t dynamicId = 0);\n\npublic:\n    /**\n     * @brief 提交任务\n     * @param pPlayer\n     * @param missionId\n     * @param selidx\n     * @return\n     */\n    int32_t OnSubmit(uint64_t missionId, uint32_t selidx);\n\n    /**\n     * @brief 提交任务\n     * @param missionId\n     * @param premissionId\n     * @param kind\n     */\n    void OnSubmit(uint64_t missionId, uint64_t premissionId, uint32_t kind);\n\n    /**\n     * @brief 检查接取条件中前置任务完成之后的可接任务\n     * @param missionId\n     * @param notify\n     */\n    void CheckPreAcceptMission(uint64_t missionId, bool notify = true);\n\npublic:\n    /**\n     * @brief 提交动态任务\n     * @param dymissionId\n     * @return\n     */\n    int32_t OnSubmitDy(uint64_t dymissionId);\n\n\n    /**\n     * @brief 提交任务(动态任务)\n     * @param dymissionId\n     * @param missionType\n     */\n    void OnSubmitDy(uint64_t dymissionId, int32_t missionType);\npublic:\n    /**\n     * @brief 完成诺林冒险\n     * @param count\n     */\n    void OnFinishLoopMission(int32_t count);\nprivate:\n    PlayerTrackMissionMap _playerTrackMissionMap;    //当前任务列表\n    NFShmHashMap<int32_t, NFShmHashSet<uint64_t, 100>, NF_MISSION_TYPE_MAX_COUNT> _mapRecentSubmit;        //最近提交的任务\n    NFShmHashSet<uint64_t, NF_MISSION_TYPE_MAX_MISSION_COUNT> _setAlreadySubmit;        //已经提交的任务\n    //动态任务\n    PlayerDyMissionTrackMap _mapDyMissionTrack;        //动态任务数据\n    MissionAllDropMap _mapMissionAllDrop;        //任务掉落\n    //\n    EventTabal _eventTabal;            //任务事件表\n    NFShmVector<bool, MISSION_MAX_DYNAMIC_ALLOC + 1> _aryDyIdAlloc; //动态任务ID分配\nprivate:\nDECLARE_IDCREATE(NFMissionPart)\n\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFMissionPart.h b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFMissionPart.h
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFMissionPart.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFMissionPart.h	(date 1688616542945)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFPart.h"
 #include "NFLogicCommon/NFMissionDefine.h"
Index: game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginModule.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginModule.cpp b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginModule.cpp
new file mode 100644
--- /dev/null	(date 1688632176998)
+++ b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginModule.cpp	(date 1688632176998)
@@ -0,0 +1,204 @@
+// -------------------------------------------------------------------------
+//    @FileName         :    NFCAccountLoginModule.h
+//    @Author           :    gaoyi
+//    @Date             :    23-7-6
+//    @Email			:    445267987@qq.com
+//    @Module           :    NFCAccountLoginModule
+//
+// -------------------------------------------------------------------------
+
+#include "NFAccountLoginModule.h"
+#include "NFComm/NFShmCore/NFShmMgr.h"
+#include "ClientServerCmd.pb.h"
+#include "NFLogicCommon/NFLogicBindRpcService.h"
+#include "NFAccountLoginMgr.h"
+#include "DBProto.pb.h"
+#include "proto_kernel.pb.h"
+#include "NFServerComm/NFServerCommon/NFIServerMessageModule.h"
+#include "NFComm/NFCore/NFTime.h"
+
+
+NFCAccountLoginModule::NFCAccountLoginModule(NFIPluginManager *p) : NFIDynamicModule(p) {
+}
+
+NFCAccountLoginModule::~NFCAccountLoginModule() {
+}
+
+bool NFCAccountLoginModule::Awake()
+{
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //////来自客户端的协议////////////////////////////////////////
+    RegisterClientMessage(NF_ST_LOGIN_SERVER, proto_ff::NF_CS_MSG_RegisterAccountReq);
+    RegisterClientMessage(NF_ST_LOGIN_SERVER, proto_ff::NF_CS_MSG_CHANGE_PASSWORD_REQ);
+
+    FindModule<NFIMessageModule>()->AddRpcService<proto_ff::NF_CS_MSG_AccountLoginReq>(NF_ST_LOGIN_SERVER, this, &NFCAccountLoginModule::OnRpcServiceAccountLogin, true);
+    /////////来自Login Server返回的协议//////////////////////////////////////////////////
+    /////来自World Server返回的协议////////////////////////////////////////
+	return true;
+}
+
+bool NFCAccountLoginModule::Execute() {
+    return true;
+}
+
+bool NFCAccountLoginModule::OnDynamicPlugin()
+{
+	return true;
+}
+
+int NFCAccountLoginModule::OnTimer(uint32_t nTimerID)
+{
+    return 0;
+}
+
+int NFCAccountLoginModule::OnHandleClientMessage(uint64_t unLinkId, NFDataPackage &packet)
+{
+    if (!m_pObjPluginManager->IsInited())
+    {
+        NFLogError(NF_LOG_SYSTEMLOG, packet.nParam1, "Proxy Server not inited, drop client msg:{}", packet.ToString());
+        return -1;
+    }
+
+    if (m_pObjPluginManager->IsServerStopping())
+    {
+        NFLogError(NF_LOG_SYSTEMLOG, packet.nParam1, "Proxy Server is Stopping, drop client msg:{}", packet.ToString());
+        return -1;
+    }
+
+    switch (packet.nMsgId)
+    {
+        case proto_ff::NF_CS_MSG_RegisterAccountReq:
+        {
+            break;
+        }
+        case proto_ff::NF_CS_MSG_CHANGE_PASSWORD_REQ:
+        {
+            break;
+        }
+        default:
+        {
+            NFLogError(NF_LOG_SYSTEMLOG, 0, "Client MsgId:{} Register, But Not Handle, Package:{}", packet.nMsgId, packet.ToString());
+            break;
+        }
+    }
+    return 0;
+}
+
+
+int NFCAccountLoginModule::OnHandleServerMessage(uint64_t unLinkId, NFDataPackage &packet)
+{
+    if (!m_pObjPluginManager->IsInited())
+    {
+        NFLogError(NF_LOG_SYSTEMLOG, packet.nParam1, "World Server not inited, drop client msg:{}", packet.ToString());
+        return -1;
+    }
+
+    if (m_pObjPluginManager->IsServerStopping())
+    {
+        NFLogError(NF_LOG_SYSTEMLOG, packet.nParam1, "World Server is Stopping, drop client msg:{}", packet.ToString());
+        return -1;
+    }
+
+    switch (packet.nMsgId)
+    {
+        default:
+        {
+            NFLogError(NF_LOG_SYSTEMLOG, 0, "Server MsgId:{} Register, But Not Handle, Package:{}", packet.nMsgId, packet.ToString());
+            break;
+        }
+    }
+    return 0;
+}
+
+int NFCAccountLoginModule::OnRpcServiceAccountLogin(proto_ff::Proto_CSAccountLoginReq& request, proto_ff::Proto_SCAccountLoginRsp& respone)
+{
+    proto_ff::tbAccountTable selectobj;
+    NFAccountLogin* pLogin = NFAccountLoginMgr::Instance(m_pObjPluginManager)->FindAccount(request.account());
+    if (pLogin == NULL)
+    {
+        selectobj.set_account(request.account());
+        int iRet = FindModule<NFIServerMessageModule>()->GetRpcSelectObjService(NF_ST_LOGIN_SERVER, std::hash<std::string>()(request.account()), selectobj);
+        if (iRet != 0)
+        {
+            if (iRet == proto_ff::ERR_CODE_STORESVR_ERRCODE_SELECT_EMPTY)
+            {
+                if (request.login_type() == proto_ff::E_VISITOR || request.login_type() == proto_ff::E_WECHAT)
+                {
+                    proto_ff::tbAccountTable insertObj;
+                    insertObj.set_account(request.account());
+                    insertObj.set_password(request.password());
+                    insertObj.set_account_type(request.login_type());
+                    insertObj.set_device_id(request.device_id());
+                    insertObj.set_phonenum(0);
+
+                    NFLogTrace(NF_LOG_SYSTEMLOG, 0, "Ready Create Account InTo Mysql:{}", insertObj.DebugString());
+
+                    iRet = FindModule<NFIServerMessageModule>()->GetRpcInsertObjService(NF_ST_LOGIN_SERVER, std::hash<std::string>()(request.account()), insertObj);
+                    if (iRet != 0)
+                    {
+                        NFLogInfo(NF_LOG_SYSTEMLOG, 0, "Insert Account:{} Failed, iRet:{}", request.account(), GetErrorStr(iRet));
+                        respone.set_result(iRet);
+                        return 0;
+                    }
+
+                    iRet = FindModule<NFIServerMessageModule>()->GetRpcSelectObjService(NF_ST_LOGIN_SERVER, std::hash<std::string>()(request.account()), selectobj);
+                    if (iRet != 0)
+                    {
+                        NFLogInfo(NF_LOG_SYSTEMLOG, 0, "Insert Account:{} Success, But Select Account Failed, iRet:{}", request.account(), GetErrorStr(iRet));
+                        respone.set_result(iRet);
+                        return 0;
+                    }
+
+                    pLogin = NFAccountLoginMgr::Instance(m_pObjPluginManager)->CreateAccount(selectobj.account(), selectobj.password(), selectobj.player_id(), selectobj.account_type(), selectobj.device_id(), selectobj.phonenum());
+                    if (pLogin == NULL)
+                    {
+                        NFLogInfo(NF_LOG_SYSTEMLOG, 0, "NFAccountLoginMgr CreateAccount:{} Failed", request.account());
+                        respone.set_result(proto_ff::ERR_CODE_SYSTEM_ERROR);
+                        return 0;
+                    }
+                }
+                else
+                {
+                    NFLogInfo(NF_LOG_SYSTEMLOG, 0, "Account:{} is not exist, must first register, iRet:{}", request.account(), GetErrorStr(iRet));
+                    respone.set_result(proto_ff::ERR_CODE_ACCOUNT_NOT_EXIST);
+                    return 0;
+                }
+            }
+            else {
+                NFLogInfo(NF_LOG_SYSTEMLOG, 0, "Select Account:{} Failed, iRet:{}", request.account(), GetErrorStr(iRet));
+                respone.set_result(iRet);
+                return 0;
+            }
+        }
+        else {
+            pLogin = NFAccountLoginMgr::Instance(m_pObjPluginManager)->CreateAccount(selectobj.account(), selectobj.password(), selectobj.player_id(), selectobj.account_type(), selectobj.device_id(), selectobj.phonenum());
+            if (pLogin == NULL)
+            {
+                NFLogInfo(NF_LOG_SYSTEMLOG, 0, "NFAccountLoginMgr CreateAccount:{} Failed", request.account());
+                respone.set_result(proto_ff::ERR_CODE_SYSTEM_ERROR);
+                return 0;
+            }
+        }
+    }
+
+    pLogin->mLastLoginTime = NFTime::Now().UnixSec();
+
+    respone.set_result(proto_ff::ERR_CODE_OK);
+    respone.set_user_id(pLogin->mPlayerId);
+    respone.set_login_time(pLogin->mLastLoginTime);
+    respone.set_token(NFLogicCommon::GetLoginToken(pLogin->mAccount.GetString(), pLogin->mPlayerId, pLogin->mLastLoginTime, LOGIN_TOKEN));
+
+    std::vector<NF_SHARE_PTR<NFServerData>> pServerList = FindModule<NFIMessageModule>()->GetServerByServerType(NF_ST_LOGIN_SERVER, NF_ST_PROXY_SERVER);
+    for(int i = 0; i < (int)pServerList.size(); i++)
+    {
+        NF_SHARE_PTR<NFServerData> pServer = pServerList[i];
+        if (pServer)
+        {
+            proto_ff::Proto_CSServerIP* pIp = respone.add_server_ip_list();
+            pIp->set_ip(pServer->mServerInfo.external_server_ip());
+            pIp->set_port(pServer->mServerInfo.external_server_port());
+        }
+    }
+
+    return 0;
+}
\ No newline at end of file
Index: game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFFishLoginPlayerPlugin.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFFishLoginPlayerPlugin.cpp b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFFishLoginPlayerPlugin.cpp
new file mode 100644
--- /dev/null	(date 1688609684677)
+++ b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFFishLoginPlayerPlugin.cpp	(date 1688609684677)
@@ -0,0 +1,61 @@
+// -------------------------------------------------------------------------
+//    @FileName         :    NFFishLoginServerPlayerPlugin.h
+//    @Author           :    gaoyi
+//    @Date             :    23-7-6
+//    @Email			:    445267987@qq.com
+//    @Module           :    NFFishLoginServerPlayerPlugin
+//
+// -------------------------------------------------------------------------
+
+#include "NFFishLoginPlayerPlugin.h"
+#include "NFComm/NFPluginModule/NFIPluginManager.h"
+#include "NFAccountLoginModule.h"
+#include "NFComm/NFPluginModule/NFIConfigModule.h"
+#include "NFAccountLoginMgr.h"
+
+#ifdef NF_DYNAMIC_PLUGIN
+
+NF_EXPORT void DllStartPlugin(NFIPluginManager* pm)
+{
+    CREATE_PLUGIN(pm, NFFishLoginPlayerPlugin)
+
+};
+
+NF_EXPORT void DllStopPlugin(NFIPluginManager* pm)
+{
+    DESTROY_PLUGIN(pm, NFFishLoginPlayerPlugin)
+};
+
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////
+
+int NFFishLoginPlayerPlugin::GetPluginVersion()
+{
+	return 0;
+}
+
+std::string NFFishLoginPlayerPlugin::GetPluginName()
+{
+	return GET_CLASS_NAME(NFFishLoginPlayerPlugin);
+}
+
+void NFFishLoginPlayerPlugin::Install()
+{
+	REGISTER_MODULE(m_pObjPluginManager, NFCAccountLoginModule, NFCAccountLoginModule);
+}
+
+void NFFishLoginPlayerPlugin::Uninstall()
+{
+	UNREGISTER_MODULE(m_pObjPluginManager, NFCAccountLoginModule, NFCAccountLoginModule);
+}
+
+bool NFFishLoginPlayerPlugin::InitShmObjectRegister()
+{
+    NFServerConfig* pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_LOGIN_SERVER);
+    NF_ASSERT(pConfig);
+
+    REGISTER_SINGLETON_SHM_OBJ(NFAccountLoginMgr);
+	return true;
+}
\ No newline at end of file
Index: game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFFishLoginPlayerPlugin.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFFishLoginPlayerPlugin.h b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFFishLoginPlayerPlugin.h
new file mode 100644
--- /dev/null	(date 1688609684670)
+++ b/game/Fish/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFFishLoginPlayerPlugin.h	(date 1688609684670)
@@ -0,0 +1,34 @@
+// -------------------------------------------------------------------------
+//    @FileName         :    NFFishLoginServerPlayerPlugin.h
+//    @Author           :    gaoyi
+//    @Date             :    23-7-6
+//    @Email			:    445267987@qq.com
+//    @Module           :    NFFishLoginServerPlayerPlugin
+//
+// -------------------------------------------------------------------------
+
+#pragma once
+
+#include "NFComm/NFPluginModule/NFIPlugin.h"
+#include "NFComm/NFPluginModule/NFIPluginManager.h"
+#include <string>
+
+//////////////////////////////////////////////////////////////////////////
+class NFFishLoginPlayerPlugin : public NFIPlugin
+{
+public:
+	explicit NFFishLoginPlayerPlugin(NFIPluginManager* p): NFIPlugin(p)
+	{
+	}
+
+	virtual int GetPluginVersion() override;
+
+	virtual std::string GetPluginName() override;
+
+	virtual void Install() override;
+
+	virtual void Uninstall() override;
+
+	virtual bool InitShmObjectRegister() override;
+};
+
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFTitlePart.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTitlePart.h\n//    @Author           :    gaoyi\n//    @Date             :    23-2-21\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTitlePart\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmStl/NFShmHashMap.h\"\n#include \"Com_s.h\"\n#include \"DescStore/TitleTitleDesc.h\"\n#include \"NFPart.h\"\n#include \"NFLogicCommon/NFComTypeDefine.h\"\n\nclass NFTitlePart : public NFPart\n{\n    typedef NFShmHashMap<uint32_t, uint64_t, 10> ATTR_MAP;\n    enum EAttrType\n    {\n        EAttrType_StarAttr = 0,\n        EAttrType_LimitAttr,\n    };\npublic:\n    NFTitlePart();\n\n    virtual ~NFTitlePart();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    static int RegisterClientMessage(NFIPluginManager *pPluginManager);\n\n    static int RegisterServerMessage(NFIPluginManager *pPluginManager);\npublic:\n    //******************part调用生物接口******************\n    //生物init调用\n    virtual int Init(NFPlayer *pMaster, uint32_t partType, const proto_ff::RoleDBData &dbData);\n\n    void LoadConfig();\n\n    //生物uint调用\n    virtual int UnInit();\n\n    /**\n     * @brief 存储DB部件入口\n     * @param proto\n     * @return\n     */\n    virtual int SaveDB(proto_ff::RoleDBData &dbData);\n\n    /**\n     * @brief 登陆入口\n     * @return\n     */\n    virtual int OnLogin();\n\n    /**\n     * @brief  登陆入口\n     * @param playerInfo\n     * @return\n     */\n    virtual int OnLogin(proto_ff::PlayerInfoRsp &playerInfo);\npublic:\n    /**\n     * @brief 处理客户端消息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleClientMessage(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 处理来自服务器的信息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleServerMessage(uint32_t msgId, NFDataPackage &packet);\npublic:\n    proto_ff_s::TitleInfo_s* GetTitleInfo(uint64_t titleId);\n    bool ProcessStarAttr(int64_t titleId, int32_t star, bool bAdd, bool bSync);\npublic:\n    void calcAttr(bool sync);\n    void calcAttr(MAP_INT32_INT64& outAttr);\n    void MergeAttr(MAP_INT32_INT64& src, MAP_INT32_INT64& dst);\n    void PrintAttr(MAP_INT32_INT64& attr);\npublic:\n    int OnHandleTitleInfoReq(uint32_t msgId, NFDataPackage &packet);\n    int OnHandleTitleActiveReq(uint32_t msgId, NFDataPackage &packet);\n    int OnHandleTitleStarLvReq(uint32_t msgId, NFDataPackage &packet);\n    int OnHandleTitleDressReq(uint32_t msgId, NFDataPackage &packet);\n    int OnHandleTitleUnDressReq(uint32_t msgId, NFDataPackage &packet);\npublic:\n    void OnDress(uint64_t titleId);\n    void UnDress(uint64_t titleId);\nprivate:\n    uint64_t m_curWearingTitle;\n    NFShmHashMap<uint64_t, proto_ff_s::TitleInfo_s, MAX_TITLE_TITLE_NUM> m_titleMap;\n    NFShmHashMap<uint8_t, ATTR_MAP, EAttrType_LimitAttr> m_mapTypeAttr;//不同类型带来的属性\nDECLARE_IDCREATE(NFTitlePart)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFTitlePart.h b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFTitlePart.h
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFTitlePart.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/NFTitlePart.h	(date 1688616543114)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmStl/NFShmHashMap.h"
 #include "Com_s.h"
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Item/NFItemMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFItemUtil.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-26\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFItemUtil\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFGridItem.h\"\n#include \"NFLogicCommon/PackageDefine.h\"\n#include \"NFLogicCommon/NFComTypeDefine.h\"\n#include \"item_s.h\"\n#include \"equip_s.h\"\n#include \"NFComm/NFShmCore/NFShmOldHashMap.h\"\n\nclass NFItemMgr : public NFShmObj\n{\npublic:\n    NFItemMgr();\n\n    virtual ~NFItemMgr();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    int ItemFromCSData(NFGridItem &item, const proto_ff::ItemGridCSData *pData);\n\n    ///////////////////////////////// 资源类 虚拟物品 接口 /////////////////////////////////////////\n    //是否是资源类 虚拟物品\n    bool IsVirItem(uint64_t itemId);\n\n    //是否是资源类 虚拟物品, 如果是，则 attrId 会设置为 虚拟物品对应的属性ID\n    bool IsVirItem(uint64_t itemId, uint32_t &attrId);\n\n    //过滤出虚拟物品的属性\n    void FilterVirItem(const LIST_ITEM &lstItem, LIST_ITEM &lstOutItem, MAP_UINT32_INT64 &mapAttr);\n\n    //过滤出虚拟物品的属性\n    void FilterVirItem(const LIST_ITEM &lstItem, LIST_ITEM &lstOutItem);\n\n    //过滤出虚拟物品的属性\n    void FilterVirItem(const VEC_ITEM_PROTO_EX &vecProtoItemsEx, VEC_ITEM_PROTO_EX &vecOutProtoItemsEx, MAP_UINT32_INT64 &mapAttr);\n\n    //过滤出虚拟物品的属性\n    void FilterVirItem(const VEC_ITEM_PROTO_EX &vecProtoItemsEx, VEC_ITEM_PROTO_EX &vecOutProtoItemsEx);\n\npublic:\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //计算物品需要的格子数量-只是初略估算出来，可堆叠的数量是一个大概的值, 不可堆叠的物品占用的格子数量是可以计算出来的\n    uint32_t CalcGridNeed(const LIST_ITEM &lstItem, const VEC_ITEM_PROTO_EX &vecProtoEx, uint32_t &nNoPileNeed, uint32_t &nPileNeed);\n\npublic:\n    //创建物品\n    bool CreateItem(const LIST_ITEM &lstItem, VEC_ITEM_PROTO_EX &vecProtoEx, SItemCond &itemCond, bool bMerge = true);\n\n    //创建物品(背包用的，其他地方不要用)\n    bool CreateItem(const VEC_ITEM_PROTO &vecProtoItems, VEC_PACKAGE_ITEM &vecItems);\n\n    //创建物品(背包用的，其他地方不要用)\n    bool CreateItem(const VEC_ITEM_PROTO_EX &vecProtoItemsEx, VEC_PACKAGE_ITEM &vecItems);\n\n    //创建物品\n    bool CreateItem(const LIST_ITEM &lstItem, VEC_PACKAGE_ITEM &vecItems, SItemCond &itemCond, bool bMerge = true);\n\n    //合并物品\n    void MergeItem(const LIST_ITEM &lstItem, LIST_ITEM &lstOutItem);\n\npublic:\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////\n    //物品的绑定状态-根据获得途径 bindWay: EItemBindWay 枚举类型\n    int8_t BindStateByWay(uint64_t nItemId, int8_t byBind, int8_t bindWay = EItemBindWay_UnBind);\n\n    int8_t BindStateByWay(const proto_ff_s::E_ItemItem_s *pItemCfg, int8_t byBind, int8_t bindWay = EItemBindWay_UnBind);\n\n    int8_t BindStateByWay(const proto_ff_s::E_EquipEquip_s *pEquipCfg, int8_t byBind, int8_t bindWay = EItemBindWay_UnBind);\n\n    //获取物品堆叠数\n    int64_t ItemMaxPile(uint64_t itemId);\n\n    int64_t ItemMaxPile(const proto_ff_s::E_ItemItem_s *pItemCfg);\n\n    int64_t ItemMaxPile(const proto_ff_s::E_EquipEquip_s *pEquipCfg);\n\n    //设置物品信息\n    bool SetItemProtoInfo(const LIST_ITEM &lstItem, VEC_ITEM_PROTO_EX &vecProto,SItemCond &itemCond);\n    //设置物品protobuf信息\n    bool SetItemProtoInfo(NFGridItem *pItem, proto_ff::ItemProtoInfo *protoItem, int64_t nNum = -1);\n    //校验物品\n    bool CheckItem(const VEC_ITEM_PROTO_EX &vecProtoItems);\npublic:\n    //是否有效的绑定途径\n    bool ValidBindWay(int8_t bindWay);\n\n    //是否有效的禁止类型\n    bool ValidForbidType(int8_t forbidType);\n\n    //是否有效的物品属性初始化类型\n    bool ValidInitAttrType(int8_t initAttrType);\n\n    //物品是否能交易\n    bool CanTrade(uint64_t itemId, int8_t byInBind);\n\n    //物品能否出售\n    bool CanSell(uint64_t itemId, int8_t byInBind);\n\n    //是否是任务物品\n    bool IsTaskItem(uint64_t itemId);\n\n    //获取拾取掉落CD\n    uint32_t GetPickupDropCd();\n\n    //获取同时拾取掉落的数量\n    uint32_t GetPickupNumAtOnce();\n\n    //是否是普通装备部位\n    bool IsNormalPos(uint8_t pos);\n\n    //是否是首饰类装备部位\n    bool IsJewelryPos(uint8_t pos);\n\n    //是否是仙器 装备部位\n    bool IsFairyPos(uint8_t pos);\n\npublic:\n    //物品排序比较函数\n    bool CompareSundryFunc_(const NFGridItem *pItemA, const NFGridItem *pItemB);\n    bool CompareMaterialFunc_(const NFGridItem *pItemA, const NFGridItem *pItemB);\n    bool CompareTaskFunc_(const NFGridItem *pItemA, const NFGridItem *pItemB);\n    bool CompareEquipFunc_(const NFGridItem *pItemA, const NFGridItem *pItemB);\n    bool CompareStarFunc_(const NFGridItem *pItemA, const NFGridItem *pItemB);\n    bool CompareGodhoodFunc_(const NFGridItem *pItemA, const NFGridItem *pItemB);\n\n    //物品排序比较函数\n    bool CompareSundryFunc(const NFGridItem& itemA, const NFGridItem& itemB);\n    bool CompareMaterialFunc(const NFGridItem& itemA, const NFGridItem& itemBB);\n    bool CompareTaskFunc(const NFGridItem& itemA, const NFGridItem& itemB);\n    bool CompareEquipFunc(const NFGridItem& itemA, const NFGridItem& itemB);\n    bool CompareStarFunc(const NFGridItem& itemA, const NFGridItem& itemBB);\n    bool CompareGodhoodFunc(const NFGridItem& itemA, const NFGridItem& itemB);\nprivate:\n    uint32_t m_nPickupMillsec;        //拾取掉落间隔，单位：毫秒\n    uint32_t m_nPickupNumLimit;        //每次拾取数量限制\n    NFShmOldHashMap<uint8_t, bool, 100> m_setNormalPos;        //普通装备部位\n    NFShmOldHashMap<uint8_t, bool, 100> m_setJewelryPos;        //首饰部位\n    NFShmOldHashMap<uint8_t, bool, 100> m_setFairyPos;        //仙器部位\nDECLARE_IDCREATE(NFItemMgr)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Item/NFItemMgr.h b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Item/NFItemMgr.h
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Item/NFItemMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Item/NFItemMgr.h	(date 1688616543322)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFGridItem.h"
 #include "NFLogicCommon/PackageDefine.h"
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Package/NFBagPage.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFBagPage.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-26\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFBagPage\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"Part/Item/NFGridItem.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"Part/Item/NFItemMgr.h\"\n#include \"NFLogicCommon/NFLogDefine.h\"\n#include \"NFLogicCommon/PackageDefine.h\"\n#include \"Package.pb.h\"\n#include \"NFComm/NFShmCore/NFShmPtr.h\"\n#include \"DBProto.pb.h\"\n#include \"CSPlayer.pb.h\"\n\nclass NFPlayer;\nclass NFBagPage : public NFObject, public NFSeqOP\n{\n    typedef std::list<SItem> LIST_ITEM_EX;\n    // label - LIST_ITEM_EX(标签-物品列表)\n    typedef std::unordered_map<uint8_t, LIST_ITEM_EX> MAP_LABEL_LIST_ITEM_EX;\n    // index - SItemEx\n    typedef std::map<uint16_t, SItem> MAP_INDEX_ITEM_EX;\n    // label - MAP_INDEX_ITEM_EX\n    typedef std::map<uint8_t, MAP_INDEX_ITEM_EX > MAP_LABEL_MAP_INDEX_ITEM_EX;\n\n    // index - SItem\n    typedef std::map<uint16_t, SItem> MAP_INDEX_ITEM;\n\n    //label - VEC_ITEM_PROTO_EX\n    typedef std::unordered_map<uint8_t, VEC_ITEM_PROTO_EX> MAP_LABEL_VEC_ITEM_PROTO_EX;\n    //index - ItemProtoInfo\n    typedef std::map<uint16_t, proto_ff::ItemProtoInfo> MAP_INDEX_ITEM_PROTO_EX;\npublic:\n    NFShmVector<NFGridItem, STORAGE_PACKAGE_MAX_GRID_NUM> m_grids;\n    uint64_t m_nLastSortTime;\t\t\t\t\t\t//上次整理的时间\n    uint32_t m_nExpandNum;\t\t\t\t\t\t\t//扩展格子数\n    uint32_t m_nOpenGrid;\t\t\t\t\t\t\t//背包开启格子数\n    uint32_t m_initGrid;\t\t\t\t\t\t\t//初始化格子大小\n    uint32_t m_maxGrid;\t\t\t\t\t\t\t\t//最大格子大小\n    uint32_t m_nPackageType;\n    NFShmPtr<NFPlayer> m_pMaster;\npublic:\n    NFBagPage(NFIPluginManager* pPluginManager);\n\n    virtual ~NFBagPage();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    virtual int InitGrid(NFPlayer *pMaster, uint32_t nPackageType,uint32_t nInitGrid,uint32_t nMaxGrid);\npublic:\n    virtual int Init(const proto_ff::RoleDBUnitBagData &dbData);\n\n    //生物uint调用\n    virtual int UnInit();\n\n    /**\n     * @brief 存储DB部件入口\n     * @param proto\n     * @return\n     */\n    virtual int SaveDB(proto_ff::RoleDBUnitBagData &dbData);\n\n    /**\n     * @brief 登陆入口\n     * @return\n     */\n    virtual int OnLogin() { return 0; }\n\n    /**\n     * @brief  登陆入口\n     * @param playerInfo\n     * @return\n     */\n    virtual int OnLogin(proto_ff::PlayerInfoRsp &playerInfo);\n\n    void SendPackageInfoToClient();\n\n    //堆叠合并\n    uint16_t PileMerge(VEC_PACKAGE_ITEM vecItems, VEC_ITEM_PROTO_EX &vecPileProtoEx);\npublic:\n    //获取指定物品数量\n    int64_t GetItemNum(uint64_t nItemID, int64_t &nUnBindNum, int64_t &nBindNum);\n    //获取指定物品绑定和非绑定数量\n    int64_t GetPackageItemNum(uint64_t nItemID, int64_t &nUnBindNum, int64_t &nBindNum);\n    //获取背包指定物品绑定和非绑定数量\n    int64_t GetPackageItemNum(uint64_t nItemID, int64_t &nUnBindNum, int64_t &nBindNum, ORDER_MAP_UINT16_INT64 &mapUnbindGridHas, ORDER_MAP_UINT16_INT64 &mapBindGridHas);\n\n    //是否存在物品\n    virtual bool HasItem(LIST_ITEM &lstItem);\n    //背包是否存在物品\n    bool HasPackageItem(const LIST_ITEM &lstItem, ORDER_MAP_UINT16_INT64 &mapGridReduceNum);\n    //背包是否存在物品\n    bool HasPackageItem(const MAP_UINT16_INT64 &mapIdxNum, ORDER_MAP_UINT16_INT64 &mapGridReduceNum);\n    //是否存在物品\n    bool HasBagItem(const LIST_ITEM &lstItem, ORDER_MAP_UINT16_INT64 &mapGridReduceNum);\n    //是否存在物品\n    bool HasBagItem(const MAP_UINT16_INT64 &mapIdxNum, ORDER_MAP_UINT16_INT64 &mapGridReduceNum);\npublic:\n    //移除物品\n    virtual bool RemoveItem(uint64_t nItemID, int64_t nNum, SCommonSource &sourceParam, int8_t byBind = (int8_t)EBindState::EBindState_all);\n    //移除物品 sourceParam : 物品移除来源（暂时没有）\n    virtual bool RemoveItem(LIST_ITEM &lstItem, SCommonSource &sourceParam);\n    //移除物品 index,num sourceParam : 物品移除来源（暂时没有）\n    virtual bool RemoveItemByIndex(uint16_t nIndex, int64_t nNum, SCommonSource &sourceParam);\n    //移除物品 index-num nGetType : 物品移除来源（暂时没有）\n    virtual bool RemoveItem(MAP_UINT16_INT64 &mapIndexItem, SCommonSource &sourceParam);\n    //移除背包物品\n    bool RemovePackageItem(ORDER_MAP_UINT16_INT64 &mapGridReduceNum, MAP_UINT64_INT64 &mapItemNum);\n    //移除物品\n    bool RemoveBagItem(ORDER_MAP_UINT16_INT64 &mapGridReduceNum, MAP_UINT64_INT64 &mapItemNum);\n\n    //移除所有指定类型的物品（根据 tem.xlsx 表中 subType 字段 移除物品）\n    virtual bool RemoveAllByType(int32_t itemSubType, SCommonSource &sourceParam);\n    virtual bool RemoveAllByItemID(uint64_t nItemID, SCommonSource& sourceParam);\npublic:\n    //添加物品\n    virtual int AddItem(uint64_t nItemID, int64_t nNum, SCommonSource &sourceParam, int8_t byBind = (int8_t)EBindState::EBindState_no);\n    //添加物品 sourceParam : 物品来源（暂时没有）\n    virtual int AddItem(const LIST_ITEM &lstItem, SCommonSource &sourceParam, bool update = true, bool tip = true);\n\n    //添加物品 sourceParam : 物品来源（暂时没有）\n    virtual bool AddItem(const VEC_ITEM_PROTO &vecProtoItems, SCommonSource &sourceParam, bool update = true, bool tip = true);\n    //添加物品 sourceParam : 物品来源（暂时没有）\n    virtual bool AddItem(const VEC_ITEM_PROTO_EX &vecProtoItemsEx, SCommonSource &sourceParam, bool update = true, bool tip = true);\n    //添加物品 sourceParam : 物品来源（暂时没有）,这个接口是通过传进来的物品顺序添加前端物品tip提示\n    virtual bool AddItemEx(const VEC_ITEM_PROTO_EX &vecProtoItemsEx, SCommonSource &sourceParam);\n    //添加物品 sourceParam : 物品来源（暂时没有） vecProtoItemsOut:传出参数，外部需要的物品数据\n    virtual bool AddItem(const VEC_ITEM_PROTO_EX &vecProtoItemsEx, const VEC_ITEM_PROTO_EX &vecProtoItemsOut, SCommonSource &sourceParam, bool update = true, bool tip = true);\npublic:\n    //合并背包物品列表\n    void MergePackageItemList(const LIST_ITEM &inlstItem, const VEC_ITEM_PROTO_EX &vecinProtoEx, MAP_LABEL_LIST_ITEM_EX &mapOutLabelItem, MAP_LABEL_VEC_ITEM_PROTO_EX &mapOutLabelVecItemProtoEx);\n    //合并物品列表\n    void MergeItemList(const LIST_ITEM &inlstItem, const VEC_ITEM_PROTO_EX &vecinProtoEx, MAP_LABEL_LIST_ITEM_EX &mapOutLabelItem, MAP_LABEL_VEC_ITEM_PROTO_EX &mapOutLabelVecItemProtoEx);\n\n    //是否能添加物品\n    virtual bool CanAddItem(LIST_ITEM &lstItem);\n    //能否添加物品\n    virtual bool CanAddItem(VEC_ITEM_PROTO_EX &vecProtoItemsEx);\n    //能否添加进背包\n    bool CanPackageAddItem(MAP_LABEL_LIST_ITEM_EX &mapInLabelItem, MAP_LABEL_VEC_ITEM_PROTO_EX &mapInLabelVecItemProtoEx, MAP_UINT16_INT64 &mapOutGridAddNum, MAP_INDEX_ITEM_PROTO_EX &mapOutNewIdxItemProtoEx);\n    //能否添加到背包  mapOutGridAddNum:可堆叠的格子，每个格子上增加的数量 index - num\n    bool CanBagAddItem(MAP_LABEL_LIST_ITEM_EX &mapInLabelItem, MAP_LABEL_VEC_ITEM_PROTO_EX &mapInLabelVecItemProtoEx, MAP_UINT16_INT64 &mapOutGridAddNum, MAP_INDEX_ITEM_PROTO_EX &mapOutNewIdxItemProtoEx);\n    //添加背包物品\n    bool AddPackageItem(MAP_UINT16_INT64 &mapOutGridAddNum, MAP_INDEX_ITEM_PROTO_EX &mapOutNewIdxItemProtoEx, const VEC_ITEM_PROTO_EX &vecProtoTipItemsEx, bool update = true);\n\n    //获取某个物品剩余可叠加的数量\n    int64_t GetItemLeftPile(uint64_t nItemID, int64_t &nUnBindNum, int64_t &nBindNum, ORDER_MAP_UINT16_INT64 &mapUnbindGridHas, ORDER_MAP_UINT16_INT64 &mapBindGridHas);\n    //获取某个标签内物品剩余可叠加数量\n    int64_t GetLabelItemLeftPile(uint8_t byLabel, uint64_t nItemID, int64_t stackLimit, int64_t &nUnBindNum, int64_t &nBindNum, ORDER_MAP_UINT16_INT64 &mapUnbindGridHas, ORDER_MAP_UINT16_INT64 &mapBindGridHas);\n\npublic:\n    NFGridItem* GetItemByIndex(uint32_t nIndex);\n    int SetItemByIndex(uint32_t nIndex, NFGridItem* pItem);\n    int SetItemByIndex(uint32_t nIndex, const proto_ff::ItemProtoInfo &protoItem);\n\n    //获取标签页空格子索引列表 nNum:为0表示标签页所有的空格子，大于0时 只返回 nNum 个空格子\n    uint32_t GetEmptyGrid(VEC_UINT32 &vecGrid);\n    void UpdatePackageInfo(proto_ff::NotifyPackageUpdate &protoUpdate);\n    bool AddPackageUpdateInfo(NFGridItem *pItem, proto_ff::NotifyPackageUpdate &ret, bool bDel = false);\n    bool SetUpdateItemInfo(NFGridItem *pItem, proto_ff::ItemProtoInfo *protoItemInfo, bool bDel = false);\npublic:\n    //移除物品事件处理\n    void OnRemoveItemEvent(MAP_UINT64_INT64 &mapItemNum, SCommonSource &sourceParam);\n    //添加收集物品（主要是用于任务收集物品）\n    void AddCollectItem(const proto_ff::ItemProtoInfo& itemProto, VEC_ITEM_PROTO_EX& vCollectItems);\n    //收集物品事件触发\n    void CollectItemEvent(VEC_ITEM_PROTO_EX &vCollectItems, SCommonSource &sourceParam, int32_t nOperateType = EItemOpetateType_None);\n\n    //物品日志\n    void ItemLog(MAP_UINT16_INT64 &items, MAP_INDEX_ITEM_PROTO_EX &mapOutNewIdxItemProtoEx, SCommonSource &source);\n    void ItemLog(MAP_UINT64_INT64 &items, SCommonSource &source);\npublic:\n    bool SortItem();\n    bool BagItemSort();\n};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Package/NFBagPage.h b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Package/NFBagPage.h
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Package/NFBagPage.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Part/Package/NFBagPage.h	(date 1688616543278)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "Part/Item/NFGridItem.h"
 #include "NFComm/NFPluginModule/NFCheck.h"
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Login/NFLoginModule.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFLoginModule.cpp\n//    @Author           :    gaoyi\n//    @Date             :    2022/10/14\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFLoginModule\n//\n// -------------------------------------------------------------------------\n\n#include <NFComm/NFPluginModule/NFIMessageModule.h>\n#include <NFComm/NFShmCore/NFISharedMemModule.h>\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include <ClientServerCmd.pb.h>\n#include <ClientServer.pb.h>\n#include <NFLogicCommon/NFServerFrameTypeDefines.h>\n#include <NFComm/NFPluginModule/NFCheck.h>\n#include <ServerInternalCmd.pb.h>\n#include <ServerInternalCmd2.pb.h>\n#include <Scene.pb.h>\n#include <Move.pb.h>\n#include \"NFLoginModule.h\"\n\n#include \"Trans/NFTransGetRoleList.h\"\n#include \"ServerInternal2.pb.h\"\n#include \"Trans/NFTransCreateRole.h\"\n#include \"Trans/NFTransGetRole.h\"\n#include \"Player/NFPlayerMgr.h\"\n#include \"Player/NFPlayer.h\"\n#include \"Trans/NFTransTransScene.h\"\n#include \"NFLogicCommon/NFSceneDefine.h\"\n#include \"DescStoreEx/NFMapDescStoreEx.h\"\n#include \"DescStore/AreaAreaDesc.h\"\n#include \"NFServerComm/NFServerCommon/NFIServerMessageModule.h\"\n\n\nNFLoginModule::NFLoginModule(NFIPluginManager *p) : NFIDynamicModule(p)\n{\n\n}\n\nNFLoginModule::~NFLoginModule()\n{\n\n}\n\nbool NFLoginModule::Awake()\n{\n    RegisterClientMessage(NF_ST_LOGIC_SERVER, proto_ff::CLIENT_SCENE_TRANS_REQ);\n\n    RegisterServerMessage(NF_ST_LOGIC_SERVER, proto_ff::WORLD_TO_LOGIC_GET_ROLE_LIST_REQ);\n    RegisterServerMessage(NF_ST_LOGIC_SERVER, proto_ff::WORLD_TO_LOGIC_CREATE_ROLE_INFO_REQ);\n    RegisterServerMessage(NF_ST_LOGIC_SERVER, proto_ff::WORLD_TO_LOGIC_LOGIN_REQ);\n    RegisterServerMessage(NF_ST_LOGIC_SERVER, proto_ff::WORLD_TO_OTHER_SERVER_NOTIFY_PLAYER_DISCONNECT);\n    RegisterServerMessage(NF_ST_LOGIC_SERVER, proto_ff::WORLD_TO_LOGIC_LOGIN_FINISH_NOTIFY);\n    RegisterServerMessage(NF_ST_LOGIC_SERVER, proto_ff::NOTIFY_LOGIC_LEAVE_GAME_REQ);\n\n    /**\n     * @brief 一帧处理200个玩家的tick\n     */\n    NFPlayerMgr::Instance(m_pObjPluginManager)->Init(1, 200);\n    return true;\n}\n\nbool NFLoginModule::Execute()\n{\n    NFPlayerMgr::Instance(m_pObjPluginManager)->Execute();\n    return true;\n}\n\nbool NFLoginModule::OnDynamicPlugin()\n{\n    return true;\n}\n\nint NFLoginModule::OnHandleClientMessage(uint32_t msgId, NFDataPackage &packet, uint64_t param1, uint64_t param2)\n{\n    if (!m_pObjPluginManager->IsInited())\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, packet.nParam1, \"World Server not inited, drop client msg:{}\", packet.ToString());\n        return -1;\n    }\n\n    if (m_pObjPluginManager->IsServerStopping())\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, packet.nParam1, \"World Server is Stopping, drop client msg:{}\", packet.ToString());\n        return -1;\n    }\n\n    switch (msgId)\n    {\n        case proto_ff::CLIENT_SCENE_TRANS_REQ:\n        {\n            OnHandleTransSceneReq(msgId, packet, param1, param2);\n            break;\n        }\n        default:\n        {\n            break;\n        }\n    }\n\n    return 0;\n}\n\nint NFLoginModule::OnHandleServerMessage(uint32_t msgId, NFDataPackage &packet, uint64_t param1, uint64_t param2)\n{\n    if (!m_pObjPluginManager->IsInited())\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, packet.nParam1, \"World Server not inited, drop client msg:{}\", packet.ToString());\n        return -1;\n    }\n\n    if (m_pObjPluginManager->IsServerStopping())\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, packet.nParam1, \"World Server is Stopping, drop client msg:{}\", packet.ToString());\n        return -1;\n    }\n\n    switch(msgId)\n    {\n        case proto_ff::WORLD_TO_LOGIC_GET_ROLE_LIST_REQ:\n        {\n            OnHandleGetRoleList(msgId, packet, param1, param2);\n            break;\n        }\n        case proto_ff::WORLD_TO_LOGIC_CREATE_ROLE_INFO_REQ:\n        {\n            OnHandleCreateRole(msgId, packet, param1, param2);\n            break;\n        }\n        case proto_ff::WORLD_TO_LOGIC_LOGIN_REQ:\n        {\n            OnHandleLoginRole(msgId, packet, param1, param2);\n            break;\n        }\n        case proto_ff::WORLD_TO_OTHER_SERVER_NOTIFY_PLAYER_DISCONNECT:\n        {\n            OnHandlePlayerDisconnect(msgId, packet, param1, param2);\n            break;\n        }\n        case proto_ff::WORLD_TO_LOGIC_LOGIN_FINISH_NOTIFY:\n        {\n            OnHandleLoginFinishNotify(msgId, packet, param1, param2);\n            break;\n        }\n        case proto_ff::NOTIFY_LOGIC_LEAVE_GAME_REQ:\n        {\n            OnHandleLeaveGameReq(msgId, packet, param1, param2);\n            break;\n        }\n        default:\n        {\n            break;\n        }\n    }\n\n    return 0;\n}\n\n\nint NFLoginModule::OnHandleGetRoleList(uint32_t msgId, NFDataPackage &packet, uint64_t param1, uint64_t param2)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::WorldToLogicGetRoleList clogin;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, clogin);\n\n    NFTransGetRoleList* pTrans = dynamic_cast<NFTransGetRoleList *>(FindModule<NFISharedMemModule>()->CreateTrans(EOT_TRANS_LOGIC_GET_ROLE_LIST));\n    CHECK_EXPR(pTrans, -1, \"CreateTrans NFTransGetRoleList failed!\");\n    pTrans->Init(0, clogin.uid(), packet.nMsgId, 0, param1);\n    int iRetCode = pTrans->HandleCSMsgReq(&clogin);\n    CHECK_ERR_AND_FIN_TRANS(iRetCode, pTrans, \"pTrans->HandleCSMsgReq(&clogin) failed\");\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFLoginModule::OnHandleCreateRole(uint32_t msgId, NFDataPackage &packet, uint64_t reqTransId, uint64_t param2)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::WorldToLogicCreateRoleReq xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    NFTransCreateRole* pTrans = dynamic_cast<NFTransCreateRole *>(FindModule<NFISharedMemModule>()->CreateTrans(EOT_TRANS_LOGIC_CREATE_ROLE));\n    CHECK_EXPR(pTrans, -1, \"CreateTrans NFTransCreateRole failed!\");\n    pTrans->Init(xMsg.cid(), xMsg.uid(), packet.nMsgId, 0, reqTransId);\n    int iRetCode = pTrans->HandleCSMsgReq(&xMsg);\n    CHECK_ERR_AND_FIN_TRANS(iRetCode, pTrans, \"pTrans->HandleCSMsgReq(&clogin) failed\");\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFLoginModule::OnHandleLoginRole(uint32_t msgId, NFDataPackage &packet, uint64_t reqTransId, uint64_t param2)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::WorldToLogicLoginReq xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    NFTransGetRole* pTrans = dynamic_cast<NFTransGetRole *>(FindModule<NFISharedMemModule>()->CreateTrans(EOT_TRANS_LOGIC_GET_ROLE));\n    CHECK_EXPR(pTrans, -1, \"CreateTrans NFTransCreateRole failed!\");\n    pTrans->Init(xMsg.cid(), xMsg.uid(), packet.nMsgId, 0, reqTransId);\n    int iRetCode = pTrans->HandleCSMsgReq(&xMsg);\n    CHECK_ERR_AND_FIN_TRANS(iRetCode, pTrans, \"pTrans->HandleCSMsgReq(&clogin) failed\");\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFLoginModule::OnHandlePlayerDisconnect(uint32_t msgId, NFDataPackage &packet, uint64_t param1, uint64_t param2)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::WorldToOtherServerDisconnectNotify xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    NFPlayer *pPlayer = NFPlayerMgr::Instance(m_pObjPluginManager)->GetPlayer(xMsg.roleid());\n    if (pPlayer && pPlayer->GetStatus() < PLAYER_STATUS_OFFLINE)\n    {\n        pPlayer->OnDisconnect(xMsg.reason());\n    }\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFLoginModule::OnHandleLoginFinishNotify(uint32_t msgId, NFDataPackage &packet, uint64_t param1, uint64_t param2)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::WorldToLogicLoginFinishNotify xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    CharLoginInfo loginInfo;\n    loginInfo.sceneid = xMsg.scene_id();\n    loginInfo.mapid = xMsg.map_id();\n    loginInfo.pos.x = xMsg.pos().x();\n    loginInfo.pos.y = xMsg.pos().y();\n    loginInfo.pos.z = xMsg.pos().z();\n    //\n    loginInfo.uid = xMsg.uid();\n    loginInfo.gateId = xMsg.proxy_id();\n    loginInfo.clientId = xMsg.client_id();\n    //\n    loginInfo.transParam.transType = ETransType_Born;\n    loginInfo.transParam.srcMapId = loginInfo.lastMapId;\n\n    NFPlayerMgr::Instance(m_pObjPluginManager)->LoginGame(xMsg.role_id(), loginInfo);\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFLoginModule::OnHandleLeaveGameReq(uint32_t msgId, NFDataPackage &packet, uint64_t reqTransId, uint64_t param2)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::NotifyLogicLeaveGameReq2 xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    uint64_t uid = xMsg.uid();\n    uint64_t roleId = xMsg.cid();\n    uint32_t type = xMsg.type();\n\n    NFPlayer *pPlayer = NFPlayerMgr::Instance(m_pObjPluginManager)->GetPlayer(roleId);\n    if (pPlayer == NULL || pPlayer->GetGameId() <= 0)\n    {\n        proto_ff::NotifyLogicLeaveGameRsp2 rspMsg;\n        rspMsg.set_cid(roleId);\n        rspMsg.set_uid(uid);\n\n        FindModule<NFIServerMessageModule>()->SendTransToWorldServer(NF_ST_LOGIC_SERVER, proto_ff::NOTIFY_LOGIC_LEAVE_GAME_RSP, rspMsg, 0, reqTransId);\n    }\n\n    NFPlayerMgr::Instance(m_pObjPluginManager)->LogoutGame(uid, roleId, type, reqTransId);\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFLoginModule::OnHandleTransSceneReq(uint32_t msgId, NFDataPackage &packet, uint64_t uid, uint64_t roleId)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::TransSceneReq req;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, req);\n\n    int32_t transType = req.type(); //传送类型\n    uint64_t transId = req.id();\t//传送ID，针对路径点传送和区域传送\n    uint64_t dstMapId = req.dst_mapid(); //目标地图ID\n\n    NFPlayerMgr::Instance(m_pObjPluginManager)->TransScene(uid, roleId, dstMapId, transType, transId);\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Login/NFLoginModule.cpp b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Login/NFLoginModule.cpp
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Login/NFLoginModule.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Login/NFLoginModule.cpp	(date 1688616543376)
@@ -12,7 +12,7 @@
 #include "NFComm/NFPluginModule/NFLogMgr.h"
 #include <ClientServerCmd.pb.h>
 #include <ClientServer.pb.h>
-#include <NFLogicCommon/NFServerFrameTypeDefines.h>
+#include <NFLogicCommon/NFLogicShmTypeDefines.h>
 #include <NFComm/NFPluginModule/NFCheck.h>
 #include <ServerInternalCmd.pb.h>
 #include <ServerInternalCmd2.pb.h>
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransCreateRole.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransCreateRole.cpp\n//    @Author           :    gaoyi\n//    @Date             :    22-10-29\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransCreateRole\n//\n// -------------------------------------------------------------------------\n\n#include \"NFTransCreateRole.h\"\n\n#include <NFServerComm/NFServerCommon/NFIServerMessageModule.h>\n#include <NFComm/NFPluginModule/NFIConfigModule.h>\n#include <NFComm/NFCore/NFCommon.h>\n#include <ClientServer.pb.h>\n#include <ServerInternal.pb.h>\n#include <ServerInternalCmd.pb.h>\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include \"NFComm/NFKernelMessage/storesvr_sqldata.pb.h\"\n#include \"NFLogicCommon/NFICommLogicModule.h\"\n#include \"Player/NFPlayer.h\"\n#include \"Player/NFPlayerMgr.h\"\n#include \"ServerInternal2.pb.h\"\n#include \"ServerInternalCmd2.pb.h\"\n#include \"DBProto2.pb.h\"\n#include \"NFComm/NFPluginModule/NFIKernelModule.h\"\n#include \"NFTransGetRole.h\"\n\nIMPLEMENT_IDCREATE_WITHTYPE(NFTransCreateRole, EOT_TRANS_LOGIC_CREATE_ROLE, NFTransBase)\n\nNFTransCreateRole::NFTransCreateRole() : NFTransPlayerBase()\n{\n    if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode())\n    {\n        CreateInit();\n    }\n    else\n    {\n        ResumeInit();\n    }\n}\n\nNFTransCreateRole::~NFTransCreateRole()\n{\n}\n\nint NFTransCreateRole::CreateInit()\n{\n    return 0;\n}\n\nint NFTransCreateRole::ResumeInit()\n{\n    return 0;\n}\n\nint NFTransCreateRole::HandleCSMsgReq(const google::protobuf::Message *pCSMsgReq)\n{\n    const proto_ff::WorldToLogicCreateRoleReq *pCreateRole = dynamic_cast<const proto_ff::WorldToLogicCreateRoleReq *>(pCSMsgReq);\n    CHECK_EXPR(pCreateRole, -1, \"dynamic_cast<proto_ff::WorldToLogicCreateRoleReq*>(pCSMsgReq) Failed\");\n\n    auto pServerConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_LOGIC_SERVER);\n    CHECK_EXPR(pServerConfig, -1, \"FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_LOGIC_SERVER) Failed\");\n\n    NFPlayer *pPlayer = NFPlayerMgr::Instance(m_pObjPluginManager)->GetPlayer(m_roleId);\n    if (pPlayer)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"Create Role But Find The Role Player Data Exist, roleId:{} uid:{}\", m_roleId, m_uid);\n        return -1;\n    }\n\n    proto_ff::RoleDBData xData;\n    xData.set_cid(m_roleId);\n    xData.set_uid(m_uid);\n    xData.set_zid(pCreateRole->zid());\n\n    auto protobase = xData.mutable_base();\n    protobase->set_level(pCreateRole->level());\n    protobase->set_prof(pCreateRole->prof());\n    protobase->set_createtime(NFTime::Now().UnixSec());\n    protobase->set_name(pCreateRole->name());\n    protobase->set_exp(0);\n    protobase->set_hp(0);\n    protobase->set_fight(0);\n    protobase->set_vip_level(0);\n    protobase->set_logintime(NFTime::Now().UnixSec());\n    protobase->set_logouttime(0);\n    protobase->mutable_facade()->set_color(pCreateRole->color());\n\n    protobase->set_enter_scene_id(pCreateRole->enter_scene_id());\n    protobase->set_enter_map_id(pCreateRole->enter_map_id());\n    protobase->set_enterposx(pCreateRole->enterposx());\n    protobase->set_enterposy(pCreateRole->enterposy());\n    protobase->set_enterposz(pCreateRole->enterposz());\n\n    protobase->set_lastsceneid(pCreateRole->lastsceneid());\n    protobase->set_lastmapid(pCreateRole->lastmapid());\n    protobase->set_lastposx(pCreateRole->lastposx());\n    protobase->set_lastposy(pCreateRole->lastposy());\n    protobase->set_lastposz(pCreateRole->lastposz());\n\n\n    FindModule<NFIServerMessageModule>()->SendTransToStoreServer(NF_ST_LOGIC_SERVER, 0,\n                                                                 proto_ff::NF_STORESVR_C2S_INSERT, 0, pServerConfig->DefaultDBName,\n                                                                 \"RoleDBData\", xData, GetGlobalId(), 0, m_roleId);\n    return 0;\n}\n\nint NFTransCreateRole::HandleDBMsgRes(const google::protobuf::Message *pSSMsgRes, uint32_t cmd, uint32_t table_id,\n                                      uint32_t seq, int32_t err_code)\n{\n    if (cmd == proto_ff::NF_STORESVR_S2C_INSERT)\n    {\n        const storesvr_sqldata::storesvr_insertobj_res *pRes = dynamic_cast<const storesvr_sqldata::storesvr_insertobj_res *>(pSSMsgRes);\n        CHECK_EXPR(pRes, -1, \"pRes == NULL\");\n\n        if (err_code != 0)\n        {\n            return err_code;\n        }\n\n        NFPlayer *pPlayer = NFPlayerMgr::Instance(m_pObjPluginManager)->GetPlayer(m_roleId);\n        if (pPlayer)\n        {\n            return -1;\n        }\n\n        NFTransGetRole *pTrans = dynamic_cast<NFTransGetRole *>(FindModule<NFISharedMemModule>()->CreateTrans(EOT_TRANS_LOGIC_GET_ROLE));\n        CHECK_EXPR(pTrans, -1, \"CreateTrans NFTransCreateRole failed!\");\n\n        pTrans->Init(m_roleId, m_uid, m_cmd, 0, m_reqTransId);\n        pTrans->HandleCSMsgReq(NULL);\n\n        SetFinished(0);\n    }\n\n    return 0;\n}\n\nint NFTransCreateRole::HandleTransFinished(int iRunLogicRetCode)\n{\n    if (iRunLogicRetCode != 0)\n    {\n        proto_ff::LogicToWorldCreateRoleRsp xData;\n        xData.set_ret_code(proto_ff::RET_LOGIN_CHARACTER_CREATE_FAILED);\n        xData.set_uid(m_uid);\n        xData.set_cid(m_roleId);\n        FindModule<NFIServerMessageModule>()->SendMsgToWorldServer(NF_ST_LOGIC_SERVER, proto_ff::LOGIC_TO_WORLD_CREATE_ROLE_INFO_RSP, xData, m_uid);\n    }\n    return 0;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransCreateRole.cpp b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransCreateRole.cpp
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransCreateRole.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransCreateRole.cpp	(date 1688616543127)
@@ -15,7 +15,7 @@
 #include <ClientServer.pb.h>
 #include <ServerInternal.pb.h>
 #include <ServerInternalCmd.pb.h>
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFPluginModule/NFLogMgr.h"
 #include "NFComm/NFPluginModule/NFCheck.h"
 #include "NFComm/NFPluginModule/NFIMessageModule.h"
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransSaveRoleDetail.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransGetUserDetail.cpp\n//    @Author           :    xxxxx\n//    @Date             :   xxxx-xx-xx\n//    @Email\t\t\t:    xxxxxxxxx@xxx.xxx\n//    @Module           :    NFTransGetUserDetail.cpp\n//\n// -------------------------------------------------------------------------\n\n#include \"NFTransSaveRoleDetail.h\"\n\n#include <NFServerComm/NFServerCommon/NFIServerMessageModule.h>\n#include <NFComm/NFPluginModule/NFIConfigModule.h>\n#include <NFComm/NFCore/NFCommon.h>\n#include <ClientServer.pb.h>\n#include <ServerInternal.pb.h>\n#include <ServerInternalCmd.pb.h>\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include \"NFComm/NFKernelMessage/storesvr_sqldata.pb.h\"\n#include \"NFLogicCommon/NFICommLogicModule.h\"\n#include \"Player/NFPlayer.h\"\n#include \"Player/NFPlayerMgr.h\"\n#include \"ServerInternal2.pb.h\"\n#include \"ServerInternalCmd2.pb.h\"\n#include \"DBProto2.pb.h\"\n#include \"NFComm/NFPluginModule/NFIKernelModule.h\"\n\n\nIMPLEMENT_IDCREATE_WITHTYPE(NFTransSaveRoleDetail, EOT_TRANS_LOGIC_SAVE_ROLE, NFTransBase)\n\nNFTransSaveRoleDetail::NFTransSaveRoleDetail() : NFTransPlayerBase()\n{\n    if (NFShmMgr::Instance()->GetCreateMode() == EN_OBJ_MODE_INIT)\n    {\n        CreateInit();\n    }\n    else\n    {\n        ResumeInit();\n    }\n}\n\nNFTransSaveRoleDetail::~NFTransSaveRoleDetail()\n{\n\n}\n\nint NFTransSaveRoleDetail::CreateInit()\n{\n    SetState(TRANS_SAVE_ROLE_DETAIL_STATE_INIT);\n    m_reason = TRANS_SAVE_ROLE_DETAIL_NORMAL;\n    return 0;\n}\n\nint NFTransSaveRoleDetail::ResumeInit()\n{\n    return 0;\n}\n\nstd::string NFTransSaveRoleDetail::DebugString() const\n{\n    return NF_FORMAT(\"reason:{} NFTransPlayerBase:{}\", m_reason, NFTransPlayerBase::DebugString());\n}\n\nint NFTransSaveRoleDetail::HandleCSMsgReq(const google::protobuf::Message *pCSMsgReq)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFTransSaveRoleDetail::SaveRoleDetail(TRANS_SAVE_ROLE_DETAIL_REASON iReason)\n{\n    int iRetCode = 0;\n    CHECK_EXPR(GetState() == TRANS_SAVE_ROLE_DETAIL_STATE_INIT, -1, \"{}\", DebugString());\n\n    auto pPlayer = GetPlayer();\n    CHECK_EXPR(pPlayer, -1, \"SaveRoleDetail Failed! Can't find role detail data, {}\", DebugString());\n\n    auto pServerConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_LOGIC_SERVER);\n    CHECK_EXPR(pServerConfig, -1, \"FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_LOGIC_SERVER) Failed\");\n\n    m_reason = iReason;\n    pPlayer->SetLastSendRoleDetailSavedTime(NFTime::Now().UnixSec());\n\n    proto_ff::RoleDBData xData;\n    pPlayer->SaveDB(xData);\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"Save Role Info To Mysql:{}\", xData.DebugString());\n\n    iRetCode = FindModule<NFIServerMessageModule>()->SendTransToStoreServer(NF_ST_LOGIC_SERVER, 0,\n                                                                            proto_ff::NF_STORESVR_C2S_MODIFYOBJ, 0, pServerConfig->DefaultDBName,\n                                                                            \"RoleDBData\", xData, GetGlobalId(), pPlayer->GetCurRoleDetailSeq(), m_roleId);\n\n    SetState(TRANS_SAVE_ROLE_DETAIL_STATE_SAVING_ROLE);\n    return iRetCode;\n}\n\nint NFTransSaveRoleDetail::HandleDBMsgRes(const google::protobuf::Message *pSSMsgRes, uint32_t cmd, uint32_t table_id,\n                                  uint32_t seq,\n                                  int32_t err_code)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    int iRetCode = 0;\n    if (cmd == proto_ff::NF_STORESVR_S2C_MODIFYOBJ)\n    {\n        iRetCode = HandleSaveRoleDetailRes(err_code, seq);\n    }\n    else\n    {\n        iRetCode = -1;\n        NFLogTrace(NF_LOG_SYSTEMLOG, 0,\n                   \"Save Role Detial InTo Failed, cmd:{} tableid:{} err_code:{}\", cmd, table_id,\n                   err_code);\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRetCode;\n}\n\nint NFTransSaveRoleDetail::HandleSaveRoleDetailRes(uint32_t err_code, uint32_t seq)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    if (err_code != 0)\n    {\n        return proto_ff::ERR_CODE_SVR_SYSTEM_DATABASE_ERROR;\n    }\n\n    auto pPlayer = GetPlayer();\n    CHECK_NULL(pPlayer);\n\n    pPlayer->SetRoleDetailSavedSeq(seq);\n    pPlayer->SetRoleDetailSavingDBTime(0);\n\n\n\n    SetFinished(0);\n    SetState(TRANS_SAVE_ROLE_DETAIL_FIN_OK);\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFTransSaveRoleDetail::HandleTransFinished(int iRunLogicRetCode)\n{\n    auto pPlayer = GetPlayer();\n    CHECK_NULL(pPlayer);\n    pPlayer->SetRoleDetailSavingDBTime(0);\n\n    NFTransPlayerBase::HandleTransFinished(iRunLogicRetCode);\n    if (iRunLogicRetCode != 0)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"Save Role Detail To DB Failed!, iRunLogicRetCode:{} debug string:{}\", iRunLogicRetCode, DebugString());\n    }\n\n    if (iRunLogicRetCode == 0)\n    {\n        if (m_reason == TRANS_SAVE_ROLE_DETAIL_LOGOUT && pPlayer->GetStatus() == PLAYER_STATUS_LOGOUT)\n        {\n            NFPlayerMgr::Instance(m_pObjPluginManager)->OnLogout(pPlayer);\n        }\n    }\n\n    return 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransSaveRoleDetail.cpp b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransSaveRoleDetail.cpp
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransSaveRoleDetail.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransSaveRoleDetail.cpp	(date 1688616543339)
@@ -15,7 +15,7 @@
 #include <ClientServer.pb.h>
 #include <ServerInternal.pb.h>
 #include <ServerInternalCmd.pb.h>
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFPluginModule/NFLogMgr.h"
 #include "NFComm/NFPluginModule/NFCheck.h"
 #include "NFComm/NFPluginModule/NFIMessageModule.h"
Index: game/Fish/NFLogicComm/Message/common/DBProto.proto
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFLogicComm/Message/common/DBProto.proto b/game/Fish/NFLogicComm/Message/common/DBProto.proto
new file mode 100644
--- /dev/null	(date 1688622704211)
+++ b/game/Fish/NFLogicComm/Message/common/DBProto.proto	(date 1688622704211)
@@ -0,0 +1,14 @@
+package proto_ff;
+
+import "yd_fieldoptions.proto";
+import "Com.proto";
+
+message tbAccountTable
+{
+  optional uint64 player_id = 1 [(yd_fieldoptions.db_field_type) = E_FIELDTYPE_PRIMARYKEY, (yd_fieldoptions.db_field_auto_increment)=true, (yd_fieldoptions.db_field_auto_increment_value)=10000, (yd_fieldoptions.db_field_comment) = "玩家ID"];
+  optional string account = 2 [(yd_fieldoptions.db_field_type) = E_FIELDTYPE_UNIQUE_INDEX, (yd_fieldoptions.field_bufsize)=128, (yd_fieldoptions.db_field_bufsize)=128, (yd_fieldoptions.db_field_comment) = "账号"];
+  optional string password = 3 [(yd_fieldoptions.db_field_type) = E_FIELDTYPE_INDEX, (yd_fieldoptions.field_bufsize)=128, (yd_fieldoptions.db_field_bufsize)=128, (yd_fieldoptions.db_field_comment) = "密码"];
+  optional uint32 account_type = 4[(yd_fieldoptions.db_field_comment) = "账号类型"];
+  optional string device_id = 5[(yd_fieldoptions.field_bufsize)=128, (yd_fieldoptions.db_field_bufsize)=128, (yd_fieldoptions.db_field_comment) = "设备ID"];
+  optional uint64 phonenum = 6[(yd_fieldoptions.db_field_comment) = "手机号码"];
+}
\ No newline at end of file
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRoleList.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransGetRoleList.cpp\n//    @Author           :    gaoyi\n//    @Date             :    2022/10/14\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransGetRoleList\n//\n// -------------------------------------------------------------------------\n\n#include <NFServerComm/NFServerCommon/NFIServerMessageModule.h>\n#include <NFComm/NFPluginModule/NFIConfigModule.h>\n#include <NFComm/NFCore/NFCommon.h>\n#include <ClientServer.pb.h>\n#include <ServerInternal.pb.h>\n#include <ServerInternalCmd.pb.h>\n#include \"NFTransGetRoleList.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include \"NFComm/NFKernelMessage/storesvr_sqldata.pb.h\"\n#include \"NFLogicCommon/NFICommLogicModule.h\"\n#include \"Player/NFPlayer.h\"\n#include \"Player/NFPlayerMgr.h\"\n#include \"ServerInternal2.pb.h\"\n#include \"ServerInternalCmd2.pb.h\"\n#include \"DBProto2.pb.h\"\n\nIMPLEMENT_IDCREATE_WITHTYPE(NFTransGetRoleList, EOT_TRANS_LOGIC_GET_ROLE_LIST, NFTransBase)\n\nNFTransGetRoleList::NFTransGetRoleList():NFTransPlayerBase()\n{\n    if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode())\n    {\n        CreateInit();\n    } else\n    {\n        ResumeInit();\n    }\n}\n\nNFTransGetRoleList::~NFTransGetRoleList()\n{\n}\n\nint NFTransGetRoleList::CreateInit()\n{\n    SetState(EN_TGRL_INIT);\n    m_bornZid = 0;\n    m_proxyId = 0;\n    m_clientId = 0;\n    m_registerNum = 0;\n    return 0;\n}\n\nint NFTransGetRoleList::ResumeInit()\n{\n    return 0;\n}\n\nint NFTransGetRoleList::HandleCSMsgReq(const google::protobuf::Message *pCSMsgReq)\n{\n    const proto_ff::WorldToLogicGetRoleList* pLogin = dynamic_cast<const proto_ff::WorldToLogicGetRoleList*>(pCSMsgReq);\n    CHECK_EXPR(pLogin, -1, \"dynamic_cast<proto_ff::ClientLoginGateReq*>(pCSMsgReq) Failed\");\n\n\n    m_bornZid = pLogin->born_zone_id();\n    m_proxyId = pLogin->proxy_id();\n    m_clientId = pLogin->client_id();\n\n    SendGetRegisterNum();\n    return 0;\n}\n\nint NFTransGetRoleList::SendGetRoleList()\n{\n    auto pServerConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_LOGIC_SERVER);\n    CHECK_EXPR(pServerConfig, -1, \"FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_LOGIC_SERVER) Failed\");\n\n    std::vector<std::string> fields;\n    fields.push_back(\"cid\");\n    fields.push_back(\"zid\");\n    fields.push_back(\"uid\");\n    fields.push_back(\"base\");\n\n    std::vector<storesvr_sqldata::storesvr_vk> vk_list;\n    storesvr_sqldata::storesvr_vk cmd1;\n    cmd1.set_column_name(\"uid\");\n    cmd1.set_column_value(NFCommon::tostr(m_uid));\n    cmd1.set_column_type(storesvr_sqldata::E_COLUMNTYPE_NUM);\n    cmd1.set_cmp_operator(storesvr_sqldata::E_CMPOP_EQUAL);\n    cmd1.set_logic_operator(storesvr_sqldata::E_LOGICOP_AND);\n    vk_list.push_back(cmd1);\n\n    storesvr_sqldata::storesvr_vk cmd2;\n    cmd2.set_column_name(\"zid\");\n    cmd2.set_column_value(NFCommon::tostr(m_bornZid));\n    cmd2.set_column_type(storesvr_sqldata::E_COLUMNTYPE_NUM);\n    cmd2.set_cmp_operator(storesvr_sqldata::E_CMPOP_EQUAL);\n    vk_list.push_back(cmd2);\n\n    FindModule<NFIServerMessageModule>()->SendTransToStoreServer(NF_ST_LOGIC_SERVER, 0,\n                                                                 proto_ff::NF_STORESVR_C2S_SELECT, 0, pServerConfig->DefaultDBName,\n                                                                 \"RoleDBData\", fields, vk_list, \"\", 10,\n                                                                 GetGlobalId(), 0, m_uid);\n    return 0;\n}\n\nint NFTransGetRoleList::SendGetRegisterNum()\n{\n    auto pServerConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_LOGIC_SERVER);\n    CHECK_EXPR(pServerConfig, -1, \"FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_LOGIC_SERVER) Failed\");\n\n    FindModule<NFIServerMessageModule>()->SendTransToStoreServer(NF_ST_LOGIC_SERVER, 0,\n                                                                 proto_ff::NF_STORESVR_C2S_EXECUTE, 0, pServerConfig->DefaultDBName,\n                                                                 \"RoleDBData\", \"select count(*) as num from RoleDBData;\",\n                                                                 GetGlobalId(), 0, m_uid, \"GetRegisterNum_RoleDBData\");\n    return 0;\n}\n\nint NFTransGetRoleList::HandleDBMsgRes(const google::protobuf::Message *pSSMsgRes, uint32_t cmd, uint32_t table_id,\n                   uint32_t seq, int32_t err_code)\n{\n    if (cmd == proto_ff::NF_STORESVR_S2C_EXECUTE)\n    {\n        const storesvr_sqldata::storesvr_execute_res *pRes = dynamic_cast<const storesvr_sqldata::storesvr_execute_res *>(pSSMsgRes);\n        CHECK_EXPR(pRes, -1, \"pRes == NULL\");\n\n        if (err_code != 0)\n        {\n            m_registerNum = 0;\n            SetFinished(proto_ff::RET_FAIL);\n            return 0;\n        }\n        else {\n            proto_ff::GetRegisterNum_RoleDBData xMsg;\n            xMsg.ParsePartialFromString(pRes->sel_records());\n            m_registerNum = xMsg.num();\n        }\n\n        SendGetRoleList();\n    }\n    else if (cmd == proto_ff::NF_STORESVR_S2C_SELECT)\n    {\n        const storesvr_sqldata::storesvr_sel_res *pRes = dynamic_cast<const storesvr_sqldata::storesvr_sel_res *>(pSSMsgRes);\n        CHECK_EXPR(pRes, -1, \"pRes == NULL\");\n\n        proto_ff::LogicToWorldGetRoleListRsp xData;\n        xData.set_uid(m_uid);\n        xData.set_client_id(m_clientId);\n        xData.set_proxy_id(m_proxyId);\n        xData.set_born_zone_id(m_bornZid);\n        xData.set_register_num(m_registerNum);\n\n        if (err_code == 0)\n        {\n            xData.set_ret_code(err_code);\n            CHECK_EXPR(pRes->is_lastbatch(), -1, \"pRes->is_lastbatch() error\");\n            for(int i = 0; i < (int)pRes->sel_records_size(); i++)\n            {\n                auto pRoleInfo = xData.add_role_info_list();\n                pRoleInfo->ParsePartialFromString(pRes->sel_records(i));\n                NFLogDebug(NF_LOG_SYSTEMLOG, 0, \"{}\", pRoleInfo->DebugString());\n            }\n        }\n        else {\n            xData.set_ret_code(err_code);\n        }\n\n        FindModule<NFIServerMessageModule>()->SendTransToWorldServer(NF_ST_LOGIC_SERVER, proto_ff::LOGIC_TO_WORLD_GET_ROLE_LIST_RSP, xData,\n                                                                     GetGlobalId(), m_reqTransId);\n        SetFinished(0);\n    }\n    return 0;\n}\n\nint NFTransGetRoleList::HandleTransFinished(int iRunLogicRetCode)\n{\n    if (iRunLogicRetCode != 0)\n    {\n        proto_ff::LogicToWorldGetRoleListRsp xData;\n        xData.set_uid(m_uid);\n        xData.set_client_id(m_clientId);\n        xData.set_proxy_id(m_proxyId);\n        xData.set_born_zone_id(m_bornZid);\n\n        xData.set_ret_code(iRunLogicRetCode);\n\n        FindModule<NFIServerMessageModule>()->SendMsgToWorldServer(NF_ST_LOGIC_SERVER, proto_ff::LOGIC_TO_WORLD_GET_ROLE_LIST_RSP, xData);\n    }\n    return 0;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRoleList.cpp b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRoleList.cpp
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRoleList.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRoleList.cpp	(date 1688616543413)
@@ -14,7 +14,7 @@
 #include <ServerInternal.pb.h>
 #include <ServerInternalCmd.pb.h>
 #include "NFTransGetRoleList.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFPluginModule/NFLogMgr.h"
 #include "NFComm/NFPluginModule/NFCheck.h"
 #include "NFComm/NFPluginModule/NFIMessageModule.h"
Index: game/Fish/NFLogicComm/NFLogicCommon/NFLogicBindRpcService.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFLogicComm/NFLogicCommon/NFLogicBindRpcService.h b/game/Fish/NFLogicComm/NFLogicCommon/NFLogicBindRpcService.h
new file mode 100644
--- /dev/null	(date 1688616427121)
+++ b/game/Fish/NFLogicComm/NFLogicCommon/NFLogicBindRpcService.h	(date 1688616427121)
@@ -0,0 +1,16 @@
+// -------------------------------------------------------------------------
+//    @FileName         :    NFLogicBindRpcService.h
+//    @Author           :    gaoyi
+//    @Date             :    23-7-6
+//    @Email			:    445267987@qq.com
+//    @Module           :    NFLogicBindRpcService
+//
+// -------------------------------------------------------------------------
+
+#pragma once
+
+#include "NFComm/NFPluginModule/NFIRpcService.h"
+#include "ClientServerCmd.pb.h"
+#include "CSLogin.pb.h"
+
+DEFINE_BIND_RPC_SERVICE(proto_ff::NF_CS_MSG_AccountLoginReq, proto_ff::Proto_CSAccountLoginReq, proto_ff::Proto_SCAccountLoginRsp)
Index: Install/FishBusPlugin/StoreServer.lua
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>require \"Common\"\t\t--\n\n--StoreServer DB代理服务器， 负责从数据库取数据\n--ServerId = \"15.100.8.1\" 15是世界服务ID， 范围1-15\n-- 100是区服务ID， 范围1-65536\n-- 8是服务器类型ID， 必须跟serverType一样 范围1-255\n-- 1服务器索引，范围1-255\nStoreServer = {\n   StoreServer_7_1 = {\n        ServerName = \"StoreServer_7_1\",\n        ServerType = NF_ST_STORE_SERVER,\n        ServerId = NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_STORE_SERVER..\".1\",\t\t\t--对每一个服务器来说都是唯一的， 应用程序需要通过这个ServerId才能知道需要加载的配置是他\n        LinkMode = NF_LINK_MODE,\n        BusLength = NF_COMMON_BUS_LENGTH,     --20M共享内存\n        IdleSleepUS = 1000,\n        MaxConnectNum = NF_INTER_MAX_CONNECT,\n        NetThreadNum = 1,\n        WorkThreadNum = 8,\n        MaxOnlinePlayerNum = NF_MAX_ONLINE_PLAYER_COUNT,\n        ServerIp = NF_INTER_SERVER_IP,\n        ServerPort = NF_INTER_SERVER_PORT+NF_ST_STORE_SERVER*10+1,\n        HandleMsgNumPerFrame = NF_TRANS_SERVER_HANDLE_MSG_COUNT,\n        LoadProtoDs = \"Sql/CommonLogic.proto.ds\",\n        MysqlConfig = {\n             MysqlIp = NF_MYSQL_IP,\n             MysqlPort = NF_MYSQL_PORT,\n             MysqlDbName = NF_MYSQL_DB_NAME,\n             MysqlUser = NF_MYSQL_USER,\n             MysqlPassword = NF_MYSQL_PASSWORD,\n             TBConfList = {\n                  {TableName=\"RoleDBData\", TableCount=1},\n                  {TableName=\"RoleDBSnsDetail\", TableCount=1},\n                  {TableName=\"dbServerMgr\", TableCount=1},\n                  {TableName=\"tbServerMgr\", TableCount=1},\n             },\n        },\n        RouteConfig = {\n             RouteAgent = NF_ROUTE_AGENT_ID,\n             --NamingHost = NF_NAMING_HOST,\n             --NamingPath = NF_NAMING_PATH,\n             MasterIp = NF_MASTER_IP,\n             MasterPort = NF_MASTER_PORT,\n        },\n   };\n   StoreServer_7_2 = {\n        ServerName = \"StoreServer_7_2\",\n        ServerType = NF_ST_STORE_SERVER,\n        ServerId = NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_STORE_SERVER..\".2\",\t\t\t--对每一个服务器来说都是唯一的， 应用程序需要通过这个ServerId才能知道需要加载的配置是他\n        LinkMode = NF_LINK_MODE,\n        BusLength = NF_COMMON_BUS_LENGTH,     --20M共享内存\n        IdleSleepUS = 1000,\n        MaxConnectNum = NF_INTER_MAX_CONNECT,\n        NetThreadNum = 1,\n        WorkThreadNum = 8,\n        MaxOnlinePlayerNum = NF_MAX_ONLINE_PLAYER_COUNT,\n        ServerIp = NF_INTER_SERVER_IP,\n        ServerPort = NF_INTER_SERVER_PORT+NF_ST_STORE_SERVER*10+2,\n        HandleMsgNumPerFrame = NF_TRANS_SERVER_HANDLE_MSG_COUNT,\n        LoadProtoDs = \"Sql/CommonLogic.proto.ds\",\n        MysqlConfig = {\n             MysqlIp = NF_MYSQL_IP,\n             MysqlPort = NF_MYSQL_PORT,\n             MysqlDbName = NF_MYSQL_DB_NAME,\n             MysqlUser = NF_MYSQL_USER,\n             MysqlPassword = NF_MYSQL_PASSWORD,\n             TBConfList = {\n                  {TableName=\"RoleDBData\", TableCount=1},\n                  {TableName=\"RoleDBSnsDetail\", TableCount=1},\n                  {TableName=\"dbServerMgr\", TableCount=1},\n                  {TableName=\"tbServerMgr\", TableCount=1},\n             },\n        },\n        RouteConfig = {\n             RouteAgent = NF_ROUTE_AGENT_ID2,\n             --NamingHost = NF_NAMING_HOST,\n             --NamingPath = NF_NAMING_PATH,\n             MasterIp = NF_MASTER_IP,\n             MasterPort = NF_MASTER_PORT,\n        },\n   };\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Install/FishBusPlugin/StoreServer.lua b/Install/FishBusPlugin/StoreServer.lua
--- a/Install/FishBusPlugin/StoreServer.lua	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/Install/FishBusPlugin/StoreServer.lua	(date 1688622296040)
@@ -28,10 +28,7 @@
              MysqlUser = NF_MYSQL_USER,
              MysqlPassword = NF_MYSQL_PASSWORD,
              TBConfList = {
-                  {TableName="RoleDBData", TableCount=1},
-                  {TableName="RoleDBSnsDetail", TableCount=1},
-                  {TableName="dbServerMgr", TableCount=1},
-                  {TableName="tbServerMgr", TableCount=1},
+                  {TableName="tbAccountTable", TableCount=1},
              },
         },
         RouteConfig = {
@@ -64,10 +61,6 @@
              MysqlUser = NF_MYSQL_USER,
              MysqlPassword = NF_MYSQL_PASSWORD,
              TBConfList = {
-                  {TableName="RoleDBData", TableCount=1},
-                  {TableName="RoleDBSnsDetail", TableCount=1},
-                  {TableName="dbServerMgr", TableCount=1},
-                  {TableName="tbServerMgr", TableCount=1},
              },
         },
         RouteConfig = {
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRole.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransGetRole.cpp\n//    @Author           :    gaoyi\n//    @Date             :    22-10-31\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransGetRole\n//\n// -------------------------------------------------------------------------\n\n#include \"NFTransGetRole.h\"\n\n#include <NFServerComm/NFServerCommon/NFIServerMessageModule.h>\n#include <NFComm/NFPluginModule/NFIConfigModule.h>\n#include <NFComm/NFCore/NFCommon.h>\n#include <ClientServer.pb.h>\n#include <ServerInternal.pb.h>\n#include <ServerInternalCmd.pb.h>\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include \"NFComm/NFKernelMessage/storesvr_sqldata.pb.h\"\n#include \"NFLogicCommon/NFICommLogicModule.h\"\n#include \"Player/NFPlayer.h\"\n#include \"Player/NFPlayerMgr.h\"\n#include \"ServerInternal2.pb.h\"\n#include \"ServerInternalCmd2.pb.h\"\n#include \"DBProto2.pb.h\"\n#include \"NFComm/NFPluginModule/NFIKernelModule.h\"\n#include \"NFTransCreateRole.h\"\n\nIMPLEMENT_IDCREATE_WITHTYPE(NFTransGetRole, EOT_TRANS_LOGIC_GET_ROLE, NFTransBase)\n\nNFTransGetRole::NFTransGetRole():NFTransPlayerBase()\n{\n    if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode())\n    {\n        CreateInit();\n    } else\n    {\n        ResumeInit();\n    }\n}\n\nNFTransGetRole::~NFTransGetRole()\n{\n}\n\nint NFTransGetRole::CreateInit()\n{\n    m_proxyId = 0;\n    m_clientId = 0;\n    m_mapId = 0;\n    m_sceneId = 0;\n    m_isLoad = false;\n    return 0;\n}\n\nint NFTransGetRole::ResumeInit()\n{\n    return 0;\n}\n\nint NFTransGetRole::Init(uint64_t roleId, uint64_t uid, uint32_t cmd, uint32_t fromBusId, uint32_t reqTransId)\n{\n    NFTransPlayerBase::Init(roleId, uid, cmd, fromBusId, reqTransId);\n    return 0;\n}\n\nint NFTransGetRole::HandleCSMsgReq(const google::protobuf::Message *pCSMsgReq)\n{\n    if (m_cmd == proto_ff::WORLD_TO_LOGIC_LOGIN_REQ)\n    {\n        const proto_ff::WorldToLogicLoginReq* pEnterGameReq = dynamic_cast<const proto_ff::WorldToLogicLoginReq*>(pCSMsgReq);\n        CHECK_EXPR(pEnterGameReq, -1, \"dynamic_cast<proto_ff::NotifyLogicEnterGameReq*>(pCSMsgReq) Failed\");\n\n        m_proxyId = pEnterGameReq->proxy_id();\n        m_clientId = pEnterGameReq->client_id();\n        m_mapId = pEnterGameReq->map_id();\n        m_sceneId = pEnterGameReq->scene_id();\n        m_pos.x = pEnterGameReq->pos().x();\n        m_pos.y = pEnterGameReq->pos().y();\n        m_pos.z = pEnterGameReq->pos().z();\n\n        NFPlayer *pPlayer = NFPlayerMgr::Instance(m_pObjPluginManager)->GetPlayer(m_roleId);\n        if (pPlayer)\n        {\n            pPlayer->SetProxyId(m_proxyId);\n            pPlayer->SetClientId(m_clientId);\n            pPlayer->OnLoad(false);\n            SetFinished(0);\n        }\n        else {\n            SendGetRoleInfo();\n        }\n    }\n    else if (m_cmd == proto_ff::WORLD_TO_LOGIC_CREATE_ROLE_INFO_REQ)\n    {\n        SendGetRoleInfo();\n    }\n    return 0;\n}\n\nint NFTransGetRole::HandleDBMsgRes(const google::protobuf::Message *pSSMsgRes, uint32_t cmd, uint32_t table_id,\n                                      uint32_t seq, int32_t err_code)\n{\n    if (cmd == proto_ff::NF_STORESVR_S2C_SELECTOBJ)\n    {\n        const storesvr_sqldata::storesvr_selobj_res *pRes = dynamic_cast<const storesvr_sqldata::storesvr_selobj_res *>(pSSMsgRes);\n        CHECK_EXPR(pRes, -1, \"pRes == NULL\");\n\n        if (err_code != 0)\n        {\n            SetFinished(err_code);\n            return 0;\n        }\n\n        ::proto_ff::RoleDBData dbData;\n        dbData.ParsePartialFromString(pRes->sel_record());\n\n        HandleGetRoleDBRsp(dbData);\n    }\n    return 0;\n}\n\nint NFTransGetRole::HandleGetRoleDBRsp(proto_ff::RoleDBData& dbData)\n{\n    if (m_cmd == proto_ff::WORLD_TO_LOGIC_LOGIN_REQ)\n    {\n        m_isLoad = true;\n        NFPlayer *pPlayer = NFPlayerMgr::Instance(m_pObjPluginManager)->GetPlayer(m_roleId);\n        if (pPlayer == NULL)\n        {\n            pPlayer = NFPlayerMgr::Instance(m_pObjPluginManager)->CreatePlayer(dbData.cid(), dbData.uid(), dbData);\n            CHECK_EXPR(pPlayer, -1, \"CreatePlayerByUid Failed! roleId:{} uid:{}\", dbData.cid(), dbData.uid());\n            pPlayer->SetProxyId(m_proxyId);\n            pPlayer->SetClientId(m_clientId);\n            pPlayer->OnLoad(true);\n        }\n        else {\n            NFLogError(NF_LOG_SYSTEMLOG, m_roleId, \"HandleGetRoleDBRsp Fail! Get Role Load From DB, but mem has role data\");\n        }\n    }\n    else if (m_cmd == proto_ff::WORLD_TO_LOGIC_CREATE_ROLE_INFO_REQ)\n    {\n        proto_ff::LogicToWorldCreateRoleRsp xData;\n        xData.set_ret_code(proto_ff::RET_SUCCESS);\n        xData.set_uid(m_uid);\n        xData.set_cid(m_roleId);\n        xData.mutable_role_info()->CopyFrom(dbData);\n        CHECK_EXPR_ASSERT(xData.mutable_role_info()->cid() == m_roleId, -1, \"xData.mutable_role_info()->cid():{} != m_roleId:{}\", xData.mutable_role_info()->cid(), m_roleId);\n        NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"{}\", xData.DebugString());\n        FindModule<NFIServerMessageModule>()->SendTransToWorldServer(NF_ST_LOGIC_SERVER, proto_ff::LOGIC_TO_WORLD_CREATE_ROLE_INFO_RSP, xData,\n                                                                     GetGlobalId(), m_reqTransId);\n    }\n\n    SetFinished(0);\n    return 0;\n}\n\nint NFTransGetRole::HandleTransFinished(int iRunLogicRetCode)\n{\n    if (iRunLogicRetCode != 0)\n    {\n        if (m_cmd == proto_ff::WORLD_TO_LOGIC_CREATE_ROLE_INFO_REQ)\n        {\n            proto_ff::LogicToWorldCreateRoleRsp xData;\n            xData.set_ret_code(proto_ff::RET_LOGIN_CHARACTER_CREATE_FAILED);\n            xData.set_uid(m_uid);\n            xData.set_cid(m_roleId);\n            FindModule<NFIServerMessageModule>()->SendTransToWorldServer(NF_ST_LOGIC_SERVER, proto_ff::LOGIC_TO_WORLD_CREATE_ROLE_INFO_RSP, xData,\n                                                                         GetGlobalId(), m_reqTransId);\n        }\n        else if (m_cmd == proto_ff::WORLD_TO_LOGIC_LOGIN_REQ)\n        {\n            proto_ff::LogicToWorldLoginRsp xMsg;\n            xMsg.set_ret_code(iRunLogicRetCode);\n            FindModule<NFIServerMessageModule>()->SendTransToWorldServer(NF_ST_LOGIC_SERVER, proto_ff::LOGIC_TO_WORLD_LOGIN_RSP, xMsg, GetGlobalId(), m_reqTransId);\n            return 0;\n        }\n    }\n    else {\n        if (m_cmd == proto_ff::WORLD_TO_LOGIC_LOGIN_REQ)\n        {\n            NFPlayer *pPlayer = NFPlayerMgr::Instance(m_pObjPluginManager)->GetPlayer(m_roleId);\n            CHECK_NULL(pPlayer);\n\n            proto_ff::LogicToWorldLoginRsp xMsg;\n            xMsg.set_ret_code(proto_ff::RET_SUCCESS);\n            auto pData = xMsg.mutable_simple_data();\n            pData->set_uid(pPlayer->GetUid());\n            pData->set_cid(pPlayer->GetRoleId());\n            pData->set_zid(pPlayer->GetZid());\n            auto pBase = pData->mutable_base();\n            pPlayer->SetBaseData(pBase);\n            pPlayer->SendTransToWorldServer(proto_ff::LOGIC_TO_WORLD_LOGIN_RSP, xMsg, GetGlobalId(), m_reqTransId);\n            return 0;\n        }\n    }\n\n    return 0;\n}\n\nint NFTransGetRole::SendGetRoleInfo()\n{\n    auto pServerConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_LOGIC_SERVER);\n    CHECK_EXPR(pServerConfig, -1, \"FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_LOGIC_SERVER) Failed\");\n\n    proto_ff::RoleDBData xData;\n    xData.set_cid(m_roleId);\n\n    FindModule<NFIServerMessageModule>()->SendTransToStoreServer(NF_ST_LOGIC_SERVER, 0,\n                                                                 proto_ff::NF_STORESVR_C2S_SELECTOBJ, 0, pServerConfig->DefaultDBName,\n                                                                 \"RoleDBData\", xData, GetGlobalId(), 0, m_roleId);\n    return 0;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRole.cpp b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRole.cpp
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRole.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransGetRole.cpp	(date 1688616543038)
@@ -15,7 +15,7 @@
 #include <ClientServer.pb.h>
 #include <ServerInternal.pb.h>
 #include <ServerInternalCmd.pb.h>
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFPluginModule/NFLogMgr.h"
 #include "NFComm/NFPluginModule/NFCheck.h"
 #include "NFComm/NFPluginModule/NFIMessageModule.h"
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransTransScene.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransEnterScene.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-15\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransEnterScene\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"Base/NFTransPlayerBase.h\"\n#include \"Com_s.h\"\n#include \"NFLogicCommon/NFPoint3.h\"\n\nclass NFTransTransScene : public NFTransPlayerBase\n{\npublic:\n    NFTransTransScene();\n\n    virtual ~NFTransTransScene();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    /**\n     * @brief\n     * @param pCSMsgReq\n     * @return\n     */\n    virtual int HandleCSMsgReq(const google::protobuf::Message *pCSMsgReq);\n    virtual int HandleDispSvrRes(uint32_t nMsgId, const NFDataPackage &packet, uint32_t reqTransId, uint32_t rspTransId);\n    int OnHandleWorldEnterSceneRsp(uint32_t nMsgId, const NFDataPackage &packet, uint32_t reqTransId, uint32_t rspTransId);\n    int OnHandleWorldLeaveSceneRsp(uint32_t nMsgId, const NFDataPackage &packet, uint32_t reqTransId, uint32_t rspTransId);\n    int OnHandleGetMapInfoRsp(uint32_t nMsgId, const NFDataPackage &packet, uint32_t reqTransId, uint32_t rspTransId);\npublic:\n    /**\n     * @brief\n     * @return\n     */\n    int InitStaticMapInfo(uint64_t mapId, uint64_t scenceId, const NFPoint3<float> &dstPos);\n\npublic:\n    /**\n     * @brief\n     * @return\n     */\n    int SendEnterScene();\n\n    /**\n     * @brief\n     * @return\n     */\n    int SendLeaveScene();\n\n    /**\n     * @brief\n     * @param mapId\n     * @param sceneId\n     * @param pos\n     * @return\n     */\n    int TransScene(uint64_t mapId, uint32_t transType, uint64_t dstId);\n\n    int SendGetMapInfoReq();\npublic:\n    /**\n     * @brief\n     * @param iRunLogicRetCode\n     * @return\n     */\n    int HandleTransFinished(int iRunLogicRetCode);\nprivate:\n    uint64_t m_mapId;\n    uint64_t m_sceneId;\n    NFPoint3<float> m_pos;\n    uint32_t m_transType;\n    uint64_t m_transId;\nDECLARE_IDCREATE(NFTransTransScene)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransTransScene.h b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransTransScene.h
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransTransScene.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Trans/NFTransTransScene.h	(date 1688616542977)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "Base/NFTransPlayerBase.h"
 #include "Com_s.h"
Index: game/Fish/NFFishRobot/NFRobotModule.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFRobotModule.cpp\n//    @Author           :    xxxxx\n//    @Date             :   xxxx-xx-xx\n//    @Email\t\t\t:    xxxxxxxxx@xxx.xxx\n//    @Module           :    NFRobotModule.cpp\n//\n// -------------------------------------------------------------------------\n\n#include \"NFRobotModule.h\"\n#include \"NFTestRobot.h\"\n#include \"NFComm/NFCore/NFRandom.hpp\"\n#include \"NFComm/NFCore/NFStringUtility.h\"\n\nNFCRobotModule::NFCRobotModule(NFIPluginManager* p):NFIDynamicModule(p)\n{\n    std::string param = p->GetStrParam();\n    std::vector<std::string> vecParam;\n\n    m_startId = 10000;\n    m_robotNum = 1;\n    m_serverIp = \"127.0.0.1\";\n    m_port = 6051;\n    NFStringUtility::SplitStringToVector(param, \",\", vecParam);\n    if (vecParam.size() >= 2)\n    {\n        m_startId = NFCommon::strto<int>(vecParam[0]);\n        m_robotNum = NFCommon::strto<int>(vecParam[1]);\n    }\n    if (vecParam.size() >= 3)\n    {\n        m_serverIp = vecParam[2];\n    }\n    if (vecParam.size() >= 4)\n    {\n        m_port = NFCommon::strto<int>(vecParam[3]);\n    }\n    m_robotIndex = m_startId;\n}\n\nNFCRobotModule::~NFCRobotModule()\n{\n}\n\nbool NFCRobotModule::Init()\n{\n    SetTimer(1, 100, m_robotNum);\n    return true;\n}\n\nNFTestRobot* NFCRobotModule::CreateRobot()\n{\n    NFTestRobot* pRobot = NF_NEW NFTestRobot(m_pObjPluginManager);\n    pRobot->m_robotId = ++m_robotIndex;\n\n    m_robotMap.emplace(pRobot->m_robotId, pRobot);\n\n    return pRobot;\n}\n\nuint64_t NFCRobotModule::GetRandRobotUserId()\n{\n    int i = NFRandomInt(0, m_robotUserIdList.size());\n    if (i >= 0 && i < (int)m_robotUserIdList.size())\n    {\n        return m_robotUserIdList[i];\n    }\n    else if (m_robotUserIdList.size() > 0)\n    {\n        return m_robotUserIdList[0];\n    }\n    else\n    {\n        if ((int)m_robotMap.size() > 0)\n        {\n            return m_robotMap.begin()->second->m_playerId;\n        }\n    }\n\n    return 0;\n}\n\nint NFCRobotModule::OnTimer(uint32_t nTimerID)\n{\n    NFTestRobot* pRobot = CreateRobot();\n    std::string url = NF_FORMAT(\"tcp://{}:{}\", m_serverIp, m_port);\n    pRobot->ConnectServer(url);\n}\n\nbool NFCRobotModule::Execute()\n{\n    return true;\n}\n\nbool NFCRobotModule::BeforeShut()\n{\n    return true;\n}\n\nbool NFCRobotModule::Shut()\n{\n    return true;\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFFishRobot/NFRobotModule.cpp b/game/Fish/NFFishRobot/NFRobotModule.cpp
--- a/game/Fish/NFFishRobot/NFRobotModule.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/Fish/NFFishRobot/NFRobotModule.cpp	(date 1688432749999)
@@ -20,7 +20,7 @@
     m_startId = 10000;
     m_robotNum = 1;
     m_serverIp = "127.0.0.1";
-    m_port = 6051;
+    m_port = 8013;
     NFStringUtility::SplitStringToVector(param, ",", vecParam);
     if (vecParam.size() >= 2)
     {
@@ -44,7 +44,7 @@
 
 bool NFCRobotModule::Init()
 {
-    SetTimer(1, 100, m_robotNum);
+    SetTimer(1, 10000, m_robotNum);
     return true;
 }
 
@@ -85,6 +85,7 @@
     NFTestRobot* pRobot = CreateRobot();
     std::string url = NF_FORMAT("tcp://{}:{}", m_serverIp, m_port);
     pRobot->ConnectServer(url);
+    return 0;
 }
 
 bool NFCRobotModule::Execute()
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFPlayerMgr.h\n//    @Author           :    gaoyi\n//    @Date             :    2022/10/14\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFPlayerMgr\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFShmOldHashMap.h\"\n#include \"DBProto.pb.h\"\n#include \"Trans/NFTransSaveRoleDetail.h\"\n#include \"NFComm/NFShmCore/NFTickByRunIndexOP.h\"\n#include \"NFLogicCommon/NFRoleDefine.h\"\n\nclass NFPlayer;\n\nclass NFPlayerMgr : public NFShmObj, public NFTickByRunIndexOP\n{\npublic:\n    NFPlayerMgr();\n\n    virtual ~NFPlayerMgr();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    /**\n     * @brief\n     * @return\n     */\n    int Execute();\n\n    /**\n     * @brief\n     * @param pPlayer\n     * @param iReason\n     * @return\n     */\n    int SavePlayerRoleDetail(NFPlayer *pPlayer, TRANS_SAVE_ROLE_DETAIL_REASON iReason);\n\n    virtual int OnTimer(int timeId, int callcount);\npublic:\n    /**\n     * @brief 处理玩家登陆一些回调事情\n     * @param pPlayer\n     * @param isLoadDB\n     * @return\n     */\n    int OnLoad(NFPlayer *pPlayer, bool isLoadDB);\n\n    int OnLogin(NFPlayer *pPlayer, bool isLoadDB);\n\n    /**\n     * @brief 处理玩家登出一些回调事情\n     * @param pPlayer\n     * @return\n     */\n    int OnLogout(NFPlayer *pPlayer);\n\n    /**\n     * @brief 处理玩家掉线一些回调事情\n     * @param pPlayer\n     * @return\n     */\n    int OnDisconnect(NFPlayer *pPlayer);\n\n    /**\n     * @brief 处理玩家重连一些回调事情\n     * @param pPlayer\n     * @return\n     */\n    int OnReconnect(NFPlayer *pPlayer);\npublic:\n    //////////////////////////////每日每周刷新接口///////////////////////////////\n    /**\n     * @brief 每日每周刷新接口  策划配置，几点\n     * @param unixSec\n     */\n    int DailyUpdate(uint64_t unixSec);\n\n    /**\n     * @brief 每日每周刷新接口  策划配置，几点\n     * @param unixSec\n     */\n    int WeekUpdate(uint64_t unixSec);\n    //////////////////////////////每日零点 每周一零点 刷新接口///////////////////////////////\n\n    /**\n     * @brief 每日零点 每周一零点 刷新接口\n     * @param unixSec\n     */\n    int DailyZeroUpdate(uint64_t unixSec);\n\n    /**\n     * @brief 每日零点 每周一零点 刷新接口\n     * @param unixSec\n     */\n    int WeekZeroUpdate(uint64_t unixSec);\npublic:\n    /**\n     * @brief 处理玩家离线事件\n     * @param pPlayer\n     * @param isLoadDB\n     * @return\n     */\n    int OnEventLogLogin(NFPlayer *pPlayer, bool isLoadDB);\npublic:\n    /**\n     * @brief 通过roleId获取玩家数据\n     * @param roleId\n     * @return\n     */\n    NFPlayer *GetPlayer(uint64_t roleId);\n\n    /**\n     * @brief 通过roleId创建玩家数据, 如果玩家存在，返回NULL\n     * @param roleId\n     * @return\n     */\n    NFPlayer *CreatePlayer(uint64_t roleId, uint64_t uid, const ::proto_ff::RoleDBData &dbData);\n\n    /**\n     * @brief 删除玩家数据\n     * @param pPlayer\n     * @return\n     */\n    int DeletePlayer(NFPlayer *pPlayer);\n\npublic:\n    int LoginGame(uint64_t roleId, const CharLoginInfo& loginInfo);\n    int LogoutGame(uint64_t uid, uint64_t roleId, uint32_t type, uint32_t reqTransId);\n    int TransScene(uint64_t uid, uint64_t roleId, uint64_t mapId, uint32_t transType, uint64_t dstId);\npublic:\n    /**\n     * @brief 继承自NFTickByRunIndexOP， 用来平衡处理每一帧应该处理的玩家数\n     * @param dwCurRunIndex\n     * @param bIsTickAll\n     * @return\n     */\n    virtual int DoTick(uint32_t dwCurRunIndex, bool bIsTickAll = false);\nprivate:\n    int m_dayZeroTimer;\n    int m_weekZeroTimer;\nDECLARE_IDCREATE(NFPlayerMgr);\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerMgr.h b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerMgr.h
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerMgr.h	(date 1688616542950)
@@ -13,7 +13,7 @@
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFShmOldHashMap.h"
 #include "DBProto.pb.h"
 #include "Trans/NFTransSaveRoleDetail.h"
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFUserDetail.h\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFUserDetail.h\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmStl/NFShmVector.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFSeqOP.h\"\n#include \"NFComm/NFShmCore/NFShmPtr.h\"\n#include \"NFComm/NFCore/NFTime.h\"\n#include \"DBProto.pb.h\"\n#include \"Part/NFPart.h\"\n#include \"NFLogicCommon/NFRoleDefine.h\"\n#include \"NFLogicCommon/NFLogicCommonDefine.h\"\n#include \"NFPlayerBase.h\"\n#include \"DescStoreEx/NFAttr.h\"\n#include \"DBProto2.pb.h\"\n\nenum\n{\n    PLAYER_UID_INDEX = 0,\n    PLAYER_MAX_INDEX = 1,\n};\n\nclass NFPlayer : public NFShmObj, public NFPlayerBase\n{\npublic:\n    NFPlayer();\n\n    virtual ~NFPlayer();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    int Tick();\n\n    int Update();\n\npublic:\n    int Init(const ::proto_ff::RoleDBData &dbData);\n\n    int UnInit();\n\n    //存储DB部件入口\n    virtual int SaveDB(proto_ff::RoleDBData &dbData) override;\n\n    virtual void SetFacadeProto(proto_ff::RoleFacadeProto &outproto) override;\n\n    virtual void SetEnterSceneProto(proto_ff::RoleEnterSceneData &outproto) override;\n\n    //同步外观\n    virtual void SyncFacade() override;\n    //////////////////////////////每日每周刷新接口///////////////////////////////\n    /**\n     * @brief 每日每周刷新接口 策划配置，几点\n     * @param unixSec\n     */\n    int DailyUpdate(uint64_t unixSec);\n\n    /**\n     * @brief 每日每周刷新接口 策划配置，几点\n     * @param unixSec\n     */\n    int WeekUpdate(uint64_t unixSec);\n    //////////////////////////////每日零点 每周一零点 刷新接口///////////////////////////////\n\n    /**\n     * @brief 每日零点 每周一零点 刷新接口\n     * @param unixSec\n     */\n    int DailyZeroUpdate(uint64_t unixSec);\n\n    /**\n     * @brief 每日零点 每周一零点 刷新接口\n     * @param unixSec\n     */\n    int WeekZeroUpdate(uint64_t unixSec);\n\n    virtual int OnExecute(uint32_t serverType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message *pMessage);\n\npublic:\n\n    NFPart *CreatePart(uint32_t partType, const ::proto_ff::RoleDBData &dbData);\n\n    int RecylePart(NFPart *pPart);\n\npublic:\n    virtual uint32_t GetCurRoleDetailSeq() const override;\n\npublic:\n    int OnLoad(bool isLoadDB);\n\n    int OnLogin(bool isLoadDB);\n\n    int OnLogout();\n\n    int OnDisconnect(uint32_t reason);\n\n    int OnReconnect();\n\npublic:\n    int SendMsgToClient(uint32_t nMsgId, const google::protobuf::Message &xData);\n\n    int SendMsgToSnsServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n\n    int SendTransToSnsServer(uint32_t msgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0, uint32_t rsp_trans_id = 0);\n\n    int SendMsgToWorldServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n\n    int SendTransToWorldServer(uint32_t msgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0, uint32_t rsp_trans_id = 0);\n\n    int SendMsgToGameServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n\n    int SendTransToGameServer(uint32_t msgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0, uint32_t rsp_trans_id = 0);\n\n    virtual int FireGame(uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message &message, bool self = false);\n\n    virtual int FireSns(uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message &message, bool self = false);\n\npublic:\n    /**\n     * @brief\n     * @param mapId\n     * @param scenceId\n     * @param dstPos\n     * @return\n     */\n    int EnterScene(uint64_t mapId, uint64_t sceneId, const NFPoint3<float> &dstPos);\n\n    /**\n     * @brief\n     * @param type\n     * @param reqTransId\n     * @return\n     */\n    int LeaveScene(int type, uint32_t reqTransId);\n\n    /**\n     * @brief 请求场景传送\n     * @param mapId 目标地图ID\n     * @param transType 传送类型 0-无，1-传送到指定路径点(path),2-传送到区域\n     * @param dstId 目标坐标(传送类型为 1 的时候表示路径点ID，为2的时候表示区域ID)\n     * @return\n     */\n    int TransScene(uint64_t mapId, uint32_t transType, uint64_t dstId);\n\n    /**\n     * @brief\n     * @return\n     */\n    int NotifyPlayerInfo();\n\n    /**\n     * @brief\n     * @param loginInfo\n     * @param change\n     * @return\n     */\n    int LoginGame(const CharLoginInfo &loginInfo, bool change);\n\n    /**\n     * @brief\n     * @param type\n     * @return\n     */\n    int LogoutGame(int type, uint32_t reqTransId);\n\npublic:\n    //////////////////////////////////////////////////////////////////////////\n    //增加属性 主要是为了增加虚拟物品相关的属性 costFlag:是否是扣除属性\n    virtual void AddVirAttr(MAP_UINT32_INT64 &mapAttr, bool costFlag = false, SCommonSource *pSource = nullptr, bool syn = false);\n\n    //属性是否足够，主要是为了属性虚拟物品的判断\n    virtual bool EnoughVirAttr(MAP_UINT32_INT64 &mapAttr);\n\n    //增加属性\n    virtual bool AddAttr(uint32_t ANum, int64_t attrValue, SCommonSource *pSource = nullptr, bool syn = false);\n\n    //增加属性 不同步到客户端\n    virtual bool AddAttrCache(uint32_t ANum, int64_t attrValue, SCommonSource *pSource = nullptr);\n\n    //能否增加属性\n    virtual bool CanAddAttr(uint32_t ANum, int64_t attrValue, SCommonSource *pSource = nullptr);\n\n    //增加属性处理\n    virtual void OnAddAttr(uint32_t ANum, int64_t oldVal, int64_t attrValue, int64_t newVal, SCommonSource *pSource = nullptr);\n\n    //设置属性\n    virtual bool SetAttr(uint32_t ANum, int64_t attrValue, SCommonSource *pSource = nullptr, bool syn = false);\n\n    //设置属性 不同步客户端\n    virtual bool SetAttrCache(uint32_t ANum, int64_t attrValue, SCommonSource *pSource = nullptr);\n\n    //能否设置属性\n    virtual bool CanSetAttr(uint32_t ANum, int64_t attrValue, SCommonSource *pSource = nullptr);\n\n    //设置属性处理\n    virtual void OnSetAttr(uint32_t ANum, int64_t oldVal, int64_t attrValue, int64_t newVal, SCommonSource *pSource = nullptr);\n\n\n    //获取该组属性值\n    virtual int64_t GetAttrGroup(uint32_t attrGroup, uint32_t ANum);\n\n    //清除某一组属性\n    virtual bool ClearAttrGroup(uint32_t attrGroup, SCommonSource *pSource = nullptr, bool syn = false);\n\n    virtual bool ClearAttrGroupCache(uint32_t attrGroup, SCommonSource *pSource = nullptr);\n\n    //增加属性组属性\n    virtual bool AddAttrGroup(uint32_t attrGroup, uint32_t ANum, int64_t val, SCommonSource *pSource = nullptr, bool syn = false);\n\n    virtual bool AddAttrGroupCache(uint32_t attrGroup, uint32_t ANum, int64_t val, SCommonSource *pSource = nullptr);\n\n    //设置属性组属性\n    virtual bool SetAttrGroup(uint32_t attrGroup, uint32_t ANum, int64_t val, SCommonSource *pSource = nullptr, bool syn = false);\n\n    virtual bool SetAttrGroupCache(uint32_t attrGroup, uint32_t ANum, int64_t val, SCommonSource *pSource = nullptr);\n\n\n    //计算属性\n    virtual void CalcAttr(uint32_t ANum);\n\n    //计算属性组属性 主要是把属性组中的属性汇总到总属性中 ANum:属性组中的属性ID\n    virtual void CalcAttrGroup(uint32_t attrgroup, uint32_t ANum, MAP_UINT32_INT64 &mapchg);\n\n    //获取属性值\n    virtual int64_t GetAttr(uint32_t ANum);\n\n    //属性改变\n    virtual void OnAttrChange(int32_t ANum, int64_t oldVal, int64_t newVal, SCommonSource *pSource = nullptr);\n\n    void CheckExp(int64_t oldexp, SCommonSource *pSource);\n\n    void CalcLevelAttr(bool sync);\n\npublic:\n    //设置是否需要计算战力\n    virtual void SetCalcFight(bool calc) { m_calcfight = calc; }\n\n    //计算战力\n    virtual void CalcFight(bool sync);\n\npublic:\n    void SynAttrToClient();\n\n    //同步属性到Sns\n    void SynAttrToSns(const proto_ff::CenterRoleProto &proto);\n\npublic:\n    template<typename PART>\n    PART *GetPart(uint32_t partType)\n    {\n        return dynamic_cast<PART *>(GetPart(partType));\n    }\n\n    NFPart *GetPart(uint32_t partType);\n\nprivate:\n    bool m_calcfight;        //是否需要计算战力\n    NFShmVector<NFShmPtr<NFPart>, PART_MAX> m_pPart;\nDECLARE_IDCREATE(NFPlayer)\n};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayer.h b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayer.h
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayer.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayer.h	(date 1688616543386)
@@ -13,7 +13,7 @@
 #include "NFComm/NFShmCore/NFShmMgr.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmStl/NFShmVector.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFSeqOP.h"
 #include "NFComm/NFShmCore/NFShmPtr.h"
 #include "NFComm/NFCore/NFTime.h"
Index: src/NFServerComm/NFServerCommon/NFIServerMessageModule.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFIMsgModule.h\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFPluginModule\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFPluginModule/NFError.h\"\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFPluginModule/NFIModule.h\"\n#include \"NFComm/NFPluginModule/NFIDynamicModule.h\"\n#include \"NFComm/NFPluginModule/NFStoreProtoCommon.h\"\n#include \"NFServerBindRpcService.h\"\n#include \"NFComm/NFPluginModule/NFProtobufCommon.h\"\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <string>\n#include <map>\n#include <functional>\n#include <unordered_set>\n\n//#define TEST_SERVER_SEND_MSG\n#define TEST_SERVER_SEND_MSG_FRAME_COUNT 1\n\n/// @brief 基于消息的通讯接口类\nclass NFIServerMessageModule : public NFIDynamicModule\n{\npublic:\n    NFIServerMessageModule(NFIPluginManager *p) : NFIDynamicModule(p)\n    {\n\n    }\n\n    virtual ~NFIServerMessageModule()\n    {\n\n    }\n\npublic:\n    virtual int SendMsgToMasterServer(NF_SERVER_TYPES eSendTyp, uint32_t nMsgId, const google::protobuf::Message &xData, uint64_t nParam1 = 0,\n                                      uint64_t nParam2 = 0) = 0;\n\npublic:\n    ////////////////////////////send proxy msg to other serer//////////////////////////////////\n    virtual int\n    SendProxyMsgByBusId(NF_SERVER_TYPES eType, uint32_t nDstId, uint32_t nMsgId, const google::protobuf::Message &xData, uint64_t nParam1 = 0,\n                        uint64_t nParam2 = 0) = 0;\n\n    virtual int\n    SendProxyMsgByBusId(NF_SERVER_TYPES eType, uint32_t nDstId, uint32_t nModuleId, uint32_t nMsgId, const google::protobuf::Message &xData,\n                        uint64_t nParam1 = 0, uint64_t nParam2 = 0) = 0;\n\n    virtual int SendProxyMsgByBusId(NF_SERVER_TYPES eType, uint32_t nDstId, uint32_t nMsgId, const char *msg, uint32_t nLen, uint64_t nParam1 = 0,\n                                    uint64_t nParam2 = 0) = 0;\n\n    virtual int SendProxyMsgByBusId(NF_SERVER_TYPES eType, uint32_t nDstId, uint32_t nModuleId, uint32_t nMsgId, const char *msg, uint32_t nLen,\n                                    uint64_t nParam1 = 0, uint64_t nParam2 = 0) = 0;\n\n    ///////////////////////////other server send msg to proxy server/////////////////////////////\n    virtual int SendRedirectMsgToProxyServer(NF_SERVER_TYPES eType, uint32_t nDstId, const std::unordered_set<uint64_t> &ids, uint32_t nMsgId,\n                                             const google::protobuf::Message &xData) = 0;\n\n    virtual int\n    SendMsgToProxyServer(NF_SERVER_TYPES eType, uint32_t nDstId, uint32_t nMsgId, const google::protobuf::Message &xData, uint64_t nParam1 = 0,\n                         uint64_t nParam2 = 0) = 0;\n\n    virtual int\n    SendMsgToProxyServer(NF_SERVER_TYPES eType, uint32_t nDstId, uint32_t nModuleId, uint32_t nMsgId, const google::protobuf::Message &xData,\n                         uint64_t nParam1 = 0, uint64_t nParam2 = 0) = 0;\n\n    ///////////////////////////other server send msg to world server/////////////////////////////\n    virtual int SendMsgToWorldServer(NF_SERVER_TYPES eType, uint32_t nMsgId, const google::protobuf::Message &xData, uint64_t nParam1 = 0,\n                                     uint64_t nParam2 = 0) = 0;\n\n    virtual int\n    SendMsgToWorldServer(NF_SERVER_TYPES eType, uint32_t nModuleId, uint32_t nMsgId, const google::protobuf::Message &xData, uint64_t nParam1 = 0,\n                         uint64_t nParam2 = 0) = 0;\n\n    virtual int SendTransToWorldServer(NF_SERVER_TYPES eType, uint32_t nMsgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0,\n                                       uint32_t rsp_trans_id = 0) = 0;\n\n    ///////////////////////////other server send msg to game server/////////////////////////////\n    virtual int\n    SendMsgToGameServer(NF_SERVER_TYPES eType, uint32_t nDstId, uint32_t nMsgId, const google::protobuf::Message &xData, uint64_t nParam1 = 0,\n                        uint64_t nParam2 = 0) = 0;\n\n    virtual int\n    SendMsgToGameServer(NF_SERVER_TYPES eType, uint32_t nDstId, uint32_t nModuleId, uint32_t nMsgId, const google::protobuf::Message &xData,\n                        uint64_t nParam1 = 0, uint64_t nParam2 = 0) = 0;\n\n    virtual int\n    SendTransToGameServer(NF_SERVER_TYPES eType, uint32_t nDstId, uint32_t nMsgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0,\n                          uint32_t rsp_trans_id = 0) = 0;\n\n    ///////////////////////////other server send msg to logic server/////////////////////////////\n    virtual int\n    SendMsgToLogicServer(NF_SERVER_TYPES eType, uint32_t nDstId, uint32_t nMsgId, const google::protobuf::Message &xData, uint64_t nParam1 = 0,\n                         uint64_t nParam2 = 0) = 0;\n\n    virtual int\n    SendMsgToLogicServer(NF_SERVER_TYPES eType, uint32_t nDstId, uint32_t nModuleId, uint32_t nMsgId, const google::protobuf::Message &xData,\n                         uint64_t nParam1 = 0, uint64_t nParam2 = 0) = 0;\n\n    virtual int\n    SendTransToLogicServer(NF_SERVER_TYPES eType, uint32_t nDstId, uint32_t nMsgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0,\n                           uint32_t rsp_trans_id = 0) = 0;\n\n    ///////////////////////////other server send msg to sns server/////////////////////////////\n    virtual int SendMsgToSnsServer(NF_SERVER_TYPES eType, uint32_t nMsgId, const google::protobuf::Message &xData, uint64_t nParam1 = 0,\n                                   uint64_t nParam2 = 0) = 0;\n\n    virtual int\n    SendMsgToSnsServer(NF_SERVER_TYPES eType, uint32_t nModuleId, uint32_t nMsgId, const google::protobuf::Message &xData, uint64_t nParam1 = 0,\n                       uint64_t nParam2 = 0) = 0;\n\n    virtual int SendTransToSnsServer(NF_SERVER_TYPES eType, uint32_t nMsgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0,\n                                     uint32_t rsp_trans_id = 0) = 0;\n\npublic:\n    virtual int\n    SendTransToStoreServer(NF_SERVER_TYPES eType, uint32_t dstBusId, uint32_t cmd, uint32_t table_id,\n                           const std::string &dbname, const std::string &table_name, const google::protobuf::Message &xData, int trans_id = 0,\n                           uint32_t seq = 0,\n                           uint64_t mod_key = 0, const std::string &cls_name = \"\", uint8_t packet_type = proto_ff::E_DISP_TYPE_BY_TRANSACTION) = 0;\n\n    virtual int\n    SendTransToStoreServer(NF_SERVER_TYPES eType, uint32_t dstBusId, uint32_t cmd, uint32_t table_id,\n                           const std::string &dbname, const std::string &table_name, const std::vector<std::string> &vecFileds,\n                           const std::vector<storesvr_sqldata::storesvr_vk> &vk_list,\n                           const std::string &where_addtional_conds, int max_records = 100, int trans_id = 0, uint32_t seq = 0,\n                           uint64_t mod_key = 0, const std::string &cls_name = \"\", uint8_t packet_type = proto_ff::E_DISP_TYPE_BY_TRANSACTION) = 0;\n\n    virtual int\n    SendTransToStoreServer(NF_SERVER_TYPES eType, uint32_t dstBusId, uint32_t cmd, uint32_t table_id,\n                           const std::string &dbname, const std::string &table_name, const google::protobuf::Message &xData,\n                           const std::vector<storesvr_sqldata::storesvr_vk> &vk_list,\n                           const std::string &where_addtional_conds, int trans_id = 0, uint32_t seq = 0,\n                           uint64_t mod_key = 0, const std::string &cls_name = \"\", uint8_t packet_type = proto_ff::E_DISP_TYPE_BY_TRANSACTION) = 0;\n\n    virtual int\n    SendTransToStoreServer(NF_SERVER_TYPES eType, uint32_t dstBusId, uint32_t cmd, uint32_t table_id,\n                           const std::string &dbname, const std::string &table_name, const std::string &xData, int max_records, int trans_id = 0,\n                           uint32_t seq = 0,\n                           uint64_t mod_key = 0, const std::string &cls_name = \"\", uint8_t packet_type = proto_ff::E_DISP_TYPE_BY_TRANSACTION) = 0;\n\n    virtual int\n    SendTransToStoreServer(NF_SERVER_TYPES eType, uint32_t dstBusId, uint32_t cmd, uint32_t table_id,\n                           const std::string &dbname, const std::string &table_name, const std::string &xData, int trans_id = 0, uint32_t seq = 0,\n                           uint64_t mod_key = 0, const std::string &cls_name = \"\", uint8_t packet_type = proto_ff::E_DISP_TYPE_BY_TRANSACTION) = 0;\n\npublic:\n    ///////////////////////store server select obj////////////////////////////////////////////////////////////////////////\n    template<typename DataType>\n    int GetRpcSelectObjService(NF_SERVER_TYPES eType, uint64_t mod_key, DataType &data,\n                               const std::vector<std::string> &vecFields = std::vector<std::string>(), uint32_t dstBusId = 0,\n                               const std::string &dbname = \"\")\n    {\n        std::string tempDBName = dbname;\n        if (dbname.empty())\n        {\n            NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n            if (pConfig)\n            {\n                tempDBName = pConfig->DefaultDBName;\n            }\n        }\n        CHECK_EXPR(!tempDBName.empty(), -1, \"no dbname ........\");\n\n\n        storesvr_sqldata::storesvr_selobj selobj;\n        std::string tbname = NFProtobufCommon::GetProtoBaseName(data);\n        std::string packageName = NFProtobufCommon::GetProtoPackageName(data);\n        CHECK_EXPR(!tbname.empty(), -1, \"no tbname ........\");\n        NFStoreProtoCommon::storesvr_selectobj(selobj, tempDBName, tbname, mod_key, data, tbname, packageName, vecFields);\n\n        storesvr_sqldata::storesvr_selobj_res selobjRes;\n        int iRet = FindModule<NFIMessageModule>()->GetRpcService<proto_ff::NF_STORESVR_C2S_SELECTOBJ>(eType, NF_ST_STORE_SERVER, dstBusId, selobj,\n                                                                                                      selobjRes);\n        if (iRet == 0)\n        {\n            data.ParseFromString(selobjRes.sel_record());\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetRpcService Failed, proto_ff::E_STORESVR_C2S_SELECTOBJ iRet:{} errMsg:{}\", GetErrorStr(iRet),\n                       selobjRes.sel_opres().errmsg());\n        }\n        return iRet;\n    }\n\n    template<class DataType, typename ResponFunc>\n    int GetRpcSelectObjService(NF_SERVER_TYPES eType, uint64_t mod_key, DataType &data, const ResponFunc &func,\n                               const std::vector<std::string> &vecFields = std::vector<std::string>(), uint32_t dstBusId = 0,\n                               const std::string &dbname = \"\")\n    {\n        return GetRpcSelectObjServiceInner(eType, mod_key, data, func, &ResponFunc::operator(), vecFields, dstBusId, dbname);\n    }\n\n    virtual int SendSelectObjTrans(NF_SERVER_TYPES eType, uint64_t mod_key, google::protobuf::Message &data, uint32_t table_id = 0, int trans_id = 0,\n                                   uint32_t seq = 0,\n                                   const std::vector<std::string> &vecFields = std::vector<std::string>(), uint32_t dstBusId = 0,\n                                   const std::string &dbname = \"\") = 0;\n\nprivate:\n    template<class DataType, typename ResponFunc>\n    int GetRpcSelectObjServiceInner(NF_SERVER_TYPES eType, uint64_t mod_key, DataType &data, const ResponFunc &responFunc,\n                                    void (ResponFunc::*pf)(int rpcRetCode, DataType &respone) const,\n                                    const std::vector<std::string> &vecFields = std::vector<std::string>(), uint32_t dstBusId = 0,\n                                    const std::string &dbname = \"\")\n    {\n        int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine\n                ([=]()\n                 {\n                     DataType respone = data;\n                     int rpcRetCode = GetRpcSelectObjService(eType, mod_key, respone, vecFields,\n                                                             dstBusId, dbname);\n                     (responFunc.*pf)(rpcRetCode, respone);\n                 });\n        return iRet;\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\npublic:\n    ///////////////////////store server select////////////////////////////////////////////////////////////////////////////\n    template<typename DataType>\n    int GetRpcSelectService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, std::vector<DataType> &respone,\n                            const std::vector<std::string> &vecFields = std::vector<std::string>(), const std::string &where_addtional_conds = \"\",\n                            int max_records = 100, uint32_t dstBusId = 0,\n                            const std::string &dbname = \"\")\n    {\n        std::string tempDBName = dbname;\n        if (dbname.empty())\n        {\n            NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n            if (pConfig)\n            {\n                tempDBName = pConfig->DefaultDBName;\n            }\n        }\n        CHECK_EXPR(!tempDBName.empty(), -1, \"no dbname ........\");\n\n\n        storesvr_sqldata::storesvr_sel sel;\n        std::string tbname = NFProtobufCommon::GetProtoBaseName(data);\n        std::string packageName = NFProtobufCommon::GetProtoPackageName(data);\n        CHECK_EXPR(!tbname.empty(), -1, \"no tbname ........\");\n\n        std::vector<storesvr_sqldata::storesvr_vk> vk_list;\n        NFStoreProtoCommon::get_vk_list_from_proto(data, vk_list);\n\n        NFStoreProtoCommon::storesvr_selectbycond(sel, tempDBName, tbname, mod_key, vecFields, vk_list, where_addtional_conds, max_records,\n                                                  tbname, packageName);\n\n        storesvr_sqldata::storesvr_sel_res selRes;\n        STATIC_ASSERT_BIND_RPC_SERVICE(proto_ff::NF_STORESVR_C2S_SELECT, storesvr_sqldata::storesvr_sel, storesvr_sqldata::storesvr_sel_res);\n        NF_ASSERT_MSG(FindModule<NFICoroutineModule>()->IsInCoroutine(), \"Call GetRpcService Must Int the Coroutine\");\n        NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n        CHECK_EXPR(pConfig, -1, \"can't find server config! servertype:{}\", GetServerName(eType));\n\n        proto_ff::Proto_SvrPkg svrPkg;\n        svrPkg.set_msg_id(proto_ff::NF_STORESVR_C2S_SELECT);\n        svrPkg.set_msg_data(sel.SerializeAsString());\n        svrPkg.mutable_rpc_info()->set_req_rpc_id(FindModule<NFICoroutineModule>()->CurrentTaskId());\n        svrPkg.mutable_rpc_info()->set_req_rpc_hash(std::hash<std::string>()(sel.GetTypeName()));\n        svrPkg.mutable_rpc_info()->set_rsp_rpc_hash(std::hash<std::string>()(selRes.GetTypeName()));\n        svrPkg.mutable_rpc_info()->set_req_server_type(eType);\n        svrPkg.mutable_rpc_info()->set_req_bus_id(pConfig->BusId);\n\n        FindModule<NFIMessageModule>()->SendMsgToServer(eType, NF_ST_STORE_SERVER, pConfig->BusId, dstBusId, proto_ff::NF_SERVER_TO_SERVER_RPC_CMD,\n                                                        svrPkg);\n\n        int iRet = FindModule<NFICoroutineModule>()->SetUserData(&selRes);\n        CHECK_EXPR(iRet == 0, iRet, \"Yield Failed, Error:{}\", GetErrorStr(iRet));\n\n        do\n        {\n            iRet = FindModule<NFICoroutineModule>()->Yield(DEFINE_RPC_SERVICE_TIME_OUT_MS);\n            CHECK_EXPR(iRet == 0, iRet, \"Yield Failed, Error:{}\", GetErrorStr(iRet));\n            if (iRet == 0)\n            {\n                for (int i = 0; i < (int) selRes.sel_records_size(); i++)\n                {\n                    DataType result;\n                    result.ParseFromString(selRes.sel_records(i));\n                    respone.push_back(result);\n                }\n\n                if (selRes.is_lastbatch())\n                {\n                    break;\n                }\n            }\n            else\n            {\n                NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetRpcService Failed, proto_ff::E_STORESVR_C2S_SELECTOBJ iRet:{} errMsg:{}\", GetErrorStr(iRet),\n                           selRes.sel_opres().errmsg());\n                break;\n            }\n        } while (true);\n\n\n        FindModule<NFICoroutineModule>()->SetUserData(NULL);\n\n        return iRet;\n    }\n\n    template<class DataType, typename ResponFunc>\n    int GetRpcSelectService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, const ResponFunc &func,\n                            const std::vector<std::string> &vecFields = std::vector<std::string>(), const std::string &where_addtional_conds = \"\",\n                            int max_records = 100, uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        return GetRpcSelectServiceInner(eType, mod_key, data, func, &ResponFunc::operator(), vecFields, where_addtional_conds, max_records, dstBusId,\n                                        dbname);\n    }\n\nprivate:\n    template<class DataType, typename ResponFunc>\n    int GetRpcSelectServiceInner(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, const ResponFunc &responFunc,\n                                 void (ResponFunc::*pf)(int rpcRetCode, std::vector<DataType> &respone) const,\n                                 const std::vector<std::string> &vecFields = std::vector<std::string>(),\n                                 const std::string &where_addtional_conds = \"\", int max_records = 100, uint32_t dstBusId = 0,\n                                 const std::string &dbname = \"\")\n    {\n        int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine\n                ([=]()\n                 {\n                     std::vector<DataType> respone;\n                     int rpcRetCode = GetRpcSelectService(eType, mod_key, data, respone, vecFields, where_addtional_conds, max_records,\n                                                          dstBusId, dbname);\n\n                     (responFunc.*pf)(rpcRetCode, respone);\n                 });\n        return iRet;\n    }\n\npublic:\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////store server insert////////////////////////////////////////////////////////////////////////////\n    template<typename DataType>\n    int GetRpcInsertObjService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        std::string tempDBName = dbname;\n        if (dbname.empty())\n        {\n            NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n            if (pConfig)\n            {\n                tempDBName = pConfig->DefaultDBName;\n            }\n        }\n        CHECK_EXPR(!tempDBName.empty(), -1, \"no dbname ........\");\n\n\n        storesvr_sqldata::storesvr_insertobj selobj;\n        std::string tbname = NFProtobufCommon::GetProtoBaseName(data);\n        std::string packageName = NFProtobufCommon::GetProtoPackageName(data);\n        CHECK_EXPR(!tbname.empty(), -1, \"no tbname ........\");\n        NFStoreProtoCommon::storesvr_insertobj(selobj, tempDBName, tbname, mod_key, data, tbname, packageName);\n\n        storesvr_sqldata::storesvr_insertobj_res selobjRes;\n        int iRet = FindModule<NFIMessageModule>()->GetRpcService<proto_ff::NF_STORESVR_C2S_INSERTOBJ>(eType, NF_ST_STORE_SERVER, dstBusId, selobj,\n                                                                                                      selobjRes);\n        if (iRet == 0)\n        {\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetRpcService Failed, proto_ff::NF_STORESVR_C2S_INSERTOBJ iRet:{} errMsg:{}\", GetErrorStr(iRet),\n                       selobjRes.ins_opres().errmsg());\n        }\n        return iRet;\n    }\n\n    template<class DataType>\n    int GetRpcInsertObjService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, const std::function<void(int)> &func,\n                               uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine\n                ([=]()\n                 {\n                     int rpcRetCode = GetRpcInsertObjService(eType, mod_key, data, dstBusId, dbname);\n                     if (func)\n                     {\n                         func(rpcRetCode);\n                     }\n                 });\n        return iRet;\n    }\n\n/*    virtual int SendInsertObjTrans(NF_SERVER_TYPES eType, uint64_t mod_key, google::protobuf::Message &data, uint32_t table_id = 0, int trans_id = 0,\n                                   uint32_t seq = 0,\n                                   const std::vector<std::string> &vecFields = std::vector<std::string>(), uint32_t dstBusId = 0,\n                                   const std::string &dbname = \"\") = 0;*/\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////store server modifyobj////////////////////////////////////////////////////////////////////////////\n    template<typename DataType>\n    int GetRpcModifyObjService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        std::string tempDBName = dbname;\n        if (dbname.empty())\n        {\n            NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n            if (pConfig)\n            {\n                tempDBName = pConfig->DefaultDBName;\n            }\n        }\n        CHECK_EXPR(!tempDBName.empty(), -1, \"no dbname ........\");\n\n\n        storesvr_sqldata::storesvr_modobj selobj;\n        std::string tbname = NFProtobufCommon::GetProtoBaseName(data);\n        std::string packageName = NFProtobufCommon::GetProtoPackageName(data);\n        CHECK_EXPR(!tbname.empty(), -1, \"no tbname ........\");\n        NFStoreProtoCommon::storesvr_modifyobj(selobj, tempDBName, tbname, mod_key, data, tbname, packageName);\n\n        storesvr_sqldata::storesvr_modobj_res selobjRes;\n        int iRet = FindModule<NFIMessageModule>()->GetRpcService<proto_ff::NF_STORESVR_C2S_MODIFYOBJ>(eType, NF_ST_STORE_SERVER, dstBusId, selobj,\n                                                                                                      selobjRes);\n        if (iRet == 0)\n        {\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetRpcService Failed, proto_ff::NF_STORESVR_C2S_MODIFYOBJ iRet:{} errMsg:{}\", GetErrorStr(iRet),\n                       selobjRes.mod_opres().errmsg());\n        }\n        return iRet;\n    }\n\n    template<class DataType>\n    int GetRpcModifyObjService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, const std::function<void(int)> &func,\n                               uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine\n                ([=]()\n                 {\n                     int rpcRetCode = GetRpcModifyObjService(eType, mod_key, data, dstBusId, dbname);\n                     if (func)\n                     {\n                         func(rpcRetCode);\n                     }\n                 });\n        return iRet;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////store server UpdateObj////////////////////////////////////////////////////////////////////////////\n    template<typename DataType>\n    int GetRpcUpdateObjService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        std::string tempDBName = dbname;\n        if (dbname.empty())\n        {\n            NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n            if (pConfig)\n            {\n                tempDBName = pConfig->DefaultDBName;\n            }\n        }\n        CHECK_EXPR(!tempDBName.empty(), -1, \"no dbname ........\");\n\n\n        storesvr_sqldata::storesvr_updateobj selobj;\n        std::string tbname = NFProtobufCommon::GetProtoBaseName(data);\n        std::string packageName = NFProtobufCommon::GetProtoPackageName(data);\n        CHECK_EXPR(!tbname.empty(), -1, \"no tbname ........\");\n        NFStoreProtoCommon::storesvr_updateobj(selobj, tempDBName, tbname, mod_key, data, tbname, packageName);\n\n        storesvr_sqldata::storesvr_updateobj_res selobjRes;\n        int iRet = FindModule<NFIMessageModule>()->GetRpcService<proto_ff::NF_STORESVR_C2S_UPDATEOBJ>(eType, NF_ST_STORE_SERVER, dstBusId, selobj,\n                                                                                                      selobjRes);\n        if (iRet == 0)\n        {\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetRpcService Failed, proto_ff::NF_STORESVR_C2S_MODINSOBJ iRet:{} errMsg:{}\", GetErrorStr(iRet),\n                       selobjRes.modins_opres().errmsg());\n        }\n        return iRet;\n    }\n\n    template<class DataType>\n    int GetRpcUpdateObjService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, const std::function<void(int)> &func,\n                               uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine\n                ([=]()\n                 {\n                     int rpcRetCode = GetRpcUpdateObjService(eType, mod_key, data, dstBusId, dbname);\n                     if (func)\n                     {\n                         func(rpcRetCode);\n                     }\n                 });\n        return iRet;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////store server delete obj////////////////////////////////////////////////////////////////////////////\n    template<typename DataType>\n    int GetRpcDeleteObjService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        std::string tempDBName = dbname;\n        if (dbname.empty())\n        {\n            NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n            if (pConfig)\n            {\n                tempDBName = pConfig->DefaultDBName;\n            }\n        }\n        CHECK_EXPR(!tempDBName.empty(), -1, \"no dbname ........\");\n\n\n        storesvr_sqldata::storesvr_delobj selobj;\n        std::string tbname = NFProtobufCommon::GetProtoBaseName(data);\n        std::string packageName = NFProtobufCommon::GetProtoPackageName(data);\n        CHECK_EXPR(!tbname.empty(), -1, \"no tbname ........\");\n        NFStoreProtoCommon::storesvr_deleteobj(selobj, tempDBName, tbname, mod_key, data, tbname, packageName);\n\n        storesvr_sqldata::storesvr_delobj_res selobjRes;\n        int iRet = FindModule<NFIMessageModule>()->GetRpcService<proto_ff::NF_STORESVR_C2S_DELETEOBJ>(eType, NF_ST_STORE_SERVER, dstBusId, selobj,\n                                                                                                      selobjRes);\n        if (iRet == 0)\n        {\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetRpcService Failed, proto_ff::NF_STORESVR_C2S_DELETEOBJ iRet:{} errMsg:{}\", GetErrorStr(iRet),\n                       selobjRes.del_opres().errmsg());\n        }\n        return iRet;\n    }\n\n    template<class DataType>\n    int GetRpcDeleteObjService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, const std::function<void(int)> &func,\n                               uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine\n                ([=]()\n                 {\n                     int rpcRetCode = GetRpcDeleteObjService(eType, mod_key, data, dstBusId, dbname);\n                     if (func)\n                     {\n                         func(rpcRetCode);\n                     }\n                 });\n        return iRet;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////store server delete////////////////////////////////////////////////////////////////////////////\n    template<typename DataType>\n    int GetRpcDeleteService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, const std::string &where_addtional_conds = \"\",\n                            uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        std::string tempDBName = dbname;\n        if (dbname.empty())\n        {\n            NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n            if (pConfig)\n            {\n                tempDBName = pConfig->DefaultDBName;\n            }\n        }\n        CHECK_EXPR(!tempDBName.empty(), -1, \"no dbname ........\");\n\n\n        storesvr_sqldata::storesvr_del selobj;\n        std::string tbname = NFProtobufCommon::GetProtoBaseName(data);\n        std::string packageName = NFProtobufCommon::GetProtoPackageName(data);\n        CHECK_EXPR(!tbname.empty(), -1, \"no tbname ........\");\n        std::vector<storesvr_sqldata::storesvr_vk> vk_list;\n        NFStoreProtoCommon::get_vk_list_from_proto(data, vk_list);\n        NFStoreProtoCommon::storesvr_deletebycond(selobj, tempDBName, tbname, mod_key, vk_list, where_addtional_conds, tbname, packageName);\n\n        storesvr_sqldata::storesvr_del_res selobjRes;\n        int iRet = FindModule<NFIMessageModule>()->GetRpcService<proto_ff::NF_STORESVR_C2S_DELETE>(eType, NF_ST_STORE_SERVER, dstBusId, selobj,\n                                                                                                   selobjRes);\n        if (iRet == 0)\n        {\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetRpcService Failed, proto_ff::NF_STORESVR_C2S_DELETE iRet:{} errMsg:{}\", GetErrorStr(iRet),\n                       selobjRes.del_opres().errmsg());\n        }\n        return iRet;\n    }\n\n    template<class DataType>\n    int GetRpcDeleteService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, const std::function<void(int)> &func,\n                            const std::string &where_addtional_conds = \"\",\n                            uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine\n                ([=]()\n                 {\n                     int rpcRetCode = GetRpcDeleteService(eType, mod_key, data, where_addtional_conds, dstBusId, dbname);\n                     if (func)\n                     {\n                         func(rpcRetCode);\n                     }\n                 });\n        return iRet;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////store server modify////////////////////////////////////////////////////////////////////////////\n    template<typename DataType>\n    int GetRpcModifyService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data,\n                            const std::vector<storesvr_sqldata::storesvr_vk> &vk_list = std::vector<storesvr_sqldata::storesvr_vk>(),\n                            const std::string &where_addtional_conds = \"\", uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        std::string tempDBName = dbname;\n        if (dbname.empty())\n        {\n            NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n            if (pConfig)\n            {\n                tempDBName = pConfig->DefaultDBName;\n            }\n        }\n        CHECK_EXPR(!tempDBName.empty(), -1, \"no dbname ........\");\n\n\n        storesvr_sqldata::storesvr_mod selobj;\n        std::string tbname = NFProtobufCommon::GetProtoBaseName(data);\n        std::string packageName = NFProtobufCommon::GetProtoPackageName(data);\n        CHECK_EXPR(!tbname.empty(), -1, \"no tbname ........\");\n        NFStoreProtoCommon::storesvr_modifybycond(selobj, tempDBName, tbname, mod_key, data, vk_list, where_addtional_conds, tbname, packageName);\n\n        storesvr_sqldata::storesvr_mod_res selobjRes;\n        int iRet = FindModule<NFIMessageModule>()->GetRpcService<proto_ff::NF_STORESVR_C2S_MODIFY>(eType, NF_ST_STORE_SERVER, dstBusId, selobj,\n                                                                                                   selobjRes);\n        if (iRet == 0)\n        {\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetRpcService Failed, proto_ff::NF_STORESVR_C2S_MODIFY iRet:{} errMsg:{}\", GetErrorStr(iRet),\n                       selobjRes.mod_opres().errmsg());\n        }\n        return iRet;\n    }\n\n    template<class DataType>\n    int GetRpcModifyService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, const std::function<void(int)> &func,\n                            const std::vector<storesvr_sqldata::storesvr_vk> &vk_list = std::vector<storesvr_sqldata::storesvr_vk>(),\n                            const std::string &where_addtional_conds = \"\",\n                            uint32_t\n                            dstBusId = 0,\n                            const std::string &dbname = \"\")\n    {\n        int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine\n                ([=]()\n                 {\n                     int rpcRetCode = GetRpcModifyService(eType, mod_key, data, vk_list, where_addtional_conds, dstBusId, dbname);\n                     if (func)\n                     {\n                         func(rpcRetCode);\n                     }\n                 });\n        return iRet;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////store server select////////////////////////////////////////////////////////////////////////////\n    template<typename DataType>\n    int GetRpcUpdateService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data,\n                            const std::vector<storesvr_sqldata::storesvr_vk> &vk_list = std::vector<storesvr_sqldata::storesvr_vk>(),\n                            const std::string &where_addtional_conds = \"\", uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        std::string tempDBName = dbname;\n        if (dbname.empty())\n        {\n            NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n            if (pConfig)\n            {\n                tempDBName = pConfig->DefaultDBName;\n            }\n        }\n        CHECK_EXPR(!tempDBName.empty(), -1, \"no dbname ........\");\n\n\n        storesvr_sqldata::storesvr_update selobj;\n        std::string tbname = NFProtobufCommon::GetProtoBaseName(data);\n        std::string packageName = NFProtobufCommon::GetProtoPackageName(data);\n        CHECK_EXPR(!tbname.empty(), -1, \"no tbname ........\");\n        NFStoreProtoCommon::storesvr_updatebycond(selobj, tempDBName, tbname, mod_key, data, vk_list, where_addtional_conds, tbname, packageName);\n\n        storesvr_sqldata::storesvr_update_res selobjRes;\n        int iRet = FindModule<NFIMessageModule>()->GetRpcService<proto_ff::NF_STORESVR_C2S_UPDATE>(eType, NF_ST_STORE_SERVER, dstBusId, selobj,\n                                                                                                   selobjRes);\n        if (iRet == 0)\n        {\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetRpcService Failed, proto_ff::NF_STORESVR_C2S_MODINS iRet:{} errMsg:{}\", GetErrorStr(iRet),\n                       selobjRes.mod_opres().errmsg());\n        }\n        return iRet;\n    }\n\n    template<class DataType>\n    int GetRpcUpdateService(NF_SERVER_TYPES eType, uint64_t mod_key, const DataType &data, const std::function<void(int)> &func,\n                            const std::vector<storesvr_sqldata::storesvr_vk> &vk_list = std::vector<storesvr_sqldata::storesvr_vk>(),\n                            const std::string &where_addtional_conds = \"\",\n                            uint32_t\n                            dstBusId = 0,\n                            const std::string &dbname = \"\")\n    {\n        int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine\n                ([=]()\n                 {\n                     int rpcRetCode = GetRpcUpdateService(eType, mod_key, data, vk_list, where_addtional_conds, dstBusId, dbname);\n                     if (func)\n                     {\n                         func(rpcRetCode);\n                     }\n                 });\n        return iRet;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////store server update////////////////////////////////////////////////////////////////////////////\n    template<class DataType>\n    int GetRpcExecuteService(NF_SERVER_TYPES eType, uint64_t mod_key, DataType &data, const std::string &sql,\n                             uint32_t dstBusId = 0,\n                             const std::string &dbname = \"\")\n    {\n        std::string tempDBName = dbname;\n        if (dbname.empty())\n        {\n            NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n            if (pConfig)\n            {\n                tempDBName = pConfig->DefaultDBName;\n            }\n        }\n        CHECK_EXPR(!tempDBName.empty(), -1, \"no dbname ........\");\n\n\n        storesvr_sqldata::storesvr_execute selobj;\n        std::string clsname = NFProtobufCommon::GetProtoBaseName(data);\n        std::string packageName = NFProtobufCommon::GetProtoPackageName(data);\n        CHECK_EXPR(!clsname.empty(), -1, \"no clsname ........\");\n        NFStoreProtoCommon::storesvr_execute(selobj, tempDBName, clsname, mod_key, sql);\n        storesvr_sqldata::storesvr_execute_res selobjRes;\n        int iRet = FindModule<NFIMessageModule>()->GetRpcService<proto_ff::NF_STORESVR_C2S_EXECUTE>(eType, NF_ST_STORE_SERVER, dstBusId, selobj,\n                                                                                                    selobjRes);\n        if (iRet == 0)\n        {\n            data.ParseFromString(selobjRes.sel_records());\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetRpcService Failed, proto_ff::NF_STORESVR_C2S_EXECUTE iRet:{} errMsg:{}\", GetErrorStr(iRet),\n                       selobjRes.exe_opres().errmsg());\n        }\n        return iRet;\n    }\n\n    template<typename ResponFunc>\n    int GetRpcExecuteService(NF_SERVER_TYPES eType, uint64_t mod_key, const std::string &sql,\n                             const ResponFunc &func, uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        return GetRpcExecuteServiceInner(eType, mod_key, sql, func, &ResponFunc::operator(), dstBusId, dbname);\n    }\n\nprivate:\n    template<class DataType, typename ResponFunc>\n    int GetRpcExecuteServiceInner(NF_SERVER_TYPES eType, uint64_t mod_key, const std::string &sql,\n                                  const ResponFunc &responFunc, void (ResponFunc::*pf)(int rpcRetCode, DataType &respone) const,\n                                  uint32_t dstBusId = 0,\n                                  const std::string &dbname = \"\")\n    {\n        int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine\n                ([=]()\n                 {\n                     DataType respone;\n                     int rpcRetCode = GetRpcExecuteService(eType, mod_key, respone, sql, dstBusId, dbname);\n                     (responFunc.*pf)(rpcRetCode, respone);\n                 });\n        return iRet;\n    }\n\npublic:\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////store server select////////////////////////////////////////////////////////////////////////////\n    template<typename DataType>\n    int\n    GetRpcExecuteMoreService(NF_SERVER_TYPES eType, uint64_t mod_key, std::vector<DataType> &respone, const std::string &sql, int max_records = 100,\n                             uint32_t dstBusId = 0,\n                             const std::string &dbname = \"\")\n    {\n        std::string tempDBName = dbname;\n        if (dbname.empty())\n        {\n            NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n            if (pConfig)\n            {\n                tempDBName = pConfig->DefaultDBName;\n            }\n        }\n        CHECK_EXPR(!tempDBName.empty(), -1, \"no dbname ........\");\n\n        DataType data;\n        storesvr_sqldata::storesvr_execute_more sel;\n        std::string tbname = NFProtobufCommon::GetProtoBaseName(data);\n        std::string packageName = NFProtobufCommon::GetProtoPackageName(data);\n        CHECK_EXPR(!tbname.empty(), -1, \"no tbname ........\");\n\n        NFStoreProtoCommon::storesvr_execute_more(sel, tempDBName, tbname, mod_key, sql, max_records, tbname, packageName);\n        storesvr_sqldata::storesvr_execute_more_res selRes;\n        STATIC_ASSERT_BIND_RPC_SERVICE(proto_ff::NF_STORESVR_C2S_EXECUTE_MORE, storesvr_sqldata::storesvr_execute_more,\n                                       storesvr_sqldata::storesvr_execute_more_res);\n        NF_ASSERT_MSG(FindModule<NFICoroutineModule>()->IsInCoroutine(), \"Call GetRpcService Must Int the Coroutine\");\n        NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eType);\n        CHECK_EXPR(pConfig, -1, \"can't find server config! servertype:{}\", GetServerName(eType));\n\n        proto_ff::Proto_SvrPkg svrPkg;\n        svrPkg.set_msg_id(proto_ff::NF_STORESVR_C2S_EXECUTE_MORE);\n        svrPkg.set_msg_data(sel.SerializeAsString());\n        svrPkg.mutable_rpc_info()->set_req_rpc_id(FindModule<NFICoroutineModule>()->CurrentTaskId());\n        svrPkg.mutable_rpc_info()->set_req_rpc_hash(std::hash<std::string>()(sel.GetTypeName()));\n        svrPkg.mutable_rpc_info()->set_rsp_rpc_hash(std::hash<std::string>()(selRes.GetTypeName()));\n        svrPkg.mutable_rpc_info()->set_req_server_type(eType);\n        svrPkg.mutable_rpc_info()->set_req_bus_id(pConfig->BusId);\n\n        FindModule<NFIMessageModule>()->SendMsgToServer(eType, NF_ST_STORE_SERVER, pConfig->BusId, dstBusId, proto_ff::NF_SERVER_TO_SERVER_RPC_CMD,\n                                                        svrPkg);\n\n        int iRet = FindModule<NFICoroutineModule>()->SetUserData(&selRes);\n        CHECK_EXPR(iRet == 0, iRet, \"Yield Failed, Error:{}\", GetErrorStr(iRet));\n\n        do\n        {\n            iRet = FindModule<NFICoroutineModule>()->Yield(DEFINE_RPC_SERVICE_TIME_OUT_MS);\n            CHECK_EXPR(iRet == 0, iRet, \"Yield Failed, Error:{}\", GetErrorStr(iRet));\n            if (iRet == 0)\n            {\n                for (int i = 0; i < (int) selRes.sel_records_size(); i++)\n                {\n                    DataType result;\n                    result.ParseFromString(selRes.sel_records(i));\n                    respone.push_back(result);\n                }\n\n                if (selRes.is_lastbatch())\n                {\n                    break;\n                }\n            }\n            else\n            {\n                NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetRpcService Failed, proto_ff::NF_STORESVR_C2S_EXECUTE_MORE iRet:{} errMsg:{}\", GetErrorStr(iRet),\n                           selRes.exe_opres().errmsg());\n                break;\n            }\n        } while (true);\n\n\n        FindModule<NFICoroutineModule>()->SetUserData(NULL);\n\n        return iRet;\n    }\n\n    template<typename ResponFunc>\n    int GetRpcExecuteMoreService(NF_SERVER_TYPES eType, uint64_t mod_key, const std::string &sql, const ResponFunc &func,\n                            int max_records = 100, uint32_t dstBusId = 0, const std::string &dbname = \"\")\n    {\n        return GetRpcExecuteMoreServiceInner(eType, mod_key, sql, func, &ResponFunc::operator(), max_records, dstBusId,\n                                        dbname);\n    }\n\nprivate:\n    template<class DataType, typename ResponFunc>\n    int GetRpcExecuteMoreServiceInner(NF_SERVER_TYPES eType, uint64_t mod_key, const std::string &sql, const ResponFunc &responFunc,\n                                 void (ResponFunc::*pf)(int rpcRetCode, std::vector<DataType> &respone) const,\n                                 int max_records = 100, uint32_t dstBusId = 0,\n                                 const std::string &dbname = \"\")\n    {\n        int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine\n                ([=]()\n                 {\n                     std::vector<DataType> respone;\n                     int rpcRetCode = GetRpcExecuteMoreService(eType, mod_key, respone, sql, max_records,\n                                                          dstBusId, dbname);\n\n                     (responFunc.*pf)(rpcRetCode, respone);\n                 });\n        return iRet;\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/NFServerComm/NFServerCommon/NFIServerMessageModule.h b/src/NFServerComm/NFServerCommon/NFIServerMessageModule.h
--- a/src/NFServerComm/NFServerCommon/NFIServerMessageModule.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/src/NFServerComm/NFServerCommon/NFIServerMessageModule.h	(date 1688624074027)
@@ -157,6 +157,17 @@
 
 public:
     ///////////////////////store server select obj////////////////////////////////////////////////////////////////////////
+    /**
+     * @brief 调用StoreServer的selectobj rpc， 查询数据库里的一条数据,  通过protobuf结构data传数据的key, 并通过protobuf结构data存储返回来的结果。这个函数必须在携程里调用数。
+     * @tparam DataType     代表要查询的表的protobuf结构,
+     * @param eType         服务器类型
+     * @param mod_key       用来作为多线程查询的哈希一致性的key,0表示随机
+     * @param data          作为输入存储查询的key, 作为输出存储查询的结果
+     * @param vecFields     要查询的列，不填意味着查询所有的列
+     * @param dstBusId      指定负责查询的storeserver
+     * @param dbname        指定要查询的数据库
+     * @return
+     */
     template<typename DataType>
     int GetRpcSelectObjService(NF_SERVER_TYPES eType, uint64_t mod_key, DataType &data,
                                const std::vector<std::string> &vecFields = std::vector<std::string>(), uint32_t dstBusId = 0,
Index: game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerBase.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFPlayerBase.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-3\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFPlayerBase\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFSeqOP.h\"\n#include \"NFComm/NFShmCore/NFShmPtr.h\"\n#include \"NFComm/NFCore/NFTime.h\"\n#include \"DBProto.pb.h\"\n#include \"Part/NFPart.h\"\n#include \"NFLogicCommon/NFRoleDefine.h\"\n#include \"NFLogicCommon/NFLogDefine.h\"\n#include \"NFLogicCommon/NFComTypeDefine.h\"\n#include \"NFLogicCommon/NFLogicCommonDefine.h\"\n#include \"NFPlayerBase.h\"\n#include \"DBProto_s.h\"\n#include \"DescStoreEx/NFAttr.h\"\n#include \"NFComm/NFShmStl/NFShmHashMap.h\"\n#include \"DBProto2.pb.h\"\n\nclass NFPlayerBase : public NFSeqOP\n{\npublic:\n    NFPlayerBase();\n\n    virtual ~NFPlayerBase();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    int Init(NFIPluginManager* pPluginManager, const ::proto_ff::RoleDBData &dbData);\n\n    int UnInit(NFIPluginManager* pPluginManager);\n\n    //存储DB部件入口\n    virtual int SaveDB(proto_ff::RoleDBData &dbData);\n\n    virtual int ReadBaseData(const ::proto_ff::RoleDBData &dbData);\n    virtual void SetBaseData(proto_ff::RoleDBData& proto);\n    virtual void SetBaseData(proto_ff::RoleDBBaseData* proto);\n    virtual void SetFacadeProto(proto_ff::RoleFacadeProto& outproto);\n    virtual void SetEnterSceneProto(proto_ff::RoleEnterSceneData& outproto);\n    virtual void SetAttrData(proto_ff::RoleDBData& proto);\n    //同步外观\n    virtual void SyncFacade() {};\npublic:\n    /**\n     * @brief 保存DB相关\n     */\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual bool IsRoleDetailSaved() const;\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual uint32_t GetCurRoleDetailSeq() const;\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual bool IsRoleDetailNowSaving() const;\n\n    /**\n     * @brief\n     * @param time\n     */\n    virtual void SetLastSendRoleDetailSavedTime(uint64_t time);\n\n    /**\n     * @brief\n     * @param seq\n     */\n    virtual void SetRoleDetailSavedSeq(uint32_t seq);\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual bool IsRoleDetailNeedSave() const;\n\n    virtual uint64_t GetRoleDetailSavingDBTime() const;\n\n    virtual void SetRoleDetailSavingDBTime(uint64_t dwTime);\n\npublic:\n    /**\n     * @brief 当前玩家正在使用的trans数量 +1\n     */\n    virtual void IncreaseTransNum();\n\n    /**\n     * @brief 当前玩家正在使用的trans数量 -1\n     */\n    virtual void DecreaseTransNum();\n\n    /**\n     * @brief 当前玩家正在使用的trans数量\n     * @return\n     */\n    virtual int GetTransNum() const;\n\n    /**\n     * @brief 角色ID\n     * @return\n     */\n    virtual uint64_t GetRoleId() const;\n    virtual uint64_t RoleId() const;\n\n    /**\n     * @brief\n     * @param roleId\n     */\n    virtual void SetRoleId(uint64_t roleId);\n\n    /**\n     * @brief 玩家ID\n     * @return\n     */\n    virtual uint64_t GetUid() const;\n\n    /**\n     * @brief\n     * @param uid\n     */\n    virtual void SetUid(uint64_t uid);\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual std::string GetName() const;\n\n    /**\n     * @brief\n     * @param name\n     */\n    virtual void SetName(const std::string& name);\npublic:\n    /**\n     * @brief\n     * @return\n     */\n    virtual PLAYER_STATUS GetStatus() const;\n\n    /**\n     * @brief\n     * @param status\n     */\n    virtual void SetStatus(PLAYER_STATUS status);\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual PLAYER_SCENE_STATE GetSceneStatus() const;\n\n    /**\n     * @brief\n     * @param status\n     */\n    virtual void SetSceneStatus(PLAYER_SCENE_STATE status);\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual bool IsInBattle();\n\n    virtual bool IsInTransSceneing();\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual bool IsDisconnect() const;\n\n    /**\n     * @brief\n     * @param isDisConnect\n     */\n    virtual void SetIsDisconnect(bool isDisConnect);\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual uint64_t GetLastLogoutTime() const;\n\n    /**\n     * @brief\n     * @param lastLogoutTime\n     */\n    virtual void SetLastLogoutTime(uint64_t lastLogoutTime);\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual uint64_t GetLastDiconnectTime() const;\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual uint64_t GetDisonnectType() const;\n\n    /**\n     * @brief\n     * @param type\n     */\n    virtual void SetDisconnectType(uint32_t type);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint64_t GetZid() const;\n\n    /**\n     * @brief\n     * @param zid\n     */\n    void SetZid(uint64_t zid);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint64_t GetChannelId() const;\n\n    /**\n     * @brief\n     * @param channelId\n     */\n    void SetChannelId(uint64_t channelId);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint32_t GetProxyId() const;\n\n    /**\n     * @brief\n     * @param proxyId\n     */\n    void SetProxyId(uint32_t proxyId);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint32_t GetClientId() const;\n\n    /**\n     * @brief\n     * @param proxyId\n     */\n    void SetClientId(uint32_t clientId);\n\n    uint32_t GetGameId() const;\n\n    void SetGameId(uint32_t gameId);\n\n    uint64_t GetMapId() const;\n    uint64_t GetSceneId() const;\n    NFPoint3<float> GetPos() const;\n    void SetMapId(uint64_t mapId);\n    void SetSceneId(uint64_t sceneId);\n    void SetPos(const NFPoint3<float>& pos);\n\n    uint64_t GetLastMapId() const;\n    uint64_t GetLastSceneId() const;\n    NFPoint3<float> GetLastPos() const;\n    void SetLastMapId(uint64_t mapId);\n    void SetLastSceneId(uint64_t sceneId);\n    void SetLastPos(const NFPoint3<float>& pos);\npublic:\n    bool BState(proto_ff::ECState state);\n    uint8_t GetState();\n    void SetState(proto_ff::ECState state);\nprotected:\n    /**\n     * @brief 玩家数据是否初始化\n     */\n    bool m_isInited;\n\n    /**\n     * @brief 当前玩家正在使用的trans数量\n     */\n    int m_transNum;\nprotected:\n    /**\n     * @brief 角色ID\n     */\n    uint64_t m_cid;\n\n    /**\n     * @brief 玩家ID\n     */\n    uint64_t m_uid;\n\n    /**\n     * @brief\n     */\n    uint64_t m_zid;\n\n    /**\n     * @brief\n     */\n    uint64_t m_channelId;\n\n    /**\n     * @brief\n     */\n    uint32_t m_proxyId;\n\n    /**\n     * @brief\n     */\n    uint64_t m_clientId;\n\n    /**\n     * @brief\n     */\n    uint32_t m_gameId;\n\n    /**\n     * @brief\n     */\n    uint32_t m_battleId;\nprotected:\n    /**\n     * @brief\n     */\n    PLAYER_STATUS m_status;\n\n    /**\n     * @brief\n     */\n    uint64_t m_curObjCreateTime;\n\n    /**\n     * @brief\n     */\n    uint64_t m_diconnectTime;\n\n    /**\n     * @brief\n     */\n    uint32_t m_disonnectType;\n\n    /**\n     * @brief\n     */\n    uint64_t m_logoutTime;\n\n\n    /**\n     * @brief\n     */\n    uint64_t m_loginTime;\n\n    /**\n     * @brief\n     */\n    uint64_t m_createTime;\n\n    /**\n     * @brief\n     */\n    bool m_isDisconnect;\nprotected:\n    /**\n     * @brief\n     */\n    uint32_t m_lastSendSaveRoleDetailTime;\n\n    /**\n     * @brief\n     */\n    uint32_t m_roleDetailSavedSeq;\n\n    /**\n     * @brief\n     */\n    uint32_t m_roleDetailSavingDBTime;\nprotected:\n    int32_t  m_color;\t\t\t\t\t//模型颜色\n    proto_ff_s::RoleFacadeProto_s m_lastFacade;\t\t\t\t//最近一次外观数据，用于和最新的外观比较\n    NFShmString<64> m_name;\n    uint64_t m_sceneId;      //场景id\n    uint64_t m_mapId;       //地图模板id\n    NFPoint3<float> m_pos; //当前生物坐标\n    NFPoint3<float> m_lastPos;           //上个地图坐标\n    uint64_t m_lastSceneId;             //上个场景ID\n    uint64_t m_lastMapId;               //上个地图ID\n    uint8_t m_curstate;\n    uint8_t m_laststate;\n    PLAYER_SCENE_STATE m_sceneState;\nprotected:\n    NFShmPtr<IFightAttr> m_pFightAttr;\t\t//战斗属性\n    NFShmPtr<IAttr> m_pAttr;\t\t\t\t//普通属性\n    NFShmHashMap<uint32_t, int64_t, 100>  m_attrCache;\t\t\t//需要同步单个客户端属性缓存\n    NFShmHashMap<uint32_t, int64_t, 100>  m_attrBroadCache;\t\t//需要广播属性缓存\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerBase.h b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerBase.h
--- a/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerBase.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLogicServer/NFLogicServerPlayerPlugin/Player/NFPlayerBase.h	(date 1688616543281)
@@ -12,7 +12,7 @@
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFSeqOP.h"
 #include "NFComm/NFShmCore/NFShmPtr.h"
 #include "NFComm/NFCore/NFTime.h"
Index: game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFGetAccountTrans.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFGetAccountTrans.cpp\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFGetAccountTrans.cpp\n//\n// -------------------------------------------------------------------------\n\n#include \"NFGetAccountTrans.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"NFComm/NFMessageDefine/proto_svr_common.pb.h\"\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include \"NFComm/NFKernelMessage/storesvr_sqldata.pb.h\"\n#include \"NFComm/NFMessageDefine/proto_svr_login.pb.h\"\n#include \"NFComm/NFPluginModule/NFCommLogic.h\"\n#include \"NFAccountLoginMgr.h\"\n#include \"NFComm/NFCore/NFMD5.h\"\n#include \"NFServerIpMgr.h\"\n#include \"NFPhoneAutoCodeMgr.h\"\n#include \"NFLoginEventDisp.h\"\n\nIMPLEMENT_IDCREATE_WITHTYPE(NFGetAccountTrans, EOT_TRANS_GET_ACCOUNT, NFTransBase)\n\nNFGetAccountTrans::NFGetAccountTrans() {\n    if (NFShmMgr::Instance()->GetCreateMode() == EN_OBJ_MODE_INIT) {\n        CreateInit();\n    } else {\n        ResumeInit();\n    }\n}\n\nNFGetAccountTrans::~NFGetAccountTrans() {\n\n}\n\nint NFGetAccountTrans::CreateInit() {\n    mProxyBusId = 0;\n    mClientLinkId = 0;\n\tmLoginType = 0;\n\tmCmd = 0;\n    mCreateAccount = false;\n    return 0;\n}\n\nint NFGetAccountTrans::ResumeInit() {\n    return 0;\n}\n\nint NFGetAccountTrans::Init(uint32_t busId, uint64_t clientLinkId, uint32_t cmd) {\n    NFTransBase::Init();\n    mProxyBusId = busId;\n    mClientLinkId = clientLinkId;\n\tmCmd = cmd;\n    return 0;\n}\n\nint NFGetAccountTrans::ProGetAccountInfoRes()\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    NFAccountLogin* pLogin = NFAccountLoginMgr::Instance()->FindAccount(mAccount.GetString());\n    CHECK_NULL(pLogin);\n\n    if (pLogin->mPassword.GetString() != mPassword.GetString())\n    {\n        return proto_ff::ERR_CODE_ACCOUNT_PASSWORD_ERROR;\n    }\n\n    if (pLogin->mPhoneNum > 0)\n    {\n        NFPhoneAutoCode* pPhone = NFPhoneAutoCodeMgr::Instance()->FindPhone(pLogin->mPhoneNum);\n        if (pPhone && pPhone->m_codeType == proto_ff::PHONE_AUTO_CODE_CHANGE_DEVICE)\n        {\n            if (pPhone->m_checkSuccess == false)\n            {\n                NFPhoneAutoCodeMgr::Instance()->DeletePhone(pLogin->mPhoneNum);\n                return proto_ff::ERR_CODE_PHONE_AUTO_CODE_ERROR;\n            }\n\n            NFPhoneAutoCodeMgr::Instance()->DeletePhone(pLogin->mPhoneNum);\n\n            pLogin->mDeviceId = mDeviecId;\n\n            proto_ff::tbAccountTable accountInfo;\n            accountInfo.set_account(pLogin->mAccount.GetString());\n            accountInfo.set_device_id(mDeviecId.GetString());\n\n            FindModule<NFIMessageModule>()->SendTransToStoreServer(NF_ST_LOGIN_SERVER,\n                                                             proto_ff::E_STORESVR_C2S_MODIFYOBJ, proto_ff::E_TABLE_ACCOUNT_PLAYER, NF_DEFAULT_MYSQL_DB_NAME, \"tbAccountTable\", accountInfo,\n                                                             0, 0, NFHash::hash<std::string>()(pLogin->mAccount.GetString()));\n\n            proto_ff::LTLPlayerDeviceChangeNotify deviceNotify;\n            deviceNotify.set_user_id(pLogin->mPlayerId);\n            deviceNotify.set_device_id(mDeviecId.GetString());\n\n            FindModule<NFIMessageModule>()->SendMsgToWorldServer(NF_ST_LOGIN_SERVER, proto_ff::NF_LTL_PLAYER_DEVICE_CHANGE_NOTIFY, deviceNotify);\n        }\n    }\n\n    if (pLogin->mDeviceId.GetString() != mDeviecId.GetString())\n    {\n        if (pLogin->mDeviceId.GetString().empty() || pLogin->mDeviceId.GetString() == \"NULL\")\n        {\n            proto_ff::tbAccountTable accountInfo;\n            accountInfo.set_account(pLogin->mAccount.GetString());\n            accountInfo.set_device_id(mDeviecId.GetString());\n\n            FindModule<NFIMessageModule>()->SendTransToStoreServer(NF_ST_LOGIN_SERVER,\n                                                             proto_ff::E_STORESVR_C2S_MODIFYOBJ, proto_ff::E_TABLE_ACCOUNT_PLAYER, NF_DEFAULT_MYSQL_DB_NAME, \"tbAccountTable\", accountInfo,\n                                                             0, 0, NFHash::hash<std::string>()(pLogin->mAccount.GetString()));\n\n            pLogin->mDeviceId = mDeviecId;\n\n            proto_ff::LTLPlayerDeviceChangeNotify deviceNotify;\n            deviceNotify.set_user_id(pLogin->mPlayerId);\n            deviceNotify.set_device_id(mDeviecId.GetString());\n\n            FindModule<NFIMessageModule>()->SendMsgToWorldServer(NF_ST_LOGIN_SERVER, proto_ff::NF_LTL_PLAYER_DEVICE_CHANGE_NOTIFY, deviceNotify);\n        }\n        else\n        {\n            if (pLogin->mPhoneNum > 0)\n            {\n                proto_login::Proto_SC_LoginServer_NotifyPhoneCheck gcMsg;\n                gcMsg.set_result(0);\n                gcMsg.set_phone_num(pLogin->mPhoneNum);\n                FindModule<NFIMessageModule>()->SendMsgToProxyServer(NF_ST_LOGIN_SERVER, mProxyBusId,\n                                                               proto_login::NF_SC_MSG_LoginServer_NotifyPhoneCheck,\n                                                               gcMsg,\n                                                               mClientLinkId);\n\n                SetFinished(0);\n                return 0;\n            }\n            else if (mLoginType == proto_ff::E_VISITOR)\n            {\n                return proto_ff::ERR_CODE_VISITOR_LOGIN_DEVICE_ERROR;\n            }\n        }\n    }\n\n    pLogin->mLastLoginTime = NFTime::Now().UnixSec();\n    NFLoginEventDisp::AccountLogin(pLogin);\n\n    proto_login::Proto_SCAccountLoginRsp gcMsg;\n    gcMsg.set_result(0);\n    gcMsg.set_user_id(pLogin->mPlayerId);\n    gcMsg.set_login_time(pLogin->mLastLoginTime);\n    gcMsg.set_token(NFCommLogic::GetLoginToken(pLogin->mAccount.GetString(), pLogin->mPlayerId, pLogin->mLastLoginTime, LOGIN_TOKEN));\n\n    std::vector<NF_SHARE_PTR<NFServerData>> pServerList = FindModule<NFIMessageModule>()->GetServerByServerType(NF_ST_LOGIN_SERVER, NF_ST_PROXY_SERVER);\n    for(int i = 0; i < (int)pServerList.size(); i++)\n    {\n        NF_SHARE_PTR<NFServerData> pServer = pServerList[i];\n        if (pServer)\n        {\n            proto_login::Proto_CSServerIP* pIp = gcMsg.add_server_ip_list();\n            pIp->set_ip(pServer->mServerInfo.external_server_ip());\n            pIp->set_port(pServer->mServerInfo.external_server_port());\n        }\n    }\n\n    FindModule<NFIMessageModule>()->SendMsgToProxyServer(NF_ST_LOGIN_SERVER, mProxyBusId,\n                                                         proto_login::NF_SC_MSG_AccountLoginRsp,\n                                                         gcMsg,\n                                                         mClientLinkId);\n\n    SetFinished(0);\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFGetAccountTrans::ProChangePasswordRes()\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    NFAccountLogin* pLogin = NFAccountLoginMgr::Instance()->FindAccount(mAccount.GetString());\n    CHECK_NULL(pLogin);\n\n    if (pLogin->mPassword.GetString() == mPassword.GetString())\n    {\n        return proto_ff::ERR_CODE_PASSWORD_NOT_CHANGE;\n    }\n\n    pLogin->mPassword = mPassword;\n\n    proto_ff::tbAccountTable accountInfo;\n    accountInfo.set_account(pLogin->mAccount.GetString());\n    accountInfo.set_password(mPassword.GetString());\n\n    FindModule<NFIMessageModule>()->SendTransToStoreServer(NF_ST_LOGIN_SERVER,\n                                                     proto_ff::E_STORESVR_C2S_MODIFYOBJ, proto_ff::E_TABLE_ACCOUNT_PLAYER, NF_DEFAULT_MYSQL_DB_NAME, \"tbAccountTable\", accountInfo,\n                                                     GetGlobalID(), 0, NFHash::hash<std::string>()(pLogin->mAccount.GetString()));\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFGetAccountTrans::HandleGetBaseInfoRes(NFAccountLogin *pUserLogin)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    int iRetCode = 0;\n    switch (mCmd)\n    {\n        case proto_login::NF_CS_MSG_AccountLoginReq:\n        {\n            iRetCode = ProGetAccountInfoRes();\n            break;\n        }\n        case proto_login::NF_CS_MSG_CHANGE_PASSWORD_REQ:\n        {\n            iRetCode = ProChangePasswordRes();\n            break;\n        }\n        default:\n        {\n            iRetCode = -1;\n            break;\n        }\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return iRetCode;\n}\n\nint NFGetAccountTrans::HandleGetBaseInfoMsgParam(const google::protobuf::Message *pCSMsgReq)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    int iRetCode = 0;\n    switch (mCmd)\n    {\n        case proto_login::NF_CS_MSG_AccountLoginReq:\n        {\n            iRetCode = ProGetAccountInfoReq(dynamic_cast<const proto_login::Proto_CSAccountLoginReq *>(pCSMsgReq));\n            break;\n        }\n        case proto_login::NF_CS_MSG_CHANGE_PASSWORD_REQ:\n        {\n            iRetCode = ProGetAccountInfoReq(dynamic_cast<const proto_login::Proto_CS_ChangePasswordReq *>(pCSMsgReq));\n            break;\n        }\n        default:\n        {\n            iRetCode = proto_ff::ERR_CODE_SYSTEM_ERROR;\n            break;\n        }\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return iRetCode;\n}\n\nint NFGetAccountTrans::ProGetBaseInfoReq()\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n\n    proto_ff::tbAccountTable accountInfo;\n    accountInfo.set_account(mAccount.GetString());\n\n    FindModule<NFIMessageModule>()->SendTransToStoreServer(NF_ST_LOGIN_SERVER,\n                                                           proto_ff::E_STORESVR_C2S_SELECTOBJ, proto_ff::E_TABLE_ACCOUNT_PLAYER, NF_DEFAULT_MYSQL_DB_NAME, \"tbAccountTable\", accountInfo,\n                                                           GetGlobalID(), 0, NFHash::hash<std::string>()(mAccount.GetString()));\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFGetAccountTrans::HandleCSMsgReq(const google::protobuf::Message *pCSMsgReq) {\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n\n    int iRetCode = HandleGetBaseInfoMsgParam(pCSMsgReq);\n    if (iRetCode) {\n        return iRetCode;\n    }\n\n    NFAccountLogin* pLogin = NFAccountLoginMgr::Instance()->FindAccount(mAccount.GetString());\n    if (pLogin)\n    {\n        iRetCode = HandleGetBaseInfoRes(pLogin);\n        if (iRetCode)\n        {\n            return iRetCode;\n        }\n    }\n    else\n    {\n        iRetCode = ProGetBaseInfoReq();\n        if (iRetCode) {\n            return iRetCode;\n        }\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFGetAccountTrans::ProGetAccountInfoReq(const proto_login::Proto_CS_ChangePasswordReq *pLoginReq)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    CHECK_EXPR(pLoginReq, -1, \"pLoginReq = NULL\");\n\n    mAccount = pLoginReq->account();\n    mPassword = pLoginReq->new_password();\n    mDeviecId = pLoginReq->device_id();\n\n    mLoginType = proto_ff::E_PHONE;\n\n    uint64_t phoneNum = NFCommon::strto<uint64_t>(mAccount.GetString());\n    NFPhoneAutoCode* pPhone = NFPhoneAutoCodeMgr::Instance()->FindPhone(phoneNum);\n    if (pPhone && pPhone->m_codeType == proto_ff::PHONE_AUTO_CODE_CHANGE_PASSWORD)\n    {\n        if (pPhone->m_checkSuccess == false)\n        {\n            NFPhoneAutoCodeMgr::Instance()->DeletePhone(phoneNum);\n            return proto_ff::ERR_CODE_PHONE_AUTO_CODE_ERROR;\n        }\n\n        NFPhoneAutoCodeMgr::Instance()->DeletePhone(phoneNum);\n        return 0;\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return proto_ff::ERR_CODE_PHONE_AUTO_CODE_TIMEOUT;\n}\n\nint NFGetAccountTrans::ProGetAccountInfoReq(const proto_login::Proto_CSAccountLoginReq *pLoginReq)\n{\n\tNFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n\tCHECK_EXPR(pLoginReq, -1, \"pLoginReq = NULL\");\n\n\tmAccount = pLoginReq->account();\n\tmPassword = pLoginReq->password();\n\tmLoginType = pLoginReq->login_type();\n\tmDeviecId = pLoginReq->device_id();\n\n\tNFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n\treturn 0;\n}\n\nint NFGetAccountTrans::CreateAccountReq() {\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n\n\tif (mLoginType == proto_ff::E_VISITOR || mLoginType == proto_ff::E_WECHAT)\n\t{\n\t\tSetState(CREATE_ACCOUNT);\n\t\tproto_ff::tbAccountTable accountInfo;\n\t\taccountInfo.set_account(mAccount.GetString());\n\t\taccountInfo.set_password(mPassword.GetString());\n\t\taccountInfo.set_account_type(mLoginType);\n\t\taccountInfo.set_device_id(mDeviecId.GetString());\n\t\taccountInfo.set_phonenum(0);\n\n\t\tNFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"Ready Create Account InTo Mysql:{}\", accountInfo.DebugString());\n\n\t\tFindModule<NFIMessageModule>()->SendTransToStoreServer(NF_ST_LOGIN_SERVER,\n\t\t\tproto_ff::E_STORESVR_C2S_INSERT, proto_ff::E_TABLE_ACCOUNT_PLAYER, NF_DEFAULT_MYSQL_DB_NAME, \"tbAccountTable\", accountInfo,\n\t\t\tGetGlobalID(), 0, NFHash::hash<std::string>()(mAccount.GetString()));\n\n\t}\n\telse\n\t{\n        return proto_ff::ERR_CODE_ACCOUNT_NOT_EXIST;\n\t}\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFGetAccountTrans::ProGetBaseInfoRes(const storesvr_sqldata::storesvr_selobj_res* pSelRsp, uint32_t cmd, uint32_t table_id, uint32_t err_code)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n\n    if (err_code != 0)\n    {\n        if (err_code == proto_ff::ERR_CODE_STORESVR_ERRCODE_SELECT_EMPTY)\n        {\n            NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"Account:{} not exist in db\", mAccount.Get());\n            return CreateAccountReq();\n        }\n\n        return -1;\n    }\n\n    proto_ff::tbAccountTable accountInfo;\n    accountInfo.ParseFromString(pSelRsp->sel_record());\n\n    if (mCmd != proto_login::NF_CS_MSG_CHANGE_PASSWORD_REQ)\n    {\n        if (mAccount.GetString() != accountInfo.account() || mPassword.GetString() != accountInfo.password() ||\n            accountInfo.player_id() <= 0) {\n            NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"Account:{} Password:{} is not right\", mAccount.Get(), mPassword.Get());\n            return proto_ff::ERR_CODE_ACCOUNT_PASSWORD_ERROR;\n        }\n    }\n\n    if (accountInfo.real_player_id() > 0)\n    {\n        accountInfo.set_player_id(accountInfo.real_player_id());\n    }\n\n    NFAccountLogin* pLogin = NFAccountLoginMgr::Instance()->CreateAccount(accountInfo.account(), accountInfo.password(), accountInfo.player_id(), accountInfo.account_type(), accountInfo.device_id(), accountInfo.phonenum());\n    CHECK_NULL(pLogin);\n\n    if (mCreateAccount)\n    {\n        proto_ff::Proto_LTWRegisterUserReq req;\n        req.set_user_id(pLogin->mPlayerId);\n        if (mLoginType == proto_ff::E_PHONE)\n        {\n            req.set_phone_num(NFCommon::strto<uint64_t>(mAccount.GetString()));\n        }\n\n        req.mutable_ext_data()->set_device_id(mDeviecId.GetString());\n        FindModule<NFIMessageModule>()->SendTransToWorldServer(NF_ST_LOGIN_SERVER, proto_ff::NF_LTW_REGISTER_USER_TO_WORLD_REQ, req, GetGlobalID());\n    }\n    else {\n        int iRetCode = HandleGetBaseInfoRes(pLogin);\n        if (iRetCode) {\n            return iRetCode;\n        }\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFGetAccountTrans::HandleDispSvrRes(uint64_t unLinkId, uint64_t destLinkId, uint64_t req_trans_id, uint32_t nMsgId, const char* msg, uint32_t nLen)\n{\n    if (nMsgId == proto_ff::NF_LTL_REGISTER_USER_TO_LOGIN_RSP)\n    {\n        proto_ff::Proto_LTLRegisterUserRsp xMsg;\n        CLIENT_MSG_PROCESS_WITH_PRINTF(nMsgId, destLinkId, msg, nLen, xMsg);\n\n        NFAccountLogin* pLogin = NFAccountLoginMgr::Instance()->FindAccount(mAccount.GetString());\n        CHECK_NULL(pLogin);\n\n        int iRetCode = HandleGetBaseInfoRes(pLogin);\n        if (iRetCode) {\n            return iRetCode;\n        }\n    }\n\n    SetFinished(0);\n    return 0;\n}\n\nint NFGetAccountTrans::ProBaseChangePassowrdRes(const storesvr_sqldata::storesvr_modobj_res* pSelRsp, uint32_t cmd, uint32_t table_id, uint32_t err_code)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n\n    if (err_code != 0)\n    {\n        NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"Account Chang Password Failed, Account:{} Password:{}\", mAccount.Get(), mPassword.Get());\n        return proto_ff::ERR_CODE_SYSTEM_DATABASE_ERROR;\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"Account Change Password Success In Mysql, Account:{} Password:{}\", mAccount.Get(), mPassword.Get());\n\n\n    proto_login::Proto_SC_ChangePasswordRsp rspMsg;\n    rspMsg.set_result(0);\n    FindModule<NFIMessageModule>()->SendMsgToProxyServer(NF_ST_LOGIN_SERVER, mProxyBusId,\n                                                         proto_login::NF_SC_MSG_CHANGE_PASSWORD_RESP,\n                                                         rspMsg,\n                                                         mClientLinkId);\n\n    NFAccountLogin* pLogin = NFAccountLoginMgr::Instance()->FindAccount(mAccount.GetString());\n    if (!pLogin)\n    {\n        SetFinished(0);\n        NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n        return 0;\n    }\n\n    pLogin->mDeviceId = mDeviecId;\n    proto_ff::tbAccountTable accountInfo;\n    accountInfo.set_account(pLogin->mAccount.GetString());\n    accountInfo.set_device_id(mDeviecId.GetString());\n\n    FindModule<NFIMessageModule>()->SendTransToStoreServer(NF_ST_LOGIN_SERVER,\n                                                     proto_ff::E_STORESVR_C2S_MODIFYOBJ, proto_ff::E_TABLE_ACCOUNT_PLAYER, NF_DEFAULT_MYSQL_DB_NAME, \"tbAccountTable\", accountInfo,\n                                                     0, 0, NFHash::hash<std::string>()(pLogin->mAccount.GetString()));\n\n\n    SetFinished(0);\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFGetAccountTrans::ProBaseCreateRes(const storesvr_sqldata::storesvr_ins_res* pSelRsp, uint32_t cmd, uint32_t table_id, uint32_t err_code)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n\n    if (err_code != 0)\n    {\n        NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"Create Account Failed In Mysql, Account:{} Password:{}\", mAccount.Get(), mPassword.Get());\n        return proto_ff::ERR_CODE_SYSTEM_DATABASE_ERROR;\n    }\n\n    mCreateAccount = true;\n\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"Create Account Success In Mysql, Account:{} Password:{}\", mAccount.Get(), mPassword.Get());\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return ProGetBaseInfoReq();\n}\n\nint NFGetAccountTrans::HandleDBMsgRes(const google::protobuf::Message *pSSMsgRes, uint32_t cmd, uint32_t table_id,\n                                      uint32_t seq,\n                                      uint32_t err_code) {\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    int iRetCode = 0;\n    if (cmd == proto_ff::E_STORESVR_S2C_SELECTOBJ) {\n        if (table_id == proto_ff::E_TABLE_ACCOUNT_PLAYER) {\n            const storesvr_sqldata::storesvr_selobj_res *pRes = dynamic_cast<const storesvr_sqldata::storesvr_selobj_res *>(pSSMsgRes);\n            CHECK_EXPR(pRes, -1, \"pRes == NULL\");\n\n            iRetCode = ProGetBaseInfoRes(pRes, cmd, table_id, err_code);\n        }\n    }\n    else if (cmd == proto_ff::E_STORESVR_S2C_INSERT) {\n        if (table_id == proto_ff::E_TABLE_ACCOUNT_PLAYER) {\n            const storesvr_sqldata::storesvr_ins_res *pRes = dynamic_cast<const storesvr_sqldata::storesvr_ins_res *>(pSSMsgRes);\n            CHECK_EXPR(pRes, -1, \"pRes == NULL\");\n\n            iRetCode = ProBaseCreateRes(pRes, cmd, table_id, err_code);\n        }\n    }\n    else if(cmd == proto_ff::E_STORESVR_S2C_MODIFYOBJ)\n    {\n        if (table_id == proto_ff::E_TABLE_ACCOUNT_PLAYER) {\n            const storesvr_sqldata::storesvr_modobj_res *pRes = dynamic_cast<const storesvr_sqldata::storesvr_modobj_res *>(pSSMsgRes);\n            CHECK_EXPR(pRes, -1, \"pRes == NULL\");\n\n            iRetCode = ProBaseChangePassowrdRes(pRes, cmd, table_id, err_code);\n        }\n    }\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return iRetCode;\n}\n\nbool NFGetAccountTrans::IsTimeOut() {\n    if (NFTime::Now().UnixSec() >= m_dwKeepAliveTime + 300) {\n        NFLogError(NF_LOG_USER_MAIL_PLUGIN, 0, \"This Trans TimeOut Type:{} Info:{}\", GetClassType(), GetDebugInfo());\n        OnTimeOut();\n        return true;\n    }\n\n    return false;\n}\n\nint NFGetAccountTrans::OnTimeOut() {\n    NFLogError(NF_LOG_USER_MAIL_PLUGIN, 0, \"NFGetAccountTrans timeout account:{}\", mAccount.GetString());\n    return 0;\n}\n\nint NFGetAccountTrans::OnTransFinished(int iRunLogicRetCode) {\n    if (iRunLogicRetCode != 0) {\n        if (mCmd == proto_login::NF_CS_MSG_AccountLoginReq)\n        {\n            proto_login::Proto_SCAccountLoginRsp gcMsg;\n            gcMsg.set_result(iRunLogicRetCode);\n\n            FindModule<NFIMessageModule>()->SendMsgToProxyServer(NF_ST_LOGIN_SERVER, mProxyBusId,\n                                                                 proto_login::NF_SC_MSG_AccountLoginRsp,\n                                                                 gcMsg,\n                                                                 mClientLinkId);\n        }\n        else if (mCmd == proto_login::NF_CS_MSG_CHANGE_PASSWORD_REQ)\n        {\n            proto_login::Proto_SC_ChangePasswordRsp gcMsg;\n            gcMsg.set_result(iRunLogicRetCode);\n\n            FindModule<NFIMessageModule>()->SendMsgToProxyServer(NF_ST_LOGIN_SERVER, mProxyBusId,\n                                                                 proto_login::NF_SC_MSG_CHANGE_PASSWORD_RESP,\n                                                                 gcMsg,\n                                                                 mClientLinkId);\n        }\n    }\n\n    return 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFGetAccountTrans.cpp b/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFGetAccountTrans.cpp
--- a/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFGetAccountTrans.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFGetAccountTrans.cpp	(date 1688616543313)
@@ -8,7 +8,7 @@
 // -------------------------------------------------------------------------
 
 #include "NFGetAccountTrans.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFPluginModule/NFLogMgr.h"
 #include "NFComm/NFPluginModule/NFCheck.h"
 #include "NFComm/NFMessageDefine/proto_svr_common.pb.h"
Index: game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFRegisterAccountTrans.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFRegisterAccountTrans.cpp\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFRegisterAccountTrans.cpp\n//\n// -------------------------------------------------------------------------\n\n#include \"NFRegisterAccountTrans.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"NFComm/NFMessageDefine/proto_svr_common.pb.h\"\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include \"NFComm/NFKernelMessage/storesvr_sqldata.pb.h\"\n#include \"NFComm/NFPluginModule/NFCommLogic.h\"\n#include \"NFAccountLoginMgr.h\"\n#include \"NFComm/NFCore/NFMD5.h\"\n#include \"NFServerIpMgr.h\"\n#include \"NFPhoneAutoCodeMgr.h\"\n#include \"NFComm/NFMessageDefine/proto_svr_behavior.pb.h\"\n#include \"NFLoginEventDisp.h\"\n\nIMPLEMENT_IDCREATE_WITHTYPE(NFRegisterAccountTrans, EOT_TRANS_REGISTER_ACCOUNT, NFGetAccountTrans)\n\n\nNFRegisterAccountTrans::NFRegisterAccountTrans()\n{\n    if (NFShmMgr::Instance()->GetCreateMode() == EN_OBJ_MODE_INIT) {\n        CreateInit();\n    } else {\n        ResumeInit();\n    }\n}\n\nNFRegisterAccountTrans::~NFRegisterAccountTrans()\n{\n\n}\n\nint NFRegisterAccountTrans::CreateInit()\n{\n    mCheckAccount = false;\n    memset(&m_data, 0, sizeof(m_data));\n    return 0;\n}\n\nint NFRegisterAccountTrans::ResumeInit()\n{\n    return 0;\n}\n\nint NFRegisterAccountTrans::HandleGetBaseInfoMsgParam(const google::protobuf::Message *pCSMsgReq)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    int iRetCode = 0;\n    switch (mCmd)\n    {\n        case proto_login::NF_CS_MSG_RegisterAccountReq:\n        {\n            iRetCode = ProRigisterAccountInfoReq(dynamic_cast<const proto_login::Proto_CSRegisterAccountReq *>(pCSMsgReq));\n            break;\n        }\n        default:\n        {\n            iRetCode = -1;\n            break;\n        }\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return iRetCode;\n}\n\nint NFRegisterAccountTrans::ProRigisterAccountInfoReq(const proto_login::Proto_CSRegisterAccountReq *pRegisterReq)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    CHECK_EXPR(pRegisterReq, -1, \"pLoginReq = NULL\");\n\n    mAccount = pRegisterReq->account();\n    mPassword = pRegisterReq->password();\n    mLoginType = proto_ff::E_PHONE;\n    mDeviecId = pRegisterReq->device_id();\n\n    uint64_t phoneNum = NFCommon::strto<uint64_t>(mAccount.GetString());\n    NFPhoneAutoCode* pPhone = NFPhoneAutoCodeMgr::Instance()->FindPhone(phoneNum);\n    if (pPhone && pPhone->m_codeType == proto_ff::PHONE_AUTO_CODE_REGISTER)\n    {\n        if (pPhone->m_checkSuccess == false)\n        {\n            return proto_ff::ERR_CODE_PHONE_AUTO_CODE_ERROR;\n        }\n\n        NFPhoneAutoCodeMgr::Instance()->DeletePhone(phoneNum);\n    }\n    else\n    {\n        return proto_ff::ERR_CODE_PHONE_AUTO_CODE_TIMEOUT;\n    }\n\n    mNickName.Copy(pRegisterReq->nick_name());\n    const ::proto_login::Proto_UserLoginExternalData& extData = pRegisterReq->ext_data();\n    m_data.aread_id = extData.aread_id();\n    m_data.agent_id = extData.agent_id();\n    m_data.channel_id = extData.channel_id();\n    m_data.referral_code = extData.referral_code();\n    m_data.platform_os.Copy(extData.platform_os());\n    m_data.country.Copy(extData.country());\n    m_data.province.Copy(extData.province());\n    m_data.city.Copy(extData.city());\n    m_data.phone_mode.Copy(extData.phone_mode());\n    m_data.device_id.Copy(pRegisterReq->device_id());\n\n    NFAccountLogin* pLogin = NFAccountLoginMgr::Instance()->FindAccount(mAccount.GetString());\n    if (pLogin)\n    {\n        return proto_ff::ERR_CODE_ACCOUNT_ALREADY_EXIST_NO_RESITER;\n    }\n\n    mCheckAccount = true;\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\n\nint NFRegisterAccountTrans::HandleGetBaseInfoRes(NFAccountLogin *pUserLogin)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    int iRetCode = 0;\n    switch (mCmd)\n    {\n        case proto_login::NF_CS_MSG_RegisterAccountReq:\n        {\n            iRetCode = ProRegisterAccountRes();\n            break;\n        }\n        default:\n        {\n            iRetCode = -1;\n            break;\n        }\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return iRetCode;\n}\n\nint NFRegisterAccountTrans::ProRegisterAccountRes()\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    NFAccountLogin* pLogin = NFAccountLoginMgr::Instance()->FindAccount(mAccount.GetString());\n    CHECK_NULL(pLogin);\n\n    if (pLogin->mPassword.GetString() != mPassword.GetString())\n    {\n        return proto_ff::ERR_CODE_ACCOUNT_PASSWORD_ERROR;\n    }\n\n    pLogin->mLastLoginTime = NFTime::Now().UnixSec();\n    NFLoginEventDisp::AccountRegister(pLogin);\n\n    proto_ff::Proto_LTWRegisterUserReq req;\n    req.set_user_id(pLogin->mPlayerId);\n    req.set_nick_name(mNickName.GetString());\n    if (mLoginType == proto_ff::E_PHONE)\n    {\n        req.set_phone_num(NFCommon::strto<uint64_t>(mAccount.GetString()));\n    }\n    proto_ff_s::LoginCommonData_s::write_to_pbmsg(m_data, *req.mutable_ext_data());\n    FindModule<NFIMessageModule>()->SendTransToWorldServer(NF_ST_LOGIN_SERVER, proto_ff::NF_LTW_REGISTER_USER_TO_WORLD_REQ, req, GetGlobalID());\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFRegisterAccountTrans::HandleDispSvrRes(uint64_t unLinkId, uint64_t destLinkId, uint64_t req_trans_id, uint32_t nMsgId, const char* msg, uint32_t nLen)\n{\n    if (nMsgId == proto_ff::NF_LTL_REGISTER_USER_TO_LOGIN_RSP)\n    {\n        proto_ff::Proto_LTLRegisterUserRsp xMsg;\n        CLIENT_MSG_PROCESS_WITH_PRINTF(nMsgId, destLinkId, msg, nLen, xMsg);\n\n        NFAccountLogin* pLogin = NFAccountLoginMgr::Instance()->FindAccount(mAccount.GetString());\n        CHECK_NULL(pLogin);\n\n        proto_login::Proto_SCRegisterAccountRsp gcMsg;\n        gcMsg.set_result(0);\n        gcMsg.set_user_id(pLogin->mPlayerId);\n        gcMsg.set_login_time(pLogin->mLastLoginTime);\n        gcMsg.set_token(NFCommLogic::GetLoginToken(pLogin->mAccount.GetString(), pLogin->mPlayerId, pLogin->mLastLoginTime, LOGIN_TOKEN));\n\n        std::vector<NF_SHARE_PTR<proto_ff::ServerInfoReport>> pServerList = NFServerIpMgr::Instance()->GetServerList();\n        for(int i = 0; i < (int)pServerList.size(); i++)\n        {\n            NF_SHARE_PTR<proto_ff::ServerInfoReport> pServer = pServerList[i];\n            if (pServer)\n            {\n                proto_login::Proto_CSServerIP* pIp = gcMsg.add_server_ip_list();\n                pIp->set_ip(pServer->external_server_ip());\n                pIp->set_port(pServer->external_server_port());\n            }\n        }\n\n        FindModule<NFIMessageModule>()->SendMsgToProxyServer(NF_ST_LOGIN_SERVER, mProxyBusId,\n                                                             proto_login::NF_SC_MSG_RegisterAccountRsp,\n                                                             gcMsg,\n                                                             mClientLinkId);\n    }\n    else\n    {\n        return -1;\n    }\n\n    SetFinished(0);\n    return 0;\n}\n\nint NFRegisterAccountTrans::OnTransFinished(int iRunLogicRetCode)\n{\n    if (iRunLogicRetCode != 0) {\n        if (mCmd == proto_login::NF_CS_MSG_RegisterAccountReq)\n        {\n            proto_login::Proto_SCRegisterAccountRsp gcMsg;\n            gcMsg.set_result(iRunLogicRetCode);\n\n            FindModule<NFIMessageModule>()->SendMsgToProxyServer(NF_ST_LOGIN_SERVER, mProxyBusId,\n                                                                 proto_login::NF_SC_MSG_RegisterAccountRsp,\n                                                                 gcMsg,\n                                                                 mClientLinkId);\n        }\n    }\n\n    return 0;\n}\n\nint NFRegisterAccountTrans::ProGetBaseInfoRes(const storesvr_sqldata::storesvr_selobj_res *pSelRsp, uint32_t cmd, uint32_t table_id, uint32_t err_code)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    if (mCmd == proto_login::NF_CS_MSG_RegisterAccountReq)\n    {\n        if (mCheckAccount)\n        {\n            if (err_code == 0)\n            {\n                return proto_ff::ERR_CODE_ACCOUNT_ALREADY_EXIST_NO_RESITER;\n            }\n\n            mCheckAccount = false;\n        }\n    }\n\n    if (err_code != 0)\n    {\n        if (err_code == proto_ff::ERR_CODE_STORESVR_ERRCODE_SELECT_EMPTY)\n        {\n            NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"Account:{} not exist in db\", mAccount.Get());\n            return CreateAccountReq();\n        }\n\n        return -1;\n    }\n\n    proto_ff::tbAccountTable accountInfo;\n    accountInfo.ParseFromString(pSelRsp->sel_record());\n\n    if (mAccount.GetString() != accountInfo.account() || mPassword.GetString() != accountInfo.password() ||\n        accountInfo.player_id() <= 0) {\n        NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"Account:{} Password:{} is not right\", mAccount.Get(), mPassword.Get());\n        return proto_ff::ERR_CODE_ACCOUNT_PASSWORD_ERROR;\n    }\n\n    if (accountInfo.real_player_id() > 0)\n    {\n        accountInfo.set_player_id(accountInfo.real_player_id());\n    }\n\n    NFAccountLogin* pLogin = NFAccountLoginMgr::Instance()->CreateAccount(accountInfo.account(), accountInfo.password(), accountInfo.player_id(), accountInfo.account_type(), accountInfo.device_id(), accountInfo.phonenum());\n    CHECK_NULL(pLogin);\n\n    int iRetCode = HandleGetBaseInfoRes(pLogin);\n    if (iRetCode) {\n        return iRetCode;\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFRegisterAccountTrans::CreateAccountReq() {\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n\n    if (mLoginType == proto_ff::E_VISITOR)\n    {\n        return -1;\n    }\n\n    SetState(CREATE_ACCOUNT);\n    proto_ff::tbAccountTable accountInfo;\n    accountInfo.set_account(mAccount.GetString());\n    accountInfo.set_password(mPassword.GetString());\n    accountInfo.set_account_type(mLoginType);\n    accountInfo.set_device_id(mDeviecId.GetString());\n    if (mLoginType == proto_ff::E_PHONE)\n    {\n        accountInfo.set_phonenum(NFCommon::strto<uint64_t>(mAccount.GetString()));\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"Ready Create Account InTo Mysql:{}\", accountInfo.DebugString());\n\n    FindModule<NFIMessageModule>()->SendTransToStoreServer(NF_ST_LOGIN_SERVER,\n                                                           proto_ff::E_STORESVR_C2S_INSERT, proto_ff::E_TABLE_ACCOUNT_PLAYER, NF_DEFAULT_MYSQL_DB_NAME, \"tbAccountTable\", accountInfo,\n                                                           GetGlobalID(), 0, NFHash::hash<std::string>()(mAccount.GetString()));\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFRegisterAccountTrans.cpp b/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFRegisterAccountTrans.cpp
--- a/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFRegisterAccountTrans.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFRegisterAccountTrans.cpp	(date 1688616543366)
@@ -8,7 +8,7 @@
 // -------------------------------------------------------------------------
 
 #include "NFRegisterAccountTrans.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFPluginModule/NFLogMgr.h"
 #include "NFComm/NFPluginModule/NFCheck.h"
 #include "NFComm/NFMessageDefine/proto_svr_common.pb.h"
Index: game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFGameServerModule.h\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFGameServerPlugin\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmOldHashMap.h\"\n#include \"NFComm/NFShmCore/NFShmString.h\"\n#include \"NFServer/NFCommHead/NFCommLogicHead.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFShmHashObjectMgr.h\"\n\nclass NFAccountLogin\n{\npublic:\n\tNFAccountLogin();\n\tvirtual ~NFAccountLogin();\n    int CreateInit();\n    int ResumeInit();\n\npublic:\n    SZ_USER_ACCOUNT  mAccount;\n    SZ_USER_ACCOUNT  mPassword;\n    SZ_USER_ACCOUNT  mDeviceId;\n    uint64_t mPhoneNum;\n\tuint64_t mPlayerId;\n\tuint64_t mLastLoginTime;\n\tuint32_t mAccountType;\n};\n\nclass NFAccountLoginMgr: public NFShmObj\n{\npublic:\n\tNFAccountLoginMgr();\n\n\tvirtual ~NFAccountLoginMgr();\n\n\tint CreateInit();\n\tint ResumeInit();\n\n    //must be virtual\n    virtual int OnTimer(int timeId, int callcount);\n\n    int Tick();\n\n    int ClearOne();\n\n\tNFAccountLogin *FindAccount(const std::string& account);\n\tNFAccountLogin *CreateAccount(const std::string& account, const std::string& password, uint64_t playerId, uint32_t accountType, const std::string& deviceId, uint64_t phonenum);\n\n\tstatic int GetExternalDataSize(int objCount) { return NFHashObjectMgr<NFSizeString<MAX_PLAYER_ACCOUNT_SIZE>, NFAccountLogin>::CountSize(objCount);}\nprivate:\n    int m_timerId;\n    NFHashObjectMgr<SZ_USER_ACCOUNT, NFAccountLogin> m_oAccountHash;\n\tDECLARE_IDCREATE(NFAccountLoginMgr)\n};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.h b/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.h
--- a/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFAccountLoginMgr.h	(date 1688616543239)
@@ -13,7 +13,7 @@
 #include "NFComm/NFShmCore/NFShmOldHashMap.h"
 #include "NFComm/NFShmCore/NFShmString.h"
 #include "NFServer/NFCommHead/NFCommLogicHead.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFShmHashObjectMgr.h"
 
 class NFAccountLogin
Index: src/NFComm/NFShmStl/NFShmString.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFShmString.h\n//    @Author           :    gaoyi\n//    @Date             :    23-2-13\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFShmString\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n\ntemplate<class Tp, int MAX_SIZE>\nclass NFShmStringBase\n{\nprotected:\n    Tp m_data[MAX_SIZE + 1];\n    size_t m_size;\n\n    size_t max_size() const { return MAX_SIZE; }\n\n    NFShmStringBase()\n    {\n        if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode())\n        {\n            CreateInit();\n        }\n        else\n        {\n            ResumeInit();\n        }\n    }\n\n    ~NFShmStringBase()\n    {\n\n    }\n\n    int CreateInit()\n    {\n        m_size = 0;\n        memset(m_data, 0, sizeof(Tp) * (MAX_SIZE + 1));\n        return 0;\n    }\n\n    int ResumeInit()\n    {\n        return 0;\n    }\n};\n\n// ------------------------------------------------------------\n// Class basic_string.\n\n// Class invariants:\n// (1) [start, finish) is a valid range.\n// (2) Each iterator in [start, finish) points to a valid object\n//     of type value_type.\n// (3) *finish is a valid object of type value_type; in particular,\n//     it is value_type().\n// (4) [finish + 1, end_of_storage) is a valid range.\n// (5) Each iterator in [finish + 1, end_of_storage) points to\n//     unininitialized memory.\n\n// Note one important consequence: a string of length n must manage\n// a block of memory whose size is at least n + 1.\n\n\ntemplate<class CharT, int MAX_SIZE, class Traits = std::char_traits<CharT>>\nclass NFShmBasicString: private NFShmStringBase<CharT, MAX_SIZE>\n{\npublic:\n    typedef CharT value_type;\n    typedef Traits traits_type;\n\n    typedef value_type *pointer;\n    typedef const value_type *const_pointer;\n    typedef value_type &reference;\n    typedef const value_type &const_reference;\n    typedef size_t size_type;\n    typedef ptrdiff_t difference_type;\n\n    typedef const value_type *const_iterator;\n    typedef value_type *iterator;\n\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n\n\n    static const size_type npos;\n\n    typedef NFShmStringBase<CharT, MAX_SIZE> _Base;\n\npublic:                         // Constructor, destructor, assignment.\n    explicit NFShmBasicString()\n    {\n        if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode())\n        {\n            CreateInit();\n        }\n        else\n        {\n            ResumeInit();\n        }\n    }\n\n    NFShmBasicString(const NFShmBasicString &__s)\n    {\n        _M_range_initialize(__s.begin(), __s.end());\n    }\n\n    NFShmBasicString(const std::basic_string<CharT, Traits> &__s)\n    {\n        _M_range_initialize(__s.begin(), __s.end());\n    }\n\n    NFShmBasicString(const NFShmBasicString &__s, size_type __pos, size_type __n = npos)\n    {\n        if (__pos <= __s.size())\n        {\n            _M_range_initialize(__s.begin() + __pos,\n                                __s.begin() + __pos + min(__n, __s.size() - __pos));\n        }\n    }\n\n    NFShmBasicString(const std::basic_string<CharT, Traits> &__s, size_type __pos, size_type __n = npos)\n    {\n        if (__pos <= __s.size())\n        {\n            _M_range_initialize(__s.begin() + __pos,\n                                __s.begin() + __pos + min(__n, __s.size() - __pos));\n        }\n    }\n\n    NFShmBasicString(const CharT *__s, size_type __n) { _M_range_initialize(__s, __s + __n); }\n\n    NFShmBasicString(const CharT *__s) { _M_range_initialize(__s, __s + Traits::length(__s)); }\n\n    NFShmBasicString(size_type __n, CharT __c)\n    {\n        if (__n > MAX_SIZE)\n        {\n            __n = MAX_SIZE;\n        }\n        std::uninitialized_fill_n(m_data, __n, __c);\n        m_size = __n;\n        _M_terminate_string();\n    }\n\n    // Check to see if _InputIterator is an integer type.  If so, then\n    // it can't be an iterator.\n    template<class _InputIterator>\n    NFShmBasicString(_InputIterator __f, _InputIterator __l)\n    {\n        typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n        _M_initialize_dispatch(__f, __l, _Integral());\n    }\n\n    NFShmBasicString(const CharT *__f, const CharT *__l)\n    {\n        _M_range_initialize(__f, __l);\n    }\n\n    ~NFShmBasicString()\n    {\n\n    }\n\n    NFShmBasicString &operator=(const NFShmBasicString &__s)\n    {\n        if (&__s != this)\n            assign(__s.begin(), __s.end());\n        return *this;\n    }\n\n    NFShmBasicString &operator=(const CharT *__s) { return assign(__s, __s + Traits::length(__s)); }\n\n    NFShmBasicString &operator=(CharT __c) { return assign(static_cast<size_type>(1), __c); }\n\n    int CreateInit()\n    {\n        _M_terminate_string();\n        return 0;\n    }\n\n    int ResumeInit()\n    {\n        return 0;\n    }\n\nprotected:\n    using _Base::m_data;\n    using _Base::m_size;\nprivate:\n\n    void _M_construct_null(CharT *__p)\n    {\n        std::_Construct(__p);\n        *__p = (CharT) 0;\n    }\n\n    static CharT _M_null()\n    {\n        return (CharT) 0;\n    }\n\n    void _M_terminate_string()\n    {\n        _M_construct_null(m_data + m_size);\n    }\n\n    template<class _InputIter>\n    void _M_range_initialize(_InputIter __f, _InputIter __l,\n                             std::input_iterator_tag)\n    {\n        _M_construct_null(m_data + m_size);\n        append(__f, __l);\n    }\n\n    template<class _ForwardIter>\n    void _M_range_initialize(_ForwardIter __f, _ForwardIter __l,\n                             std::forward_iterator_tag)\n    {\n        difference_type __n = std::distance(__f, __l);\n        if (__n > MAX_SIZE)\n        {\n            __n = MAX_SIZE;\n        }\n        auto finish = std::uninitialized_copy_n(__f, __n, m_data);\n        m_size = finish - m_data;\n        _M_terminate_string();\n    }\n\n    template<class _InputIter>\n    void _M_range_initialize(_InputIter __f, _InputIter __l)\n    {\n        typedef typename iterator_traits<_InputIter>::iterator_category _Category;\n        _M_range_initialize(__f, __l, _Category());\n    }\n\n    template<class _Integer>\n    void _M_initialize_dispatch(_Integer __n, _Integer __x, std::__true_type)\n    {\n        if (__n > MAX_SIZE)\n        {\n            __n = MAX_SIZE;\n        }\n\n        std::uninitialized_fill_n(m_data, __n, __x);\n        m_size = __n;\n        _M_terminate_string();\n    }\n\n    template<class _InputIter>\n    void _M_initialize_dispatch(_InputIter __f, _InputIter __l, std::__false_type)\n    {\n        _M_range_initialize(__f, __l);\n    }\n\n\n    void _M_range_initialize(const CharT *__f, const CharT *__l)\n    {\n        ptrdiff_t __n = __l - __f;\n        if (__n > MAX_SIZE)\n        {\n            __n = MAX_SIZE;\n        }\n        auto finish = uninitialized_copy_n(__f, __n, m_data);\n        m_size = finish - m_data;\n        _M_terminate_string();\n    }\n\n\npublic:                         // Iterators.\n    iterator begin() { return m_data; }\n\n    iterator end() { return m_data + m_size; }\n\n    const_iterator begin() const { return m_data; }\n\n    const_iterator end() const { return m_data + m_size; }\n\n    reverse_iterator rbegin() { return reverse_iterator(m_data + m_size); }\n\n    reverse_iterator rend() { return reverse_iterator(m_data); }\n\n    const_reverse_iterator rbegin() const { return const_reverse_iterator(m_data + m_size); }\n\n    const_reverse_iterator rend() const { return const_reverse_iterator(m_data); }\n\npublic:                         // Size, capacity, etc.\n    size_type size() const { return m_size; }\n\n    size_type length() const { return size(); }\n\n    size_t max_size() const { return _Base::max_size(); }\n\n    void reserve(size_type = 0);\n\n    size_type capacity() const { return (m_data + MAX_SIZE - m_data) - 1; }\n\n    void clear()\n    {\n        if (!empty())\n        {\n            Traits::assign(*m_data, _M_null());\n            std::_Destroy(m_data + 1, m_data + m_size + 1);\n            m_size = 0;\n        }\n    }\n\n    bool empty() const { return m_size == 0; }\n\npublic:                         // Element access.\n\n    const_reference operator[](size_type __n) const { return *(m_data + __n); }\n\n    reference operator[](size_type __n) { return *(m_data + __n); }\n\n    const_reference at(size_type __n) const\n    {\n        NF_ASSERT(__n < size());\n        return *(m_data + __n);\n    }\n\n    reference at(size_type __n)\n    {\n        NF_ASSERT(__n < size());\n        return *(m_data + __n);\n    }\n\npublic:                         // Other modifier member functions.\n\n    size_type copy(CharT *__s, size_type __n, size_type __pos = 0) const\n    {\n        NF_ASSERT(__pos <= size());\n        const size_type __len = min(__n, size() - __pos);\n        Traits::copy(__s, m_data + __pos, __len);\n        return __len;\n    }\n\n    void swap(NFShmBasicString &__s)\n    {\n    }\n\npublic:                         // Conversion to C string.\n\n    const CharT *c_str() const { return m_data; }\n\n    const CharT *data() const { return m_data; }\n\npublic:                         // Compare\n\n    int compare(const NFShmBasicString &__s) const { return _M_compare(m_data, m_data + m_size, __s.m_data, __s.m_data + m_size); }\n\n    int compare(size_type __pos1, size_type __n1,\n                const NFShmBasicString &__s) const\n    {\n        NF_ASSERT(__pos1 <= size());\n        return _M_compare(m_data + __pos1,\n                          m_data + __pos1 + min(__n1, size() - __pos1),\n                          __s.m_data, __s.m_data + m_size);\n    }\n\n    int compare(size_type __pos1, size_type __n1,\n                const NFShmBasicString &__s,\n                size_type __pos2, size_type __n2) const\n    {\n        NF_ASSERT(!(__pos1 > size() || __pos2 > __s.size()));\n        return _M_compare(m_data + __pos1,\n                          m_data + __pos1 + min(__n1, size() - __pos1),\n                          __s.m_data + __pos2,\n                          __s.m_data + __pos2 + min(__n2, size() - __pos2));\n    }\n\n    int compare(const CharT *__s) const\n    {\n        return _M_compare(m_data, m_data + m_size, __s, __s + Traits::length(__s));\n    }\n\n    int compare(size_type __pos1, size_type __n1, const CharT *__s) const\n    {\n        NF_ASSERT(__pos1 <= size());\n        return _M_compare(m_data + __pos1,\n                          m_data + __pos1 + min(__n1, size() - __pos1),\n                          __s, __s + Traits::length(__s));\n    }\n\n    int compare(size_type __pos1, size_type __n1, const CharT *__s,\n                size_type __n2) const\n    {\n        NF_ASSERT (__pos1 <= size());\n        return _M_compare(m_data + __pos1,\n                          m_data + __pos1 + min(__n1, size() - __pos1),\n                          __s, __s + __n2);\n    }\n\npublic:                        // Helper function for compare.\n    static int _M_compare(const CharT *__f1, const CharT *__l1,\n                          const CharT *__f2, const CharT *__l2)\n    {\n        const ptrdiff_t __n1 = __l1 - __f1;\n        const ptrdiff_t __n2 = __l2 - __f2;\n        const int cmp = Traits::compare(__f1, __f2, min(__n1, __n2));\n        return cmp != 0 ? cmp : (__n1 < __n2 ? -1 : (__n1 > __n2 ? 1 : 0));\n    }\n};\n\n\n\n// ------------------------------------------------------------\n// Non-inline declarations.\n\ntemplate<class _CharT, int MAX_SIZE, class _Traits>\nconst typename NFShmBasicString<_CharT, MAX_SIZE, _Traits>::size_type\n        NFShmBasicString<_CharT, MAX_SIZE, _Traits>::npos\n        = (typename NFShmBasicString<_CharT, MAX_SIZE, _Traits>::size_type) -1;\n\n// Change the string's capacity so that it is large enough to hold\n//  at least __res_arg elements, plus the terminating null.  Note that,\n//  if __res_arg < capacity(), this member function may actually decrease\n//  the string's capacity.\ntemplate<class _CharT, int MAX_SIZE, class _Traits>\nvoid NFShmBasicString<_CharT, MAX_SIZE, _Traits>::reserve(size_type __res_arg)\n{\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/NFComm/NFShmStl/NFShmString.h b/src/NFComm/NFShmStl/NFShmString.h
--- a/src/NFComm/NFShmStl/NFShmString.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/src/NFComm/NFShmStl/NFShmString.h	(date 1688606521137)
@@ -426,4 +426,4 @@
 void NFShmBasicString<_CharT, MAX_SIZE, _Traits>::reserve(size_type __res_arg)
 {
 
-}
+}
\ No newline at end of file
Index: Install/Config/Fish/Server/Common.lua
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Install/Config/Fish/Server/Common.lua b/Install/Config/Fish/Server/Common.lua
new file mode 100644
--- /dev/null	(date 1666917760773)
+++ b/Install/Config/Fish/Server/Common.lua	(date 1666917760773)
@@ -0,0 +1,16 @@
+-- server type
+NF_ST_NONE = 0;    		--NONE
+NF_ST_MASTER_SERVER = 1;
+NF_ST_ROUTE_SERVER = 2; --路由集群服务器 负责不同机子服务器数据之间的转发
+NF_ST_ROUTE_AGENT_SERVER = 3; --路由代理服务器  负责同一台机子服务器数据之间的转发
+NF_ST_PROXY_SERVER = 4;
+NF_ST_PROXY_AGENT_SERVER = 5; --Proxy 路由代理服务器 负责同一台机子客户端与服务器数据之间的转发
+NF_ST_STORE_SERVER = 6; --DB服务器
+NF_ST_LOGIN_SERVER = 7;
+NF_ST_WORLD_SERVER = 8;
+NF_ST_LOGIC_SERVER = 9; --Logic服务器
+NF_ST_GAME_SERVER = 10;
+NF_ST_SNS_SERVER = 11; --SNS服务器
+NF_ST_WEB_SERVER = 12; --Web服务器
+NF_ST_MONITOR_SERVER = 18; ---Monitor服务器
+NF_ST_MAX = 20;
Index: Install/Config/Fish/Server/WorldServer.lua
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Install/Config/Fish/Server/WorldServer.lua b/Install/Config/Fish/Server/WorldServer.lua
new file mode 100644
--- /dev/null	(date 1678362400316)
+++ b/Install/Config/Fish/Server/WorldServer.lua	(date 1678362400316)
@@ -0,0 +1,10 @@
+require "Common"
+
+WorldServer = {
+    TokenTimeCheck = true;
+    WhiteListState = false;
+    MaxRegisterNum = 20000;
+    StartQueueNum = 2000;
+    MaxQueueNum = 2000;
+    WhiteList = {10,2,5,9,20,279};
+};
\ No newline at end of file
Index: Install/Config/Fish/Server/ProxyServer.lua
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Install/Config/Fish/Server/ProxyServer.lua b/Install/Config/Fish/Server/ProxyServer.lua
new file mode 100644
--- /dev/null	(date 1688432250357)
+++ b/Install/Config/Fish/Server/ProxyServer.lua	(date 1688432250357)
@@ -0,0 +1,18 @@
+require "Common"
+
+--发包上限  upper_limit
+--统计时间间隔 control_time  毫秒统计
+--两个消息最小间隔  min_interval 毫秒统计
+
+CLIENT_TO_CENTER_LOGIN_BEGIN = 18;
+CLIENT_TO_CENTER_LOGIN = 19;       --登陆网关请求
+CLIENT_TO_CENTER_CREATE_CHARACTER = 20;    --请求创建角色请求
+CLIENT_TO_CENTER_DEL_CHARACTER = 21;       --删角色请求
+
+ProxyServer = {
+    PacketMsg = {
+        {cmd = CLIENT_TO_CENTER_LOGIN, upper_limit = 100, min_interval = 0,  control_time = 10000},
+        {cmd = CLIENT_TO_CENTER_CREATE_CHARACTER,  upper_limit = 100, min_interval = 0,  control_time = 10000},
+        {cmd = CLIENT_TO_CENTER_DEL_CHARACTER,  upper_limit = 100, min_interval = 0,  control_time = 10000}
+    },
+};
\ No newline at end of file
Index: Install/Config/Fish/Server/GameServer.lua
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Install/Config/Fish/Server/GameServer.lua b/Install/Config/Fish/Server/GameServer.lua
new file mode 100644
--- /dev/null	(date 1678695939715)
+++ b/Install/Config/Fish/Server/GameServer.lua	(date 1678695939715)
@@ -0,0 +1,68 @@
+require "Common"
+
+GameServer_1 = {
+    map = {
+        1000,
+        1003,
+        1201,
+        1202,
+        1203,
+        1204,
+        1205,
+        1103,
+        1104,
+        1106,
+        1309,
+        1101,
+        1004,
+        1100,
+        1105,
+        1106,
+        1107,
+        1220,
+        1221,
+        1222,
+        1240,
+        1241,
+        1242,
+        1300,
+        1301,
+        1400,
+        1401,
+        1200,
+        1005,
+        1008,
+        1102,
+        1001,
+        1002,
+        1006,
+        1007,
+        1302,
+        1303,
+        1304,
+        1305,
+        1306,
+        1307,
+        1308,
+        1108,
+        1109,
+        1250,
+        1251,
+        1252,
+        1260,
+        1261,
+        1262,
+        1265,
+        1266,
+        1267,
+        1270,
+        1271,
+        1272,
+        1275,
+        1276,
+        1277,
+        1280,
+        1281,
+        1282
+    },
+};
\ No newline at end of file
Index: game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFBindPhoneTrans.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFBindPhoneTrans.cpp\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFBindPhoneTrans.cpp\n//\n// -------------------------------------------------------------------------\n\n#include \"NFBindPhoneTrans.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"NFComm/NFMessageDefine/proto_svr_common.pb.h\"\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include \"NFComm/NFKernelMessage/storesvr_sqldata.pb.h\"\n#include \"NFComm/NFPluginModule/NFCommLogic.h\"\n#include \"NFAccountLoginMgr.h\"\n#include \"NFComm/NFCore/NFMD5.h\"\n#include \"NFServerIpMgr.h\"\n#include \"NFPhoneAutoCodeMgr.h\"\n\nIMPLEMENT_IDCREATE_WITHTYPE(NFBindPhoneTrans, EOT_TRANS_REGISTER_ACCOUNT_BIND_PHONE, NFTransBase)\n\nNFBindPhoneTrans::NFBindPhoneTrans()\n{\n    if (NFShmMgr::Instance()->GetCreateMode() == EN_OBJ_MODE_INIT) {\n        CreateInit();\n    } else {\n        ResumeInit();\n    }\n}\n\nNFBindPhoneTrans::~NFBindPhoneTrans()\n{\n\n}\n\nint NFBindPhoneTrans::CreateInit()\n{\n    m_phoneNum = 0;\n    mProxyBusId = 0;\n    mClientLinkId = 0;\n    mCmd = 0;\n    return 0;\n}\n\nint NFBindPhoneTrans::ResumeInit()\n{\n    return 0;\n}\n\nint NFBindPhoneTrans::OnTransFinished(int iRunLogicRetCode)\n{\n    if (iRunLogicRetCode)\n    {\n        switch (mCmd)\n        {\n            case proto_login::NF_CS_MSG_LoginServer_PhoneAutoCodeReq:\n            {\n                proto_login::Proto_SC_LoginServer_PhoneAutoCodeRsp rspMsg;\n                rspMsg.set_result(iRunLogicRetCode);\n                rspMsg.set_phone_num(m_phoneNum);\n\n                FindModule<NFIMessageModule>()->SendMsgToProxyServer(NF_ST_LOGIN_SERVER, mProxyBusId,\n                                                               proto_login::NF_SC_MSG_LoginServer_PhoneAutoCodeRsp,\n                                                               rspMsg,\n                                                               mClientLinkId);\n                break;\n            }\n            case proto_login::NF_CS_MSG_LoginServer_CheckPhoneCodeReq:\n            {\n                proto_login::Proto_SC_LoginServer_CheckPhoneCodeRsp rspMsg;\n                rspMsg.set_result(iRunLogicRetCode);\n                rspMsg.set_phone_num(m_phoneNum);\n\n                FindModule<NFIMessageModule>()->SendMsgToProxyServer(NF_ST_LOGIN_SERVER, mProxyBusId,\n                                                               proto_login::NF_SC_MSG_LoginServer_CheckPhoneCodeRsp,\n                                                               rspMsg,\n                                                               mClientLinkId);\n                break;\n            }\n            default:\n            {\n                break;\n            }\n        }\n    }\n\n    return 0;\n}\n\nint NFBindPhoneTrans::Init(uint32_t busId, uint64_t clientLinkId, uint32_t cmd)\n{\n    NFTransBase::Init();\n    mProxyBusId = busId;\n    mClientLinkId = clientLinkId;\n    mCmd = cmd;\n    return 0;\n}\n\nint NFBindPhoneTrans::HandleCSMsgReq(const google::protobuf::Message *pCSMsgReq)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n\n    int iRetCode = HandleGetBaseInfoMsgParam(pCSMsgReq);\n    if (iRetCode) {\n        return iRetCode;\n    }\n\n    iRetCode = ProGetBaseInfoReq();\n    if (iRetCode) {\n        return iRetCode;\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFBindPhoneTrans::HandleDispSvrRes(uint64_t unLinkId, uint64_t destLinkId, uint64_t req_trans_id, uint32_t nMsgId, const char* msg, uint32_t nLen)\n{\n    if (nMsgId == proto_ff::NF_WebTL_PHONE_AUTH_CODE_RSP)\n    {\n        proto_ff::WebTLPhoneAuthCodeRsp xMsg;\n        CLIENT_MSG_PROCESS_WITH_PRINTF(nMsgId, destLinkId, msg, nLen, xMsg);\n\n        NFPhoneAutoCode* pLogin = NFPhoneAutoCodeMgr::Instance()->FindPhone(m_phoneNum);\n        CHECK_EXPR(pLogin, -1, \"pLogin == NULL\");\n        CHECK_EXPR(xMsg.phone_num() == m_phoneNum, -1, \"phone is not right, xMsg.phone_num:{} m_phoneNum:{}\", xMsg.phone_num(), m_phoneNum);\n\n        proto_login::Proto_SC_LoginServer_PhoneAutoCodeRsp rspMsg;\n        rspMsg.set_result(xMsg.result());\n        rspMsg.set_phone_num(xMsg.phone_num());\n        rspMsg.set_code_type(pLogin->m_codeType);\n\n        FindModule<NFIMessageModule>()->SendMsgToProxyServer(NF_ST_LOGIN_SERVER, mProxyBusId,\n                                                             proto_login::NF_SC_MSG_LoginServer_PhoneAutoCodeRsp,\n                                                             rspMsg,\n                                                             mClientLinkId);\n\n        SetFinished(0);\n        return 0;\n    }\n    else if (nMsgId == proto_ff::NF_WebTL_PHONE_CHECK_CODE_RSP)\n    {\n        proto_ff::WebTLPhoneAuthCodeRsp xMsg;\n        CLIENT_MSG_PROCESS_WITH_PRINTF(nMsgId, destLinkId, msg, nLen, xMsg);\n\n        CHECK_EXPR(xMsg.phone_num() == m_phoneNum, -1, \"phone is not right, xMsg.phone_num:{} m_phoneNum:{}\", xMsg.phone_num(), m_phoneNum);\n\n        NFPhoneAutoCode* pLogin = NFPhoneAutoCodeMgr::Instance()->FindPhone(m_phoneNum);\n        if (pLogin)\n        {\n            if (xMsg.result() == 0)\n            {\n                pLogin->m_checkSuccess = true;\n            }\n            else\n            {\n                pLogin->m_checkSuccess = false;\n            }\n            proto_login::Proto_SC_LoginServer_CheckPhoneCodeRsp rspMsg;\n            rspMsg.set_result(xMsg.result());\n            rspMsg.set_phone_num(xMsg.phone_num());\n            rspMsg.set_code_type(pLogin->m_codeType);\n\n            FindModule<NFIMessageModule>()->SendMsgToProxyServer(NF_ST_LOGIN_SERVER, mProxyBusId,\n                                                           proto_login::NF_SC_MSG_LoginServer_CheckPhoneCodeRsp,\n                                                           rspMsg,\n                                                           mClientLinkId);\n        }\n        else\n        {\n            proto_login::Proto_SC_LoginServer_CheckPhoneCodeRsp rspMsg;\n            rspMsg.set_result(proto_ff::ERR_CODE_PHONE_AUTO_CODE_TIMEOUT);\n            rspMsg.set_phone_num(xMsg.phone_num());\n\n            FindModule<NFIMessageModule>()->SendMsgToProxyServer(NF_ST_LOGIN_SERVER, mProxyBusId,\n                                                           proto_login::NF_SC_MSG_LoginServer_CheckPhoneCodeRsp,\n                                                           rspMsg,\n                                                           mClientLinkId);\n        }\n\n\n\n        SetFinished(0);\n        return 0;\n    }\n\n    return proto_ff::ERR_CODE_SYSTEM_ERROR;\n}\n\nint NFBindPhoneTrans::HandleDBMsgRes(const google::protobuf::Message *pSSMsgRes, uint32_t cmd, uint32_t table_id,\n                                      uint32_t seq,\n                                      uint32_t err_code)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    int iRetCode = 0;\n    if (cmd == proto_ff::E_STORESVR_S2C_SELECTOBJ)\n    {\n        if (table_id == proto_ff::E_TABLE_ACCOUNT_PLAYER)\n        {\n            const storesvr_sqldata::storesvr_selobj_res *pRes = dynamic_cast<const storesvr_sqldata::storesvr_selobj_res *>(pSSMsgRes);\n            CHECK_EXPR(pRes, -1, \"pRes == NULL\");\n\n            iRetCode = ProGetBaseInfoRes(pRes, cmd, table_id, err_code);\n        }\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return iRetCode;\n}\n\nint NFBindPhoneTrans::ProGetBaseInfoRes(const storesvr_sqldata::storesvr_selobj_res* pSelRsp, uint32_t cmd, uint32_t table_id, uint32_t err_code)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n\n    if (err_code != 0)\n    {\n        if (err_code == proto_ff::ERR_CODE_STORESVR_ERRCODE_SELECT_EMPTY)\n        {\n            NFPhoneAutoCode* pLogin = NFPhoneAutoCodeMgr::Instance()->FindPhone(m_phoneNum);\n            if (pLogin)\n            {\n                int iRetCode = HandleGetBaseInfoRes(pLogin);\n                if (iRetCode)\n                {\n                    SetFinished(iRetCode);\n                }\n            }\n            else\n            {\n                return proto_ff::ERR_CODE_SYSTEM_ERROR;\n            }\n            return 0;\n        }\n\n        return proto_ff::ERR_CODE_SYSTEM_ERROR;\n    }\n    else\n    {\n        NFPhoneAutoCode* pLogin = NFPhoneAutoCodeMgr::Instance()->FindPhone(m_phoneNum);\n        if (pLogin)\n        {\n            if (pLogin->m_codeType == proto_ff::PHONE_AUTO_CODE_REGISTER)\n            {\n                return proto_ff::ERR_CODE_BIND_PHONE_ALREADY;\n            }\n            else if (pLogin->m_codeType == proto_ff::PHONE_AUTO_CODE_CHANGE_PASSWORD || pLogin->m_codeType == proto_ff::PHONE_AUTO_CODE_CHANGE_DEVICE) {\n                int iRetCode = HandleGetBaseInfoRes(pLogin);\n                if (iRetCode) {\n                    SetFinished(iRetCode);\n                }\n                return 0;\n            }\n        }\n        else\n        {\n            return proto_ff::ERR_CODE_SYSTEM_ERROR;\n        }\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return proto_ff::ERR_CODE_SYSTEM_ERROR;\n}\n\nint NFBindPhoneTrans::ProGetBaseInfoReq()\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n\n    proto_ff::tbAccountTable accountInfo;\n    accountInfo.set_account(NFCommon::tostr(m_phoneNum));\n\n    FindModule<NFIMessageModule>()->SendTransToStoreServer(NF_ST_LOGIN_SERVER,\n                                                           proto_ff::E_STORESVR_C2S_SELECTOBJ, proto_ff::E_TABLE_ACCOUNT_PLAYER, NF_DEFAULT_MYSQL_DB_NAME, \"tbAccountTable\", accountInfo,\n                                                           GetGlobalID(), 0, m_phoneNum);\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFBindPhoneTrans::HandleGetBaseInfoMsgParam(const google::protobuf::Message *pCSMsgReq)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    int iRetCode = 0;\n    switch (mCmd)\n    {\n        case proto_login::NF_CS_MSG_LoginServer_PhoneAutoCodeReq:\n        {\n            iRetCode = ProPhoneAutoCodeInfoReq(dynamic_cast<const proto_login::Proto_CS_LoginServer_PhoneAutoCodeReq *>(pCSMsgReq));\n            break;\n        }\n        case proto_login::NF_CS_MSG_LoginServer_CheckPhoneCodeReq:\n        {\n            iRetCode = ProPhoneCheckCodeInfoReq(dynamic_cast<const proto_login::Proto_CS_LoginServer_CheckPhoneCodeReq *>(pCSMsgReq));\n            break;\n        }\n        default:\n        {\n            iRetCode = -1;\n            break;\n        }\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return iRetCode;\n}\n\nint NFBindPhoneTrans::ProPhoneCheckCodeInfoReq(const proto_login::Proto_CS_LoginServer_CheckPhoneCodeReq *pCSMsgReq)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    CHECK_EXPR(pCSMsgReq, -1, \"pLoginReq = NULL\");\n\n    m_phoneNum = pCSMsgReq->phone_num();\n\n    NFPhoneAutoCode* pLogin = NFPhoneAutoCodeMgr::Instance()->FindPhone(m_phoneNum);\n    if (pLogin == NULL)\n    {\n        return proto_ff::ERR_CODE_PHONE_AUTO_CODE_TIMEOUT;\n    }\n\n    pLogin->m_lastTime = NFTime::Now().UnixSec();\n\n    proto_ff::LTWebPhoneCheckCodeReq reqMsg;\n    reqMsg.set_phone_num(m_phoneNum);\n    reqMsg.set_code(pCSMsgReq->auth_code());\n    reqMsg.set_code_type(pLogin->m_codeType);\n\n    FindModule<NFIMessageModule>()->SendTransToWebServer(NF_ST_LOGIN_SERVER, proto_ff::NF_LTWeb_PHONE_CHECK_CODE_REQ, reqMsg, GetGlobalID());\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFBindPhoneTrans::ProPhoneAutoCodeInfoReq(const proto_login::Proto_CS_LoginServer_PhoneAutoCodeReq *pCSMsgReq)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    CHECK_EXPR(pCSMsgReq, -1, \"pLoginReq = NULL\");\n\n    m_phoneNum = pCSMsgReq->phone_num();\n\n    NFPhoneAutoCode* pLogin = NFPhoneAutoCodeMgr::Instance()->FindPhone(m_phoneNum);\n    if (pLogin == NULL)\n    {\n        pLogin = NFPhoneAutoCodeMgr::Instance()->CreatePhone(m_phoneNum);\n        CHECK_NULL(pLogin);\n    }\n\n    pLogin->m_codeType = pCSMsgReq->code_type();\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}\n\nint NFBindPhoneTrans::HandleGetBaseInfoRes(NFPhoneAutoCode *pUserLogin)\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    int iRetCode = 0;\n    switch (mCmd)\n    {\n        case proto_login::NF_CS_MSG_LoginServer_PhoneAutoCodeReq:\n        {\n            iRetCode = ProPhoneAutoCodeRes();\n            break;\n        }\n        default:\n        {\n            iRetCode = -1;\n            break;\n        }\n    }\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return iRetCode;\n}\n\nint NFBindPhoneTrans::ProPhoneAutoCodeRes()\n{\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- begin --\");\n    NFPhoneAutoCode* pLogin = NFPhoneAutoCodeMgr::Instance()->FindPhone(m_phoneNum);\n    CHECK_NULL(pLogin);\n\n    pLogin->m_lastTime = NFTime::Now().UnixSec();\n\n    proto_ff::LTWebPhoneAuthCodeReq reqMsg;\n    reqMsg.set_phone_num(m_phoneNum);\n    reqMsg.set_code_type(pLogin->m_codeType);\n\n    FindModule<NFIMessageModule>()->SendTransToWebServer(NF_ST_LOGIN_SERVER, proto_ff::NF_LTWeb_PHONE_AUTH_CODE_REQ, reqMsg, GetGlobalID());\n\n    NFLogTrace(NF_LOG_LOGIN_SERVER_PLUGIN, 0, \"-- end --\");\n    return 0;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFBindPhoneTrans.cpp b/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFBindPhoneTrans.cpp
--- a/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFBindPhoneTrans.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFBindPhoneTrans.cpp	(date 1688616542972)
@@ -8,7 +8,7 @@
 // -------------------------------------------------------------------------
 
 #include "NFBindPhoneTrans.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFPluginModule/NFLogMgr.h"
 #include "NFComm/NFPluginModule/NFCheck.h"
 #include "NFComm/NFMessageDefine/proto_svr_common.pb.h"
Index: src/NFComm/NFShmCore/NFShmObj.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFShmObj.h\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFPluginModule\n//\n// -------------------------------------------------------------------------\n#pragma once\n\n#include \"NFShmDefine.h\"\n#include \"NFDynamicHead.h\"\n#include \"NFComm/NFPluginModule/NFObject.h\"\n#include \"NFComm/NFPluginModule/NFEventObj.h\"\n\nclass NFShmObj : public NFObject\n{\npublic:\n    NFShmObj();\n\n    virtual ~NFShmObj();\n\n    //非继承函数, 不要加virtual\n    int CreateInit();\n\n    //非继承函数, 不要加virtual\n    int ResumeInit()\n    {\n        return 0;\n    }\n\n    virtual int AfterOnReloadConfig()\n    {\n        return 0;\n    }\n\n    //must be virtual\n    virtual int OnTimer(int timeId, int callcount);\n\n#if defined(_DEBUG) | defined(_DEBUG_)\n\n    void CheckMemMagicNum()\n    {\n        assert(m_iMagicCheckNum == OBJECT_MAGIC_CHECK_NUMBER);\n    }\n\n#endif\n\n    void SetInRecycle(bool bRet)\n    {\n        m_bIsInRecycle = bRet;\n    }\n\n    bool IsInRecycle()\n    {\n        return m_bIsInRecycle;\n    }\n\n    int GetObjId() const\n    {\n        return m_iObjId;\n    }\n\n    int64_t GetHashId()\n    {\n        return m_iHashId;\n    }\n\n    void SetHashId(int64_t Id)\n    {\n        m_iHashId = Id;\n    }\n\n    int GetGlobalId() const\n    {\n        return m_iGlobalId;\n    }\n\n    void SetGlobalId(int iID)\n    {\n        m_iGlobalId = iID;\n    }\n\n    int GetTypeIndexID()\n    {\n        return ((GetClassType() << 23) | 0x80000000) | GetObjId();\n    }\n\n    int GetMiscID()\n    {\n        if (m_iGlobalId >= 0)\n        {\n            return m_iGlobalId;\n        }\n        else\n        {\n            return GetTypeIndexID();\n        }\n    }\n\npublic:\n    /**\n    * @brief 收到事件函数, 对收到的事件进行处理\n    *\n    * @param nEventID\t\t事件ID\n    * @param nSrcID\t\t\t事件源ID，一般都是玩家，生物唯一id\n    * @param bySrcType\t\t事件源类型，玩家类型，怪物类型之类的\n    * @param pEventContext\t发过来的事件数据\n    * @return\n    */\n    /*\n    * 由Fire的问题，导致的问题:\n    * 问题1:如果在OnExecute函数里， 调用别的对象的UnSubscribe函数, 如果key一致(也就是nEventID,nSrcID,bySrcType都一样),\n    *\t\t可能导致将要执行的事件被删除，这可能与你预想的设计不一样\n    * 问题2:如果在OnExecute函数里， Fire了别的事件，会导致迭代问题，事件系统已经了做了预付， 相同的事件，最多迭代5次，\n    *       所有的Fire事件最多迭代20次\n    */\n    virtual int OnExecute(uint32_t serverType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message* pMessage);\n\n\n    /**\n     * @brief 发送事件,并执行收到事件的对象的对应函数\n     *\n     * @param nEventID\t\t事件ID\n     * @param nSrcID\t\t\t事件源ID，一般都是玩家，生物唯一id\n     * @param bySrcType\t\t事件源类型，玩家类型，怪物类型之类的\n     * @param pEventContext\t事件传输的数据\n     * @return\t\t\t\t执行是否成功\n     */\n    /*\n    * 几个威胁，可能导致问题, 但不会导致崩溃, 可能与你预想的不一样:\n    * 问题1:假设我在Fire事件里，相同的key，删除不同的pSink,\n    *\t\t可能导致将要执行的事件被删除，这可能与你预想的设计不一样\n    * 问题2:假设我在Fire事件里，相同的key，删除相同的pSink, 由于事件系统利用SubscribeInfo的Add,Sub引用计数做了预防，\n    *       迭代器不会立马被删除，不会导致std::list迭代器失效， 这样删除不会导致问题\n    * 问题3:假设我在Fire事件里， Fire了别的事件，会导致迭代问题，事件系统已经了做了预付， 相同的事件，最多迭代5次，\n    *       所有的Fire事件最多迭代20次\n    */\n    virtual int FireExecute(uint32_t nServerType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message &message);\n\n    /**\n     * @brief 事件将在先在本服务器执行，然后被广播至别的服务器执行\n     * @param nServerType\n     * @param nRecvServerType\n     * @param nEventID\n     * @param bySrcType\n     * @param nSrcID\n     * @param message\n     * @return\n     */\n    virtual int FireBroadcast(uint32_t nServerType, uint32_t nRecvServerType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message &message, bool self = false);\n    virtual int FireBroadcast(uint32_t nServerType, uint32_t nRecvServerType, uint32_t busId, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message &message, bool self = false);\n    virtual int FireBroadcast(uint32_t nServerType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message &message, bool self = false);\n\n    /**\n    * @brief 订阅事件\n    *\n    * @param nEventID\t事件ID\n    * @param nSrcID\t\t事件源ID，一般都是玩家，生物唯一id\n    * @param bySrcType\t事件源类型，玩家类型，怪物类型之类的\n    * @param desc\t\t事件描述，用于打印，获取信息，查看BUG之类的\n    * @return\t\t\t订阅事件是否成功\n    */\n    virtual int Subscribe(uint32_t nServerType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const std::string &desc);\n\n    /**\n    * @brief 取消订阅事件\n    *\n    * @param nEventID\t事件ID\n    * @param nSrcID\t\t事件源ID，一般都是玩家，生物唯一id\n    * @param bySrcType\t事件源类型，玩家类型，怪物类型之类的\n    * @return\t\t\t取消订阅事件是否成功\n    */\n    virtual int UnSubscribe(uint32_t nServerType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID);\n\n    /**\n    * @brief 取消NFEventObj所有订阅事件\n    *\n    * @return\t\t\t取消订阅事件是否成功\n    */\n    virtual int UnSubscribeAll();\npublic:\n    //delete objid\n    virtual int DeleteTimer(int timeObjId);\n    virtual int DeleteAllTimer();\n\n    ////注册距离现在多少时间执行一次的定时器(hour  minutes  second  microSec为第一次执行距离现在的时分秒毫秒, 只执行一次)\n    virtual int SetTimer(int hour, int minutes, int second, int microSec);\n\n    //注册某一个时间点执行一次的定时器(hour  minutes  second为第一次执行的时间点时分秒, 只执行一次)\n    virtual int SetCalender(int hour, int minutes, int second);\n\n    //注册某一个时间点执行一次的定时器(timestamp为第一次执行的时间点的时间戳,单位是秒, 只执行一次)\n    virtual  int SetCalender(uint64_t timestamp);\n\n    //注册循环执行定时器（hour  minutes  second  microSec为第一次执行距离现在的时分秒毫秒,  interval 为循环间隔时间，为毫秒）\n    virtual int SetTimer(int interval, int callcount, int hour, int minutes, int second, int microSec);\n\n    //注册循环执行定时器（hour  minutes  second  microSec为第一次执行距离现在的时分秒毫秒）\n    virtual  int SetDayTime(int callcount, int hour, int minutes, int second, int microSec);\n\n    //注册某一个时间点日循环执行定时器（hour  minutes  second为一天中开始执行的时间点，    23：23：23     每天23点23分23秒执行）\n    virtual  int SetDayCalender(int callcount, int hour, int minutes, int second);\n\n    //周循环（hour  minutes  second  microSec为第一次执行距离现在的时分秒毫秒）\n    virtual int SetWeekTime(int callcount, int hour, int minutes, int second, int microSec);\n\n    //注册某一个时间点周循环执行定时器（ weekDay  hour  minutes  second 为一周中某一天开始执行的时间点）\n    virtual int SetWeekCalender(int callcount, int weekDay, int hour, int minutes, int second);\n\n    //月循环（hour  minutes  second  microSec为第一次执行距离现在的时分秒毫秒,最好是同一天）\n    virtual int SetMonthTime(int callcount, int hour, int minutes, int second, int microSec);\n\n    //注册某一个时间点月循环执行定时器（ day  hour  minutes  second 为一月中某一天开始执行的时间点）\n    virtual int SetMonthCalender(int callcount, int day, int hour, int minutes, int second);\npublic:\n\n#if defined(_DEBUG) | defined(_DEBUG_)\n    int m_iMagicCheckNum;\n#endif\n    int m_iGlobalId;\n    int m_iObjId;\n    int m_iObjSeq;\n    int64_t m_iHashId;\n    int m_iObjType;\n\n    bool m_bIsInRecycle;\n\nDECLARE_IDCREATE(NFShmObj)\n};\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/NFComm/NFShmCore/NFShmObj.h b/src/NFComm/NFShmCore/NFShmObj.h
--- a/src/NFComm/NFShmCore/NFShmObj.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/src/NFComm/NFShmCore/NFShmObj.h	(date 1688609194127)
@@ -10,6 +10,8 @@
 
 #include "NFShmDefine.h"
 #include "NFDynamicHead.h"
+#include "NFTypeDefines.h"
+#include "NFISharedMemModule.h"
 #include "NFComm/NFPluginModule/NFObject.h"
 #include "NFComm/NFPluginModule/NFEventObj.h"
 
Index: game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFPhoneAutoCodeMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFPhoneAutoCodeMgr.h\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFPhoneAutoCodeMgr.h\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmOldHashMap.h\"\n#include \"NFComm/NFShmCore/NFShmString.h\"\n#include \"NFServer/NFCommHead/NFCommLogicHead.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n\nclass NFPhoneAutoCode: public NFShmObj\n{\npublic:\n    NFPhoneAutoCode();\n    virtual ~NFPhoneAutoCode();\n    int CreateInit();\n    int ResumeInit();\n\npublic:\n    uint64_t m_phoneNum;\n    uint64_t m_lastTime;\n    bool m_checkSuccess;\n    uint32_t m_codeType;\nDECLARE_IDCREATE(NFPhoneAutoCode)\n};\n\nclass NFPhoneAutoCodeMgr: public NFShmObj\n{\npublic:\n    NFPhoneAutoCodeMgr();\n\n    virtual ~NFPhoneAutoCodeMgr();\n\n    int CreateInit();\n    int ResumeInit();\n\n    //must be virtual\n    virtual void OnTimer(int timeId, int callcount);\n\n    int Tick();\n\n    int ReleaseNum(int num);\n\n    bool IsFull() { return NFPhoneAutoCode::GetUsedCount() >= NFPhoneAutoCode::GetItemCount();}\n    NFPhoneAutoCode *FindPhone(uint64_t phoneNum);\n    NFPhoneAutoCode *CreatePhone(uint64_t phoneNum);\n    int DeletePhone(uint64_t phoneNum);\nprivate:\n    int m_timerId;\nDECLARE_IDCREATE(NFPhoneAutoCodeMgr)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFPhoneAutoCodeMgr.h b/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFPhoneAutoCodeMgr.h
--- a/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFPhoneAutoCodeMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFLoginServer/NFLoginServerPlayerPlugin/NFPhoneAutoCodeMgr.h	(date 1688616543219)
@@ -13,7 +13,7 @@
 #include "NFComm/NFShmCore/NFShmOldHashMap.h"
 #include "NFComm/NFShmCore/NFShmString.h"
 #include "NFServer/NFCommHead/NFCommLogicHead.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 
 class NFPhoneAutoCode: public NFShmObj
 {
Index: Install/FishBusPlugin/ProxyServer.lua
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>require \"Common\"\n\n--ProxyServer 网管服务器， 负责与外部的客户端连接, 转发数据\n--ServerId = \"15.100.5.1\" 15是世界服务ID， 范围1-15\n-- 100是区服务ID， 范围1-65536\n-- 5是服务器类型ID， 必须跟serverType一样 范围1-255\n-- 1服务器索引，范围1-255\nProxyServer = {\n    ProxyServer_1 = {\n        ServerName = \"ProxyServer_1\",\n        ServerType = NF_ST_PROXY_SERVER,\n        ServerId = NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_PROXY_SERVER..\".1\",\t\t\t--对每一个服务器来说都是唯一的， 应用程序需要通过这个ServerId才能知道需要加载的配置是他\n        IdleSleepUS = 1000,\n        BusLength = NF_COMMON_BUS_LENGTH,     --20M共享内存\n        MaxConnectNum = NF_EXTERN_MAX_CONNECT,\n        NetThreadNum = 5,\n        WorkThreadNum = 1,\n        ParseType = 1, --0是内网协议，1是外网协议\n        ServerIp = NF_EXTER_SERVER_IP,\n        ServerPort = NF_INTER_SERVER_PORT+NF_ST_PROXY_SERVER*10+1,\n\t    ExternalServerIp = NF_EXTER_SERVER_IP,\n\t    ExternalServerPort = NF_EXTER_PROXY_SERVER_PORT,\n        MaxOnlinePlayerNum = NF_MAX_ONLINE_PLAYER_COUNT,\n        HeartBeatTimeout = NF_CLIENT_HEART_BEAT_TIME_OUT,\n        ClientKeepAliveTimeout = NF_CLIENT_KEEP_ALIVE_TIME_OUT,\n        HandleMsgNumPerFrame = NF_TRANS_SERVER_HANDLE_MSG_COUNT,\n        RouteConfig = {\n            --NamingHost = NF_NAMING_HOST,\n            --NamingPath = NF_NAMING_PATH,\n            MasterIp = NF_MASTER_IP,\n            MasterPort = NF_MASTER_PORT,\n        },\n        Security = true,\n        ParseType = 1,\n\t};\n\n    ProxyServer_4_2 = {\n        ServerName = \"ProxyServer_4_2\",\n        ServerType = NF_ST_PROXY_SERVER,\n        ServerId = NF_ST_WORLD_ID..\".\"..NF_ST_ZONE_ID..\".\"..NF_ST_PROXY_SERVER..\".2\",\t\t\t--对每一个服务器来说都是唯一的， 应用程序需要通过这个ServerId才能知道需要加载的配置是他\n        IdleSleepUS = 1000,\n        BusLength = NF_COMMON_BUS_LENGTH,     --20M共享内存\n        MaxConnectNum = NF_EXTERN_MAX_CONNECT,\n        NetThreadNum = 5,\n        WorkThreadNum = 1,\n        ParseType = 1, --0是内网协议，1是外网协议\n        ServerIp = NF_EXTER_SERVER_IP,\n        ServerPort = NF_INTER_SERVER_PORT+NF_ST_PROXY_SERVER*10+2,\n        ExternalServerIp = NF_EXTER_SERVER_IP,\n        ExternalServerPort = NF_EXTER_PROXY_SERVER_PORT+1,\n        MaxOnlinePlayerNum = NF_MAX_ONLINE_PLAYER_COUNT,\n        HeartBeatTimeout = NF_CLIENT_HEART_BEAT_TIME_OUT,\n        ClientKeepAliveTimeout = NF_CLIENT_KEEP_ALIVE_TIME_OUT,\n        RouteConfig = {\n            --NamingHost = NF_NAMING_HOST,\n            --NamingPath = NF_NAMING_PATH,\n            MasterIp = NF_MASTER_IP,\n            MasterPort = NF_MASTER_PORT,\n        },\n        Security = true,\n        ParseType = 1,\n    };\n};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Install/FishBusPlugin/ProxyServer.lua b/Install/FishBusPlugin/ProxyServer.lua
--- a/Install/FishBusPlugin/ProxyServer.lua	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/Install/FishBusPlugin/ProxyServer.lua	(date 1688534998554)
@@ -30,7 +30,7 @@
             MasterIp = NF_MASTER_IP,
             MasterPort = NF_MASTER_PORT,
         },
-        Security = true,
+        Security = false,
         ParseType = 1,
 	};
 
@@ -57,7 +57,7 @@
             MasterIp = NF_MASTER_IP,
             MasterPort = NF_MASTER_PORT,
         },
-        Security = true,
+        Security = false,
         ParseType = 1,
     };
 };
Index: game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFProxyClientModule.h\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFProxyClientModule\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFPackageConfig.h\"\n#include \"NFServerComm/NFServerCommon/NFIProxyPlayerModule.h\"\n#include \"NFComm/NFPluginModule/NFServerDefine.h\"\n#include \"NFComm/NFCore/NFMap.hpp\"\n#include \"NFProxySession.h\"\n#include \"NFProxyPlayerInfo.h\"\n#include <ComDefine.pb.h>\n\n#define NF_PROXY_CLIENT_TIMER_ID 1\n#define NF_PROXY_CLIENT_INTERVAL_TIME 100\n\nclass NFCProxyPlayerModule : public NFIProxyPlayerModule\n{\npublic:\n    explicit NFCProxyPlayerModule(NFIPluginManager *p);\n\n    virtual ~NFCProxyPlayerModule();\n\n    virtual bool Awake() override;\n\n    virtual bool Init() override;\n\n    virtual bool Execute() override;\n\n    virtual bool OnDynamicPlugin() override;\n\n    virtual int OnTimer(uint32_t nTimerID) override;\n\n    /**\n     * @brief 处理客户端消息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleClientMessage(uint64_t unLinkId, NFDataPackage &packet) override;\n\n    /**\n     * @brief 处理来自服务器的信息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleServerMessage(uint64_t unLinkId, NFDataPackage& packet) override;\npublic:\n    /*\n        处理客户端链接事件和未注册消息\n    */\n    int OnProxyClientSocketEvent(eMsgType nEvent, uint64_t unLinkId);\n\n    int OnHandleProxyClientOtherMessage(uint64_t unLinkId, NFDataPackage &packet);\n\n    int OnHandleClientDisconnect(uint64_t unLinkId);\n\n    /*\n     * 处理客户端连接超时\n     * */\n    int HandleProxyClientTick();\n    int HandlePlayerTick();\n\n\n\n    /**\n     * @brief 处理其他服务器发给客户的 信息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    int OnHandleOtherServerToClientMsg(uint64_t unLinkId, NFDataPackage &packet);\npublic:\n    int OnHandleRedirectMsg(uint64_t unLinkId, NFDataPackage &packet);\npublic:\n    /*\n     * 处理心跳包\n     */\n    int OnHandleClientHeartBeat(uint64_t unLinkId, NFDataPackage &packet);\npublic:\n    /**\n     * @brief 账号登陆\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    int OnHandleAccountLoginFromClient(uint64_t unLinkId, NFDataPackage &packet);\nprivate:\n    NFMapEx<uint64_t, NFProxySession> mClientLinkInfo; //unlink -- NFProxySession\n    NFMapEx<uint64_t, NFProxyPlayerInfo> mPlayerLinkInfo; //playerId -- NFProxyPlayerInfo\n    NFPackageConfig m_packetConfig;\n};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.h b/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.h
--- a/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/Fish/NFServerLogic/NFProxyServer/NFProxyPlayerPlugin/NFProxyPlayerModule.h	(date 1688557954772)
@@ -61,14 +61,15 @@
     int OnHandleProxyClientOtherMessage(uint64_t unLinkId, NFDataPackage &packet);
 
     int OnHandleClientDisconnect(uint64_t unLinkId);
-
+public:
     /*
      * 处理客户端连接超时
      * */
     int HandleProxyClientTick();
     int HandlePlayerTick();
 
-
+    int KickPlayer(uint64_t unLinkId);
+public:
 
     /**
      * @brief 处理其他服务器发给客户的 信息
Index: src/NFServer/NFMasterServer/NFMasterServerPlugin/NFMasterServerModule.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFCMasterServerModule.cpp\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFCMasterServerModule\n//\n// -------------------------------------------------------------------------\n\n#include <NFCommPlugin/NFNetPlugin/NFEmailSender.h>\n#include \"NFMasterServerModule.h\"\n\n#include \"NFComm/NFCore/NFMD5.h\"\n#include \"NFComm/NFCore/NFDateTime.hpp\"\n\n#include \"NFComm/NFPluginModule/NFIConfigModule.h\"\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include \"NFComm/NFCore/NFServerIDUtil.h\"\n#include \"NFComm/NFPluginModule/NFProtobufCommon.h\"\n#include \"NFComm/NFPluginModule/NFINamingModule.h\"\n#include \"NFComm/NFPluginModule/NFIMonitorModule.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"NFServerComm/NFServerCommon/NFIServerMessageModule.h\"\n#include \"NFServerComm/NFServerMessage/proto_svr_msg.pb.h\"\n#include \"NFServerComm/NFServerMessage/proto_svr_common.pb.h\"\n#include \"NFServerComm/NFServerCommon/NFServerBindRpcService.h\"\n\n\n#define NF_MASTER_TIMER_SAVE_SERVER_DATA 0\n#define NF_MASTER_TIMER_SAVE_SERVER_DATA_TIME 30000\n#define NF_MASTER_TIMER_CLEAR_SERVER_DATA 1\n#define NF_MASTER_TIMER_CLEAR_SERVER_DATA_TIME 600000\n\nNFCMasterServerModule::NFCMasterServerModule(NFIPluginManager* p):NFIMasterServerModule(p)\n{\n}\n\nNFCMasterServerModule::~NFCMasterServerModule()\n{\n}\n\nbool NFCMasterServerModule::Awake()\n{\n    FindModule<NFINamingModule>()->InitAppInfo(NF_ST_MASTER_SERVER);\n    FindModule<NFINamingModule>()->RegisterAppInfo(NF_ST_MASTER_SERVER);\n\n    /**\n     * @brief Master Rpc Service\n     */\n    FindModule<NFIMessageModule>()->AddRpcService<proto_ff::NF_SERVER_TO_SERVER_REGISTER>(NF_ST_MASTER_SERVER, this, &NFCMasterServerModule::OnServerRegisterRpcService);\n\n\n\tFindModule<NFIMessageModule>()->AddMessageCallBack(NF_ST_MASTER_SERVER, proto_ff::NF_SERVER_TO_SERVER_REGISTER, this, &NFCMasterServerModule::OnServerRegisterProcess);\n    FindModule<NFIMessageModule>()->AddMessageCallBack(NF_ST_MASTER_SERVER, proto_ff::NF_SERVER_TO_MASTER_SERVER_REPORT, this, &NFCMasterServerModule::OnServerReportProcess);\n    FindModule<NFIMessageModule>()->AddMessageCallBack(NF_ST_MASTER_SERVER, proto_ff::NF_STS_SEND_DUMP_INFO_NTF, this, &NFCMasterServerModule::OnServerDumpInfoProcess);\n    FindModule<NFIMessageModule>()->AddMessageCallBack(NF_ST_MASTER_SERVER, proto_ff::NF_GTM_KILL_ALL_SERVER_NTF, this, &NFCMasterServerModule::OnServerKillAllServerProcess);\n    //////////////////////http send to monitor//////////////////\n    FindModule<NFIMessageModule>()->AddHttpRequestHandler(NF_ST_MASTER_SERVER, \"reload\", NF_HTTP_REQ_GET, this, &NFCMasterServerModule::HandleReloadServer);\n    FindModule<NFIMessageModule>()->AddHttpRequestHandler(NF_ST_MASTER_SERVER, \"reloadall\", NF_HTTP_REQ_GET, this, &NFCMasterServerModule::HandleReloadAllServer);\n    FindModule<NFIMessageModule>()->AddHttpRequestHandler(NF_ST_MASTER_SERVER, \"restart\", NF_HTTP_REQ_GET, this, &NFCMasterServerModule::HandleRestartServer);\n    FindModule<NFIMessageModule>()->AddHttpRequestHandler(NF_ST_MASTER_SERVER, \"restartall\", NF_HTTP_REQ_GET, this, &NFCMasterServerModule::HandleRestartAllServer);\n    FindModule<NFIMessageModule>()->AddHttpRequestHandler(NF_ST_MASTER_SERVER, \"start\", NF_HTTP_REQ_GET, this, &NFCMasterServerModule::HandleStartServer);\n    FindModule<NFIMessageModule>()->AddHttpRequestHandler(NF_ST_MASTER_SERVER, \"startall\", NF_HTTP_REQ_GET, this, &NFCMasterServerModule::HandleStartAllServer);\n    FindModule<NFIMessageModule>()->AddHttpRequestHandler(NF_ST_MASTER_SERVER, \"stop\", NF_HTTP_REQ_GET, this, &NFCMasterServerModule::HandleStopServer);\n    FindModule<NFIMessageModule>()->AddHttpRequestHandler(NF_ST_MASTER_SERVER, \"stopall\", NF_HTTP_REQ_GET, this, &NFCMasterServerModule::HandleStopAllServer);\n    FindModule<NFIMessageModule>()->AddHttpRequestHandler(NF_ST_MASTER_SERVER, \"killall\", NF_HTTP_REQ_GET, this, &NFCMasterServerModule::HandleKillAllServer);\n    //////////////////////msg from monitor/////////////////\n    FindModule<NFIMessageModule>()->AddMessageCallBack(NF_ST_MASTER_SERVER, proto_ff::NF_MonitorTMaster_STOP_CMD_RSP, this, &NFCMasterServerModule::HandleStopSeverRsp);\n    FindModule<NFIMessageModule>()->AddMessageCallBack(NF_ST_MASTER_SERVER, proto_ff::NF_MonitorTMaster_RESTART_CMD_RSP, this, &NFCMasterServerModule::HandleRestartSeverRsp);\n    FindModule<NFIMessageModule>()->AddMessageCallBack(NF_ST_MASTER_SERVER, proto_ff::NF_MonitorTMaster_START_CMD_RSP, this, &NFCMasterServerModule::HandleStartSeverRsp);\n    FindModule<NFIMessageModule>()->AddMessageCallBack(NF_ST_MASTER_SERVER, proto_ff::NF_MonitorTMaster_RELOAD_CMD_RSP, this, &NFCMasterServerModule::HandleReloadSeverRsp);\n    FindModule<NFIMessageModule>()->AddMessageCallBack(NF_ST_MASTER_SERVER, proto_ff::NF_MonitorTMaster_STOP_ALL_CMD_RSP, this, &NFCMasterServerModule::HandleStopAllSeverRsp);\n    FindModule<NFIMessageModule>()->AddMessageCallBack(NF_ST_MASTER_SERVER, proto_ff::NF_MonitorTMaster_RESTART_ALL_CMD_RSP, this, &NFCMasterServerModule::HandleRestartAllSeverRsp);\n    FindModule<NFIMessageModule>()->AddMessageCallBack(NF_ST_MASTER_SERVER, proto_ff::NF_MonitorTMaster_START_ALL_CMD_RSP, this, &NFCMasterServerModule::HandleStartAllSeverRsp);\n    FindModule<NFIMessageModule>()->AddMessageCallBack(NF_ST_MASTER_SERVER, proto_ff::NF_MonitorTMaster_RELOAD_ALL_CMD_RSP, this, &NFCMasterServerModule::HandleReloadAllSeverRsp);\n\n\tNFServerConfig* pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_MASTER_SERVER);\n\tif (pConfig)\n\t{\n        uint64_t unlinkId = FindModule<NFIMessageModule>()->BindServer(NF_ST_MASTER_SERVER, pConfig->Url, pConfig->NetThreadNum, pConfig->MaxConnectNum, PACKET_PARSE_TYPE_INTERNAL);\n\t\tif (unlinkId > 0)\n\t\t{\n\t\t\tuint64_t masterServerLinkId = unlinkId;\n            FindModule<NFIMessageModule>()->SetServerLinkId(NF_ST_MASTER_SERVER, masterServerLinkId);\n\t\t\tFindModule<NFIMessageModule>()->AddEventCallBack(NF_ST_MASTER_SERVER, masterServerLinkId, this, &NFCMasterServerModule::OnProxySocketEvent);\n\t\t\tFindModule<NFIMessageModule>()->AddOtherCallBack(NF_ST_MASTER_SERVER, masterServerLinkId, this, &NFCMasterServerModule::OnHandleOtherMessage);\n\t\t\tNFLogInfo(NF_LOG_SYSTEMLOG, 0, \"master server listen success, serverId:{}, ip:{}, port:{}\", pConfig->ServerId, pConfig->ServerIp, pConfig->ServerPort);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNFLogInfo(NF_LOG_SYSTEMLOG, 0, \"master server listen failed!, serverId:{}, ip:{}, port:{}\", pConfig->ServerId, pConfig->ServerIp, pConfig->ServerPort);\n\t\t\treturn false;\n\t\t}\n\n        std::string httpUrl = NF_FORMAT(\"http://{}:{}\", pConfig->ServerIp, pConfig->HttpPort);\n        uint64_t ret = FindModule<NFIMessageModule>()->BindServer(NF_ST_MASTER_SERVER, httpUrl, pConfig->NetThreadNum, pConfig->MaxConnectNum, PACKET_PARSE_TYPE_INTERNAL);\n        if (ret == 0)\n        {\n            NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"master server listen http failed!, serverId:{}, ip:{}, httpport:{}\", pConfig->ServerId, pConfig->ServerIp, pConfig->HttpPort);\n            return false;\n        }\n\n        NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"master server listen http success, serverId:{}, ip:{}, port:{}\", pConfig->ServerId, pConfig->ServerIp, pConfig->HttpPort);\n\t}\n\telse\n\t{\n\t\tNFLogError(NF_LOG_SYSTEMLOG, 0, \"I Can't get the Master Server config!\");\n\t\treturn false;\n\t}\n\n    Subscribe(NF_ST_MASTER_SERVER, proto_ff::NF_EVENT_SERVER_DEAD_EVENT, proto_ff::NF_EVENT_SERVER_TYPE, 0, __FUNCTION__);\n    Subscribe(NF_ST_MASTER_SERVER, proto_ff::NF_EVENT_SERVER_REG_EVENT, proto_ff::NF_EVENT_SERVER_TYPE, 0, __FUNCTION__);\n\treturn true;\n}\n\nint NFCMasterServerModule::OnServerRegisterRpcService(uint64_t unLinkId, proto_ff::ServerInfoReportList& reqeust, proto_ff::ServerInfoReportListRespne& respone)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n\n    for (int i = 0; i < reqeust.server_list_size(); ++i)\n    {\n        const proto_ff::ServerInfoReport& xData = reqeust.server_list(i);\n        NF_SHARE_PTR<NFServerData> pServerData = FindModule<NFIMessageModule>()->GetServerByServerId(NF_ST_MASTER_SERVER, xData.bus_id());\n        if (!pServerData)\n        {\n            pServerData = FindModule<NFIMessageModule>()->CreateServerByServerId(NF_ST_MASTER_SERVER, xData.bus_id(), (NF_SERVER_TYPES)xData.server_type(), xData);\n        }\n        else\n        {\n            if (pServerData->mServerInfo.server_type() != xData.server_type())\n            {\n                //该服务器ID已经注册过, 又被别的服务器使用了\n                respone.set_ret_code(-1);\n                NFLogError(NF_LOG_SYSTEMLOG, 0, \"server:{} connect some wrong, old server:{}\", xData.server_name(), pServerData->mServerInfo.server_name());\n                return -1;\n            }\n            else if (pServerData->mUnlinkId > 0 && pServerData->mUnlinkId != unLinkId)\n            {\n                NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"server:{} new link, old link will close......\", pServerData->mServerInfo.server_name());\n                //服务器连接还在没有崩溃\n                FindModule<NFIMessageModule>()->CloseLinkId(pServerData->mUnlinkId);\n            }\n        }\n\n        pServerData->mUnlinkId = unLinkId;\n        pServerData->mServerInfo = xData;\n        FindModule<NFIMessageModule>()->CreateLinkToServer(NF_ST_MASTER_SERVER, xData.bus_id(), pServerData->mUnlinkId);\n        if (xData.server_state() == proto_ff::EST_INIT)\n        {\n            SynOtherServerToServer(pServerData);\n        }\n        else {\n            SynServerToOthers(pServerData);\n            SynOtherServerToServer(pServerData);\n        }\n        NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"{} Server Register Master Server Success,  busId:{}, ip:{}, port:{}\", pServerData->mServerInfo.server_name(), pServerData->mServerInfo.bus_id(), pServerData->mServerInfo.server_ip(), pServerData->mServerInfo.server_port());\n    }\n\n    respone.set_ret_code(0);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMasterServerModule::OnServerRegisterProcess(uint64_t unLinkId, NFDataPackage& packet)\n{\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n\tproto_ff::ServerInfoReportList xMsg;\n\tCLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n\tfor (int i = 0; i < xMsg.server_list_size(); ++i)\n\t{\n\t\tconst proto_ff::ServerInfoReport& xData = xMsg.server_list(i);\n\t\tNF_SHARE_PTR<NFServerData> pServerData = FindModule<NFIMessageModule>()->GetServerByServerId(NF_ST_MASTER_SERVER, xData.bus_id());\n\t\tif (!pServerData)\n\t\t{\n\t\t\tpServerData = FindModule<NFIMessageModule>()->CreateServerByServerId(NF_ST_MASTER_SERVER, xData.bus_id(), (NF_SERVER_TYPES)xData.server_type(), xData);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (pServerData->mServerInfo.server_type() != xData.server_type() || (pServerData->mUnlinkId > 0 && pServerData->mUnlinkId != unLinkId))\n\t\t\t{\n\t\t\t\t//该服务器ID已经注册过, 又被别的服务器使用了\n\t\t\t\t//服务器连接还在没有崩溃\n\t\t\t\tNFLogError(NF_LOG_SYSTEMLOG, 0, \"server:{} connect some wrong, old server:{}\", xData.server_name(), pServerData->mServerInfo.server_name());\n\t\t\t\tFindModule<NFIMessageModule>()->CloseLinkId(pServerData->mUnlinkId);\n\t\t\t}\n\t\t}\n\n\t\tpServerData->mUnlinkId = unLinkId;\n\t\tpServerData->mServerInfo = xData;\n        FindModule<NFIMessageModule>()->CreateLinkToServer(NF_ST_MASTER_SERVER, xData.bus_id(), pServerData->mUnlinkId);\n        if (xData.server_state() == proto_ff::EST_INIT)\n        {\n#if NF_PLATFORM == NF_PLATFORM_WIN\n            SynOtherServerToServer(pServerData);\n#else\n            NFServerConfig* pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_MASTER_SERVER);\n            if (pConfig && pConfig->RouteConfig.NamingHost.empty())\n            {\n                SynOtherServerToServer(pServerData);\n            }\n#endif\n        }\n        else {\n#if NF_PLATFORM == NF_PLATFORM_WIN\n            SynServerToOthers(pServerData);\n            SynOtherServerToServer(pServerData);\n#else\n            NFServerConfig* pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_MASTER_SERVER);\n            if (pConfig && pConfig->RouteConfig.NamingHost.empty())\n            {\n                SynServerToOthers(pServerData);\n                SynOtherServerToServer(pServerData);\n            }\n#endif\n            NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"{} Server Register Master Server Success,  busId:{}, ip:{}, port:{}\", pServerData->mServerInfo.server_name(), pServerData->mServerInfo.bus_id(), pServerData->mServerInfo.server_ip(), pServerData->mServerInfo.server_port());\n        }\n\t}\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n\treturn 0;\n}\n\nint NFCMasterServerModule::OnServerReportProcess(uint64_t unLinkId, NFDataPackage& packet)\n{\n    proto_ff::ServerInfoReportList xMsg;\n    CLIENT_MSG_PROCESS_NO_PRINTF(packet, xMsg);\n\n    for (int i = 0; i < xMsg.server_list_size(); ++i) {\n        const proto_ff::ServerInfoReport &xData = xMsg.server_list(i);\n        NF_SHARE_PTR<NFServerData> pServerData = FindModule<NFIMessageModule>()->GetServerByServerId(NF_ST_MASTER_SERVER, xData.bus_id());\n        if (pServerData)\n        {\n            pServerData->mServerInfo.set_system_info(xData.system_info());\n            pServerData->mServerInfo.set_total_mem(xData.total_mem());\n            pServerData->mServerInfo.set_free_mem(xData.free_mem());\n            pServerData->mServerInfo.set_used_mem(xData.used_mem());\n\n            pServerData->mServerInfo.set_proc_cpu(xData.proc_cpu());\n            pServerData->mServerInfo.set_proc_mem(xData.proc_mem());\n            pServerData->mServerInfo.set_proc_thread(xData.proc_thread());\n            pServerData->mServerInfo.set_proc_name(xData.proc_name());\n            pServerData->mServerInfo.set_proc_cwd(xData.proc_cwd());\n            pServerData->mServerInfo.set_proc_pid(xData.proc_pid());\n            pServerData->mServerInfo.set_server_cur_online(xData.server_cur_online());\n        }\n    }\n    return 0;\n}\n\nint NFCMasterServerModule::OnServerDumpInfoProcess(uint64_t unLinkId, NFDataPackage& packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::Proto_ServerDumpInfoNtf xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    NFServerConfig* pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_MASTER_SERVER);\n    CHECK_NULL(pConfig);\n\n    NF_SHARE_PTR<NFServerData> pServerData = FindModule<NFIMessageModule>()->GetServerByServerId(NF_ST_MASTER_SERVER, xMsg.bus_id());\n    CHECK_EXPR(pServerData, -1, \"can't find the serverID:{}..............................\\n{}\",xMsg.bus_id(), xMsg.dump_info());\n    pServerData->mServerInfo.set_server_state(proto_ff::EST_CRASH);\n    SynServerToOthers(pServerData);\n\n    NFLogError(NF_LOG_SYSTEMLOG, 0, \"ServerName:{} serverID:{} Dump...............................\\n{}\", pServerData->mServerInfo.server_name(),\n               pServerData->mServerInfo.server_id(), xMsg.dump_info());\n\n    FindModule<NFIMessageModule>()->SendEmail(NF_ST_MASTER_SERVER, \"Server Dump Info\", pServerData->mServerInfo.server_name() + \" Crash Message Report\", xMsg.dump_info());\n\n    FindModule<NFIMessageModule>()->SendWxWork(NF_ST_MASTER_SERVER, \"Server:\" + pServerData->mServerInfo.server_name() + \" Dump Info:\\n\" + xMsg.dump_info());\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMasterServerModule::OnServerKillAllServerProcess(uint64_t unLinkId, NFDataPackage& packet)\n{\n    proto_ff::Proto_KillAllServerNtf xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n    std::vector<NF_SHARE_PTR<NFServerData>> vec = FindModule<NFIMessageModule>()->GetAllServer(NF_ST_MASTER_SERVER);\n\n    for(size_t i = 0; i < vec.size(); i++)\n    {\n        NF_SHARE_PTR<NFServerData> pCurServer = vec[i];\n        if (pCurServer)\n        {\n            FindModule<NFIMessageModule>()->Send(pCurServer->mUnlinkId, NF_MODULE_SERVER, proto_ff::NF_STS_KILL_ALL_SERVER_NTF, xMsg);\n        }\n    }\n    return 0;\n}\n\nint NFCMasterServerModule::OnProxySocketEvent(eMsgType nEvent, uint64_t unLinkId)\n{\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n\tstd::string ip = FindModule<NFIMessageModule>()->GetLinkIp(unLinkId);\n\tif (nEvent == eMsgType_CONNECTED)\n\t{\n\t\tNFLogInfo(NF_LOG_SYSTEMLOG, 0, \"ip:{} connect master server success\", ip);\n\t}\n\telse if (nEvent == eMsgType_DISCONNECTED)\n\t{\n\t\tNFLogInfo(NF_LOG_SYSTEMLOG, 0, \"ip:{} disconnect master server success\", ip);\n\t\tOnClientDisconnect(unLinkId);\n\t}\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n\treturn 0;\n}\n\nint NFCMasterServerModule::OnHandleOtherMessage(uint64_t unLinkId, NFDataPackage& packet)\n{\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n\tstd::string ip = FindModule<NFIMessageModule>()->GetLinkIp(unLinkId);\n\tNFLogWarning(NF_LOG_SYSTEMLOG, 0, \"other message not handled:packet:{},ip:{}\", packet.ToString(), ip);\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n\treturn 0;\n}\n\nbool NFCMasterServerModule::Execute()\n{\n    ServerReport();\n\treturn true;\n}\n\nbool NFCMasterServerModule::OnDynamicPlugin()\n{\n\tFindModule<NFIMessageModule>()->CloseAllLink(NF_ST_MASTER_SERVER);\n\treturn true;\n}\n\nint NFCMasterServerModule::OnExecute(uint32_t serverType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message* pMessage)\n{\n    return 0;\n}\n\nint NFCMasterServerModule::OnTimer(uint32_t nTimerID)\n{\n    if (nTimerID == 10000)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"kill the exe..................\");\n        NFSLEEP(1000);\n        exit(0);\n    }\n    else if (nTimerID == 10001)\n    {\n        ConnectGlobalServer();\n    }\n    return 0;\n}\n\n\nint NFCMasterServerModule::OnClientDisconnect(uint64_t unLinkId)\n{\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n\tNF_SHARE_PTR<NFServerData> pServerData = FindModule<NFIMessageModule>()->GetServerByUnlinkId(NF_ST_MASTER_SERVER, unLinkId);\n\tif (pServerData)\n\t{\n\t\tNFLogInfo(NF_LOG_SYSTEMLOG, 0, \"Server Disconnect Master Server, serverName:{}, busId:{}, ip:{}, port:{}\", pServerData->mServerInfo.server_name(), pServerData->mServerInfo.bus_id(), pServerData->mServerInfo.server_ip(), pServerData->mServerInfo.server_port());\n\t\tpServerData->mUnlinkId = 0;\n        pServerData->mServerInfo.set_server_state(proto_ff::EST_CRASH);\n\t}\n    FindModule<NFIMessageModule>()->DelServerLink(NF_ST_MASTER_SERVER, unLinkId);\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n\treturn 0;\n}\n\nint NFCMasterServerModule::SynOtherServerToServer(NF_SHARE_PTR<NFServerData> pServerData)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::ServerInfoReportList xData;\n\n    std::vector<NF_SHARE_PTR<NFServerData>> vec = FindModule<NFIMessageModule>()->GetAllServer(NF_ST_MASTER_SERVER);\n\n    for(size_t i = 0; i < vec.size(); i++)\n    {\n        NF_SHARE_PTR<NFServerData> pCurServer = vec[i];\n        if (pCurServer->mServerInfo.bus_id() != pServerData->mServerInfo.bus_id())\n        {\n            if (pCurServer->mServerInfo.server_state() > proto_ff::EST_INIT)\n            {\n                if (NFServerIDUtil::GetWorldID(pCurServer->mServerInfo.bus_id()) == NFServerIDUtil::GetWorldID(pServerData->mServerInfo.bus_id()))\n                {\n                    if (NFServerIDUtil::GetZoneID(pCurServer->mServerInfo.bus_id()) == NFServerIDUtil::GetZoneID(pServerData->mServerInfo.bus_id()))\n                    {\n                        proto_ff::ServerInfoReport* pData = xData.add_server_list();\n                        *pData = pCurServer->mServerInfo;\n                    }\n                }\n            }\n        }\n    }\n\n    FindModule<NFIMessageModule>()->Send(pServerData->mUnlinkId, proto_ff::NF_MASTER_SERVER_SEND_OTHERS_TO_SERVER, xData, 0);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMasterServerModule::SynServerToOthers(NF_SHARE_PTR<NFServerData> pServerData)\n{\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n\tproto_ff::ServerInfoReportList xSelfData;\n\tproto_ff::ServerInfoReport* pSelfData = xSelfData.add_server_list();\n\t*pSelfData = pServerData->mServerInfo;\n\n\tstd::vector<NF_SHARE_PTR<NFServerData>> vec = FindModule<NFIMessageModule>()->GetAllServer(NF_ST_MASTER_SERVER);\n\n\tfor(size_t i = 0; i < vec.size(); i++)\n    {\n        NF_SHARE_PTR<NFServerData> pCurServer = vec[i];\n        if (pServerData->mServerInfo.bus_id() != pCurServer->mServerInfo.bus_id())\n        {\n            if (NFServerIDUtil::GetWorldID(pServerData->mServerInfo.bus_id()) == NFServerIDUtil::GetWorldID(pCurServer->mServerInfo.bus_id()))\n            {\n                FindModule<NFIMessageModule>()->Send(pCurServer->mUnlinkId, proto_ff::NF_MASTER_SERVER_SEND_OTHERS_TO_SERVER, xSelfData, 0);\n            }\n        }\n    }\n\n\tNFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n\treturn 0;\n}\n\nbool NFCMasterServerModule::HandleReloadServer(uint32_t, const NFIHttpHandle &req)\n{\n    std::string uri = req.GetOriginalUri();\n    std::string remote = req.GetRemoteHost();\n    NFLogInfo(NF_LOG_SYSTEMLOG, 0, \" remote:{} send url:{}\", remote, uri);\n\n    std::string serverName = req.GetQuery(\"Server\");\n    std::string serverID = req.GetQuery(\"ID\");\n\n    if (serverID.empty() || serverName.empty())\n    {\n        return false;\n    }\n\n    std::vector<NF_SHARE_PTR<NFServerData>> vecServer = FindModule<NFIMessageModule>()->GetAllServer(NF_ST_MASTER_SERVER, NF_ST_MONITOR_SERVER);\n    for(int i = 0; i < (int)vecServer.size(); i++)\n    {\n        proto_ff::Proto_MasterTMonitorReloadReq reqMsg;\n        reqMsg.set_server_name(serverName);\n        reqMsg.set_server_id(serverID);\n        FindModule<NFIMessageModule>()->Send(vecServer[i]->mUnlinkId, proto_ff::NF_MasterTMonitor_RELOAD_CMD_REQ, reqMsg, req.GetRequestId());\n    }\n    return true;\n}\n\nbool NFCMasterServerModule::HandleReloadAllServer(uint32_t, const NFIHttpHandle &req)\n{\n    std::string uri = req.GetOriginalUri();\n    std::string remote = req.GetRemoteHost();\n    NFLogInfo(NF_LOG_SYSTEMLOG, 0, \" remote:{} send url:{}\", remote, uri);\n\n    std::vector<NF_SHARE_PTR<NFServerData>> vecServer = FindModule<NFIMessageModule>()->GetAllServer(NF_ST_MASTER_SERVER, NF_ST_MONITOR_SERVER);\n    for(int i = 0; i < (int)vecServer.size(); i++)\n    {\n        proto_ff::Proto_MasterTMonitorReloadReq reqMsg;\n        FindModule<NFIMessageModule>()->Send(vecServer[i]->mUnlinkId, proto_ff::NF_MasterTMonitor_RELOAD_ALL_CMD_REQ, reqMsg, req.GetRequestId());\n    }\n    return true;\n}\n\nbool NFCMasterServerModule::HandleRestartServer(uint32_t, const NFIHttpHandle &req)\n{\n    std::string uri = req.GetOriginalUri();\n    std::string remote = req.GetRemoteHost();\n    NFLogInfo(NF_LOG_SYSTEMLOG, 0, \" remote:{} send url:{}\", remote, uri);\n\n    std::string serverName = req.GetQuery(\"Server\");\n    std::string serverID = req.GetQuery(\"ID\");\n\n    if (serverID.empty() || serverName.empty())\n    {\n        return false;\n    }\n\n    std::vector<NF_SHARE_PTR<NFServerData>> vecServer = FindModule<NFIMessageModule>()->GetAllServer(NF_ST_MASTER_SERVER, NF_ST_MONITOR_SERVER);\n    for(int i = 0; i < (int)vecServer.size(); i++)\n    {\n        proto_ff::Proto_MasterTMonitorRestartReq reqMsg;\n        reqMsg.set_server_name(serverName);\n        reqMsg.set_server_id(serverID);\n        FindModule<NFIMessageModule>()->Send(vecServer[i]->mUnlinkId, proto_ff::NF_MasterTMonitor_RESTART_CMD_REQ, reqMsg, req.GetRequestId());\n    }\n\n    return true;\n}\n\nbool NFCMasterServerModule::HandleRestartAllServer(uint32_t, const NFIHttpHandle &req)\n{\n    std::string uri = req.GetOriginalUri();\n    std::string remote = req.GetRemoteHost();\n    NFLogInfo(NF_LOG_SYSTEMLOG, 0, \" remote:{} send url:{}\", remote, uri);\n\n    std::vector<NF_SHARE_PTR<NFServerData>> vecServer = FindModule<NFIMessageModule>()->GetAllServer(NF_ST_MASTER_SERVER, NF_ST_MONITOR_SERVER);\n    for(int i = 0; i < (int)vecServer.size(); i++)\n    {\n        proto_ff::Proto_MasterTMonitorRestartReq reqMsg;\n        FindModule<NFIMessageModule>()->Send(vecServer[i]->mUnlinkId, proto_ff::NF_MasterTMonitor_RESTART_ALL_CMD_REQ, reqMsg, req.GetRequestId());\n    }\n\n    return true;\n}\n\nbool NFCMasterServerModule::HandleStartServer(uint32_t, const NFIHttpHandle &req)\n{\n    std::string uri = req.GetOriginalUri();\n    std::string remote = req.GetRemoteHost();\n    NFLogInfo(NF_LOG_SYSTEMLOG, 0, \" remote:{} send url:{}\", remote, uri);\n\n    std::string serverName = req.GetQuery(\"Server\");\n    std::string serverID = req.GetQuery(\"ID\");\n\n    if (serverID.empty() || serverName.empty())\n    {\n        return false;\n    }\n\n    std::vector<NF_SHARE_PTR<NFServerData>> vecServer = FindModule<NFIMessageModule>()->GetAllServer(NF_ST_MASTER_SERVER, NF_ST_MONITOR_SERVER);\n    for(int i = 0; i < (int)vecServer.size(); i++)\n    {\n        proto_ff::Proto_MasterTMonitorStartReq reqMsg;\n        reqMsg.set_server_name(serverName);\n        reqMsg.set_server_id(serverID);\n        FindModule<NFIMessageModule>()->Send(vecServer[i]->mUnlinkId, proto_ff::NF_MasterTMonitor_START_CMD_REQ, reqMsg, req.GetRequestId());\n    }\n    return true;\n}\n\nbool NFCMasterServerModule::HandleStartAllServer(uint32_t, const NFIHttpHandle &req)\n{\n    std::string uri = req.GetOriginalUri();\n    std::string remote = req.GetRemoteHost();\n    NFLogInfo(NF_LOG_SYSTEMLOG, 0, \" remote:{} send url:{}\", remote, uri);\n\n    std::vector<NF_SHARE_PTR<NFServerData>> vecServer = FindModule<NFIMessageModule>()->GetAllServer(NF_ST_MASTER_SERVER, NF_ST_MONITOR_SERVER);\n    for(int i = 0; i < (int)vecServer.size(); i++)\n    {\n        proto_ff::Proto_MasterTMonitorStartReq reqMsg;\n        FindModule<NFIMessageModule>()->Send(vecServer[i]->mUnlinkId, proto_ff::NF_MasterTMonitor_START_ALL_CMD_REQ, reqMsg, req.GetRequestId());\n    }\n    return true;\n}\n\nbool NFCMasterServerModule::HandleStopServer(uint32_t, const NFIHttpHandle &req)\n{\n    std::string uri = req.GetOriginalUri();\n    std::string remote = req.GetRemoteHost();\n    NFLogInfo(NF_LOG_SYSTEMLOG, 0, \" remote:{} send url:{}\", remote, uri);\n\n    std::string serverName = req.GetQuery(\"Server\");\n    std::string serverID = req.GetQuery(\"ID\");\n\n    if (serverID.empty() || serverName.empty())\n    {\n        return false;\n    }\n\n    std::vector<NF_SHARE_PTR<NFServerData>> vecServer = FindModule<NFIMessageModule>()->GetAllServer(NF_ST_MASTER_SERVER, NF_ST_MONITOR_SERVER);\n    for(int i = 0; i < (int)vecServer.size(); i++)\n    {\n        proto_ff::Proto_MasterTMonitorStopReq reqMsg;\n        reqMsg.set_server_name(serverName);\n        reqMsg.set_server_id(serverID);\n        FindModule<NFIMessageModule>()->Send(vecServer[i]->mUnlinkId, proto_ff::NF_MasterTMonitor_STOP_CMD_REQ, reqMsg, req.GetRequestId());\n    }\n    return true;\n}\n\nbool NFCMasterServerModule::HandleStopAllServer(uint32_t, const NFIHttpHandle &req)\n{\n    std::string uri = req.GetOriginalUri();\n    std::string remote = req.GetRemoteHost();\n    NFLogInfo(NF_LOG_SYSTEMLOG, 0, \" remote:{} send url:{}\", remote, uri);\n\n    std::vector<NF_SHARE_PTR<NFServerData>> vecServer = FindModule<NFIMessageModule>()->GetAllServer(NF_ST_MASTER_SERVER, NF_ST_MONITOR_SERVER);\n    for(int i = 0; i < (int)vecServer.size(); i++)\n    {\n        proto_ff::Proto_MasterTMonitorStopReq reqMsg;\n        FindModule<NFIMessageModule>()->Send(vecServer[i]->mUnlinkId, proto_ff::NF_MasterTMonitor_STOP_ALL_CMD_REQ, reqMsg, req.GetRequestId());\n    }\n    return true;\n}\n\nbool NFCMasterServerModule::HandleKillAllServer(uint32_t, const NFIHttpHandle &req)\n{\n    proto_ff::Proto_KillAllServerNtf xMsg;\n    std::vector<NF_SHARE_PTR<NFServerData>> vec = FindModule<NFIMessageModule>()->GetAllServer(NF_ST_MASTER_SERVER);\n\n    for(size_t i = 0; i < vec.size(); i++)\n    {\n        NF_SHARE_PTR<NFServerData> pCurServer = vec[i];\n        if (pCurServer)\n        {\n            FindModule<NFIMessageModule>()->Send(pCurServer->mUnlinkId, proto_ff::NF_STS_KILL_ALL_SERVER_NTF, xMsg, 0);\n        }\n    }\n\n    return true;\n}\n\nint NFCMasterServerModule::HandleStopSeverRsp(uint64_t unLinkId, NFDataPackage& packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::Proto_MonitorTMasterStopRsp xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    uint64_t httpReqId = packet.nParam1;\n    std::string json;\n    NFProtobufCommon::ProtoMessageToJson(xMsg, &json);\n    FindModule<NFIMessageModule>()->ResponseHttpMsg(NF_ST_MASTER_SERVER, httpReqId, json);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMasterServerModule::HandleStopAllSeverRsp(uint64_t unLinkId, NFDataPackage& packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::Proto_MonitorTMasterStopRsp xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    uint64_t httpReqId = packet.nParam1;\n    std::string json;\n    NFProtobufCommon::ProtoMessageToJson(xMsg, &json);\n    FindModule<NFIMessageModule>()->ResponseHttpMsg(NF_ST_MASTER_SERVER, httpReqId, json);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMasterServerModule::HandleStartSeverRsp(uint64_t unLinkId, NFDataPackage& packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::Proto_MonitorTMasterStartRsp xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    uint64_t httpReqId = packet.nParam1;\n    std::string json;\n    NFProtobufCommon::ProtoMessageToJson(xMsg, &json);\n    FindModule<NFIMessageModule>()->ResponseHttpMsg(NF_ST_MASTER_SERVER, httpReqId, json);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMasterServerModule::HandleStartAllSeverRsp(uint64_t unLinkId, NFDataPackage& packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::Proto_MonitorTMasterStartRsp xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    uint64_t httpReqId = packet.nParam1;\n    std::string json;\n    NFProtobufCommon::ProtoMessageToJson(xMsg, &json);\n    FindModule<NFIMessageModule>()->ResponseHttpMsg(NF_ST_MASTER_SERVER, httpReqId, json);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMasterServerModule::HandleRestartSeverRsp(uint64_t unLinkId, NFDataPackage& packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::Proto_MonitorTMasterRestartRsp xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    uint64_t httpReqId = packet.nParam1;\n    std::string json;\n    NFProtobufCommon::ProtoMessageToJson(xMsg, &json);\n    FindModule<NFIMessageModule>()->ResponseHttpMsg(NF_ST_MASTER_SERVER, httpReqId, json);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMasterServerModule::HandleRestartAllSeverRsp(uint64_t unLinkId, NFDataPackage& packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::Proto_MonitorTMasterRestartRsp xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    uint64_t httpReqId = packet.nParam1;\n    std::string json;\n    NFProtobufCommon::ProtoMessageToJson(xMsg, &json);\n    FindModule<NFIMessageModule>()->ResponseHttpMsg(NF_ST_MASTER_SERVER, httpReqId, json);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMasterServerModule::HandleReloadSeverRsp(uint64_t unLinkId, NFDataPackage& packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::Proto_MonitorTMasterReloadRsp xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    uint64_t httpReqId = packet.nParam1;\n    std::string json;\n    NFProtobufCommon::ProtoMessageToJson(xMsg, &json);\n    FindModule<NFIMessageModule>()->ResponseHttpMsg(NF_ST_MASTER_SERVER, httpReqId, json);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMasterServerModule::HandleReloadAllSeverRsp(uint64_t unLinkId, NFDataPackage& packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    proto_ff::Proto_MonitorTMasterReloadRsp xMsg;\n    CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n    uint64_t httpReqId = packet.nParam1;\n    std::string json;\n    NFProtobufCommon::ProtoMessageToJson(xMsg, &json);\n    FindModule<NFIMessageModule>()->ResponseHttpMsg(NF_ST_MASTER_SERVER, httpReqId, json);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nbool NFCMasterServerModule::Init() {\n    NFServerConfig* pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_MASTER_SERVER);\n    CHECK_EXPR(pConfig, false, \"\");\n\n    FindModule<NFIMessageModule>()->SendWxWork(NF_ST_MASTER_SERVER, \"Server:\" + pConfig->ServerName + \" Start Info:\\n\" + pConfig->ServerIp);\n    return true;\n}\n\nint NFCMasterServerModule::ConnectGlobalServer() {\n    NFServerConfig* pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_MASTER_SERVER);\n    if (pConfig)\n    {\n        auto pMasterServerData = FindModule<NFIMessageModule>()->GetMasterData(NF_ST_MASTER_SERVER);\n        if (pMasterServerData->mUnlinkId <= 0)\n        {\n            pMasterServerData->mUnlinkId = FindModule<NFIMessageModule>()->ConnectServer(NF_ST_MASTER_SERVER, \"tcp://www.shmnframe.com:6100\", PACKET_PARSE_TYPE_INTERNAL);\n            FindModule<NFIMessageModule>()->AddEventCallBack(NF_ST_MASTER_SERVER, pMasterServerData->mUnlinkId, this, &NFCMasterServerModule::OnGlobalSocketEvent);\n            FindModule<NFIMessageModule>()->AddOtherCallBack(NF_ST_MASTER_SERVER, pMasterServerData->mUnlinkId, this, &NFCMasterServerModule::OnHandleGlobalOtherMessage);\n        }\n    }\n    else\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"I Can't get the global Server config!\");\n        return -1;\n    }\n\n    return 0;\n}\n\n/*\n\t处理Master服务器链接事件\n*/\nint NFCMasterServerModule::OnGlobalSocketEvent(eMsgType nEvent, uint64_t unLinkId)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n\n    if (nEvent == eMsgType_CONNECTED)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"connect global server..........\");\n        RegisterGlobalServer();\n    }\n    else if (nEvent == eMsgType_DISCONNECTED)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"disconnect global server..........\");\n    }\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMasterServerModule::RegisterGlobalServer()\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    NFServerConfig* pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_MASTER_SERVER);\n    if (pConfig)\n    {\n        proto_ff::ServerInfoReportList xMsg;\n        proto_ff::ServerInfoReport* pData = xMsg.add_server_list();\n        pData->set_bus_id(pConfig->BusId);\n        pData->set_server_id(pConfig->ServerId);\n        pData->set_server_type(pConfig->ServerType);\n        pData->set_server_name(pConfig->ServerName);\n\n        pData->set_bus_length(pConfig->BusLength);\n        pData->set_link_mode(pConfig->LinkMode);\n        pData->set_url(pConfig->Url);\n        pData->set_server_ip(pConfig->ServerIp);\n        pData->set_server_port(pConfig->ServerPort);\n        pData->set_route_svr(pConfig->RouteConfig.RouteAgent);\n        pData->set_server_state(proto_ff::EST_NARMAL);\n        pData->set_machine_addr(m_pObjPluginManager->GetMachineAddrMD5());\n\n        FindModule<NFIServerMessageModule>()->SendMsgToMasterServer(NF_ST_MASTER_SERVER, proto_ff::NF_SERVER_TO_SERVER_REGISTER, xMsg);\n    }\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\n/*\n\t处理Master服务器未注册协议\n*/\nint NFCMasterServerModule::OnHandleGlobalOtherMessage(uint64_t unLinkId, NFDataPackage& packet)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string ip = FindModule<NFIMessageModule>()->GetLinkIp(unLinkId);\n    NFLogWarning(NF_LOG_SYSTEMLOG, 0, \"global server other message not handled:packet:{},ip:{}\", packet.ToString(), ip);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMasterServerModule::ServerReport()\n{\n    if (m_pObjPluginManager->IsLoadAllServer())\n    {\n        return 0;\n    }\n\n    static uint64_t mLastReportTime = m_pObjPluginManager->GetNowTime();\n    if (mLastReportTime + 100000 > m_pObjPluginManager->GetNowTime())\n    {\n        return 0;\n    }\n\n    mLastReportTime = m_pObjPluginManager->GetNowTime();\n\n    NFServerConfig* pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_MASTER_SERVER);\n    if (pConfig)\n    {\n        proto_ff::ServerInfoReportList xMsg;\n        proto_ff::ServerInfoReport* pData = xMsg.add_server_list();\n        pData->set_bus_id(pConfig->BusId);\n        pData->set_server_id(pConfig->ServerId);\n        pData->set_server_type(pConfig->ServerType);\n        pData->set_server_name(pConfig->ServerName);\n\n        pData->set_bus_length(pConfig->BusLength);\n        pData->set_link_mode(pConfig->LinkMode);\n        pData->set_url(pConfig->Url);\n        pData->set_server_ip(pConfig->ServerIp);\n        pData->set_server_port(pConfig->ServerPort);\n        pData->set_server_state(proto_ff::EST_NARMAL);\n        pData->set_route_svr(pConfig->RouteConfig.RouteAgent);\n        NFIMonitorModule* pMonitorModule = m_pObjPluginManager->FindModule<NFIMonitorModule>();\n        if (pMonitorModule)\n        {\n            const NFSystemInfo& systemInfo = pMonitorModule->GetSystemInfo();\n\n            pData->set_system_info(systemInfo.GetOsInfo().mOsDescription);\n            pData->set_total_mem(systemInfo.GetMemInfo().mTotalMem);\n            pData->set_free_mem(systemInfo.GetMemInfo().mFreeMem);\n            pData->set_used_mem(systemInfo.GetMemInfo().mUsedMem);\n\n            pData->set_proc_cpu(systemInfo.GetProcessInfo().mCpuUsed);\n            pData->set_proc_mem(systemInfo.GetProcessInfo().mMemUsed);\n            pData->set_proc_thread(systemInfo.GetProcessInfo().mThreads);\n            pData->set_proc_name(systemInfo.GetProcessInfo().mName);\n            pData->set_proc_cwd(systemInfo.GetProcessInfo().mCwd);\n            pData->set_proc_pid(systemInfo.GetProcessInfo().mPid);\n            pData->set_server_cur_online(systemInfo.GetUserCount());\n            pData->set_machine_addr(m_pObjPluginManager->GetMachineAddrMD5());\n        }\n\n        if (pData->proc_cpu() > 0 && pData->proc_mem() > 0)\n        {\n            FindModule<NFIServerMessageModule>()->SendMsgToMasterServer(NF_ST_MASTER_SERVER, proto_ff::NF_SERVER_TO_MASTER_SERVER_REPORT, xMsg);\n        }\n    }\n    return 0;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/NFServer/NFMasterServer/NFMasterServerPlugin/NFMasterServerModule.cpp b/src/NFServer/NFMasterServer/NFMasterServerPlugin/NFMasterServerModule.cpp
--- a/src/NFServer/NFMasterServer/NFMasterServerPlugin/NFMasterServerModule.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/src/NFServer/NFMasterServer/NFMasterServerPlugin/NFMasterServerModule.cpp	(date 1688612283733)
@@ -154,6 +154,12 @@
             SynServerToOthers(pServerData);
             SynOtherServerToServer(pServerData);
         }
+
+        if (xData.server_type() == NF_ST_PROXY_SERVER)
+        {
+            FindModule<NFIMessageModule>()->SendWxWork(NF_ST_MASTER_SERVER, "Proxy Server, External Ip:" + xData.external_server_ip() + " Port:" + NFCommon::tostr(xData.external_server_port()) + "\n");
+        }
+
         NFLogInfo(NF_LOG_SYSTEMLOG, 0, "{} Server Register Master Server Success,  busId:{}, ip:{}, port:{}", pServerData->mServerInfo.server_name(), pServerData->mServerInfo.bus_id(), pServerData->mServerInfo.server_ip(), pServerData->mServerInfo.server_port());
     }
 
@@ -200,6 +206,11 @@
             {
                 SynOtherServerToServer(pServerData);
             }
+
+            if (xData.server_type() == NF_ST_PROXY_SERVER)
+            {
+                FindModule<NFIMessageModule>()->SendWxWork(NF_ST_MASTER_SERVER, "Proxy Server, External Ip:" + xData.external_server_ip() + " Port:" + NFCommon::tostr(xData.external_server_port()) + "\n");
+            }
 #endif
         }
         else {
@@ -213,6 +224,11 @@
                 SynServerToOthers(pServerData);
                 SynOtherServerToServer(pServerData);
             }
+
+            if (xData.server_type() == NF_ST_PROXY_SERVER)
+            {
+                FindModule<NFIMessageModule>()->SendWxWork(NF_ST_MASTER_SERVER, "Proxy Server, External Ip:" + xData.external_server_ip() + " Port:" + NFCommon::tostr(xData.external_server_port()) + "\n");
+            }
 #endif
             NFLogInfo(NF_LOG_SYSTEMLOG, 0, "{} Server Register Master Server Success,  busId:{}, ip:{}, port:{}", pServerData->mServerInfo.server_name(), pServerData->mServerInfo.bus_id(), pServerData->mServerInfo.server_ip(), pServerData->mServerInfo.server_port());
         }
Index: game/Fish/NFLogicComm/NFLogicCommon/NFLogicError.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFLogicComm/NFLogicCommon/NFLogicError.cpp b/game/Fish/NFLogicComm/NFLogicCommon/NFLogicError.cpp
new file mode 100644
--- /dev/null	(date 1688628458723)
+++ b/game/Fish/NFLogicComm/NFLogicCommon/NFLogicError.cpp	(date 1688628458723)
@@ -0,0 +1,31 @@
+// -------------------------------------------------------------------------
+//    @FileName         :    NFLogicError.cpp
+//    @Author           :    gaoyi
+//    @Date             :    23-3-29
+//    @Email			:    445267987@qq.com
+//    @Module           :    NFLogicError
+//
+// -------------------------------------------------------------------------
+
+#include "NFLogicError.h"
+#include "proto_kernel.pb.h"
+#include "ComDefine.pb.h"
+#include "NFComm/NFCore/NFCommon.h"
+
+std::string NFLogicError::GetErrorStr(int32_t retCode)
+{
+    if (proto_ff::Proto_CS_ErrorCode_IsValid(retCode))
+    {
+        return proto_ff::Proto_CS_ErrorCode_Name((proto_ff::Proto_CS_ErrorCode)retCode);
+    }
+    else if (proto_ff::Proto_Kernel_ErrorCode_IsValid(retCode))
+    {
+        return proto_ff::Proto_Kernel_ErrorCode_Name((proto_ff::Proto_Kernel_ErrorCode)retCode);
+    }
+    else
+    {
+        return NFCommon::tostr(retCode);
+    }
+}
+
+
Index: game/Fish/NFLogicComm/NFLogicCommon/NFLogicError.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFLogicComm/NFLogicCommon/NFLogicError.h b/game/Fish/NFLogicComm/NFLogicCommon/NFLogicError.h
new file mode 100644
--- /dev/null	(date 1680057325751)
+++ b/game/Fish/NFLogicComm/NFLogicCommon/NFLogicError.h	(date 1680057325751)
@@ -0,0 +1,20 @@
+// -------------------------------------------------------------------------
+//    @FileName         :    NFLogicError.h
+//    @Author           :    gaoyi
+//    @Date             :    23-3-29
+//    @Email			:    445267987@qq.com
+//    @Module           :    NFLogicError
+//
+// -------------------------------------------------------------------------
+
+#pragma once
+
+
+#include "NFComm/NFCore/NFPlatform.h"
+#include "NFComm/NFPluginModule/NFError.h"
+
+class NFLogicError : public NFError
+{
+public:
+    virtual std::string GetErrorStr(int32_t retCode) override;
+};
\ No newline at end of file
Index: game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldGetRoleList.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransWorldSendGetRoleList.h\n//    @Author           :    gaoyi\n//    @Date             :    23-3-3\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransWorldSendGetRoleList\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFTransBase.h\"\n\nclass NFTransWorldGetRoleList : public NFTransBase\n{\npublic:\n    NFTransWorldGetRoleList();\n\n    virtual ~NFTransWorldGetRoleList();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    int Init(uint64_t uid, uint32_t proxyId, uint64_t clientId, uint32_t bornZid, uint32_t chanId);\n\n    virtual int HandleDispSvrRes(uint32_t nMsgId, const NFDataPackage &packet, uint32_t reqTransId, uint32_t rspTransId);\n\npublic:\n    int OnHandleLogicGetRoleListRsp(uint32_t nMsgId, const NFDataPackage &packet, uint32_t reqTransId, uint32_t rspTransId);\n    int OnHandleLogicLeaveGameRsp(uint32_t nMsgId, const NFDataPackage &packet, uint32_t reqTransId, uint32_t rspTransId);\n    int OnHandleClientLogin();\n    int SendGetRoleList();\npublic:\n    virtual int OnTransFinished(int iRunLogicRetCode);\nprivate:\n    uint64_t m_uid;\n    uint32_t m_proxyId;\n    uint64_t m_clientId;\n    uint32_t m_loginZid;\n    uint32_t m_chanId;\nprivate:\nDECLARE_IDCREATE(NFTransWorldGetRoleList)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldGetRoleList.h b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldGetRoleList.h
--- a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldGetRoleList.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldGetRoleList.h	(date 1688616543351)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFTransBase.h"
 
Index: game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldEnterGame.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransWorldEnterGame.h\n//    @Author           :    gaoyi\n//    @Date             :    23-3-7\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransWorldEnterGame\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFTransBase.h\"\n#include \"ServerInternal2.pb.h\"\n#include \"CSLogin.pb.h\"\n\nclass NFTransWorldEnterGame : public NFTransBase\n{\npublic:\n    NFTransWorldEnterGame();\n\n    virtual ~NFTransWorldEnterGame();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    int Init(uint64_t uid, uint64_t roleId, uint32_t proxyId, uint64_t clientId);\n\n    int OnHandleEnterGame(const proto_ff::ClientEnterGameReq& req);\n\n    int SendLoadRoleInfo(const proto_ff::WorldToLogicLoginReq& req);\n\n    virtual int HandleDispSvrRes(uint32_t nMsgId, const NFDataPackage &packet, uint32_t reqTransId, uint32_t rspTransId);\n\npublic:\n    /**\n     * @brief 处理逻辑登陆返回\n     * @param msgId\n     * @param packet\n     * @param reqTransId\n     * @param rspTransId\n     * @return\n     */\n    int OnHandleLogicLoginRsp(uint32_t msgId, const NFDataPackage& packet, uint32_t reqTransId, uint32_t rspTransId);\n\n    /**\n     * @brief 处理Sns登陆返回\n     * @param msgId\n     * @param packet\n     * @param reqTransId\n     * @param rspTransId\n     * @return\n     */\n    int OnHandleSnsLoginRsp(uint32_t msgId, const NFDataPackage& packet, uint32_t reqTransId, uint32_t rspTransId);\n\n    virtual int OnTransFinished(int iRunLogicRetCode);\nprivate:\n    uint64_t m_uid;\n    uint64_t m_roleId;\n    uint32_t m_proxyId;\n    uint64_t m_clientId;\n\n    bool m_loadLogic;\n    bool m_loadSns;\nDECLARE_IDCREATE(NFTransWorldEnterGame)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldEnterGame.h b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldEnterGame.h
--- a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldEnterGame.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldEnterGame.h	(date 1688616543356)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFTransBase.h"
 #include "ServerInternal2.pb.h"
Index: src/NFCommPlugin/NFKernelPlugin/NFCMysqlDriver.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"NFCMysqlDriver.h\"\n#include \"NFComm/NFCore/NFCommon.h\"\n#include \"NFComm/NFPluginModule/NFProtobufCommon.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"NFComm/NFKernelMessage/proto_kernel.pb.h\"\n\n//m_pMysqlConnect在调用Connect会引发多线程的崩溃，必须枷锁\nNFMutex NFCMysqlDriver::ConnectLock;\n\nNFCMysqlDriver::NFCMysqlDriver(const int nReconnectTime/* = 60*/, const int nReconnectCount /*= -1*/)\n{\n    mfCheckReconnect = 0.0f;\n    mnDBPort = 0;\n    m_pMysqlConnect = nullptr;\n    mnReconnectTime = nReconnectTime;\n    mnReconnectCount = nReconnectCount;\n}\n\nNFCMysqlDriver::NFCMysqlDriver(const std::string &strDBName, const std::string &strDBHost, const int nDBPort,\n                               const std::string &strDBUser, const std::string &strDBPwd)\n{\n    mfCheckReconnect = 0.0f;\n    mnDBPort = 0;\n    m_pMysqlConnect = nullptr;\n\n    mnReconnectTime = 3;\n    mnReconnectCount = -1;\n\n    NFCMysqlDriver::Connect(strDBName, strDBHost, nDBPort, strDBUser, strDBPwd);\n}\n\nNFCMysqlDriver::~NFCMysqlDriver()\n{\n    NFCMysqlDriver::CloseConnection();\n}\n\nint NFCMysqlDriver::Connect(const std::string &strDBName, const std::string &strDBHost, const int nDBPort,\n                            const std::string &strDBUser, const std::string &strDBPwd)\n{\n    mstrDBName = strDBName;\n    mstrDBHost = strDBHost;\n    mnDBPort = nDBPort;\n    mstrDBUser = strDBUser;\n    mstrDBPwd = strDBPwd;\n\n    return Connect();\n}\n\nint NFCMysqlDriver::CheckConnect()\n{\n    if (IsNeedReconnect() && CanReconnect())\n    {\n        Connect(mstrDBName, mstrDBHost, mnDBPort, mstrDBUser, mstrDBPwd);\n    }\n\n    return 0;\n}\n\nint NFCMysqlDriver::Query(const std::string &qstr, mysqlpp::StoreQueryResult &queryResult, std::string &errormsg)\n{\n    mysqlpp::Connection *pConection = GetConnection();\n    if (pConection)\n    {\n        //NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"query:{}\", qstr);\n\n        NFMYSQLTRYBEGIN\n            mysqlpp::Query query = pConection->query(qstr);\n            //query.execute();\n            //NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"query:{}\", query.str());\n            queryResult = query.store();\n\n            query.reset();\n        NFMYSQLTRYEND(\"Query Error\")\n        return 0;\n    }\n\n    return -1;\n}\n\nint NFCMysqlDriver::ExecuteOne(const std::string &qstr, std::map<std::string, std::string> &valueVec,\n                               std::string &errormsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"ExecuteOne:{}\", qstr);\n\n    mysqlpp::StoreQueryResult queryResult;\n    if (NFCMysqlDriver::Query(qstr, queryResult, errormsg) == 0)\n    {\n        for (size_t i = 0; i < queryResult.num_rows(); ++i)\n        {\n            for (size_t j = 0; j < queryResult[i].size(); j++)\n            {\n                std::string value;\n                if (!queryResult[i][j].is_null())\n                {\n                    queryResult[i][j].to_string(value);\n                }\n                valueVec.emplace(queryResult.field_name(j), value);\n            }\n            return 0; //-V612\n        }\n        return 0;\n    }\n    return -1;\n}\n\nint NFCMysqlDriver::Execute(const storesvr_sqldata::storesvr_execute &select, storesvr_sqldata::storesvr_execute_res &select_res)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"query:{}\", select.execute_record());\n\n    mysqlpp::StoreQueryResult queryResult;\n    std::vector<std::map<std::string, std::string>> resultVec;\n    std::string errormsg;\n    int iRet = ExecuteMore(select.execute_record(), resultVec, errormsg);\n    if (iRet != 0)\n    {\n        select_res.mutable_exe_opres()->set_errmsg(errormsg);\n        return -1;\n    }\n\n    select_res.mutable_baseinfo()->CopyFrom(select.baseinfo());\n    select_res.mutable_exe_opres()->set_mod_key(select.mod_key());\n\n    for (size_t i = 0; i < resultVec.size(); i++)\n    {\n        const std::map<std::string, std::string> &result = resultVec[i];\n\n        google::protobuf::Message *pMessage = NULL;\n        iRet = TransTableRowToMessage(result, select.baseinfo().package_name(), select.baseinfo().clname(), &pMessage);\n        if (iRet == 0 && pMessage != NULL)\n        {\n            select_res.set_sel_records(pMessage->SerializeAsString());\n            NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"{}\", pMessage->Utf8DebugString());\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"TransTableRowToMessage Failed, result:{} sql:{}\",\n                       NFCommon::tostr(result), select.execute_record());\n            iRet = -1;\n        }\n\n        if (pMessage != NULL)\n        {\n            NF_SAFE_DELETE(pMessage);\n        }\n\n        break;\n    }\n\n    return iRet;\n}\n\nint NFCMysqlDriver::ExecuteMore(const storesvr_sqldata::storesvr_execute_more &select,\n                                 ::google::protobuf::RepeatedPtrField<storesvr_sqldata::storesvr_execute_more_res> &vecSelectRes)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    mysqlpp::StoreQueryResult queryResult;\n    std::vector<std::map<std::string, std::string>> resultVec;\n    std::string errormsg;\n    int iRet = ExecuteMore(select.execute_record(), resultVec, errormsg);\n    if (iRet != 0)\n    {\n        storesvr_sqldata::storesvr_execute_more_res *select_res = vecSelectRes.Add();\n        select_res->mutable_exe_opres()->set_errmsg(errormsg);\n        return -1;\n    }\n\n    storesvr_sqldata::storesvr_execute_more_res *select_res = vecSelectRes.Add();\n\n    select_res->mutable_baseinfo()->CopyFrom(select.baseinfo());\n    select_res->mutable_exe_opres()->set_mod_key(select.mod_key());\n    select_res->set_is_lastbatch(false);\n\n    int count = 0;\n    for (size_t i = 0; i < resultVec.size(); i++)\n    {\n        const std::map<std::string, std::string> &result = resultVec[i];\n\n        google::protobuf::Message *pMessage = NULL;\n        iRet = TransTableRowToMessage(result, select.baseinfo().package_name(), select.baseinfo().clname(), &pMessage);\n        if (iRet == 0 && pMessage != NULL)\n        {\n            select_res->add_sel_records(pMessage->SerializeAsString());\n\n            count++;\n            select_res->set_row_count(count);\n            if ((int)select_res->sel_records_size() >= (int)select.baseinfo().max_records())\n            {\n                count = 0;\n                select_res = vecSelectRes.Add();\n\n                select_res->mutable_baseinfo()->CopyFrom(select.baseinfo());\n                select_res->mutable_exe_opres()->set_mod_key(select.mod_key());\n                select_res->set_is_lastbatch(false);\n            }\n            NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"{}\", pMessage->Utf8DebugString());\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"TransTableRowToMessage Failed, result:{} tableName:{}\",\n                       NFCommon::tostr(result), select.baseinfo().clname());\n            iRet = -1;\n        }\n\n        if (pMessage != NULL)\n        {\n            NF_SAFE_DELETE(pMessage);\n        }\n    }\n\n    select_res->set_is_lastbatch(true);\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\nint NFCMysqlDriver::ExecuteMore(const storesvr_sqldata::storesvr_execute_more &select, storesvr_sqldata::storesvr_execute_more_res &select_res)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"query:{}\", select.execute_record());\n\n    mysqlpp::StoreQueryResult queryResult;\n    std::vector<std::map<std::string, std::string>> resultVec;\n    std::string errormsg;\n    int iRet = ExecuteMore(select.execute_record(), resultVec, errormsg);\n    if (iRet != 0)\n    {\n        select_res.mutable_exe_opres()->set_errmsg(errormsg);\n        return -1;\n    }\n\n    select_res.mutable_baseinfo()->CopyFrom(select.baseinfo());\n    select_res.mutable_exe_opres()->set_mod_key(select.mod_key());\n\n    for (size_t i = 0; i < resultVec.size(); i++)\n    {\n        const std::map<std::string, std::string> &result = resultVec[i];\n\n        google::protobuf::Message *pMessage = NULL;\n        iRet = TransTableRowToMessage(result, select.baseinfo().package_name(), select.baseinfo().clname(), &pMessage);\n        if (iRet == 0 && pMessage != NULL)\n        {\n            select_res.add_sel_records(pMessage->SerializeAsString());\n            NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"{}\", pMessage->Utf8DebugString());\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"TransTableRowToMessage Failed, result:{} sql:{}\",\n                       NFCommon::tostr(result), select.execute_record());\n            iRet = -1;\n        }\n\n        if (pMessage != NULL)\n        {\n            NF_SAFE_DELETE(pMessage);\n        }\n    }\n\n    return iRet;\n}\n\nint NFCMysqlDriver::ExecuteMore(const std::string &qstr, std::vector<std::map<std::string, std::string>> &valueVec,\n                                std::string &errormsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"query:{}\", qstr);\n\n    mysqlpp::StoreQueryResult queryResult;\n    if (NFCMysqlDriver::Query(qstr, queryResult, errormsg) == 0)\n    {\n        for (size_t i = 0; i < queryResult.num_rows(); ++i)\n        {\n            valueVec.push_back(std::map<std::string, std::string>());\n            std::map<std::string, std::string> &tmpVec = valueVec.back();\n            for (size_t j = 0; j < queryResult[i].size(); j++)\n            {\n                std::string value;\n                if (!queryResult[i][j].is_null())\n                {\n                    queryResult[i][j].to_string(value);\n                }\n                tmpVec.emplace(queryResult.field_name(j), value);\n            }\n        }\n        return 0;\n    }\n    return -1;\n}\n\n/**\n * @brief 执行sql语句, 把数据库配置表里的数据取出来\n *\n * @param  table 配置表表明\n * @param  sheet_fullname protobuf中代表一个表格的message\n * @param  pMessage sheet_fullname的protobuf的数据结构，携带返回数据\n *  比如 message Sheet_GameRoomDesc\n *\t\t{\n *\t\t\trepeated GameRoomDesc GameRoomDesc_List = 1  [(yd_fieldoptions.field_arysize)=100];\n *\t\t}\n * 代表一个Excel表格GameRoomDesc, 同时数据库有一个表GameRoomDesc\n * 都用这个数据结构来表达，以及存取数据\n *\n *\n * @return bool 执行成功或失败\n */\nint NFCMysqlDriver::QueryDescStore(const std::string &table, google::protobuf::Message **pMessage)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --table:{}\", table);\n    int iRet = 0;\n    std::string selectSql = \"select * from \" + table;\n    std::vector<std::map<std::string, std::string>> resultVec;\n    std::string errmsg;\n    iRet = ExecuteMore(selectSql, resultVec, errmsg);\n    CHECK_EXPR(iRet == 0, iRet, \"ExecuteMore:{} Failed!\", errmsg);\n\n    if (resultVec.size() <= 0)\n    {\n        return 0;\n    }\n\n    //通过sheet_fullname名字，获得这个protobuf类的默认变量\n    std::string sheet_fullname = DEFINE_DEFAULT_PROTO_PACKAGE_ADD + std::string(\"Sheet_\") + table;\n    //通过protobuf默认便利new出来一个新的sheet_fullname变量\n    ::google::protobuf::Message *pSheetMessageObject = NFProtobufCommon::Instance()->CreateDynamicMessageByName(sheet_fullname);\n    CHECK_EXPR(pSheetMessageObject, -1, \"{} New Failed\", sheet_fullname);\n\n    if (pMessage)\n    {\n        *pMessage = pSheetMessageObject;\n    }\n\n    const google::protobuf::Descriptor *pSheetFieldDesc = pSheetMessageObject->GetDescriptor();\n    CHECK_EXPR(pSheetFieldDesc, -1, \"pSheetFieldDesc == NULL\");\n    const google::protobuf::Reflection *pSheetReflect = pSheetMessageObject->GetReflection();\n    CHECK_EXPR(pSheetReflect, -1, \"pSheetFieldDesc == NULL\");\n\n    for (int sheet_field_index = 0; sheet_field_index < pSheetFieldDesc->field_count(); sheet_field_index++)\n    {\n        /*  比如 message Sheet_GameRoomDesc\n        *\t\t{\n        *\t\t\trepeated GameRoomDesc GameRoomDesc_List = 1  [(yd_fieldoptions.field_arysize)=100];\n        *\t\t}\n        *\t\t获得上面GameRoomDesc_List信息\n        */\n        const google::protobuf::FieldDescriptor *pSheetRepeatedFieldDesc = pSheetFieldDesc->field(sheet_field_index);\n        if (pSheetRepeatedFieldDesc->is_repeated() &&\n            pSheetRepeatedFieldDesc->cpp_type() == google::protobuf::FieldDescriptor::CPPTYPE_MESSAGE)\n        {\n            //如果is_repeated 开始处理\n            for (size_t result_i = 0; result_i < resultVec.size(); result_i++)\n            {\n                const std::map<std::string, std::string> &result = resultVec[result_i];\n                ::google::protobuf::Message *pSheetRepeatedMessageObject = pSheetReflect->AddMessage(\n                        pSheetMessageObject, pSheetRepeatedFieldDesc);\n                NFProtobufCommon::GetMessageFromMapFields(result, pSheetRepeatedMessageObject);\n            }\n        }\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::QueryDescStore(const std::string &table, google::protobuf::Message *pSheetMessageObject)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --table:{}\", table);\n    CHECK_EXPR(pSheetMessageObject, -1, \"pMessage == NULL\");\n    int iRet = 0;\n    std::string selectSql = \"select * from \" + table;\n    std::vector<std::map<std::string, std::string>> resultVec;\n    std::string errmsg;\n    iRet = ExecuteMore(selectSql, resultVec, errmsg);\n    CHECK_EXPR(iRet == 0, iRet, \"ExecuteMore:{} Failed!\", errmsg);\n\n    if (resultVec.size() <= 0)\n    {\n        return 0;\n    }\n\n    const google::protobuf::Descriptor *pSheetFieldDesc = pSheetMessageObject->GetDescriptor();\n    CHECK_EXPR(pSheetFieldDesc, -1, \"pSheetFieldDesc == NULL\");\n    const google::protobuf::Reflection *pSheetReflect = pSheetMessageObject->GetReflection();\n    CHECK_EXPR(pSheetReflect, -1, \"pSheetFieldDesc == NULL\");\n\n    for (int sheet_field_index = 0; sheet_field_index < pSheetFieldDesc->field_count(); sheet_field_index++)\n    {\n        /*  比如 message Sheet_GameRoomDesc\n        *\t\t{\n        *\t\t\trepeated GameRoomDesc GameRoomDesc_List = 1  [(yd_fieldoptions.field_arysize)=100];\n        *\t\t}\n        *\t\t获得上面GameRoomDesc_List信息\n        */\n        const google::protobuf::FieldDescriptor *pSheetRepeatedFieldDesc = pSheetFieldDesc->field(sheet_field_index);\n        if (pSheetRepeatedFieldDesc->is_repeated() &&\n            pSheetRepeatedFieldDesc->cpp_type() == google::protobuf::FieldDescriptor::CPPTYPE_MESSAGE)\n        {\n            //如果is_repeated 开始处理\n            for (size_t result_i = 0; result_i < resultVec.size(); result_i++)\n            {\n                const std::map<std::string, std::string> &result = resultVec[result_i];\n                ::google::protobuf::Message *pSheetRepeatedMessageObject = pSheetReflect->AddMessage(\n                        pSheetMessageObject, pSheetRepeatedFieldDesc);\n                NFProtobufCommon::GetMessageFromMapFields(result, pSheetRepeatedMessageObject);\n            }\n        }\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::TransTableRowToMessage(const std::map<std::string, std::string> &result, const std::string& packageName, const std::string &table,\n                                           google::protobuf::Message **pMessage)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --table:{}\", table);\n    std::string proto_fullname;\n    if (packageName.empty())\n    {\n        proto_fullname = DEFINE_DEFAULT_PROTO_PACKAGE_ADD + table;\n    }\n    else {\n        proto_fullname =  packageName + \".\" + table;\n    }\n\n    //通过protobuf默认便利new出来一个新的proto_fullname变量\n    ::google::protobuf::Message *pMessageObject = NFProtobufCommon::Instance()->CreateDynamicMessageByName(proto_fullname);\n    CHECK_EXPR(pMessageObject, -1, \"{} New Failed\", proto_fullname);\n\n    if (pMessage)\n    {\n        *pMessage = pMessageObject;\n    }\n\n    NFProtobufCommon::GetMessageFromMapFields(result, pMessageObject);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::SelectByCond(const storesvr_sqldata::storesvr_sel &select,\n                                 ::google::protobuf::RepeatedPtrField<storesvr_sqldata::storesvr_sel_res> &vecSelectRes)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string selectSql;\n    int iRet = 0;\n    iRet = CreateSql(select, selectSql);\n    CHECK_EXPR(iRet == 0, -1, \"CreateSql Failed:{}\", selectSql);\n\n    std::vector<std::map<std::string, std::string>> resultVec;\n    std::string errmsg;\n    iRet = ExecuteMore(selectSql, resultVec, errmsg);\n    if (iRet != 0)\n    {\n        storesvr_sqldata::storesvr_sel_res *select_res = vecSelectRes.Add();\n        select_res->mutable_sel_opres()->set_errmsg(errmsg);\n        return -1;\n    }\n\n    storesvr_sqldata::storesvr_sel_res *select_res = vecSelectRes.Add();\n\n    select_res->mutable_baseinfo()->CopyFrom(select.baseinfo());\n    select_res->mutable_sel_opres()->set_mod_key(select.sel_cond().mod_key());\n    select_res->set_is_lastbatch(false);\n\n    int count = 0;\n    for (size_t i = 0; i < resultVec.size(); i++)\n    {\n        const std::map<std::string, std::string> &result = resultVec[i];\n\n        google::protobuf::Message *pMessage = NULL;\n        iRet = TransTableRowToMessage(result, select.baseinfo().package_name(), select.baseinfo().clname(), &pMessage);\n        if (iRet == 0 && pMessage != NULL)\n        {\n            select_res->add_sel_records(pMessage->SerializeAsString());\n\n            count++;\n            select_res->set_row_count(count);\n            if ((int)select_res->sel_records_size() >= (int)select.baseinfo().max_records())\n            {\n                count = 0;\n                select_res = vecSelectRes.Add();\n\n                select_res->mutable_baseinfo()->CopyFrom(select.baseinfo());\n                select_res->mutable_sel_opres()->set_mod_key(select.sel_cond().mod_key());\n                select_res->set_is_lastbatch(false);\n            }\n            NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"{}\", pMessage->Utf8DebugString());\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"TransTableRowToMessage Failed, result:{} tableName:{}\",\n                       NFCommon::tostr(result), select.baseinfo().tbname());\n            iRet = -1;\n        }\n\n        if (pMessage != NULL)\n        {\n            NF_SAFE_DELETE(pMessage);\n        }\n    }\n\n    select_res->set_is_lastbatch(true);\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\nint NFCMysqlDriver::SelectByCond(const storesvr_sqldata::storesvr_sel &select,\n                                 storesvr_sqldata::storesvr_sel_res &select_res)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string selectSql;\n    int iRet = 0;\n    iRet = CreateSql(select, selectSql);\n    CHECK_EXPR(iRet == 0, -1, \"CreateSql Failed:{}\", selectSql);\n\n    *select_res.mutable_baseinfo() = select.baseinfo();\n    select_res.mutable_sel_opres()->set_mod_key(select.sel_cond().mod_key());\n    std::vector<std::map<std::string, std::string>> resultVec;\n    std::string errmsg;\n    iRet = ExecuteMore(selectSql, resultVec, errmsg);\n    if (iRet != 0)\n    {\n        select_res.mutable_sel_opres()->set_errmsg(errmsg);\n        return -1;\n    }\n\n    select_res.set_is_lastbatch(true);\n\n    int count = 0;\n    for (size_t i = 0; i < resultVec.size(); i++)\n    {\n        const std::map<std::string, std::string> &result = resultVec[i];\n\n        google::protobuf::Message *pMessage = NULL;\n        iRet = TransTableRowToMessage(result, select.baseinfo().package_name(), select.baseinfo().clname(), &pMessage);\n        if (iRet == 0 && pMessage != NULL)\n        {\n            count++;\n            select_res.add_sel_records(pMessage->SerializeAsString());\n            NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"{}\", pMessage->Utf8DebugString());\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"TransTableRowToMessage Failed, result:{} tableName:{}\",\n                       NFCommon::tostr(result), select.baseinfo().tbname());\n            iRet = -1;\n        }\n        if (pMessage != NULL)\n        {\n            NF_SAFE_DELETE(pMessage);\n        }\n    }\n\n    select_res.set_row_count(count);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\nint NFCMysqlDriver::SelectObj(const std::string &tbName, google::protobuf::Message *pMessage, std::string &errMsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --tbName:{} errMsg:{}\", tbName, errMsg);\n    CHECK_EXPR(pMessage, -1, \"pMessage == NULL\");\n\n    storesvr_sqldata::storesvr_selobj select;\n    select.mutable_baseinfo()->set_tbname(tbName);\n    select.set_sel_record(pMessage->SerializeAsString());\n\n    storesvr_sqldata::storesvr_selobj_res select_res;\n\n    int iRet = SelectObj(select, select_res);\n    if (iRet == 0)\n    {\n        pMessage->ParsePartialFromString(select_res.sel_record());\n    }\n    else\n    {\n        errMsg = select_res.sel_opres().errmsg();\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\nint NFCMysqlDriver::SelectObj(const storesvr_sqldata::storesvr_selobj &select,\n                              storesvr_sqldata::storesvr_selobj_res &select_res)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    int iRet = 0;\n    std::map<std::string, std::string> keyMap;\n    iRet = CreateSql(select, keyMap);\n    CHECK_EXPR(iRet == 0, -1, \"CreateSql Failed:{}\", iRet);\n\n    *select_res.mutable_baseinfo() = select.baseinfo();\n    select_res.mutable_sel_opres()->set_mod_key(select.mod_key());\n\n    std::vector<std::string> vecFields;\n    for(int i = 0; i < (int)select.baseinfo().sel_fields_size(); i++)\n    {\n        vecFields.push_back(select.baseinfo().sel_fields(i));\n    }\n\n    std::map<std::string, std::string> result;\n    std::string errmsg;\n    iRet = QueryOne(select.baseinfo().tbname(), keyMap, vecFields, result, errmsg);\n    if (iRet != 0)\n    {\n        select_res.mutable_sel_opres()->set_errmsg(errmsg);\n        return iRet;\n    }\n\n    google::protobuf::Message *pMessage = NULL;\n    iRet = TransTableRowToMessage(result, select.baseinfo().package_name(), select.baseinfo().clname(), &pMessage);\n    if (iRet == 0 && pMessage != NULL)\n    {\n        select_res.set_sel_record(pMessage->SerializeAsString());\n        NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"{}\", pMessage->Utf8DebugString());\n    }\n    else\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"TransTableRowToMessage Failed, result:{} tableName:{}\",\n                   NFCommon::tostr(result), select.baseinfo().tbname());\n        iRet = -1;\n    }\n    if (pMessage != NULL)\n    {\n        NF_SAFE_DELETE(pMessage);\n    }\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\n\nint NFCMysqlDriver::DeleteByCond(const storesvr_sqldata::storesvr_del &select,\n                                 storesvr_sqldata::storesvr_del_res &select_res)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string selectSql;\n    int iRet = 0;\n    iRet = CreateSql(select, selectSql);\n    CHECK_EXPR(iRet == 0, -1, \"CreateSql Failed:{}\", selectSql);\n\n    *select_res.mutable_baseinfo() = select.baseinfo();\n    select_res.mutable_del_opres()->set_mod_key(select.del_cond().mod_key());\n    std::string errmsg;\n    iRet = Delete(selectSql, errmsg);\n    if (iRet != 0)\n    {\n        select_res.mutable_del_opres()->set_errmsg(errmsg);\n        return -1;\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::DeleteObj(const storesvr_sqldata::storesvr_delobj &select,\n                              storesvr_sqldata::storesvr_delobj_res &select_res)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    int iRet = 0;\n    std::map<std::string, std::string> keyMap;\n    iRet = CreateSql(select, keyMap);\n    CHECK_EXPR(iRet == 0, -1, \"CreateSql Failed\");\n\n    *select_res.mutable_baseinfo() = select.baseinfo();\n    select_res.mutable_del_opres()->set_mod_key(select.mod_key());\n    std::string errmsg;\n    iRet = Delete(select.baseinfo().tbname(), keyMap, errmsg);\n    if (iRet != 0)\n    {\n        select_res.mutable_del_opres()->set_errmsg(errmsg);\n        return -1;\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::CreateSql(const storesvr_sqldata::storesvr_delobj &select, std::map<std::string, std::string> &keyMap)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string tableName = select.baseinfo().clname();\n    CHECK_EXPR(tableName.size() > 0, -1, \"talbeName empty!\");\n    std::string packageName = select.baseinfo().package_name();\n\n    std::string full_name;\n    if (packageName.empty())\n    {\n        full_name = DEFINE_DEFAULT_PROTO_PACKAGE_ADD + tableName;\n    }\n    else {\n        full_name = packageName + \".\" + tableName;\n    }\n    google::protobuf::Message *pMessageObject = NFProtobufCommon::Instance()->CreateDynamicMessageByName(full_name);\n    CHECK_EXPR(pMessageObject, -1, \"NFProtobufCommon::CreateMessageByName:{} Failed\", full_name);\n    CHECK_EXPR(pMessageObject->ParsePartialFromString(select.del_record()), -1, \"ParsePartialFromString Failed:{}\", full_name);\n\n    NFProtobufCommon::GetMapFieldsFromMessage(*pMessageObject, keyMap, true, true);\n    delete pMessageObject;\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::CreateSql(const storesvr_sqldata::storesvr_mod &select, std::string &selectSql)\n{\n    if (select.has_mod_cond())\n    {\n        selectSql = \" \";\n        const ::storesvr_sqldata::storesvr_wherecond &whereCond = select.mod_cond();\n        for (int i = 0; i < whereCond.where_conds_size(); i++)\n        {\n            std::string sql;\n            const ::storesvr_sqldata::storesvr_vk &vk = whereCond.where_conds(i);\n            if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_EQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"=\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_GREATER)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \">'\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \">\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_LESS)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"<'\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"<\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_GREATEREQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \">='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \">=\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_LESSEQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"<='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"<=\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_NOTEQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"!='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"!=\" + vk.column_value();\n                }\n            }\n\n            if (sql.size() > 0 && i < whereCond.where_conds_size() - 1)\n            {\n                if (vk.logic_operator() == ::storesvr_sqldata::E_LOGICOP_AND)\n                {\n                    sql += \" and \";\n                }\n                else if (vk.logic_operator() == ::storesvr_sqldata::E_LOGICOP_OR)\n                {\n                    sql += \" or \";\n                }\n            }\n\n            if (sql.size() > 0)\n            {\n                selectSql += sql;\n            }\n        }\n\n        if (whereCond.where_additional_conds().size() > 0)\n        {\n            selectSql += \" \" + whereCond.where_additional_conds();\n        }\n    }\n\n    return 0;\n}\n\nint NFCMysqlDriver::CreateSql(const storesvr_sqldata::storesvr_update &select, std::string &selectSql)\n{\n    if (select.has_mod_cond())\n    {\n        selectSql = \" \";\n        const ::storesvr_sqldata::storesvr_wherecond &whereCond = select.mod_cond();\n        for (int i = 0; i < whereCond.where_conds_size(); i++)\n        {\n            std::string sql;\n            const ::storesvr_sqldata::storesvr_vk &vk = whereCond.where_conds(i);\n            if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_EQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"=\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_GREATER)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \">'\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \">\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_LESS)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"<'\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"<\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_GREATEREQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \">='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \">=\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_LESSEQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"<='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"<=\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_NOTEQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"!='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"!=\" + vk.column_value();\n                }\n            }\n\n            if (sql.size() > 0 && i < whereCond.where_conds_size() - 1)\n            {\n                if (vk.logic_operator() == ::storesvr_sqldata::E_LOGICOP_AND)\n                {\n                    sql += \" and \";\n                }\n                else if (vk.logic_operator() == ::storesvr_sqldata::E_LOGICOP_OR)\n                {\n                    sql += \" or \";\n                }\n            }\n\n            if (sql.size() > 0)\n            {\n                selectSql += sql;\n            }\n        }\n\n        if (whereCond.where_additional_conds().size() > 0)\n        {\n            selectSql += \" \" + whereCond.where_additional_conds();\n        }\n    }\n\n    return 0;\n}\n\nint NFCMysqlDriver::CreateSql(const storesvr_sqldata::storesvr_del &select, std::string &selectSql)\n{\n    std::string tableName = select.baseinfo().tbname();\n    CHECK_EXPR(tableName.size() > 0, -1, \"talbeName empty!\");\n\n    if (select.has_del_cond())\n    {\n        selectSql = \"delete from \" + tableName + \" where \";\n        const ::storesvr_sqldata::storesvr_wherecond &whereCond = select.del_cond();\n        for (int i = 0; i < whereCond.where_conds_size(); i++)\n        {\n            std::string sql;\n            const ::storesvr_sqldata::storesvr_vk &vk = whereCond.where_conds(i);\n            if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_EQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"=\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_GREATER)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \">'\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \">\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_LESS)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"<'\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"<\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_GREATEREQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \">='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \">=\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_LESSEQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"<='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"<=\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_NOTEQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"!='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"!=\" + vk.column_value();\n                }\n            }\n\n            if (sql.size() > 0 && i < whereCond.where_conds_size() - 1)\n            {\n                if (vk.logic_operator() == ::storesvr_sqldata::E_LOGICOP_AND)\n                {\n                    sql += \" and \";\n                }\n                else if (vk.logic_operator() == ::storesvr_sqldata::E_LOGICOP_OR)\n                {\n                    sql += \" or \";\n                }\n            }\n\n            if (sql.size() > 0)\n            {\n                selectSql += sql;\n            }\n        }\n\n        if (whereCond.where_additional_conds().size() > 0)\n        {\n            selectSql += \" \" + whereCond.where_additional_conds();\n        }\n    }\n\n    return 0;\n}\n\nint\nNFCMysqlDriver::CreateSql(const storesvr_sqldata::storesvr_selobj &select, std::map<std::string, std::string> &keyMap)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string tableName = select.baseinfo().clname();\n    CHECK_EXPR(tableName.size() > 0, -1, \"talbeName empty!\");\n    std::string packageName = select.baseinfo().package_name();\n\n    std::string full_name;\n    if (packageName.empty())\n    {\n        full_name = DEFINE_DEFAULT_PROTO_PACKAGE_ADD + tableName;\n    }\n    else {\n        full_name = packageName + \".\" + tableName;\n    }\n    google::protobuf::Message *pMessageObject = NFProtobufCommon::Instance()->CreateDynamicMessageByName(full_name);\n    CHECK_EXPR(pMessageObject, -1, \"NFProtobufCommon::CreateMessageByName:{} Failed\", full_name);\n    CHECK_EXPR(pMessageObject->ParsePartialFromString(select.sel_record()), -1, \"ParsePartialFromString Failed:{}\", full_name);\n\n    NFProtobufCommon::GetMapFieldsFromMessage(*pMessageObject, keyMap, true, false);\n    delete pMessageObject;\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::CreateSql(const storesvr_sqldata::storesvr_sel &select, std::string &selectSql)\n{\n    std::string tableName = select.baseinfo().tbname();\n    CHECK_EXPR(tableName.size() > 0, -1, \"talbeName empty!\");\n\n    std::string stringFileds = \"*\";\n    if (select.baseinfo().sel_fields_size() > 0)\n    {\n        stringFileds = \"\";\n        for (int i = 0; i < (int) select.baseinfo().sel_fields_size(); i++)\n        {\n            if (i != select.baseinfo().sel_fields_size() - 1)\n            {\n                stringFileds += select.baseinfo().sel_fields(i) + \",\";\n            }\n            else\n            {\n                stringFileds += select.baseinfo().sel_fields(i);\n            }\n        }\n    }\n\n    if (!select.has_sel_cond())\n    {\n        selectSql = \"select \" + stringFileds + \" from \" + tableName;\n    }\n    else\n    {\n        selectSql = \"select \" + stringFileds + \" from \" + tableName;\n\n        const ::storesvr_sqldata::storesvr_wherecond &whereCond = select.sel_cond();\n        if (whereCond.where_conds_size() > 0)\n        {\n            selectSql += \" where \";\n        }\n        for (int i = 0; i < whereCond.where_conds_size(); i++)\n        {\n            std::string sql;\n            const ::storesvr_sqldata::storesvr_vk &vk = whereCond.where_conds(i);\n            if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_EQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"=\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_GREATER)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \">'\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \">\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_LESS)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"<'\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"<\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_GREATEREQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \">='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \">=\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_LESSEQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"<='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"<=\" + vk.column_value();\n                }\n            }\n            else if (vk.cmp_operator() == ::storesvr_sqldata::E_CMPOP_NOTEQUAL)\n            {\n                if (vk.column_type() == ::storesvr_sqldata::E_COLUMNTYPE_STRING)\n                {\n                    sql += vk.column_name() + \"!='\" + vk.column_value() + \"'\";\n                }\n                else\n                {\n                    sql += vk.column_name() + \"!=\" + vk.column_value();\n                }\n            }\n\n            if (sql.size() > 0 && i < whereCond.where_conds_size() - 1)\n            {\n                if (vk.logic_operator() == ::storesvr_sqldata::E_LOGICOP_AND)\n                {\n                    sql += \" and \";\n                }\n                else if (vk.logic_operator() == ::storesvr_sqldata::E_LOGICOP_OR)\n                {\n                    sql += \" or \";\n                }\n            }\n\n            if (sql.size() > 0)\n            {\n                selectSql += sql;\n            }\n        }\n\n        if (whereCond.where_additional_conds().size() > 0)\n        {\n            selectSql += \" \" + whereCond.where_additional_conds();\n        }\n    }\n\n    return 0;\n}\n\nmysqlpp::Connection *NFCMysqlDriver::GetConnection()\n{\n    return m_pMysqlConnect;\n}\n\nvoid NFCMysqlDriver::CloseConnection()\n{\n    if (m_pMysqlConnect)\n    {\n        NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"CloseConnection dbName:{} dbHost:{} dbPort:{}\", mstrDBName, mstrDBHost, mnDBPort);\n        delete m_pMysqlConnect;\n        m_pMysqlConnect = nullptr;\n    }\n}\n\nbool NFCMysqlDriver::Enable()\n{\n    return !IsNeedReconnect();\n}\n\nbool NFCMysqlDriver::CanReconnect()\n{\n    mfCheckReconnect += 0.1f;\n\n    //30检查断线重连\n    if (mfCheckReconnect < mnReconnectTime)\n    {\n        return false;\n    }\n\n    if (mnReconnectCount == 0)\n    {\n        return false;\n    }\n\n    mfCheckReconnect = 0.0f;\n\n    return true;\n}\n\nint NFCMysqlDriver::Reconnect()\n{\n    CloseConnection();\n    NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"Start Reconnect nServerID:{}, strIP:{}, nPort{}, strDBName:{}, strDBUser:{}, strDBPwd:{}\",\n              mstrDBName, mstrDBHost, mnDBPort, mstrDBName, mstrDBUser, mstrDBPwd);\n    int iRet = Connect(mstrDBName, mstrDBHost, mnDBPort, mstrDBUser, mstrDBPwd);\n    if (iRet != 0)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0,\n                   \"Reconnect Failed!:nServerID:{}, strIP:{}, nPort{}, strDBName:{}, strDBUser:{}, strDBPwd:{}\",\n                   mstrDBName, mstrDBHost, mnDBPort, mstrDBName, mstrDBUser, mstrDBPwd);\n    }\n    else\n    {\n        NFLogInfo(NF_LOG_SYSTEMLOG, 0,\n                  \"Reconnect Success!:nServerID:{}, strIP:{}, nPort{}, strDBName:{}, strDBUser:{}, strDBPwd:{}\",\n                  mstrDBName, mstrDBHost, mnDBPort, mstrDBName, mstrDBUser, mstrDBPwd);\n    }\n\n    if (mnReconnectCount > 0)\n    {\n        mnReconnectCount--;\n    }\n\n    return 0;\n}\n\nbool NFCMysqlDriver::IsNeedReconnect()\n{\n    //没有配置表\n    if (mstrDBHost.length() < 1 || mstrDBUser.length() < 1)\n    {\n        return false;\n    }\n\n    if (nullptr == m_pMysqlConnect)\n    {\n        return true;\n    }\n\n    if (!m_pMysqlConnect->connected())\n    {\n        CloseConnection();\n        return true;\n    }\n\n    if (!m_pMysqlConnect->ping())\n    {\n        CloseConnection();\n        return true;\n    }\n\n    return false;\n}\n\nint NFCMysqlDriver::Connect()\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    m_pMysqlConnect = new mysqlpp::Connection();\n    if (nullptr == m_pMysqlConnect)\n    {\n        return -1;\n    }\n    std::string errormsg;\n    NFMYSQLTRYBEGIN\n        m_pMysqlConnect->set_option(new mysqlpp::MultiStatementsOption(true));\n        m_pMysqlConnect->set_option(new mysqlpp::SetCharsetNameOption(\"utf8mb4\"));\n        m_pMysqlConnect->set_option(new mysqlpp::ReconnectOption(true));\n        m_pMysqlConnect->set_option(new mysqlpp::ConnectTimeoutOption(60));\n        m_pMysqlConnect->set_option(new mysqlpp::ReadTimeoutOption(1));\n\n        {\n            //m_pMysqlConnect在调用Connect会引发多线程的崩溃，必须枷锁\n            NFLock lock(ConnectLock);\n            if (!m_pMysqlConnect->connect(mstrDBName.c_str(), mstrDBHost.c_str(), mstrDBUser.c_str(), mstrDBPwd.c_str(),\n                                          mnDBPort))\n            {\n                CloseConnection();\n                // 连接失败\n                return -1;\n            }\n        }\n\n        // 设置超时时间为24小时\n        mysqlpp::Query query = m_pMysqlConnect->query(\"set interactive_timeout = 24*3600\");\n        query.execute();\n        query.reset();\n    NFMYSQLTRYEND(\"Connect faild\")\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::Disconnect()\n{\n    CloseConnection();\n    return 0;\n}\n\nint NFCMysqlDriver::Update(const std::string &strTableName, const std::map<std::string, std::string> &keyMap,\n                           const std::map<std::string, std::string> &keyvalueMap,\n                           std::string &errormsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    mysqlpp::Connection *pConnection = GetConnection();\n    if (nullptr == pConnection)\n    {\n        return -1;\n    }\n\n    bool bExist = false;\n    if (Exists(strTableName, keyMap, bExist) != 0)\n    {\n        return -1;\n    }\n\n    int iRet = 0;\n    if (bExist)\n    {\n        iRet = Modify(strTableName, keyMap, keyvalueMap, errormsg);\n    }\n    else\n    {\n        std::map<std::string, std::string> insertMap = keyvalueMap;\n        for (auto iter = keyMap.begin(); iter != keyMap.end(); iter++)\n        {\n            insertMap.emplace(iter->first, iter->second);\n        }\n        iRet = Insert(strTableName, insertMap, errormsg);\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\nint NFCMysqlDriver::Modify(const std::string &strTableName, const std::string &where,\n                           const std::map<std::string, std::string> &keyvalueMap, std::string &errormsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    mysqlpp::Connection *pConnection = GetConnection();\n    if (nullptr == pConnection)\n    {\n        return -1;\n    }\n\n    NFMYSQLTRYBEGIN\n        mysqlpp::Query query = pConnection->query();\n        // update\n        query << \"UPDATE \" << strTableName << \" SET \";\n        int i = 0;\n        for (auto iter = keyvalueMap.begin(); iter != keyvalueMap.end(); ++iter)\n        {\n            if (i == 0)\n            {\n                query << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n            else\n            {\n                query << \",\" << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n            i++;\n        }\n\n        if (!where.empty())\n        {\n            query << \" WHERE \" << where;\n        }\n        query << \";\";\n\n        NFLogDebug(NF_LOG_SYSTEMLOG, 0, \"query:{}\", query.str());\n        query.execute();\n        query.reset();\n    NFMYSQLTRYEND(\"modify error\")\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::Modify(const std::string &strTableName, const std::map<std::string, std::string> &keyMap,\n                           const std::map<std::string, std::string> &keyvalueMap, std::string &errormsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    mysqlpp::Connection *pConnection = GetConnection();\n    if (nullptr == pConnection)\n    {\n        return -1;\n    }\n\n    NFMYSQLTRYBEGIN\n        mysqlpp::Query query = pConnection->query();\n        // update\n        query << \"UPDATE \" << strTableName << \" SET \";\n        int i = 0;\n        for (auto iter = keyvalueMap.begin(); iter != keyvalueMap.end(); ++iter)\n        {\n            if (i == 0)\n            {\n                query << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n            else\n            {\n                query << \",\" << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n            i++;\n        }\n\n        query << \" WHERE \";\n        i = 0;\n        for (auto iter = keyMap.begin(); iter != keyMap.end(); ++iter)\n        {\n            if (i == 0)\n            {\n                query << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n            else\n            {\n                query << \" and \" << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n            i++;\n        }\n        query << \";\";\n\n        NFLogDebug(NF_LOG_SYSTEMLOG, 0, \"query:{}\", query.str());\n        query.execute();\n        query.reset();\n    NFMYSQLTRYEND(\"modify error\")\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::Insert(const std::string &strTableName, const std::map<std::string, std::string> &keyvalueMap,\n                           std::string &errormsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    mysqlpp::Connection *pConnection = GetConnection();\n    if (nullptr == pConnection)\n    {\n        return -1;\n    }\n    NFMYSQLTRYBEGIN\n        mysqlpp::Query query = pConnection->query();\n        // insert\n        query << \"INSERT INTO \" << strTableName << \"(\";\n        int i = 0;\n        for (auto iter = keyvalueMap.begin(); iter != keyvalueMap.end(); ++iter)\n        {\n            if (i == 0)\n            {\n                query << iter->first;\n            }\n            else\n            {\n                query << \", \" << iter->first;\n            }\n            i++;\n        }\n\n        query << \") VALUES (\";\n        i = 0;\n        for (auto iter = keyvalueMap.begin(); iter != keyvalueMap.end(); ++iter)\n        {\n            if (i == 0)\n            {\n                query << mysqlpp::quote << iter->second;\n            }\n            else\n            {\n                query << \", \" << mysqlpp::quote << iter->second;\n            }\n            i++;\n        }\n\n        query << \");\";\n\n        NFLogDebug(NF_LOG_SYSTEMLOG, 0, \"query:{}\", query.str());\n        query.execute();\n        query.reset();\n    NFMYSQLTRYEND(\"error\")\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::QueryOne(const std::string &strTableName, const std::map<std::string, std::string> &keyMap,\n                             std::map<std::string, std::string> &valueVec, std::string &errormsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    valueVec.clear();\n    mysqlpp::Connection *pConnection = GetConnection();\n    if (nullptr == pConnection)\n    {\n        return -1;\n    }\n    NFMYSQLTRYBEGIN\n        mysqlpp::Query query = pConnection->query();\n        query << \"SELECT * \";\n\n        query << \" FROM \" << strTableName << \" WHERE \";\n        for (auto iter = keyMap.begin(); iter != keyMap.end(); ++iter)\n        {\n            if (iter == keyMap.begin())\n            {\n                query << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n            else\n            {\n                query << \" and \" << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n        }\n        query << \" limit 1;\";\n\n        NFLogDebug(NF_LOG_SYSTEMLOG, 0, \"query:{}\", query.str());\n        //query.execute(); // 官网例子不需要execute\n        mysqlpp::StoreQueryResult xResult = query.store();\n        query.reset();\n\n        if (xResult.empty() || !xResult)\n        {\n            return proto_ff::ERR_CODE_STORESVR_ERRCODE_SELECT_EMPTY;\n        }\n\n        for (size_t i = 0; i < xResult.num_rows(); ++i)\n        {\n            for (size_t j = 0; j < xResult[i].size(); j++)\n            {\n                std::string value;\n                if (!xResult[i][j].is_null())\n                {\n                    xResult[i][j].to_string(value);\n                }\n                valueVec.emplace(xResult.field_name(j), value);\n            }\n        }\n    NFMYSQLTRYEND(\"query error\")\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::QueryOne(const std::string &strTableName, const std::map<std::string, std::string> &keyMap,\n                             const std::vector<std::string> &fieldVec,\n                             std::map<std::string, std::string> &valueVec, std::string &errormsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    valueVec.clear();\n    mysqlpp::Connection *pConnection = GetConnection();\n    if (nullptr == pConnection)\n    {\n        return -1;\n    }\n    NFMYSQLTRYBEGIN\n        mysqlpp::Query query = pConnection->query();\n        query << \"SELECT \";\n        for (auto iter = fieldVec.begin(); iter != fieldVec.end(); ++iter)\n        {\n            if (iter == fieldVec.begin())\n            {\n                query << *iter;\n            }\n            else\n            {\n                query << \",\" << *iter;\n            }\n        }\n\n        query << \" FROM \" << strTableName << \" WHERE \";\n        for (auto iter = keyMap.begin(); iter != keyMap.end(); ++iter)\n        {\n            if (iter == keyMap.begin())\n            {\n                query << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n            else\n            {\n                query << \" and \" << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n        }\n        query << \" limit 1;\";\n\n        NFLogDebug(NF_LOG_SYSTEMLOG, 0, \"query:{}\", query.str());\n\n        //query.execute(); // 官网例子不需要execute\n        mysqlpp::StoreQueryResult xResult = query.store();\n        query.reset();\n\n        if (xResult.empty() || !xResult)\n        {\n            return proto_ff::ERR_CODE_STORESVR_ERRCODE_SELECT_EMPTY;\n        }\n\n        for (size_t i = 0; i < xResult.num_rows(); ++i)\n        {\n            for (size_t j = 0; j < xResult[i].size(); j++)\n            {\n                std::string value;\n                if (!xResult[i][j].is_null())\n                {\n                    xResult[i][j].to_string(value);\n                }\n                valueVec.emplace(xResult.field_name(j), value);\n            }\n        }\n    NFMYSQLTRYEND(\"query error\")\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::QueryMore(const std::string &strTableName, const std::map<std::string, std::string> &keyMap,\n                              const std::vector<std::string> &fieldVec,\n                              std::vector<std::map<std::string, std::string>> &valueVec, std::string &errormsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    valueVec.clear();\n    mysqlpp::Connection *pConnection = GetConnection();\n    if (nullptr == pConnection)\n    {\n        return -1;\n    }\n    NFMYSQLTRYBEGIN\n        mysqlpp::Query query = pConnection->query();\n        query << \"SELECT \";\n        for (std::vector<std::string>::const_iterator iter = fieldVec.begin(); iter != fieldVec.end(); ++iter)\n        {\n            if (iter == fieldVec.begin())\n            {\n                query << *iter;\n            }\n            else\n            {\n                query << \",\" << *iter;\n            }\n        }\n\n        query << \" FROM \" << strTableName << \" WHERE \";\n        for (auto iter = keyMap.begin(); iter != keyMap.end(); ++iter)\n        {\n            if (iter == keyMap.begin())\n            {\n                query << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n            else\n            {\n                query << \" and \" << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n        }\n        query << \";\";\n\n        NFLogDebug(NF_LOG_SYSTEMLOG, 0, \"query:{}\", query.str());\n\n        //query.execute(); // 官网例子不需要execute\n        mysqlpp::StoreQueryResult xResult = query.store();\n        query.reset();\n\n        if (xResult.empty() || !xResult)\n        {\n            return proto_ff::ERR_CODE_STORESVR_ERRCODE_SELECT_EMPTY;\n        }\n\n        for (size_t i = 0; i < xResult.num_rows(); ++i)\n        {\n            valueVec.push_back(std::map<std::string, std::string>());\n            std::map<std::string, std::string> &tmpVec = valueVec.back();\n            for (size_t j = 0; j < xResult[i].size(); j++)\n            {\n                std::string value;\n                if (!xResult[i][j].is_null())\n                {\n                    xResult[i][j].to_string(value);\n                }\n                tmpVec.emplace(xResult.field_name(j), value);\n            }\n        }\n    NFMYSQLTRYEND(\"query error\")\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::Delete(const std::string &strTableName, const std::map<std::string, std::string> &keyMap, std::string &errormsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    mysqlpp::Connection *pConnection = GetConnection();\n    if (nullptr == pConnection)\n    {\n        return -1;\n    }\n    NFMYSQLTRYBEGIN\n        mysqlpp::Query query = pConnection->query();\n        query << \"DELETE FROM \" << strTableName << \" WHERE \";\n        for (auto iter = keyMap.begin(); iter != keyMap.end(); ++iter)\n        {\n            if (iter == keyMap.begin())\n            {\n                query << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n            else\n            {\n                query << \" and \" << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n        }\n        query << \";\";\n\n        NFLogDebug(NF_LOG_SYSTEMLOG, 0, \"query:{}\", query.str());\n        query.execute();\n        query.reset();\n\n    NFMYSQLTRYEND(\"delete error\")\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::Delete(const std::string &strTableName, const std::string &strKeyColName,\n                           const std::string &strKey, std::string &errormsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    mysqlpp::Connection *pConnection = GetConnection();\n    if (nullptr == pConnection)\n    {\n        return -1;\n    }\n    NFMYSQLTRYBEGIN\n        mysqlpp::Query query = pConnection->query();\n        query << \"DELETE FROM \" << strTableName << \" WHERE \" << strKeyColName << \" = \" << mysqlpp::quote << strKey <<\n              \";\";\n\n        NFLogDebug(NF_LOG_SYSTEMLOG, 0, \"query:{}\", query.str());\n\n        query.execute();\n        query.reset();\n\n    NFMYSQLTRYEND(\"delete error\")\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::Delete(const std::string &sql, std::string &errormsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    mysqlpp::Connection *pConnection = GetConnection();\n    if (nullptr == pConnection)\n    {\n        return -1;\n    }\n\n    std::string msg = \"delete error\";\n    try\n    {\n        mysqlpp::Query query = pConnection->query();\n        query << sql << \";\";\n\n        NFLogDebug(NF_LOG_SYSTEMLOG, 0, \"query:{}\", query.str());\n        query.execute();\n        query.reset();\n\n    }\n    catch (mysqlpp::BadQuery er)\n    {\n        errormsg = er.what();\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"BadQuery [{}] Error:{}\", msg, er.what());\n        return -1;\n    }\n    catch (const mysqlpp::BadConversion &er)\n    {\n        errormsg = er.what();\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"BadConversion [{}] Error:{} retrieved data size:{}, actual size:{}\", msg,\n                   er.what(), er.retrieved, er.actual_size);\n        return -1;\n    }\n    catch (const mysqlpp::Exception &er)\n    {\n        errormsg = er.what();\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"mysqlpp::Exception [{}] Error:{}\", msg, er.what());\n        return -1;\n    }\n    catch (...)\n    {\n        errormsg = \"Unknown Error\";\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"std::exception [{}] Error:Error:Unknown\", msg);\n        return -1;\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::Exists(const std::string &strTableName, const std::map<std::string, std::string> &keyMap,\n                           bool &bExit)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    mysqlpp::Connection *pConnection = GetConnection();\n    if (nullptr == pConnection)\n    {\n        return -1;\n    }\n\n    if (keyMap.empty())\n    {\n        bExit = false;\n        return 0;\n    }\n\n    std::string errormsg;\n    NFMYSQLTRYBEGIN\n        mysqlpp::Query query = pConnection->query();\n        query << \"SELECT 1 FROM \" << strTableName << \" WHERE \";\n        int i = 0;\n        for (auto iter = keyMap.begin(); iter != keyMap.end(); ++iter)\n        {\n            if (i == 0)\n            {\n                query << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n            else\n            {\n                query << \" and \" << iter->first << \" = \" << mysqlpp::quote << iter->second;\n            }\n            i++;\n        }\n        query << \" limit 1;\";\n\n        NFLogDebug(NF_LOG_SYSTEMLOG, 0, \"query:{}\", query.str());\n\n        //query.execute();\n        mysqlpp::StoreQueryResult result = query.store();\n        query.reset();\n\n        if (!result || result.empty())\n        {\n            bExit = false;\n            return 0;\n        }\n\n    NFMYSQLTRYEND(\"exist error\")\n\n    bExit = true;\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::Exists(const std::string &strTableName, const std::string &strKeyColName,\n                           const std::string &strKey, bool &bExit)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    mysqlpp::Connection *pConnection = GetConnection();\n    if (nullptr == pConnection)\n    {\n        return -1;\n    }\n    std::string errormsg;\n    NFMYSQLTRYBEGIN\n        mysqlpp::Query query = pConnection->query();\n        query << \"SELECT 1 FROM \" << strTableName << \" WHERE \" << strKeyColName << \" = \" << mysqlpp::quote << strKey <<\n              \" LIMIT 1;\";\n\n        mysqlpp::StoreQueryResult result = query.store();\n        query.reset();\n\n        if (!result || result.empty())\n        {\n            bExit = false;\n            return 0;\n        }\n\n    NFMYSQLTRYEND(\"exist error\")\n\n    bExit = true;\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::InsertObj(const std::string &tbName, const google::protobuf::Message *pMessage, std::string &errMsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    CHECK_EXPR(pMessage, -1, \"pMessage == NULL\");\n\n    storesvr_sqldata::storesvr_insertobj select;\n    select.mutable_baseinfo()->set_tbname(tbName);\n    select.set_ins_record(pMessage->SerializeAsString());\n\n    storesvr_sqldata::storesvr_insertobj_res select_res;\n    int iRet = InsertObj(select, select_res);\n    if (iRet != 0)\n    {\n        errMsg = select_res.ins_opres().errmsg();\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\nint NFCMysqlDriver::InsertObj(const storesvr_sqldata::storesvr_insertobj &select,\n                              storesvr_sqldata::storesvr_insertobj_res &select_res)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    int iRet = 0;\n    std::map<std::string, std::string> resultMap;\n    iRet = CreateSql(select, resultMap);\n    CHECK_EXPR(iRet == 0, -1, \"CreateSql Failed\");\n\n    *select_res.mutable_baseinfo() = select.baseinfo();\n    select_res.mutable_ins_opres()->set_mod_key(select.mod_key());\n    std::string errmsg;\n    iRet = Insert(select.baseinfo().tbname(), resultMap, errmsg);\n    if (iRet != 0)\n    {\n        select_res.mutable_ins_opres()->set_errmsg(errmsg);\n        return iRet;\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint\nNFCMysqlDriver::CreateSql(const storesvr_sqldata::storesvr_insertobj &select, std::map<std::string, std::string> &resultMap)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string tableName = select.baseinfo().clname();\n    CHECK_EXPR(tableName.size() > 0, -1, \"talbeName empty!\");\n\n    std::string packageName = select.baseinfo().package_name();\n\n    std::string full_name;\n    if (packageName.empty())\n    {\n        full_name = DEFINE_DEFAULT_PROTO_PACKAGE_ADD + tableName;\n    }\n    else {\n        full_name = packageName + \".\" + tableName;\n    }\n    google::protobuf::Message *pMessageObject = NFProtobufCommon::Instance()->CreateDynamicMessageByName(full_name);\n    CHECK_EXPR(pMessageObject, -1, \"NFProtobufCommon::CreateMessageByName:{} Failed\", full_name);\n    CHECK_EXPR(pMessageObject->ParsePartialFromString(select.ins_record()), -1, \"ParsePartialFromString Failed:{}\", full_name);\n\n    NFProtobufCommon::GetMapFieldsFromMessage(*pMessageObject, resultMap, false, false);\n    delete pMessageObject;\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::ModifyObj(const std::string &tbName, const google::protobuf::Message *pMessage, std::string &errMsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    CHECK_EXPR(pMessage, -1, \"pMessage == NULL\");\n\n    storesvr_sqldata::storesvr_modobj select;\n    select.mutable_baseinfo()->set_tbname(tbName);\n    select.set_mod_record(pMessage->SerializeAsString());\n\n    storesvr_sqldata::storesvr_modobj_res select_res;\n    int iRet = ModifyObj(select, select_res);\n    if (iRet != 0)\n    {\n        errMsg = select_res.mod_opres().errmsg();\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\nint NFCMysqlDriver::ModifyByCond(const storesvr_sqldata::storesvr_mod &select, storesvr_sqldata::storesvr_mod_res &select_res)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    int iRet = 0;\n    std::map<std::string, std::string> keyMap;\n    std::map<std::string, std::string> keyValueMap;\n    iRet = CreateSql(select, keyMap, keyValueMap);\n    CHECK_EXPR(iRet == 0, -1, \"CreateSql Failed\");\n\n    std::string where;\n    CreateSql(select, where);\n\n    *select_res.mutable_baseinfo() = select.baseinfo();\n    select_res.mutable_mod_opres()->set_mod_key(select.mod_cond().mod_key());\n    std::string errmsg;\n    iRet = Modify(select.baseinfo().tbname(), where, keyValueMap, errmsg);\n    if (iRet != 0)\n    {\n        select_res.mutable_mod_opres()->set_errmsg(errmsg);\n        return iRet;\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\n\nint NFCMysqlDriver::ModifyObj(const storesvr_sqldata::storesvr_modobj &select,\n                              storesvr_sqldata::storesvr_modobj_res &select_res)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    int iRet = 0;\n    std::map<std::string, std::string> keyMap;\n    std::map<std::string, std::string> keyValueMap;\n    iRet = CreateSql(select, keyMap, keyValueMap);\n    CHECK_EXPR(iRet == 0, -1, \"CreateSql Failed\");\n\n    *select_res.mutable_baseinfo() = select.baseinfo();\n    select_res.mutable_mod_opres()->set_mod_key(select.mod_key());\n    std::string errmsg;\n    iRet = Modify(select.baseinfo().tbname(), keyMap, keyValueMap, errmsg);\n    if (iRet != 0)\n    {\n        select_res.mutable_mod_opres()->set_errmsg(errmsg);\n        return iRet;\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::CreateSql(const storesvr_sqldata::storesvr_mod &select, std::map<std::string, std::string> &keyMap,\n                              std::map<std::string, std::string> &kevValueMap)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string tableName = select.baseinfo().clname();\n    CHECK_EXPR(tableName.size() > 0, -1, \"talbeName empty!\");\n    std::string packageName = select.baseinfo().package_name();\n\n    std::string full_name;\n    if (packageName.empty())\n    {\n        full_name = DEFINE_DEFAULT_PROTO_PACKAGE_ADD + tableName;\n    }\n    else {\n        full_name = packageName + \".\" + tableName;\n    }\n    google::protobuf::Message *pMessageObject = NFProtobufCommon::Instance()->CreateDynamicMessageByName(full_name);\n    CHECK_EXPR(pMessageObject, -1, \"NFProtobufCommon::CreateMessageByName:{} Failed\", full_name);\n    CHECK_EXPR(pMessageObject->ParsePartialFromString(select.mod_record()), -1, \"ParsePartialFromString Failed:{}\", full_name);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"CreateSql From message:{}\", pMessageObject->DebugString());\n\n    NFProtobufCommon::GetMapFieldsFromMessage(*pMessageObject, keyMap, kevValueMap, false);\n    delete pMessageObject;\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::CreateSql(const storesvr_sqldata::storesvr_update &select, std::map<std::string, std::string> &keyMap,\n                              std::map<std::string, std::string> &kevValueMap)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string tableName = select.baseinfo().clname();\n    CHECK_EXPR(tableName.size() > 0, -1, \"talbeName empty!\");\n    std::string packageName = select.baseinfo().package_name();\n\n    std::string full_name;\n    if (packageName.empty())\n    {\n        full_name = DEFINE_DEFAULT_PROTO_PACKAGE_ADD + tableName;\n    }\n    else {\n        full_name = packageName + \".\" + tableName;\n    }\n    google::protobuf::Message *pMessageObject = NFProtobufCommon::Instance()->CreateDynamicMessageByName(full_name);\n    CHECK_EXPR(pMessageObject, -1, \"NFProtobufCommon::CreateMessageByName:{} Failed\", full_name);\n    CHECK_EXPR(pMessageObject->ParsePartialFromString(select.mod_record()), -1, \"ParsePartialFromString Failed:{}\", full_name);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"CreateSql From message:{}\", pMessageObject->DebugString());\n\n    NFProtobufCommon::GetMapFieldsFromMessage(*pMessageObject, keyMap, kevValueMap, false);\n    delete pMessageObject;\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::CreateSql(const storesvr_sqldata::storesvr_modobj &select, std::map<std::string, std::string> &keyMap,\n                              std::map<std::string, std::string> &kevValueMap)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string tableName = select.baseinfo().clname();\n    CHECK_EXPR(tableName.size() > 0, -1, \"talbeName empty!\");\n    std::string packageName = select.baseinfo().package_name();\n\n    std::string full_name;\n    if (packageName.empty())\n    {\n        full_name = DEFINE_DEFAULT_PROTO_PACKAGE_ADD + tableName;\n    }\n    else {\n        full_name = packageName + \".\" + tableName;\n    }\n    google::protobuf::Message *pMessageObject = NFProtobufCommon::Instance()->CreateDynamicMessageByName(full_name);\n    CHECK_EXPR(pMessageObject, -1, \"NFProtobufCommon::CreateMessageByName:{} Failed\", full_name);\n    CHECK_EXPR(pMessageObject->ParsePartialFromString(select.mod_record()), -1, \"ParsePartialFromString Failed:{}\", full_name);\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"CreateSql From message:{}\", pMessageObject->DebugString());\n\n    NFProtobufCommon::GetMapFieldsFromMessage(*pMessageObject, keyMap, kevValueMap, false);\n    delete pMessageObject;\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::UpdateObj(const std::string &tbName, const google::protobuf::Message *pMessage, std::string &errMsg)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    CHECK_EXPR(pMessage, -1, \"pMessage == NULL\");\n\n    storesvr_sqldata::storesvr_updateobj select;\n    select.mutable_baseinfo()->set_tbname(tbName);\n    select.set_modins_record(pMessage->SerializeAsString());\n\n    storesvr_sqldata::storesvr_updateobj_res select_res;\n    int iRet = UpdateObj(select, select_res);\n    if (iRet != 0)\n    {\n        errMsg = select_res.modins_opres().errmsg();\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\nint NFCMysqlDriver::UpdateByCond(const storesvr_sqldata::storesvr_update &select, storesvr_sqldata::storesvr_update_res &select_res)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    int iRet = 0;\n    std::map<std::string, std::string> keyMap;\n    std::map<std::string, std::string> keyValueMap;\n    iRet = CreateSql(select, keyMap, keyValueMap);\n    CHECK_EXPR(iRet == 0, -1, \"CreateSql Failed\");\n\n    std::string where;\n    CreateSql(select, where);\n\n    *select_res.mutable_baseinfo() = select.baseinfo();\n    select_res.mutable_mod_opres()->set_mod_key(select.mod_cond().mod_key());\n    std::string errmsg;\n    iRet = Modify(select.baseinfo().tbname(), where, keyValueMap, errmsg);\n    if (iRet != 0)\n    {\n        select_res.mutable_mod_opres()->set_errmsg(errmsg);\n        return iRet;\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::UpdateObj(const storesvr_sqldata::storesvr_updateobj &select,\n                              storesvr_sqldata::storesvr_updateobj_res &select_res)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    int iRet = 0;\n    std::map<std::string, std::string> keyMap;\n    std::map<std::string, std::string> keyValueMap;\n    iRet = CreateSql(select, keyMap, keyValueMap);\n    CHECK_EXPR(iRet == 0, -1, \"CreateSql Failed\");\n\n    *select_res.mutable_baseinfo() = select.baseinfo();\n    select_res.mutable_modins_opres()->set_mod_key(select.mod_key());\n    std::string errmsg;\n    iRet = Update(select.baseinfo().tbname(), keyMap, keyValueMap, errmsg);\n    if (iRet != 0)\n    {\n        select_res.mutable_modins_opres()->set_errmsg(errmsg);\n        return iRet;\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint\nNFCMysqlDriver::CreateSql(const storesvr_sqldata::storesvr_updateobj &select, std::map<std::string, std::string> &keyMap,\n                          std::map<std::string, std::string> &kevValueMap)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string tableName = select.baseinfo().clname();\n    CHECK_EXPR(tableName.size() > 0, -1, \"talbeName empty!\");\n    std::string packageName = select.baseinfo().package_name();\n\n    std::string full_name;\n    if (packageName.empty())\n    {\n        full_name = DEFINE_DEFAULT_PROTO_PACKAGE_ADD + tableName;\n    }\n    else {\n        full_name = packageName + \".\" + tableName;\n    }\n    google::protobuf::Message *pMessageObject = NFProtobufCommon::Instance()->CreateDynamicMessageByName(full_name);\n    CHECK_EXPR(pMessageObject, -1, \"NFProtobufCommon::CreateMessageByName:{} Failed\", full_name);\n    CHECK_EXPR(pMessageObject->ParsePartialFromString(select.modins_record()), -1, \"ParsePartialFromString Failed:{}\", full_name);\n\n    NFProtobufCommon::GetMapFieldsFromMessage(*pMessageObject, keyMap, kevValueMap, false);\n    delete pMessageObject;\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return 0;\n}\n\nint NFCMysqlDriver::ExistsDB(const std::string &dbName, bool &bExit)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    int iRet = Exists(\"information_schema.SCHEMATA\", \"SCHEMA_NAME\", dbName, bExit);\n    if (iRet != 0)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"ExistsDB Error, dbName:{}\", dbName);\n    }\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\n/**\n * @brief 创建数据库\n * @param dbName\n * @return\n */\nint NFCMysqlDriver::CreateDB(const std::string &dbName)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string errormsg;\n    int iRet = 0;\n    NFMYSQLTRYBEGIN\n        mysqlpp::Connection *pConnection = GetConnection();\n        if (nullptr == pConnection)\n        {\n            iRet = -1;\n        }\n        else\n        {\n            if (pConnection->create_db(dbName) == false)\n            {\n                iRet = -1;\n            }\n        }\n    NFMYSQLTRYEND(\"error\")\n\n    if (iRet != 0)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"create db failed, dbName:{} errMsg:{}\", dbName, errormsg);\n    }\n    else {\n        NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"Create Database:{} Success\", dbName);\n    }\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\n/**\n * @brief 选择数据库\n * @param dbName\n * @return\n */\nint NFCMysqlDriver::SelectDB(const std::string &dbName)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::string errormsg;\n    int iRet = 0;\n    NFMYSQLTRYBEGIN\n        mysqlpp::Connection *pConnection = GetConnection();\n        if (nullptr == pConnection)\n        {\n            iRet = -1;\n        }\n        else\n        {\n            if (pConnection->select_db(dbName) == false)\n            {\n                iRet = -1;\n            }\n        }\n    NFMYSQLTRYEND(\"error\")\n\n    if (iRet != 0)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"create db failed, dbName:{} errMsg:{}\", dbName, errormsg);\n    }\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\n/**\n * @brief 是否存在表格\n * @param tableName\n * @return\n */\nint NFCMysqlDriver::ExistTable(const std::string &dbName, const std::string &tableName, bool &bExit)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::map<std::string, std::string> keyMap;\n    keyMap.emplace(\"TABLE_SCHEMA\", dbName);\n    keyMap.emplace(\"TABLE_NAME\", tableName);\n    int iRet = Exists(\"information_schema.TABLES\", keyMap, bExit);\n    if (iRet != 0)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"ExistTable Error, dbName:{}, tableName:{}\", dbName, tableName);\n    }\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\n\nint NFCMysqlDriver::GetTableColInfo(const std::string &dbName, const std::string &tableName, std::map<std::string, DBTableColInfo> &col)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    std::map<std::string, std::string> keyMap;\n    keyMap.emplace(\"table_schema\", dbName);\n    keyMap.emplace(\"TABLE_NAME\", tableName);\n    std::vector<std::string> fieldVec;\n    fieldVec.push_back(\"column_name\");\n    fieldVec.push_back(\"data_type\");\n    fieldVec.push_back(\"column_type\");\n    fieldVec.push_back(\"CHARACTER_MAXIMUM_LENGTH\");\n    fieldVec.push_back(\"column_key\");\n    std::vector<std::map<std::string, std::string>> valueVec;\n    std::string errorMsg;\n    int iRet = QueryMore(\"information_schema.COLUMNS\", keyMap, fieldVec, valueVec, errorMsg);\n    if (iRet != 0)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"QueryMore Error, dbName:{}, tableName:{} errorMsg:{}\", dbName, tableName, errorMsg);\n        return iRet;\n    }\n\n    for (int i = 0; i < (int) valueVec.size(); i++)\n    {\n        std::map<std::string, std::string> &colData = valueVec[i];\n        std::string fields = colData[\"column_name\"];\n        std::string strDataType = colData[\"data_type\"];\n        std::string strColumnType = colData[\"column_type\"];\n        std::string charMax = colData[\"CHARACTER_MAXIMUM_LENGTH\"];\n        std::string columnKey = colData[\"column_key\"];\n        DBTableColInfo colInfo;\n        colInfo.m_colType = NFProtobufCommon::GetPBDataTypeFromDBDataType(strDataType, strColumnType);\n        if (colInfo.m_colType == google::protobuf::FieldDescriptor::CPPTYPE_STRING)\n        {\n            colInfo.m_bufsize = NFCommon::strto<uint32_t>(charMax);\n            if (colInfo.m_bufsize >= 1024)\n            {\n                colInfo.m_bufsize = 1024;\n            }\n        }\n\n        if (columnKey == \"PRI\")\n        {\n            colInfo.m_primaryKey = true;\n        }\n        else if (columnKey == \"UNI\")\n        {\n            colInfo.m_unionKey = true;\n        }\n        else if (columnKey == \"MUL\")\n        {\n            colInfo.m_indexKey = true;\n        }\n\n\n        col[fields] = colInfo;\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\n/**\n * @brief 查询表格信息\n * @param tableName\n * @param pTableMessage\n * @param needCreateColumn\n * @return\n */\nint NFCMysqlDriver::QueryTableInfo(const std::string &dbName, const std::string &tableName, bool &bExit,\n                                   std::map<std::string, DBTableColInfo> &primaryKey, std::multimap<uint32_t, std::string> &needCreateColumn)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    int iRet = ExistTable(dbName, tableName, bExit);\n    if (iRet != 0)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"QueryTableInfo Error, dbName:{}, tableName:{}\", dbName, tableName);\n        return iRet;\n    }\n\n    std::string full_name = DEFINE_DEFAULT_PROTO_PACKAGE_ADD + tableName;\n    const google::protobuf::Descriptor *pDescriptor = NFProtobufCommon::Instance()->FindDynamicMessageTypeByName(full_name);\n    CHECK_EXPR(pDescriptor, -1, \"NFProtobufCommon::FindDynamicMessageTypeByName:{} Failed\", full_name);\n\n    std::map<std::string, DBTableColInfo> mapFields;\n    iRet = NFProtobufCommon::Instance()->GetDbFieldsInfoFromMessage(pDescriptor, primaryKey, mapFields);\n    if (iRet != 0)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetDbFieldsInfoFromMessage Error, dbName:{}, tableName:{}\", dbName, tableName);\n        return iRet;\n    }\n\n    std::map<std::string, DBTableColInfo> colData;\n    if (bExit)\n    {\n        iRet = GetTableColInfo(dbName, tableName, colData);\n        if (iRet != 0)\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetTableColInfo Error, dbName:{}, tableName:{}\", dbName, tableName);\n            return iRet;\n        }\n\n        for (auto iter = primaryKey.begin(); iter != primaryKey.end(); iter++)\n        {\n            auto findIter = colData.find(iter->first);\n            if (findIter != colData.end())\n            {\n                if (findIter->second.m_colType != iter->second.m_colType)\n                {\n                    NFLogError(NF_LOG_SYSTEMLOG, 0,\n                               \"dbName:{}, tableName:{} Exist Col:{}, but the db col data type:{} is not equal protobuf data type:{}, please check\",\n                               dbName, tableName, iter->first, findIter->second.m_colType, iter->second.m_colType);\n                }\n                else {\n                    std::string sql;\n\n                    if (findIter->second.m_primaryKey == true && iter->second.m_primaryKey == false)\n                    {\n                        sql.clear();\n                        NF_FORMAT_EXPR(sql, \"alter table {} DROP PRIMARY KEY;\", tableName);\n                        if (sql.size() > 0)\n                            needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n                    }\n\n                    if (findIter->second.m_primaryKey == false && iter->second.m_primaryKey == true)\n                    {\n                        sql.clear();\n                        NF_FORMAT_EXPR(sql, \"alter table {} add PRIMARY KEY ({});\", tableName, iter->first);\n                        if (sql.size() > 0)\n                            needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n                    }\n                }\n            }\n            else\n            {\n                std::string otherInfo;\n                if (iter->second.m_notNull)\n                {\n                    otherInfo += \" NOT NULL \";\n                }\n\n                if (iter->second.m_autoIncrement)\n                {\n                    otherInfo += \" AUTO_INCREMENT \";\n                }\n\n                if (iter->second.m_isDefaultValue)\n                {\n                    otherInfo += \" Default = \" + NFCommon::tostr(iter->second.m_defaultValue);\n                }\n\n                if (iter->second.m_comment.size() > 0)\n                {\n                    otherInfo += \" COMMENT \\\"\" + iter->second.m_comment + \"\\\"\";\n                }\n\n                std::string sql;\n                NF_FORMAT_EXPR(sql, \"alter table {} add column {} {} {};\", tableName, iter->first,\n                               NFProtobufCommon::GetDBDataTypeFromPBDataType(iter->second.m_colType, iter->second.m_bufsize), otherInfo);\n\n                if (sql.size() > 0)\n                    needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n\n                if (findIter->second.m_primaryKey)\n                {\n                    sql.clear();\n                    NF_FORMAT_EXPR(sql, \"alter table {} add PRIMARY KEY {};\", tableName, iter->first);\n                    if (sql.size() > 0)\n                        needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n                }\n            }\n        }\n    }\n\n    for (auto iter = mapFields.begin(); iter != mapFields.end(); iter++)\n    {\n        auto findIter = colData.find(iter->first);\n        if (findIter != colData.end())\n        {\n            if (findIter->second.m_colType != iter->second.m_colType)\n            {\n                NFLogError(NF_LOG_SYSTEMLOG, 0,\n                           \"dbName:{}, tableName:{} Exist Col:{}, but the db col data type:{} is not equal protobuf data type:{}, please check\",\n                           dbName, tableName, iter->first, findIter->second.m_colType, iter->second.m_colType);\n            }\n            else\n            {\n                std::string sql;\n\n                if (findIter->second.m_primaryKey == true && iter->second.m_primaryKey == false)\n                {\n                    sql.clear();\n                    NF_FORMAT_EXPR(sql, \"alter table {} DROP PRIMARY KEY;\", tableName);\n                    if (sql.size() > 0)\n                        needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n                }\n\n                if (findIter->second.m_unionKey == true && iter->second.m_unionKey == false)\n                {\n                    sql.clear();\n                    NF_FORMAT_EXPR(sql, \"alter table {} DROP INDEX {};\", tableName, iter->first);\n                    if (sql.size() > 0)\n                        needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n                }\n\n                if (findIter->second.m_indexKey == true && iter->second.m_indexKey == false)\n                {\n                    sql.clear();\n                    NF_FORMAT_EXPR(sql, \"alter table {} DROP INDEX {};\", tableName, iter->first);\n                    if (sql.size() > 0)\n                        needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n                }\n\n                if (findIter->second.m_primaryKey == false && iter->second.m_primaryKey == true)\n                {\n                    sql.clear();\n                    NF_FORMAT_EXPR(sql, \"alter table {} add PRIMARY KEY ({});\", tableName, iter->first);\n                    if (sql.size() > 0)\n                        needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n                }\n\n                if (findIter->second.m_unionKey == false && iter->second.m_unionKey == true)\n                {\n                    sql.clear();\n                    NF_FORMAT_EXPR(sql, \"alter table {} add UNIQUE {} ({});\", tableName, iter->first, iter->first);\n                    if (sql.size() > 0)\n                        needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n                }\n\n                if (findIter->second.m_indexKey == false && iter->second.m_indexKey == true)\n                {\n                    sql.clear();\n                    NF_FORMAT_EXPR(sql, \"alter table {} add INDEX {} ({});\", tableName, iter->first, iter->first);\n                    if (sql.size() > 0)\n                        needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n                }\n            }\n        }\n        else\n        {\n\n            std::string otherInfo;\n            if (iter->second.m_notNull)\n            {\n                otherInfo += \" NOT NULL \";\n            }\n\n            if (iter->second.m_isDefaultValue)\n            {\n                otherInfo += \" Default = \" + NFCommon::tostr(iter->second.m_defaultValue);\n            }\n\n            if (iter->second.m_comment.size() > 0)\n            {\n                otherInfo += \" COMMENT \\\"\" + iter->second.m_comment + \"\\\"\";\n            }\n\n            std::string sql;\n            NF_FORMAT_EXPR(sql, \"alter table {} add column {} {} {};\", tableName, iter->first,\n                           NFProtobufCommon::GetDBDataTypeFromPBDataType(iter->second.m_colType, iter->second.m_bufsize), otherInfo);\n\n            if (sql.size() > 0)\n                needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n\n            if (iter->second.m_primaryKey)\n            {\n                sql.clear();\n                NF_FORMAT_EXPR(sql, \"alter table {} add PRIMARY KEY ({});\", tableName, iter->first);\n                if (sql.size() > 0)\n                    needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n            }\n\n            if (iter->second.m_unionKey)\n            {\n                sql.clear();\n                NF_FORMAT_EXPR(sql, \"alter table {} add UNIQUE {} ({});\", tableName, iter->first, iter->first);\n                if (sql.size() > 0)\n                    needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n            }\n\n            if (iter->second.m_indexKey)\n            {\n                sql.clear();\n                NF_FORMAT_EXPR(sql, \"alter table {} add INDEX {} ({});\", tableName, iter->first, iter->first);\n                if (sql.size() > 0)\n                    needCreateColumn.emplace(iter->second.m_fieldIndex, sql);\n            }\n        }\n    }\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\nint NFCMysqlDriver::CreateTable(const std::string &tableName, const std::map<std::string, DBTableColInfo>& primaryKey, const std::multimap<uint32_t, std::string> &needCreateColumn)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    int iRet = 0;\n    std::string sql;\n    std::string colSql;\n    std::string privateKey = \"PRIMARY KEY(\";\n    std::string auto_increment;\n\n    for(auto iter = primaryKey.begin(); iter != primaryKey.end(); iter++)\n    {\n        if (iter == primaryKey.begin())\n        {\n            privateKey += iter->first;\n        }\n        else {\n            privateKey += \",\"+iter->first;\n        }\n\n        std::string col;\n        std::string otherInfo;\n        if (iter->second.m_notNull)\n        {\n            otherInfo += \" NOT NULL \";\n        }\n\n        if (iter->second.m_autoIncrement)\n        {\n            otherInfo += \" AUTO_INCREMENT \";\n            auto_increment = \"AUTO_INCREMENT = \" + NFCommon::tostr(iter->second.m_autoIncrementValue);\n        }\n\n        if (iter->second.m_isDefaultValue)\n        {\n            otherInfo += \" Default = \" + NFCommon::tostr(iter->second.m_defaultValue);\n        }\n\n        if (iter->second.m_comment.size() > 0)\n        {\n            otherInfo += \" COMMENT \\\"\" + iter->second.m_comment + \"\\\"\";\n        }\n        NF_FORMAT_EXPR(col, \" {} {} {},\", iter->first, NFProtobufCommon::GetDBDataTypeFromPBDataType(iter->second.m_colType, iter->second.m_bufsize), otherInfo)\n        colSql += col;\n    }\n    privateKey += \")\";\n\n    NF_FORMAT_EXPR(sql, \"CREATE TABLE IF NOT EXISTS {} ({} {}) ENGINE=InnoDB {} DEFAULT CHARSET=utf8;\", tableName, colSql, privateKey, auto_increment);\n\n    std::map<std::string, std::string> mapValue;\n    std::string errMsg;\n    iRet = ExecuteOne(sql, mapValue, errMsg);\n    if (iRet != 0)\n    {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"executeone sql:{} fail, err:{}\", sql, errMsg);\n    }\n    else {\n        NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"Create Table Success! sql:{}\", sql);\n    }\n\n   for(auto iter = needCreateColumn.begin(); iter != needCreateColumn.end(); iter++)\n   {\n       iRet = ExecuteOne(iter->second, mapValue, errMsg);\n       if (iRet != 0)\n       {\n           NFLogError(NF_LOG_SYSTEMLOG, 0, \"executeone sql:{} fail, err:{}\", iter->second, errMsg);\n           return iRet;\n       }\n       else {\n           NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"add Table Col Success! sql:{}\", iter->second);\n       }\n   }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}\n\nint NFCMysqlDriver::AddTableRow(const std::string& tableName, const std::multimap<uint32_t, std::string>& needCreateColumn)\n{\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- begin --\");\n    int iRet = 0;\n\n    std::map<std::string, std::string> mapValue;\n    std::string errMsg;\n    for(auto iter = needCreateColumn.begin(); iter != needCreateColumn.end(); iter++)\n    {\n        iRet = ExecuteOne(iter->second, mapValue, errMsg);\n        if (iRet != 0)\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"executeone sql:{} fail, err:{}\", iter->second, errMsg);\n            return iRet;\n        }\n        else {\n            NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"add Table Col Success! sql:{}\", iter->second);\n        }\n    }\n\n    NFLogTrace(NF_LOG_SYSTEMLOG, 0, \"-- end --\");\n    return iRet;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/NFCommPlugin/NFKernelPlugin/NFCMysqlDriver.cpp b/src/NFCommPlugin/NFKernelPlugin/NFCMysqlDriver.cpp
--- a/src/NFCommPlugin/NFKernelPlugin/NFCMysqlDriver.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/src/NFCommPlugin/NFKernelPlugin/NFCMysqlDriver.cpp	(date 1688626846675)
@@ -1564,17 +1564,24 @@
     NFMYSQLTRYBEGIN
         mysqlpp::Query query = pConnection->query();
         query << "SELECT ";
-        for (auto iter = fieldVec.begin(); iter != fieldVec.end(); ++iter)
-        {
-            if (iter == fieldVec.begin())
-            {
-                query << *iter;
-            }
-            else
-            {
-                query << "," << *iter;
+        if (fieldVec.size() > 0)
+        {
+            for (auto iter = fieldVec.begin(); iter != fieldVec.end(); ++iter)
+            {
+                if (iter == fieldVec.begin())
+                {
+                    query << *iter;
+                }
+                else
+                {
+                    query << "," << *iter;
+                }
             }
         }
+        else {
+            query << "*";
+        }
+
 
         query << " FROM " << strTableName << " WHERE ";
         for (auto iter = keyMap.begin(); iter != keyMap.end(); ++iter)
Index: game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFWorldPlayer.h\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFWorldPlayer.h\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFLogicCommon/NFLogicCommonDefine.h\"\n#include \"NFWorldCommonDefine.h\"\n#include \"NFWorldRoleInfo.h\"\n#include \"NFLogicCommon/NFAccountDefine.h\"\n#include \"NFComm/NFShmStl/NFShmHashMap.h\"\n#include \"DBProto.pb.h\"\n\nclass NFWorldPlayer : public NFShmObj\n{\npublic:\n    NFWorldPlayer();\n\n    virtual ~NFWorldPlayer();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    void Tick();\n\n    virtual int OnTimer(int timeId, int callcount);\n\npublic:\n    /**\n     * @brief 玩家发信息到网关\n     * @param msgId\n     * @param xData\n     */\n    void SendMsgToProxyServer(uint32_t msgId, const google::protobuf::Message &xData);\n\n    /**\n     * @brief 玩家发信息到网关\n     * @param msgId\n     * @param xData\n     */\n    void SendMsgToClient(uint32_t msgId, const google::protobuf::Message &xData);\n\n    /**\n     * @brief\n     * @param moduleId\n     * @param msgId\n     * @param xData\n     */\n    void SendMsgToLogicServer(uint32_t msgId, const google::protobuf::Message &xData);\n    void SendTransToLogicServer(uint32_t msgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0, uint32_t rsp_trans_id = 0);\n\n    /**\n     * @brief\n     * @param moduleId\n     * @param msgId\n     * @param xData\n     */\n    void SendMsgToSnsServer(uint32_t msgId, const google::protobuf::Message &xData);\n    void SendTransToSnsServer(uint32_t msgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0, uint32_t rsp_trans_id = 0);\n\n    /**\n     * @brief\n     * @param msgId\n     * @param xData\n     */\n    void SendMsgToGameServer(uint32_t msgId, const google::protobuf::Message &xData);\n    void SendTransToGameServer(uint32_t msgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0, uint32_t rsp_trans_id = 0);\npublic:\n    /**\n     * @brief\n     * @return\n     */\n    uint64_t GetUid() const;\n\n    /**\n     * @brief\n     * @param uid\n     */\n    void SetUid(uint64_t uid);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint32_t GetProxyId() const;\n\n    /**\n     * @brief\n     * @param proxyId\n     */\n    void SetProxyId(uint32_t proxyId);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint64_t GetClientId() const;\n\n    /**\n     * @brief\n     * @param clientId\n     */\n    void SetClientId(uint64_t clientId);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint32_t GetLogicId() const;\n\n    /**\n     * @brief\n     * @param logicId\n     */\n    void SetLogicId(uint32_t logicId);\n\n    /**\n     * @brief\n     * @return\n     */\n    PLAYER_STATUS GetStatus() const;\n\n    /**\n     * @brief\n     * @param status\n     */\n    void SetStatus(PLAYER_STATUS status);\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual PLAYER_SCENE_STATE GetSceneStatus() const;\n\n    /**\n     * @brief\n     * @param status\n     */\n    virtual void SetSceneStatus(PLAYER_SCENE_STATE status);\n\n    virtual bool IsInTransSceneing();\n\n    /**\n     * @brief\n     * @return\n     */\n    uint64_t GetCreateTime() const;\n\n    /**\n     * @brief\n     * @param createTime\n     */\n    void SetCreateTime(uint64_t createTime);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint64_t GetLastDiconnectTime() const;\n\n    /**\n     * @brief\n     * @param lastDiconnectTime\n     */\n    void SetLastDiconnectTime(uint64_t lastDiconnectTime);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint64_t GetLastLogoutTime() const;\n\n    /**\n     * @brief\n     * @param lastLogoutTime\n     */\n    void SetLastLogoutTime(uint64_t lastLogoutTime);\n\npublic:\n    /**\n     * @brief\n     * @return\n     */\n    bool IsDisconnect() const;\n\n    /**\n     * @brief\n     * @param isDisConnect\n     */\n    void SetIsDisconnect(bool isDisConnect);\n\n    /**\n     * @brief\n     * @return\n     */\n    const string &GetToken() const;\n\n    /**\n     * @brief\n     * @param token\n     */\n    void SetToken(const string &token);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint64_t GetTokenTimeStamp() const;\n\n    /**\n     * @brief\n     * @param tokenTimeStamp\n     */\n    void SetTokenTimeStamp(uint64_t tokenTimeStamp);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint64_t GetRoleId() const;\n\n    /**\n     * @brief\n     * @param playCid\n     */\n    void SetRoleId(uint64_t playCid);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint32_t GetChannelId() const;\n\n    /**\n     * @brief\n     * @param channelId\n     */\n    void SetChannelId(uint32_t channelId);\n\n    /**\n     * @brief\n     * @return\n     */\n    uint32_t GetLoginZid() const;\n\n    /**\n     * @brief\n     * @param zid\n     */\n    void SetLoginZid(uint32_t zid);\n\n    /**\n     * @brief\n     * @return\n     */\n    bool IsWhite() const;\n\n    /**\n     * @brief\n     * @param isWhite\n     */\n    void SetIsWhite(bool isWhite);\n\n    uint32_t GetCharNum() const;\n\n    void SetCharNum(uint32_t charNum);\n\n    uint32_t GetGameId() const;\n\n    void SetGameId(uint32_t gameId);\n\npublic:\n    NFWorldRoleInfo *GetRoleInfo(uint64_t roleId);\n\n    NFWorldRoleInfo *CreateRoleInfo(uint64_t roleId);\n\n    int DeleteRoleInfo(uint64_t roleId);\n\n    void ClearRoleInfo();\n\n    NFShmHashMap<uint64_t, NFWorldRoleInfo, MAX_ROLE_NUM>& GetAllRoleInfo() { return m_roleInfo; }\npublic:\n    int OnDisconnect();\nprivate:\n    /**\n     * @brief\n     */\n    uint64_t m_uid;\n\n    /**\n     * @brief\n     */\n    uint32_t m_proxyId;\n\n    /**\n     * @brief\n     */\n    uint64_t m_clientId;\n\n    /**\n     * @brief\n     */\n    uint32_t m_logicId;\n\n    /**\n     * @brief\n     */\n    uint32_t m_gameId;\n\n\nprivate:\n\n    /**\n     * @brief\n     */\n    PLAYER_STATUS m_status;\n\n    /**\n     * @brief\n     */\n    uint64_t m_createTime;\n\n    /**\n     * @brief\n     */\n    uint64_t m_lastDiconnectTime;\n\n    /**\n     * @brief\n     */\n    uint64_t m_lastLogoutTime;\n\n    /**\n     * @brief\n     */\n    bool m_isDisconnect;\n\n    /**\n     * @brief\n     */\n    std::string m_token;\n\n    /**\n     * @brief\n     */\n    uint64_t m_tokenTimeStamp;\n\n    /**\n     * @brief\n     */\n    uint64_t m_roleId;\n\n    /**\n     * @brief\n     */\n    uint32_t m_channelId;\n\n    /**\n     * @brief\n     */\n    uint32_t m_loginZid;\n\n    /**\n     * @brief\n     */\n    bool m_isWhite;\n\n    /**\n     * @brief\n     */\n    uint32_t m_charNum;\n\n    /**\n     * @brief\n     */\n    PLAYER_SCENE_STATE m_sceneState;\nprivate:\n    NFShmHashMap<uint64_t, NFWorldRoleInfo, MAX_ROLE_NUM> m_roleInfo;\nprivate:\nDECLARE_IDCREATE(NFWorldPlayer)\n};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayer.h b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayer.h
--- a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayer.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayer.h	(date 1688616543401)
@@ -12,7 +12,7 @@
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFLogicCommon/NFLogicCommonDefine.h"
 #include "NFWorldCommonDefine.h"
 #include "NFWorldRoleInfo.h"
Index: game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldCreateRole.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransWorldCreateRole.h\n//    @Author           :    gaoyi\n//    @Date             :    23-3-3\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransWorldCreateRole\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFTransBase.h\"\n#include \"ServerInternal2.pb.h\"\n#include \"CSLogin.pb.h\"\n\nclass NFTransWorldCreateRole : public NFTransBase\n{\npublic:\n    NFTransWorldCreateRole();\n\n    virtual ~NFTransWorldCreateRole();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    int Init(uint64_t uid, uint64_t roleId, uint32_t proxyId, uint64_t clientId, uint32_t bornZid);\n\n    int OnHandleCreateRole(const proto_ff::ClientCreateRoleReq& msg);\n\n    int SendCreateRoleInfo(const proto_ff::WorldToLogicCreateRoleReq& req);\n\n    virtual int HandleDispSvrRes(uint32_t nMsgId, const NFDataPackage &packet, uint32_t reqTransId, uint32_t rspTransId);\npublic:\n    /**\n     * @brief 处理逻辑服务器创建角色返回\n     * @param msgId\n     * @param packet\n     * @param param1\n     * @param param2\n     * @return\n     */\n    int OnHandleLogicCreateRoleRsp(uint32_t msgId, const NFDataPackage& packet, uint32_t reqTransId, uint32_t rspTransId);\npublic:\n\n    virtual int OnTransFinished(int iRunLogicRetCode);\nprivate:\n    uint64_t m_uid;\n    uint64_t m_roleId;\n    uint32_t m_proxyId;\n    uint64_t m_clientId;\n    uint32_t m_bornZid;\nprivate:\nDECLARE_IDCREATE(NFTransWorldCreateRole)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldCreateRole.h b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldCreateRole.h
--- a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldCreateRole.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldCreateRole.h	(date 1688616542957)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFTransBase.h"
 #include "ServerInternal2.pb.h"
Index: game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSceneMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFWorldSceneMgr.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-14\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFWorldSceneMgr\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmStl/NFShmHashMap.h\"\n#include \"NFComm/NFShmStl/NFShmVector.h\"\n#include \"NFComm/NFShmCore/NFArray.h\"\n#include \"NFLogicCommon/NFSceneDefine.h\"\n#include \"ServerInternal2.pb.h\"\n\n#define NF_WORLD_SERVER_MAX_MAP_NUM 1000\n#define NF_WORLD_MAP_ID_MAX_SERVER_NUM 10\n\nclass NFWorldSceneMgr : public NFShmObj\n{\npublic:\n    NFWorldSceneMgr();\n\n    virtual ~NFWorldSceneMgr();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    /**\n     * @brief\n     * @param xData\n     * @return\n     */\n    int LoadGameMap(const proto_ff::GameToWorldRegisterMapReq& xData);\n\npublic:\n    bool IsStaticMapId(uint64_t mapId) const;\n    uint32_t GetStaticMapGameId(uint64_t mapId) const;\nprivate:\n    NFShmHashMap<uint64_t, NFShmVector<uint32_t, NF_WORLD_MAP_ID_MAX_SERVER_NUM>, NF_WORLD_SERVER_MAX_MAP_NUM> m_mapIdToGameBusIdMap;\n    NFShmHashMap<uint64_t, SceneSimpleInfo, NF_WORLD_SERVER_MAX_MAP_NUM*10> m_sceneMap;\nprivate:\nDECLARE_IDCREATE(NFWorldSceneMgr)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSceneMgr.h b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSceneMgr.h
--- a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSceneMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSceneMgr.h	(date 1688616543384)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmStl/NFShmHashMap.h"
 #include "NFComm/NFShmStl/NFShmVector.h"
Index: game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldTransScene.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransWorldTransScene.h\n//    @Author           :    gaoyi\n//    @Date             :    23-3-10\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransWorldTransScene\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFTransBase.h\"\n#include \"NFLogicCommon/NFPoint3.h\"\n#include \"ServerInternal2.pb.h\"\n\nclass NFTransWorldTransScene : public NFTransBase\n{\npublic:\n    NFTransWorldTransScene();\n\n    virtual ~NFTransWorldTransScene();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    int Init(uint64_t roleId, uint64_t mapId, uint64_t sceneId, const NFPoint3<float>& pos, int reqTransId, uint32_t cmd);\n    int OnHandleTransScene(const proto_ff::LogicToWorldEnterSceneReq& xData);\n    int OnHandleLeaveScene(const proto_ff::LogicToWorldLeaveSceneReq& xData);\n    virtual int OnTransFinished(int iRunLogicRetCode);\n    virtual int HandleDispSvrRes(uint32_t nMsgId, const NFDataPackage &packet, uint32_t reqTransId, uint32_t rspTransId);\n    int OnHandleGameEnterSceneRsp(uint32_t nMsgId, const NFDataPackage &packet, uint32_t reqTransId, uint32_t rspTransId);\n    int OnHandleGameLeaveSceneRsp(uint32_t nMsgId, const NFDataPackage &packet, uint32_t reqTransId, uint32_t rspTransId);\nprivate:\n    uint64_t m_roleId;\n    uint64_t m_mapId;\n    uint64_t m_sceneId;\n    uint32_t m_gameId;\n    uint32_t m_logicId;\n    NFPoint3<float> m_pos;\n    uint32_t m_cmd;\n    int m_reqTransId;\n    uint64_t m_srcMapId;\n    uint64_t m_srcSceneId;\n    uint32_t m_transType;\nDECLARE_IDCREATE(NFTransWorldTransScene)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldTransScene.h b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldTransScene.h
--- a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldTransScene.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFTransWorldTransScene.h	(date 1688616542993)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFTransBase.h"
 #include "NFLogicCommon/NFPoint3.h"
Index: src/NFCommPlugin/NFKernelPlugin/NFCMessageModule.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFCMsgModule.cpp\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFPluginModule\n//\n// -------------------------------------------------------------------------\n\n#include <NFComm/NFCore/NFStringUtility.h>\n#include <NFComm/NFPluginModule/NFProtobufCommon.h>\n#include \"NFCMessageModule.h\"\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"NFComm/NFKernelMessage/storesvr_sqldata.pb.h\"\n#include \"NFComm/NFKernelMessage/proto_kernel.pb.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFComm/NFShmCore/NFTransBase.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFPluginModule/NFIConfigModule.h\"\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include \"NFComm/NFPluginModule/NFNetPackagePool.h\"\n#include \"NFComm/NFPluginModule/NFIEventModule.h\"\n\n\nNFCMessageModule::NFCMessageModule(NFIPluginManager *p) : NFIMessageModule(p)\n{\n    m_pObjPluginManager = p;\n    m_netModule = NULL;\n    mxCallBack.resize(NF_ST_MAX);\n    mServerLinkData.resize(NF_ST_MAX);\n    for (size_t i = 0; i < mServerLinkData.size(); i++)\n    {\n        mServerLinkData[i].mServerType = (NF_SERVER_TYPES) i;\n    }\n}\n\nNFCMessageModule::~NFCMessageModule()\n{\n    mxCallBack.clear();\n}\n\nbool NFCMessageModule::Awake()\n{\n    if (m_netModule != NULL)\n    {\n        return true;\n    }\n\n    NFINetModule *pDriver = FindModule<NFINetModule>();\n    if (pDriver)\n    {\n        SetNetModule(pDriver);\n    }\n\n    return true;\n}\n\nbool NFCMessageModule::Finalize()\n{\n    mxCallBack.clear();\n    return true;\n}\n\nbool NFCMessageModule::Execute()\n{\n    return true;\n}\n\nbool NFCMessageModule::OnReloadConfig()\n{\n    return true;\n}\n\nvoid NFCMessageModule::SetNetModule(NFINetModule *driver)\n{\n    m_netModule = driver;\n    m_netModule->SetRecvCB(this, &NFCMessageModule::OnReceiveNetPack);\n    m_netModule->SetEventCB(this, &NFCMessageModule::OnSocketNetEvent);\n    m_netModule->SetHttpRecvCB(this, &NFCMessageModule::OnHttpReceiveNetPack);\n    m_netModule->SetHttpFilterCB(this, &NFCMessageModule::OnHttpFilterPack);\n}\n\nuint64_t NFCMessageModule::BindServer(NF_SERVER_TYPES eServerType, const std::string &url, uint32_t nNetThreadNum, uint32_t nMaxConnectNum,\n                                      uint32_t nPacketParseType, bool bSecurity)\n{\n    if (m_netModule)\n    {\n        return m_netModule->BindServer(eServerType, url, nNetThreadNum, nMaxConnectNum, nPacketParseType, bSecurity);\n    }\n    return 0;\n}\n\nuint64_t NFCMessageModule::ConnectServer(NF_SERVER_TYPES eServerType, const std::string &url, uint32_t nPacketParseType, bool bSecurity)\n{\n    if (m_netModule)\n    {\n        return m_netModule->ConnectServer(eServerType, url, nPacketParseType, bSecurity);\n    }\n    return 0;\n}\n\nint NFCMessageModule::ResumeConnect(NF_SERVER_TYPES eServerType)\n{\n    if (m_netModule)\n    {\n        return m_netModule->ResumeConnect(eServerType);\n    }\n    return -1;\n}\n\nstd::string NFCMessageModule::GetLinkIp(uint64_t usLinkId)\n{\n    if (m_netModule)\n    {\n        return m_netModule->GetLinkIp(usLinkId);\n    }\n    return std::string();\n}\n\nuint32_t NFCMessageModule::GetPort(uint64_t usLinkId)\n{\n    if (m_netModule)\n    {\n        return m_netModule->GetPort(usLinkId);\n    }\n    return 0;\n}\n\nvoid NFCMessageModule::CloseLinkId(uint64_t usLinkId)\n{\n    if (m_netModule)\n    {\n        m_netModule->CloseLinkId(usLinkId);\n    }\n\n    uint32_t serverType = GetServerTypeFromUnlinkId(usLinkId);\n\n    if (serverType > NF_ST_NONE && serverType < NF_ST_MAX)\n    {\n        DelAllCallBack((NF_SERVER_TYPES) serverType, usLinkId);\n        DelServerLink((NF_SERVER_TYPES) serverType, usLinkId);\n    }\n}\n\nvoid NFCMessageModule::TransPackage(uint64_t usLinkId, NFDataPackage &packet)\n{\n    if (m_netModule)\n    {\n        m_netModule->TransPackage(usLinkId, packet);\n    }\n}\n\nvoid NFCMessageModule::Send(uint64_t usLinkId, uint32_t nModuleId, uint32_t nMsgID, const std::string &strData, uint64_t nParam1, uint64_t nParam2,\n                            uint64_t srcId, uint64_t dstId)\n{\n    if (m_netModule)\n    {\n        m_netModule->Send(usLinkId, nModuleId, nMsgID, strData, nParam1, nParam2, srcId, dstId);\n    }\n}\n\nvoid\nNFCMessageModule::Send(uint64_t usLinkId, uint32_t nModuleId, uint32_t nMsgID, const char *msg, uint32_t nLen, uint64_t nParam1, uint64_t nParam2,\n                       uint64_t srcId, uint64_t dstId)\n{\n    if (m_netModule)\n    {\n        m_netModule->Send(usLinkId, nModuleId, nMsgID, msg, nLen, nParam1, nParam2, srcId, dstId);\n    }\n}\n\nvoid NFCMessageModule::Send(uint64_t usLinkId, uint32_t nModuleId, uint32_t nMsgID, const google::protobuf::Message &xData, uint64_t nParam1,\n                            uint64_t nParam2, uint64_t srcId, uint64_t dstId)\n{\n    if (m_netModule)\n    {\n        m_netModule->Send(usLinkId, nModuleId, nMsgID, xData, nParam1, nParam2, srcId, dstId);\n    }\n}\n\nvoid\nNFCMessageModule::SendServer(uint64_t usLinkId, uint32_t nModuleId, uint32_t nMsgID, const std::string &strData, uint64_t nParam1, uint64_t nParam2,\n                             uint64_t nSrcID, uint64_t nDstId)\n{\n    if (m_netModule)\n    {\n        m_netModule->SendServer(usLinkId, nModuleId, nMsgID, strData, nParam1, nParam2, nSrcID, nDstId);\n    }\n}\n\nvoid NFCMessageModule::SendServer(uint64_t usLinkId, uint32_t nModuleId, uint32_t nMsgID, const char *msg, uint32_t nLen, uint64_t nParam1,\n                                  uint64_t nParam2, uint64_t nSrcID, uint64_t nDstId)\n{\n    if (m_netModule)\n    {\n        m_netModule->SendServer(usLinkId, nModuleId, nMsgID, msg, nLen, nParam1, nParam2, nSrcID, nDstId);\n    }\n}\n\nvoid NFCMessageModule::SendServer(uint64_t usLinkId, uint32_t nModuleId, uint32_t nMsgID, const google::protobuf::Message &xData, uint64_t nParam1,\n                                  uint64_t nParam2, uint64_t nSrcID, uint64_t nDstId)\n{\n    if (m_netModule)\n    {\n        m_netModule->SendServer(usLinkId, nModuleId, nMsgID, xData, nParam1, nParam2, nSrcID, nDstId);\n    }\n}\n\nbool NFCMessageModule::DelAllCallBack(NF_SERVER_TYPES eType, uint64_t unLinkId)\n{\n    if (eType < mxCallBack.size() && unLinkId > 0)\n    {\n        mxCallBack[eType].mxEventCallBack.erase(unLinkId);\n        mxCallBack[eType].mxOtherMsgCallBackList.erase(unLinkId);\n        return true;\n    }\n\n    return true;\n}\n\nbool NFCMessageModule::DelAllCallBack(NFIDynamicModule *pTarget)\n{\n    for (size_t i = 0; i < mxCallBack.size(); i++)\n    {\n        CallBack &callBack = mxCallBack[i];\n        for (int i = 0; i < (int) callBack.mxReceiveCallBack.size(); i++)\n        {\n            for (int j = 0; j < (int) callBack.mxReceiveCallBack[i].size(); j++)\n            {\n                if (callBack.mxReceiveCallBack[i][j].m_pTarget != NULL)\n                {\n                    callBack.mxReceiveCallBack[i][j] = NetReceiveFunctor();\n                }\n            }\n        }\n\n        for (int j = 0; j < (int) callBack.mxRpcCallBack.size(); j++)\n        {\n            if (callBack.mxRpcCallBack[j].m_pTarget != NULL)\n            {\n                NF_SAFE_DELETE(callBack.mxRpcCallBack[j].m_pRpcService);\n                callBack.mxRpcCallBack[j] = NetRpcService();\n            }\n        }\n\n        for (auto iter = callBack.mxEventCallBack.begin(); iter != callBack.mxEventCallBack.end();)\n        {\n            if (iter->second.m_pTarget == pTarget)\n            {\n                iter = mxCallBack[i].mxEventCallBack.erase(iter);\n            }\n            else\n            {\n                iter++;\n            }\n        }\n\n        for (auto iter = callBack.mxOtherMsgCallBackList.begin(); iter != callBack.mxOtherMsgCallBackList.end();)\n        {\n            if (iter->second.m_pTarget == pTarget)\n            {\n                iter = callBack.mxOtherMsgCallBackList.erase(iter);\n            }\n            else\n            {\n                iter++;\n            }\n        }\n\n        if (callBack.mxAllMsgCallBackList.m_pTarget == pTarget)\n        {\n            callBack.mxAllMsgCallBackList = NetReceiveFunctor();\n        }\n    }\n    return true;\n}\n\nbool NFCMessageModule::AddMessageCallBack(NF_SERVER_TYPES eType, uint32_t nMsgID, NFIDynamicModule *pTarget,\n                                          const NET_RECEIVE_FUNCTOR &cb, bool createCo)\n{\n    if (eType < mxCallBack.size())\n    {\n        CHECK_EXPR_ASSERT(nMsgID < NF_NET_MAX_MSG_ID, false, \"nMsgID:{} >= NF_NET_MAX_MSG_ID\", nMsgID);\n        CHECK_EXPR(!mxCallBack[eType].mxReceiveCallBack[0][nMsgID].m_pFunctor, false, \"eType:{} nModuleId:{} nMsgID:{} Exist, AddMessageCallBack Failed..........\", eType, 0, nMsgID);\n        mxCallBack[eType].mxReceiveCallBack[0][nMsgID] = NetReceiveFunctor(pTarget, cb, createCo);\n        return true;\n    }\n    return false;\n}\n\nbool NFCMessageModule::AddMessageCallBack(NF_SERVER_TYPES eType, uint32_t nModuleId, uint32_t nMsgID, NFIDynamicModule *pTarget,\n                                          const NET_RECEIVE_FUNCTOR &cb, bool createCo)\n{\n    if (eType < mxCallBack.size())\n    {\n        CHECK_EXPR(nModuleId < NF_MODULE_MAX, false, \"nModuleId:{} >= NF_MODULE_MAX\", nModuleId);\n        CHECK_EXPR(nMsgID < NF_NET_MAX_MSG_ID, false, \"nMsgID:{} >= NF_NET_MAX_MSG_ID\", nMsgID);\n        CHECK_EXPR(!mxCallBack[eType].mxReceiveCallBack[nModuleId][nMsgID].m_pFunctor, false, \"eType:{} nModuleId:{} nMsgID:{} Exist, AddMessageCallBack Failed..........\", eType, nModuleId, nMsgID);\n        mxCallBack[eType].mxReceiveCallBack[nModuleId][nMsgID] = NetReceiveFunctor(pTarget, cb, createCo);\n        return true;\n    }\n    return false;\n}\n\nstd::set<uint32_t> NFCMessageModule::GetAllMsg(NF_SERVER_TYPES eType, uint32_t nModuleId)\n{\n    std::set<uint32_t> vec;\n    if (eType < mxCallBack.size())\n    {\n        CHECK_EXPR_ASSERT(nModuleId < NF_MODULE_MAX, vec, \"nModuleId:{} >= NF_MODULE_MAX\", nModuleId);\n        for (int i = 0; i < (int) mxCallBack[eType].mxReceiveCallBack[nModuleId].size(); i++)\n        {\n            if (mxCallBack[eType].mxReceiveCallBack[nModuleId][i].m_pTarget != NULL)\n            {\n                vec.insert(i);\n            }\n        }\n    }\n    return vec;\n}\n\nbool NFCMessageModule::AddOtherCallBack(NF_SERVER_TYPES eType, uint64_t linkId, NFIDynamicModule *pTarget,\n                                        const NET_RECEIVE_FUNCTOR &cb, bool createCo)\n{\n    if (eType < mxCallBack.size())\n    {\n        NFLogWarningIf(mxCallBack[eType].mxOtherMsgCallBackList[linkId].m_pFunctor, NF_LOG_SYSTEMLOG, 0, \"serverType:{} linkId:{} Exist, this is replace old func..........\", eType, linkId);\n        mxCallBack[eType].mxOtherMsgCallBackList[linkId] = NetReceiveFunctor(pTarget, cb, createCo);\n        return true;\n    }\n    return false;\n}\n\nbool NFCMessageModule::AddAllMsgCallBack(NF_SERVER_TYPES eType, NFIDynamicModule *pTarget, const NET_RECEIVE_FUNCTOR &cb, bool createCo)\n{\n    if (eType < mxCallBack.size())\n    {\n        NFLogWarningIf(mxCallBack[eType].mxAllMsgCallBackList.m_pFunctor, NF_LOG_SYSTEMLOG, 0, \"serverType:{} Exist, this is replace old func..........\", eType);\n        mxCallBack[eType].mxAllMsgCallBackList = NetReceiveFunctor(pTarget, cb, createCo);\n        return true;\n    }\n    return false;\n}\n\nbool NFCMessageModule::AddRpcService(NF_SERVER_TYPES serverType, uint32_t nMsgID, NFIDynamicModule *pTarget, NFIRpcService *pRpcService,\n                                     bool createCo/* = false*/)\n{\n    if (serverType < mxCallBack.size())\n    {\n        CHECK_EXPR(nMsgID < NF_NET_MAX_MSG_ID, false, \"nMsgID:{} >= NF_NET_MAX_MSG_ID\", nMsgID);\n        CHECK_EXPR(!mxCallBack[serverType].mxRpcCallBack[nMsgID].m_pRpcService, false, \"serverType:{} nMsgID:{} Exist, AddRpcService Failed..........\", serverType, nMsgID);\n        mxCallBack[serverType].mxRpcCallBack[nMsgID] = NetRpcService(pTarget, pRpcService, createCo);\n        return true;\n    }\n    return false;\n}\n\nbool NFCMessageModule::AddEventCallBack(NF_SERVER_TYPES eType, uint64_t linkId, NFIDynamicModule *pTarget, const NET_EVENT_FUNCTOR &cb, bool createCo)\n{\n    if (eType < mxCallBack.size())\n    {\n\n        NFLogWarningIf(mxCallBack[eType].mxEventCallBack.find(linkId) != mxCallBack[eType].mxEventCallBack.end(), NF_LOG_SYSTEMLOG, 0, \"serverType:{} Exist, this is replace old func..........\", eType);\n        mxCallBack[eType].mxEventCallBack[linkId] = NetEventFunctor(pTarget, cb, createCo);\n        return true;\n    }\n    return false;\n}\n\nint NFCMessageModule::OnHandleReceiveNetPack(uint64_t connectionLink, uint64_t objectLinkId, NFDataPackage &packet)\n{\n    uint32_t eServerType = GetServerTypeFromUnlinkId(objectLinkId);\n    if (eServerType < mxCallBack.size())\n    {\n        uint64_t startTime = NFGetMicroSecondTime();\n        CallBack &callBack = mxCallBack[eServerType];\n        if (callBack.mxAllMsgCallBackList.m_pFunctor)\n        {\n            if (callBack.mxAllMsgCallBackList.m_createCo)\n            {\n                NET_RECEIVE_FUNCTOR &pFun = callBack.mxAllMsgCallBackList.m_pFunctor;\n                int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine(\n                        [pFun, objectLinkId, packet]\n                        {\n                            //从消息层传过来的包中的数据，会在处理函数执行完后销毁掉，所以携程必须复制一份，以防万一yield后又用到。\n                            std::string tempCopyBuffer(packet.GetBuffer(), packet.GetSize());\n                            NFDataPackage tempPackage = packet;\n                            tempPackage.nBuffer = (char*)tempCopyBuffer.data();\n                            pFun(objectLinkId, tempPackage);\n                        });\n\n                if (iRet != 0)\n                {\n                    return 0;\n                }\n            }\n            else {\n                int iRet = callBack.mxAllMsgCallBackList.m_pFunctor(objectLinkId, packet);\n                if (iRet != 0)\n                {\n                    return 0;\n                }\n            }\n        }\n\n        CHECK_EXPR(packet.mModuleId < NF_MODULE_MAX, -1, \"nModuleId:{} >= NF_MODULE_MAX\", packet.mModuleId);\n        CHECK_EXPR(packet.nMsgId < NF_NET_MAX_MSG_ID, -1, \"nMsgID:{} >= NF_NET_MAX_MSG_ID\", packet.nMsgId);\n        NetReceiveFunctor &netFunctor = callBack.mxReceiveCallBack[packet.mModuleId][packet.nMsgId];\n        if (netFunctor.m_pTarget != NULL)\n        {\n            NET_RECEIVE_FUNCTOR &pFun = netFunctor.m_pFunctor;\n            if (pFun)\n            {\n                int iRet = 0;\n                if (netFunctor.m_createCo)\n                {\n                    iRet = FindModule<NFICoroutineModule>()->MakeCoroutine(\n                            [objectLinkId, packet, pFun]\n                            {\n                                //从消息层传过来的包中的数据，会在处理函数执行完后销毁掉，所以携程必须复制一份，以防万一yield后又用到。\n                                std::string tempCopyBuffer(packet.GetBuffer(), packet.GetSize());\n                                NFDataPackage tempPackage = packet;\n                                tempPackage.nBuffer = (char*)tempCopyBuffer.data();\n                                pFun(objectLinkId, tempPackage);\n                            });\n                }\n                else {\n                    iRet = pFun(objectLinkId, packet);\n                }\n                netFunctor.m_iCount++;\n                uint64_t useTime = NFGetMicroSecondTime() - startTime;\n                netFunctor.m_iAllUseTime += useTime;\n                if (useTime > netFunctor.m_iMaxTime)\n                {\n                    netFunctor.m_iMaxTime = useTime;\n                }\n                if (useTime < netFunctor.m_iMinTime)\n                {\n                    netFunctor.m_iMinTime = useTime;\n                }\n                if (useTime / 1000 > 33)\n                {\n                    NFLogError(NF_LOG_SYSTEMLOG, 0, \"moduleId:{}, nMsgId:{} use time:{} ms, too long\", packet.mModuleId, packet.nMsgId,\n                               useTime / 1000);\n                }\n\n                if (!(packet.mModuleId == 0 && (packet.nMsgId == NF_CLIENT_TO_SERVER_HEART_BEAT\n                                                || packet.nMsgId == NF_CLIENT_TO_SERVER_HEART_BEAT_RSP ||\n                                                packet.nMsgId == NF_SERVER_TO_SERVER_HEART_BEAT ||\n                                                packet.nMsgId == NF_SERVER_TO_SERVER_HEART_BEAT_RSP)))\n                {\n                    NFLogTrace(NF_LOG_RECV_MSG, 0, \"packet:{} use time:{} us, count:{} allTime:{} perTime:{} minTime:{} maxTime:{}\",\n                               packet.ToString(), useTime, netFunctor.m_iCount, netFunctor.m_iAllUseTime,\n                               netFunctor.m_iAllUseTime / netFunctor.m_iCount, netFunctor.m_iMinTime, netFunctor.m_iMaxTime);\n                }\n\n                CHECK_RET(iRet, \"packet:{}\", packet.ToString());\n            }\n\n            return 0;\n        }\n\n        auto iterator2 = callBack.mxOtherMsgCallBackList.find(connectionLink);\n        if (iterator2 != callBack.mxOtherMsgCallBackList.end())\n        {\n            NET_RECEIVE_FUNCTOR &pFun = iterator2->second.m_pFunctor;\n            if (pFun)\n            {\n                int iRet = 0;\n                if (iterator2->second.m_createCo)\n                {\n                    iRet = FindModule<NFICoroutineModule>()->MakeCoroutine(\n                            [objectLinkId, packet, pFun]\n                            {\n                                //从消息层传过来的包中的数据，会在处理函数执行完后销毁掉，所以携程必须复制一份，以防万一yield后又用到。\n                                std::string tempCopyBuffer(packet.GetBuffer(), packet.GetSize());\n                                NFDataPackage tempPackage = packet;\n                                tempPackage.nBuffer = (char*)tempCopyBuffer.data();\n                                pFun(objectLinkId, tempPackage);\n                            });\n                }\n                else {\n                    iRet = pFun(objectLinkId, packet);\n                }\n                iterator2->second.m_iCount++;\n                uint64_t useTime = NFGetMicroSecondTime() - startTime;\n                iterator2->second.m_iAllUseTime += useTime;\n                if (useTime > iterator2->second.m_iMaxTime)\n                {\n                    iterator2->second.m_iMaxTime = useTime;\n                }\n                if (useTime < iterator2->second.m_iMinTime)\n                {\n                    iterator2->second.m_iMinTime = useTime;\n                }\n                if (useTime / 1000 > 33)\n                {\n                    NFLogError(NF_LOG_SYSTEMLOG, 0, \"connectionLink:{} use time:{} ms, too long\", connectionLink, useTime / 1000);\n                }\n                if (!(packet.mModuleId == 0 && (packet.nMsgId == NF_CLIENT_TO_SERVER_HEART_BEAT\n                                                || packet.nMsgId == NF_CLIENT_TO_SERVER_HEART_BEAT_RSP ||\n                                                packet.nMsgId == NF_SERVER_TO_SERVER_HEART_BEAT ||\n                                                packet.nMsgId == NF_SERVER_TO_SERVER_HEART_BEAT_RSP)))\n                {\n                    NFLogTrace(NF_LOG_RECV_MSG, 0, \"connectionLink:{} packet:{} use time:{} us, count:{} allTime:{} perTime:{} minTime:{} maxTime:{}\",\n                               connectionLink, packet.ToString(), useTime, iterator2->second.m_iCount, iterator2->second.m_iAllUseTime,\n                               iterator2->second.m_iAllUseTime / iterator2->second.m_iCount, iterator2->second.m_iMinTime,\n                               iterator2->second.m_iMaxTime);\n                }\n\n                CHECK_RET(iRet, \"packet:{}\", packet.ToString());\n            }\n        }\n\n        return 0;\n    }\n    return 0;\n}\n\nint NFCMessageModule::OnReceiveNetPack(uint64_t connectionLink, uint64_t objectLinkId, NFDataPackage &packet)\n{\n    uint32_t eServerType = GetServerTypeFromUnlinkId(objectLinkId);\n    if (eServerType < mxCallBack.size())\n    {\n        uint64_t startTime = NFGetMicroSecondTime();\n        if (eServerType != NF_ST_ROUTE_AGENT_SERVER && eServerType != NF_ST_ROUTE_SERVER && eServerType != NF_ST_PROXY_AGENT_SERVER)\n        {\n            if (packet.mModuleId == 0 && packet.nMsgId == proto_ff::NF_SERVER_TO_SERVER_TRANS_CMD)\n            {\n                proto_ff::Proto_SvrPkg svrPkg;\n                CLIENT_MSG_PROCESS_WITH_PRINTF(packet, svrPkg);\n\n                if (svrPkg.disp_info().rsp_trans_id() > 0)\n                {\n                    NFTransBase *pTrans = FindModule<NFISharedMemModule>()->GetTrans(svrPkg.disp_info().rsp_trans_id());\n                    if (pTrans && !pTrans->IsFinished())\n                    {\n                        NFDataPackage transPacket;\n                        transPacket.nParam1 = svrPkg.disp_info().req_trans_id();\n                        transPacket.nParam2 = svrPkg.disp_info().rsp_trans_id();\n                        transPacket.mModuleId = 0;\n                        transPacket.nMsgId = svrPkg.msg_id();\n                        transPacket.nBuffer = (char *) svrPkg.msg_data().data();\n                        transPacket.nMsgLen = svrPkg.msg_data().length();\n\n                        pTrans->ProcessDispSvrRes(svrPkg.msg_id(), transPacket, svrPkg.disp_info().req_trans_id(), svrPkg.disp_info().rsp_trans_id());\n                        uint64_t useTime = NFGetMicroSecondTime() - startTime;\n                        if (useTime / 1000 > 33)\n                        {\n                            NFLogError(NF_LOG_SYSTEMLOG, 0, \"Trans:{} ProcessDispSvrRes nMsgId:{} use time:{} ms, too long\", pTrans->ClassTypeInfo(),\n                                       svrPkg.msg_id(), useTime / 1000);\n                        }\n                        NFLogTrace(NF_LOG_RECV_MSG, 0, \"Trans:{} ProcessDispSvrRes nMsgId:{} packet:{} use time:{} us\", pTrans->ClassTypeInfo(),\n                                   svrPkg.msg_id(), packet.ToString(), useTime);\n                    }\n                    else\n                    {\n                        NFLogError(NF_LOG_SYSTEMLOG, 0,\n                                   \"can't find trans, trans maybe timeout, msgId:{} req_transid:{} rsp_transid:{}\",\n                                   svrPkg.msg_id(), svrPkg.disp_info().req_trans_id(), svrPkg.disp_info().rsp_trans_id());\n                    }\n                    return 0;\n                }\n                else\n                {\n                    NFDataPackage transPacket;\n                    transPacket.nParam1 = svrPkg.disp_info().req_trans_id();\n                    transPacket.nParam2 = svrPkg.disp_info().rsp_trans_id();\n                    transPacket.mModuleId = 0;\n                    transPacket.nMsgId = svrPkg.msg_id();\n                    transPacket.nBuffer = (char *) svrPkg.msg_data().data();\n                    transPacket.nMsgLen = svrPkg.msg_data().length();\n                    OnHandleReceiveNetPack(connectionLink, objectLinkId, transPacket);\n                }\n\n                return 0;\n            }\n            else if (packet.mModuleId == 0 && packet.nMsgId == proto_ff::NF_STORE_SERVER_TO_SERVER_DB_CMD)\n            {\n                proto_ff::Proto_SvrPkg svrPkg;\n                CLIENT_MSG_PROCESS_WITH_PRINTF(packet, svrPkg);\n\n                if (svrPkg.store_info().cb_data().type() == proto_ff::E_DISP_TYPE_BY_TRANSACTION)\n                {\n                    if (svrPkg.store_info().cb_data().id() > 0)\n                    {\n                        NFTransBase *pTrans = FindModule<NFISharedMemModule>()->GetTrans(svrPkg.store_info().cb_data().id());\n                        if (pTrans && !pTrans->IsFinished())\n                        {\n                            pTrans->ProcessDBMsgRes(svrPkg);\n                            uint64_t useTime = NFGetMicroSecondTime() - startTime;\n                            if (useTime / 1000 > 33)\n                            {\n                                NFLogError(NF_LOG_SYSTEMLOG, 0, \"Trans:{} ProcessDispSvrRes nMsgId:{} use time:{} ms, too long\",\n                                           pTrans->ClassTypeInfo(), svrPkg.store_info().cmd(), useTime / 1000);\n                            }\n                            NFLogTrace(NF_LOG_RECV_MSG, 0, \"Trans:{} ProcessDispSvrRes nMsgId:{}  use time:{} us\", pTrans->ClassTypeInfo(),\n                                       svrPkg.store_info().cmd(), useTime);\n                        }\n                        else\n                        {\n                            NFLogError(NF_LOG_SYSTEMLOG, 0,\n                                       \"can't find trans, trans maybe timeout, transid:{} \",\n                                       svrPkg.store_info().cb_data().id());\n                        }\n                        return 0;\n                    }\n                    else\n                    {\n                        NFLogWarning(NF_LOG_SYSTEMLOG, 0, \"the store server rsp not handle, no transid, msg:{}\", svrPkg.DebugString());\n                        return 0;\n                    }\n                }\n            }\n            else if (packet.mModuleId == 0 && packet.nMsgId == proto_ff::NF_STS_BROAD_PLAYER_MSG_NOTIFY)\n            {\n                proto_ff::Proto_STSBroadPlayerMsgNotify xMsg;\n                CLIENT_MSG_PROCESS_WITH_PRINTF(packet, xMsg);\n\n                for (int i = 0; i < (int) xMsg.user_id_size(); i++)\n                {\n                    uint64_t userId = xMsg.user_id(i);\n                    NFDataPackage transPacket;\n                    transPacket.nParam1 = userId;\n                    transPacket.nParam2 = packet.nParam2;\n                    transPacket.mModuleId = 0;\n                    transPacket.nMsgId = xMsg.msg_id();\n                    transPacket.nBuffer = (char *) xMsg.msg_data().data();\n                    transPacket.nMsgLen = xMsg.msg_data().length();\n\n                    OnHandleReceiveNetPack(connectionLink, objectLinkId, transPacket);\n                }\n\n                uint64_t useTime = NFGetMicroSecondTime() - startTime;\n                if (useTime / 1000 > 33)\n                {\n                    NFLogError(NF_LOG_SYSTEMLOG, 0, \"BroadPlayerMsgNotify nMsgId:{} use time:{} ms, too long\", xMsg.msg_id(), useTime / 1000);\n                }\n                NFLogTrace(NF_LOG_RECV_MSG, 0, \"BroadPlayerMsgNotify nMsgId:{}  use time:{} us\", xMsg.msg_id(), useTime);\n\n                return 0;\n            }\n            else if (packet.mModuleId == 0 && packet.nMsgId == proto_ff::NF_SERVER_BROAD_EVENT_TO_SERVER_CMD)\n            {\n                proto_ff::Proto_SvrPkg svrPkg;\n                CLIENT_MSG_PROCESS_WITH_PRINTF(packet, svrPkg);\n\n                auto pEventInfo = svrPkg.mutable_event_info();\n                NF_ASSERT(pEventInfo);\n\n                if (pEventInfo->server_type() > 0 && !pEventInfo->full_message_name().empty())\n                {\n                    ::google::protobuf::Message *pMessage = NFProtobufCommon::CreateMessageByName(pEventInfo->full_message_name());\n                    if (pMessage == NULL)\n                    {\n                        NFLogError(NF_LOG_SYSTEMLOG, 0, \"NFProtobufCommon::CreateMessageByName Failed, full name:{}\",\n                                   pEventInfo->full_message_name());\n                        NFLogError(NF_LOG_SYSTEMLOG, 0, \"Broadcst Event To Server Failed, message:{}\", pEventInfo->Utf8DebugString());\n                        return 0;\n                    }\n\n                    if (!pMessage->ParseFromArray(svrPkg.msg_data().data(), svrPkg.msg_data().length()))\n                    {\n                        NFLogError(NF_LOG_PROTOBUF_PARSE, 0, \"Protobuf Parse Message Failed, FireBorad Failed packet name:{}\",\n                                   pEventInfo->full_message_name());\n                        return -1;\n                    }\n\n                    if (m_pObjPluginManager->FindModule<NFISharedMemModule>())\n                    {\n                        m_pObjPluginManager->FindModule<NFISharedMemModule>()->FireExecute(pEventInfo->server_type(), pEventInfo->event_id(),\n                                                                                           pEventInfo->src_type(), pEventInfo->src_id(), *pMessage);\n                    }\n\n                    if (m_pObjPluginManager->FindModule<NFIEventModule>())\n                    {\n                        m_pObjPluginManager->FindModule<NFIEventModule>()->FireExecute(pEventInfo->server_type(), pEventInfo->event_id(),\n                                                                                       pEventInfo->src_type(), pEventInfo->src_id(), *pMessage);\n                    }\n\n                    NF_SAFE_DELETE(pMessage);\n                    return 0;\n                }\n                else\n                {\n                    NFLogError(NF_LOG_SYSTEMLOG, 0, \"Broadcst Event To Server Failed, param error, message:{}\", pEventInfo->Utf8DebugString());\n                    return 0;\n                }\n            }\n            else if (packet.mModuleId == 0 && packet.nMsgId == proto_ff::NF_SERVER_TO_SERVER_RPC_CMD)\n            {\n                proto_ff::Proto_SvrPkg svrPkg;\n                CLIENT_MSG_PROCESS_WITH_PRINTF(packet, svrPkg);\n\n                if (svrPkg.rpc_info().rsp_rpc_id() > 0)\n                {\n                    if (svrPkg.rpc_info().is_script_rpc())\n                    {\n                        proto_ff::Proto_ScriptRpcResult *pRespone = dynamic_cast<proto_ff::Proto_ScriptRpcResult *>(FindModule<NFICoroutineModule>()->GetUserData(svrPkg.rpc_info().rsp_rpc_id()));\n                        if (pRespone && svrPkg.rpc_info().rpc_ret_code() == 0)\n                        {\n                            if (svrPkg.rpc_info().req_rpc_hash() == std::hash<std::string>()(pRespone->req_type()) && svrPkg.rpc_info().rsp_rpc_hash() == std::hash<std::string>()(pRespone->rsp_type()))\n                            {\n                                pRespone->set_respone(svrPkg.msg_data());\n                            }\n                            else\n                            {\n                                int iRet = FindModule<NFICoroutineModule>()->Resume(svrPkg.rpc_info().rsp_rpc_id(),\n                                                                                    proto_ff::ERR_CODE_RPC_DECODE_FAILED);\n                                if (iRet != 0)\n                                {\n                                    NFLogError(NF_LOG_SYSTEMLOG, 0, \"NFICoroutineModule Resume Failed, CoId:{} nMsgId:{} iRet:{}\",\n                                               svrPkg.rpc_info().rsp_rpc_id(), svrPkg.msg_id(), iRet);\n                                }\n                                return 0;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        google::protobuf::Message *pRespone = FindModule<NFICoroutineModule>()->GetUserData(svrPkg.rpc_info().rsp_rpc_id());\n                        if (pRespone && svrPkg.rpc_info().rpc_ret_code() == 0)\n                        {\n                            if (svrPkg.rpc_info().rsp_rpc_hash() == std::hash<std::string>()(pRespone->GetTypeName()))\n                            {\n                                pRespone->ParseFromString(svrPkg.msg_data());\n                            }\n                            else\n                            {\n                                int iRet = FindModule<NFICoroutineModule>()->Resume(svrPkg.rpc_info().rsp_rpc_id(),\n                                                                                    proto_ff::ERR_CODE_RPC_DECODE_FAILED);\n                                if (iRet != 0)\n                                {\n                                    NFLogError(NF_LOG_SYSTEMLOG, 0, \"NFICoroutineModule Resume Failed, CoId:{} nMsgId:{} iRet:{}\",\n                                               svrPkg.rpc_info().rsp_rpc_id(), svrPkg.msg_id(), iRet);\n                                }\n                                return 0;\n                            }\n                        }\n                    }\n\n                    int iRet = FindModule<NFICoroutineModule>()->Resume(svrPkg.rpc_info().rsp_rpc_id(), svrPkg.rpc_info().rpc_ret_code());\n                    if (iRet != 0)\n                    {\n                        NFLogError(NF_LOG_SYSTEMLOG, 0, \"NFICoroutineModule Resume Failed, CoId:{} nMsgId:{} iRet:{}\", svrPkg.rpc_info().rsp_rpc_id(),\n                                   svrPkg.msg_id(), iRet);\n                    }\n                    return 0;\n                }\n                else\n                {\n                    OnHandleRpcService(connectionLink, objectLinkId, svrPkg);\n                    uint64_t useTime = NFGetMicroSecondTime() - startTime;\n                    if (useTime / 1000 > 33)\n                    {\n                        NFLogError(NF_LOG_SYSTEMLOG, 0, \"RpcServiec nMsgId:{} use time:{} ms, too long\", svrPkg.msg_id(), useTime / 1000);\n                    }\n                    NFLogTrace(NF_LOG_RECV_MSG, 0, \"RpcServiec:{} nMsgId:{} packet:{} use time:{} us\",\n                               svrPkg.msg_id(), packet.ToString(), useTime);\n\n                    return 0;\n                }\n            }\n        }\n\n\n        OnHandleReceiveNetPack(connectionLink, objectLinkId, packet);\n    }\n    return 0;\n}\n\nint NFCMessageModule::OnHandleRpcService(uint64_t connectionLink, uint64_t objectLinkId, const proto_ff::Proto_SvrPkg &reqSvrPkg)\n{\n    int iRet = 0;\n    uint32_t nMsgId = reqSvrPkg.msg_id();\n    uint32_t eServerType = GetServerTypeFromUnlinkId(objectLinkId);\n    if (eServerType < mxCallBack.size())\n    {\n        uint64_t startTime = NFGetMicroSecondTime();\n        CallBack &callBack = mxCallBack[eServerType];\n\n        if (nMsgId < NF_NET_MAX_MSG_ID)\n        {\n            NetRpcService &netRpcService = callBack.mxRpcCallBack[nMsgId];\n            if (netRpcService.m_pTarget != NULL && netRpcService.m_pRpcService != NULL)\n            {\n                if (netRpcService.m_createCo)\n                {\n                    NFIRpcService* pRpcService = netRpcService.m_pRpcService;\n                    iRet = FindModule<NFICoroutineModule>()->MakeCoroutine(\n                            [this, pRpcService, objectLinkId, reqSvrPkg]()\n                            {\n                                int iRet = pRpcService->run(objectLinkId, reqSvrPkg);\n                                if (iRet != 0)\n                                {\n                                    uint32_t eServerType = GetServerTypeFromUnlinkId(objectLinkId);\n                                    uint32_t nMsgId = reqSvrPkg.msg_id();\n                                    uint32_t reqBusId = reqSvrPkg.rpc_info().req_bus_id();\n                                    uint32_t reqServerType = reqSvrPkg.rpc_info().req_server_type();\n\n                                    proto_ff::Proto_SvrPkg rspSvrPkg;\n                                    rspSvrPkg.set_msg_id(nMsgId);\n                                    rspSvrPkg.mutable_rpc_info()->set_req_rpc_id(0);\n                                    rspSvrPkg.mutable_rpc_info()->set_rsp_rpc_id(reqSvrPkg.rpc_info().req_rpc_id());\n                                    rspSvrPkg.mutable_rpc_info()->set_req_rpc_hash(reqSvrPkg.rpc_info().req_rpc_hash());\n                                    rspSvrPkg.mutable_rpc_info()->set_rsp_rpc_hash(reqSvrPkg.rpc_info().rsp_rpc_hash());\n                                    rspSvrPkg.mutable_rpc_info()->set_rpc_ret_code(iRet);\n                                    rspSvrPkg.mutable_rpc_info()->set_is_script_rpc(reqSvrPkg.rpc_info().is_script_rpc());\n\n                                    FindModule<NFIMessageModule>()->SendMsgToServer((NF_SERVER_TYPES) eServerType, (NF_SERVER_TYPES) reqServerType, 0,\n                                                                                    reqBusId,\n                                                                                    proto_ff::NF_SERVER_TO_SERVER_RPC_CMD, rspSvrPkg);\n                                }\n                            });\n                }\n                else\n                {\n                    iRet = netRpcService.m_pRpcService->run(objectLinkId, reqSvrPkg);\n                }\n                netRpcService.m_iCount++;\n                uint64_t useTime = NFGetMicroSecondTime() - startTime;\n                netRpcService.m_iAllUseTime += useTime;\n                if (useTime > netRpcService.m_iMaxTime)\n                {\n                    netRpcService.m_iMaxTime = useTime;\n                }\n                if (useTime < netRpcService.m_iMinTime)\n                {\n                    netRpcService.m_iMinTime = useTime;\n                }\n                if (useTime / 1000 > 33)\n                {\n                    NFLogError(NF_LOG_SYSTEMLOG, 0, \"RpcService nMsgId:{} use time:{} ms, too long\", nMsgId,\n                               useTime / 1000);\n                }\n            }\n            else\n            {\n                iRet = proto_ff::ERR_CODE_RPC_MSG_FUNCTION_UNEXISTED;\n            }\n        }\n        else\n        {\n            iRet = proto_ff::ERR_CODE_RPC_MSG_FUNCTION_UNEXISTED;\n            NFLogErrorIf(nMsgId >= NF_NET_MAX_MSG_ID, NF_LOG_SYSTEMLOG, 0, \"nMsgID:{} >= NF_NET_MAX_MSG_ID\", nMsgId);\n        }\n\n        if (iRet != 0)\n        {\n            uint32_t reqBusId = reqSvrPkg.rpc_info().req_bus_id();\n            uint32_t reqServerType = reqSvrPkg.rpc_info().req_server_type();\n\n            proto_ff::Proto_SvrPkg rspSvrPkg;\n            rspSvrPkg.set_msg_id(nMsgId);\n            rspSvrPkg.mutable_rpc_info()->set_req_rpc_id(0);\n            rspSvrPkg.mutable_rpc_info()->set_rsp_rpc_id(reqSvrPkg.rpc_info().req_rpc_id());\n            rspSvrPkg.mutable_rpc_info()->set_req_rpc_hash(reqSvrPkg.rpc_info().req_rpc_hash());\n            rspSvrPkg.mutable_rpc_info()->set_rsp_rpc_hash(reqSvrPkg.rpc_info().rsp_rpc_hash());\n            rspSvrPkg.mutable_rpc_info()->set_rpc_ret_code(iRet);\n            rspSvrPkg.mutable_rpc_info()->set_is_script_rpc(reqSvrPkg.rpc_info().is_script_rpc());\n\n            FindModule<NFIMessageModule>()->SendMsgToServer((NF_SERVER_TYPES) eServerType, (NF_SERVER_TYPES) reqServerType, 0, reqBusId,\n                                                            proto_ff::NF_SERVER_TO_SERVER_RPC_CMD, rspSvrPkg);\n        }\n    }\n\n    return 0;\n}\n\nint NFCMessageModule::OnSocketNetEvent(eMsgType nEvent, uint64_t serverLinkId, uint64_t objectLinkId)\n{\n    uint32_t eServerType = GetServerTypeFromUnlinkId(objectLinkId);\n    if (eServerType < mxCallBack.size())\n    {\n        auto iter = mxCallBack[eServerType].mxEventCallBack.find(serverLinkId);\n        if (iter != mxCallBack[eServerType].mxEventCallBack.end())\n        {\n            NET_EVENT_FUNCTOR &pFun = iter->second.m_pFunctor;\n            if (pFun)\n            {\n                if (iter->second.m_createCo)\n                {\n                    int iRet = FindModule<NFICoroutineModule>()->MakeCoroutine(\n                            [pFun, nEvent, objectLinkId]{\n                                pFun(nEvent, objectLinkId);\n                            });\n                    CHECK_RET(iRet, \"nEvent:{}\", nEvent);\n                }\n                else {\n                    int iRet = pFun(nEvent, objectLinkId);\n                    CHECK_RET(iRet, \"nEvent:{}\", nEvent);\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nint\nNFCMessageModule::SendMsgToServer(NF_SERVER_TYPES eSendType, NF_SERVER_TYPES recvType, uint32_t srcBusId, uint32_t dstBusId, uint32_t nModuleId,\n                                  uint32_t nMsgId,\n                                  const google::protobuf::Message &xData, uint64_t param1, uint64_t param2)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), -1, \"eType error:{}\", (int) eSendType);\n    ServerLinkData &linkData = mServerLinkData[eSendType];\n\n    NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eSendType);\n    CHECK_EXPR(pConfig, -1, \"can't find server config! servertype:{}\", GetServerName(eSendType));\n\n    uint64_t destServerLinkId = GetUnLinkId(NF_IS_NONE, recvType, dstBusId, 0);\n    uint64_t sendLinkId = GetUnLinkId(NF_IS_NONE, eSendType, srcBusId, 0);\n    if (srcBusId == 0)\n    {\n        sendLinkId = GetUnLinkId(NF_IS_NONE, eSendType, pConfig->BusId, 0);\n    }\n\n    if (recvType == NF_ST_MASTER_SERVER)\n    {\n        Send(linkData.m_masterServerData.mUnlinkId, nModuleId, nMsgId, xData, param1, param2, sendLinkId, destServerLinkId);\n    }\n    else if (eSendType == NF_ST_MASTER_SERVER)\n    {\n        NF_SHARE_PTR<NFServerData> pServerData = FindModule<NFIMessageModule>()->GetServerByServerId(NF_ST_MASTER_SERVER, dstBusId);\n        if (pServerData)\n        {\n            Send(pServerData->mUnlinkId, nModuleId, nMsgId, xData, param1, param2, sendLinkId, destServerLinkId);\n        }\n    }\n    else\n    {\n        Send(linkData.m_routeData.mUnlinkId, nModuleId, nMsgId, xData, param1, param2, sendLinkId, destServerLinkId);\n    }\n    return 0;\n}\n\nint NFCMessageModule::SendMsgToServer(NF_SERVER_TYPES eSendType, NF_SERVER_TYPES recvType, uint32_t srcBusId, uint32_t dstBusId, uint32_t nModuleId,\n                                      uint32_t nMsgId, const std::string &xData, uint64_t param1, uint64_t param2)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), -1, \"eType error:{}\", (int) eSendType);\n    ServerLinkData &linkData = mServerLinkData[eSendType];\n\n    NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eSendType);\n    CHECK_EXPR(pConfig, -1, \"can't find server config! servertype:{}\", GetServerName(eSendType));\n\n    uint64_t destServerLinkId = GetUnLinkId(NF_IS_NONE, recvType, dstBusId, 0);\n    uint64_t sendLinkId = GetUnLinkId(NF_IS_NONE, eSendType, srcBusId, 0);\n    if (srcBusId == 0)\n    {\n        sendLinkId = GetUnLinkId(NF_IS_NONE, eSendType, pConfig->BusId, 0);\n    }\n\n    if (recvType == NF_ST_MASTER_SERVER)\n    {\n        Send(linkData.m_masterServerData.mUnlinkId, nModuleId, nMsgId, xData, param1, param2, sendLinkId, destServerLinkId);\n    }\n    else if (eSendType == NF_ST_MASTER_SERVER)\n    {\n        NF_SHARE_PTR<NFServerData> pServerData = FindModule<NFIMessageModule>()->GetServerByServerId(NF_ST_MASTER_SERVER, dstBusId);\n        if (pServerData)\n        {\n            Send(pServerData->mUnlinkId, nModuleId, nMsgId, xData, param1, param2, sendLinkId, destServerLinkId);\n        }\n    }\n    else\n    {\n        Send(linkData.m_routeData.mUnlinkId, nModuleId, nMsgId, xData, param1, param2, sendLinkId, destServerLinkId);\n    }\n    return 0;\n}\n\nint NFCMessageModule::SendTrans(NF_SERVER_TYPES eSendType, NF_SERVER_TYPES recvType, uint32_t srcBusId, uint32_t dstBusId, uint32_t nMsgID,\n                                const google::protobuf::Message &xData, uint32_t req_trans_id, uint32_t rsp_trans_id)\n{\n    proto_ff::Proto_SvrPkg svrPkg;\n    svrPkg.set_msg_id(nMsgID);\n    svrPkg.mutable_disp_info()->set_req_trans_id(req_trans_id);\n    svrPkg.mutable_disp_info()->set_rsp_trans_id(rsp_trans_id);\n    svrPkg.set_msg_data(xData.SerializeAsString());\n\n    CHECK_EXPR(eSendType < mServerLinkData.size(), -1, \"eType error:{}\", (int) eSendType);\n    ServerLinkData &linkData = mServerLinkData[eSendType];\n\n    NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eSendType);\n    CHECK_EXPR(pConfig, -1, \"can't find server config! servertype:{}\", GetServerName(eSendType));\n\n    uint64_t destServerLinkId = GetUnLinkId(NF_IS_NONE, recvType, dstBusId, 0);\n    uint64_t sendLinkId = GetUnLinkId(NF_IS_NONE, eSendType, srcBusId, 0);\n    if (srcBusId == 0)\n    {\n        sendLinkId = GetUnLinkId(NF_IS_NONE, eSendType, pConfig->BusId, 0);\n    }\n    if (recvType == NF_ST_MASTER_SERVER)\n    {\n        Send(linkData.m_masterServerData.mUnlinkId, NF_MODULE_SERVER, proto_ff::NF_SERVER_TO_SERVER_TRANS_CMD, svrPkg, 0, 0, sendLinkId,\n             destServerLinkId);\n    }\n    else if (eSendType == NF_ST_MASTER_SERVER)\n    {\n        NF_SHARE_PTR<NFServerData> pServerData = FindModule<NFIMessageModule>()->GetServerByServerId(NF_ST_MASTER_SERVER, dstBusId);\n        if (pServerData)\n        {\n            Send(pServerData->mUnlinkId, NF_MODULE_SERVER, proto_ff::NF_SERVER_TO_SERVER_TRANS_CMD, svrPkg, 0, 0, sendLinkId, destServerLinkId);\n        }\n    }\n    else\n    {\n        Send(linkData.m_routeData.mUnlinkId, NF_MODULE_SERVER, proto_ff::NF_SERVER_TO_SERVER_TRANS_CMD, svrPkg, 0, 0, sendLinkId, destServerLinkId);\n    }\n    return 0;\n}\n\nint NFCMessageModule::SendTrans(NF_SERVER_TYPES eSendType, NF_SERVER_TYPES recvType, uint32_t srcBusId, uint32_t dstBusId, uint32_t nMsgID,\n                                const std::string &xData, uint32_t req_trans_id, uint32_t rsp_trans_id)\n{\n    proto_ff::Proto_SvrPkg svrPkg;\n    svrPkg.set_msg_id(nMsgID);\n    svrPkg.mutable_disp_info()->set_req_trans_id(req_trans_id);\n    svrPkg.mutable_disp_info()->set_rsp_trans_id(rsp_trans_id);\n    svrPkg.set_msg_data(xData);\n\n    CHECK_EXPR(eSendType < mServerLinkData.size(), -1, \"eType error:{}\", (int) eSendType);\n    ServerLinkData &linkData = mServerLinkData[eSendType];\n\n    NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(eSendType);\n    CHECK_EXPR(pConfig, -1, \"can't find server config! servertype:{}\", GetServerName(eSendType));\n\n    uint64_t destServerLinkId = GetUnLinkId(NF_IS_NONE, recvType, dstBusId, 0);\n    uint64_t sendLinkId = GetUnLinkId(NF_IS_NONE, eSendType, srcBusId, 0);\n    if (srcBusId == 0)\n    {\n        sendLinkId = GetUnLinkId(NF_IS_NONE, eSendType, pConfig->BusId, 0);\n    }\n    if (recvType == NF_ST_MASTER_SERVER)\n    {\n        Send(linkData.m_masterServerData.mUnlinkId, NF_MODULE_SERVER, proto_ff::NF_SERVER_TO_SERVER_TRANS_CMD, svrPkg, 0, 0, sendLinkId,\n             destServerLinkId);\n    }\n    else if (eSendType == NF_ST_MASTER_SERVER)\n    {\n        NF_SHARE_PTR<NFServerData> pServerData = FindModule<NFIMessageModule>()->GetServerByServerId(NF_ST_MASTER_SERVER, dstBusId);\n        if (pServerData)\n        {\n            Send(pServerData->mUnlinkId, NF_MODULE_SERVER, proto_ff::NF_SERVER_TO_SERVER_TRANS_CMD, svrPkg, 0, 0, sendLinkId, destServerLinkId);\n        }\n    }\n    else\n    {\n        Send(linkData.m_routeData.mUnlinkId, NF_MODULE_SERVER, proto_ff::NF_SERVER_TO_SERVER_TRANS_CMD, svrPkg, 0, 0, sendLinkId, destServerLinkId);\n    }\n    return 0;\n}\n\nNF_SHARE_PTR<NFServerData> NFCMessageModule::GetServerByServerId(NF_SERVER_TYPES eSendType, uint32_t busId)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), NULL, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetServerByServerId(busId);\n}\n\nNF_SHARE_PTR<NFServerData> NFCMessageModule::GetServerByUnlinkId(NF_SERVER_TYPES eSendType, uint64_t unlinkId)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), NULL, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetServerByUnlinkId(unlinkId);\n}\n\nvoid NFCMessageModule::CloseServer(NF_SERVER_TYPES eSendType, NF_SERVER_TYPES destServer, uint32_t busId, uint64_t usLinkId)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), , \"eType error:{}\", (int) eSendType);\n    CloseLinkId(usLinkId);\n    return mServerLinkData[eSendType].CloseServer(destServer, busId, usLinkId);\n}\n\n\nNF_SHARE_PTR<NFServerData> NFCMessageModule::CreateServerByServerId(NF_SERVER_TYPES eSendType, uint32_t busId, NF_SERVER_TYPES busServerType,\n                                                                    const proto_ff::ServerInfoReport &data)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), NULL, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].CreateServerByServerId(busId, busServerType, data);\n}\n\nvoid NFCMessageModule::DelServerLink(NF_SERVER_TYPES eSendType, uint64_t linkId)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), , \"eType error:{}\", (int) eSendType);\n    mServerLinkData[eSendType].DelServerLink(linkId);\n}\n\nNFServerData *NFCMessageModule::GetRouteData(NF_SERVER_TYPES eSendType)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), NULL, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetRouteData();\n}\n\nconst NFServerData *NFCMessageModule::GetRouteData(NF_SERVER_TYPES eSendType) const\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), NULL, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetRouteData();\n}\n\nNFServerData *NFCMessageModule::GetMasterData(NF_SERVER_TYPES eSendType)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), NULL, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetMasterData();\n}\n\nconst NFServerData *NFCMessageModule::GetMasterData(NF_SERVER_TYPES eSendType) const\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), NULL, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetMasterData();\n}\n\nvoid NFCMessageModule::CloseAllLink(NF_SERVER_TYPES eSendType)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), , \"eType error:{}\", (int) eSendType);\n    mServerLinkData[eSendType].CloseAllLink(this);\n}\n\nvoid NFCMessageModule::CreateLinkToServer(NF_SERVER_TYPES eSendType, uint32_t busId, uint64_t linkId)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), , \"eType error:{}\", (int) eSendType);\n    mServerLinkData[eSendType].CreateLinkToServer(busId, linkId);\n}\n\nvoid NFCMessageModule::SetServerLinkId(NF_SERVER_TYPES eSendType, uint64_t linkId)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), , \"eType error:{}\", (int) eSendType);\n    mServerLinkData[eSendType].SetServerLinkId(linkId);\n}\n\nuint64_t NFCMessageModule::GetServerLinkId(NF_SERVER_TYPES eSendType) const\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), 0, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetServerLinkId();\n}\n\nuint64_t NFCMessageModule::GetClientLinkId(NF_SERVER_TYPES eSendType) const\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), 0, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetClientLinkId();\n}\n\nvoid NFCMessageModule::SetClientLinkId(NF_SERVER_TYPES eSendType, uint64_t linkId)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), , \"eType error:{}\", (int) eSendType);\n    mServerLinkData[eSendType].SetClientLinkId(linkId);\n}\n\nstd::vector<NF_SHARE_PTR<NFServerData>> NFCMessageModule::GetServerByServerType(NF_SERVER_TYPES eSendType, NF_SERVER_TYPES serverTypes)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), std::vector<NF_SHARE_PTR < NFServerData>>(), \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetServerByServerType(serverTypes);\n}\n\nNF_SHARE_PTR<NFServerData> NFCMessageModule::GetFirstServerByServerType(NF_SERVER_TYPES eSendType, NF_SERVER_TYPES serverTypes)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), NULL, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetFirstServerByServerType(serverTypes);\n}\n\nNF_SHARE_PTR<NFServerData>\nNFCMessageModule::GetRandomServerByServerType(NF_SERVER_TYPES eSendType, NF_SERVER_TYPES serverTypes)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), NULL, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetRandomServerByServerType(serverTypes);\n}\n\nNF_SHARE_PTR<NFServerData>\nNFCMessageModule::GetSuitServerByServerType(NF_SERVER_TYPES eSendType, NF_SERVER_TYPES serverTypes, uint64_t value)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), NULL, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetSuitServerByServerType(serverTypes, value);\n}\n\nNF_SHARE_PTR<NFServerData>\nNFCMessageModule::GetSuitServerByServerType(NF_SERVER_TYPES eSendType, NF_SERVER_TYPES serverTypes, const std::string &value)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), NULL, \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetSuitServerByServerType(serverTypes, value);\n}\n\nstd::vector<NF_SHARE_PTR<NFServerData>> NFCMessageModule::GetAllServer(NF_SERVER_TYPES eSendType)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), std::vector<NF_SHARE_PTR < NFServerData>>(), \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetAllServer();\n}\n\nstd::vector<NF_SHARE_PTR<NFServerData>> NFCMessageModule::GetAllServer(NF_SERVER_TYPES eSendType, NF_SERVER_TYPES serverTypes)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), std::vector<NF_SHARE_PTR < NFServerData>>(), \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetAllServer(serverTypes);\n}\n\nstd::vector<std::string> NFCMessageModule::GetDBNames(NF_SERVER_TYPES eSendType)\n{\n    CHECK_EXPR(eSendType < mServerLinkData.size(), std::vector<std::string>(), \"eType error:{}\", (int) eSendType);\n    return mServerLinkData[eSendType].GetDBNames();\n}\n\nbool NFCMessageModule::ResponseHttpMsg(NF_SERVER_TYPES serverType, const NFIHttpHandle &req, const string &strMsg,\n                                       NFWebStatus code, const string &reason)\n{\n    if (m_netModule)\n    {\n        return m_netModule->ResponseHttpMsg(serverType, req, strMsg, code, reason);\n    }\n    return false;\n}\n\nbool NFCMessageModule::ResponseHttpMsg(NF_SERVER_TYPES serverType, uint64_t requestId, const string &strMsg,\n                                       NFWebStatus code, const string &reason)\n{\n    if (m_netModule)\n    {\n        return m_netModule->ResponseHttpMsg(serverType, requestId, strMsg, code, reason);\n    }\n    return false;\n}\n\nbool NFCMessageModule::AddHttpMsgCB(NF_SERVER_TYPES serverType, const string &strCommand, NFHttpType eRequestType,\n                                    const HTTP_RECEIVE_FUNCTOR &cb)\n{\n    if (serverType > NF_ST_NONE && serverType < NF_ST_MAX)\n    {\n        std::string lowerCmd = NFStringUtility::ToLower(strCommand);\n        mxCallBack[serverType].mxHttpMsgCBMap[eRequestType].emplace(lowerCmd, cb);\n        return true;\n    }\n\n    return false;\n}\n\nbool NFCMessageModule::AddHttpOtherMsgCB(NF_SERVER_TYPES serverType, NFHttpType eRequestType,\n                                         const HTTP_RECEIVE_FUNCTOR &cb)\n{\n    if (serverType > NF_ST_NONE && serverType < NF_ST_MAX)\n    {\n        mxCallBack[serverType].mxHttpOtherMsgCBMap[eRequestType].push_back(cb);\n        return true;\n    }\n\n    return false;\n}\n\nbool\nNFCMessageModule::AddHttpFilterCB(NF_SERVER_TYPES serverType, const string &strCommand, const HTTP_FILTER_FUNCTOR &cb)\n{\n    if (serverType > NF_ST_NONE && serverType < NF_ST_MAX)\n    {\n        std::string lowerCmd = NFStringUtility::ToLower(strCommand);\n        mxCallBack[serverType].mxHttpMsgFliterMap.emplace(lowerCmd, cb);\n        return true;\n    }\n\n    return true;\n}\n\nbool NFCMessageModule::OnHttpReceiveNetPack(uint32_t serverType, const NFIHttpHandle &req)\n{\n    if (serverType <= NF_ST_NONE || serverType >= NF_ST_MAX) return false;\n\n    auto iter = mxCallBack[serverType].mxHttpMsgCBMap.find((NFHttpType) req.GetType());\n    if (iter != mxCallBack[serverType].mxHttpMsgCBMap.end())\n    {\n        std::string lowerPath = NFStringUtility::ToLower(req.GetPath());\n        NFStringUtility::TrimLeft(lowerPath, '/');\n        auto itPath = iter->second.find(lowerPath);\n        if (itPath != iter->second.end())\n        {\n            HTTP_RECEIVE_FUNCTOR &pFunPtr = itPath->second;\n            try\n            {\n                pFunPtr(serverType, req);\n            }\n            catch (const std::exception &)\n            {\n                ResponseHttpMsg((NF_SERVER_TYPES) serverType, req, \"unknow error\", NFWebStatus::WEB_INTER_ERROR);\n            }\n            return true;\n        }\n        else\n        {\n            for (int i = 0; i < (int) mxCallBack[serverType].mxHttpOtherMsgCBMap[(NFHttpType) req.GetType()].size(); ++i)\n            {\n                HTTP_RECEIVE_FUNCTOR &pFunPtr = mxCallBack[serverType].mxHttpOtherMsgCBMap[(NFHttpType) req.GetType()][i];\n                try\n                {\n                    pFunPtr(serverType, req);\n                }\n                catch (const std::exception &)\n                {\n                    ResponseHttpMsg((NF_SERVER_TYPES) serverType, req, \"unknow error\", NFWebStatus::WEB_INTER_ERROR);\n                    return true;\n                }\n            }\n            if (mxCallBack[serverType].mxHttpOtherMsgCBMap[(NFHttpType) req.GetType()].size() > 0)\n            {\n                return true;\n            }\n        }\n    }\n    else\n    {\n        for (int i = 0; i < (int) mxCallBack[serverType].mxHttpOtherMsgCBMap[(NFHttpType) req.GetType()].size(); ++i)\n        {\n            HTTP_RECEIVE_FUNCTOR &pFunPtr = mxCallBack[serverType].mxHttpOtherMsgCBMap[(NFHttpType) req.GetType()][i];\n            try\n            {\n                pFunPtr(serverType, req);\n            }\n            catch (const std::exception &)\n            {\n                ResponseHttpMsg((NF_SERVER_TYPES) serverType, req, \"unknow error\", NFWebStatus::WEB_INTER_ERROR);\n                return true;\n            }\n        }\n        if (mxCallBack[serverType].mxHttpOtherMsgCBMap[(NFHttpType) req.GetType()].size() > 0)\n        {\n            return true;\n        }\n    }\n\n    return ResponseHttpMsg((NF_SERVER_TYPES) serverType, req, \"\", NFWebStatus::WEB_ERROR);\n}\n\nNFWebStatus NFCMessageModule::OnHttpFilterPack(uint32_t serverType, const NFIHttpHandle &req)\n{\n    if (serverType <= NF_ST_NONE || serverType >= NF_ST_MAX) return NFWebStatus::WEB_ERROR;\n\n    std::string lowerPath = NFStringUtility::ToLower(req.GetPath());\n    NFStringUtility::TrimLeft(lowerPath, '/');\n    auto itPath = mxCallBack[serverType].mxHttpMsgFliterMap.find(lowerPath);\n    if (itPath != mxCallBack[serverType].mxHttpMsgFliterMap.end())\n    {\n        HTTP_FILTER_FUNCTOR &pFunPtr = itPath->second;\n        return pFunPtr(serverType, req);\n    }\n\n    return NFWebStatus::WEB_OK;\n}\n\nint NFCMessageModule::HttpGet(NF_SERVER_TYPES serverType, const string &strUri, const HTTP_CLIENT_RESPONE &respone,\n                              const map<std::string, std::string> &xHeaders, int timeout)\n{\n    if (m_netModule)\n    {\n        return m_netModule->HttpGet(serverType, strUri, respone, xHeaders, timeout);\n    }\n    return -1;\n}\n\nint NFCMessageModule::HttpPost(NF_SERVER_TYPES serverType, const string &strUri, const string &strPostData,\n                               const HTTP_CLIENT_RESPONE &respone, const map<std::string, std::string> &xHeaders,\n                               int timeout)\n{\n    if (m_netModule)\n    {\n        return m_netModule->HttpPost(serverType, strUri, strPostData, respone, xHeaders, timeout);\n    }\n    return -1;\n}\n\nint NFCMessageModule::SendEmail(NF_SERVER_TYPES serverType, const string &title, const string &subject, const string &content)\n{\n    if (m_netModule)\n    {\n        return m_netModule->SendEmail(serverType, title, subject, content);\n    }\n    return -1;\n}\n\nint NFCMessageModule::SendWxWork(NF_SERVER_TYPES serverType, const string &content)\n{\n    NFServerConfig *pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_MASTER_SERVER);\n    CHECK_NULL(pConfig);\n\n    std::string url = pConfig->wxWorkdRobot;\n    proto_ff::wxWorkRobotHttpPost msg;\n    msg.set_msgtype(\"text\");\n    auto pText = msg.mutable_text();\n    pText->set_content(content);\n    pText->add_mentioned_list(\"@all\");\n    std::string json;\n    NFProtobufCommon::ProtoMessageToJson(msg, &json, NULL);\n\n    std::map<std::string, std::string> xHeaders;\n    xHeaders.emplace(\"Accept\", \"application/json\");\n    xHeaders.emplace(\"Content-Type\", \"application/json;charset=utf-8\");\n\n    HttpPost(NF_ST_MASTER_SERVER, url, json, [](int code, const std::string &resp)\n    {\n        NFLogInfo(NF_LOG_SYSTEMLOG, 0, \"send wxWork info, code:{} rsp:{}\", code, resp);\n    }, xHeaders);\n    return 0;\n}\n\nint NFCMessageModule::BroadcastEventToServer(NF_SERVER_TYPES eType, NF_SERVER_TYPES recvType, uint32_t dstBusId, uint32_t nEventID,\n                                             uint32_t bySrcType, uint64_t nSrcID, const google::protobuf::Message &message)\n{\n    if (dstBusId <= 0) return -1;\n\n    proto_ff::Proto_SvrPkg svrPkg;\n    svrPkg.set_msg_id(0);\n    auto pEventInfo = svrPkg.mutable_event_info();\n    NF_ASSERT(pEventInfo);\n\n    pEventInfo->set_server_type(recvType);\n    pEventInfo->set_event_id(nEventID);\n    pEventInfo->set_src_type(bySrcType);\n    pEventInfo->set_src_id(nSrcID);\n    pEventInfo->set_full_message_name(message.GetTypeName());\n\n    svrPkg.set_msg_data(message.SerializeAsString());\n\n    return FindModule<NFIMessageModule>()->SendMsgToServer(eType, recvType, 0, dstBusId, NF_MODULE_SERVER,\n                                                           proto_ff::NF_SERVER_BROAD_EVENT_TO_SERVER_CMD, svrPkg);\n}\n\nint\nNFCMessageModule::BroadcastEventToServer(NF_SERVER_TYPES eType, NF_SERVER_TYPES recvType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID,\n                                         const google::protobuf::Message &message)\n{\n    return BroadcastEventToServer(eType, recvType, 0, nEventID, bySrcType, nSrcID, message);\n}\n\nint NFCMessageModule::BroadcastEventToServer(NF_SERVER_TYPES eType, uint32_t nEventID, uint32_t bySrcType, uint64_t nSrcID,\n                                             const google::protobuf::Message &message)\n{\n    BroadcastEventToServer(eType, NF_ST_SNS_SERVER, nEventID, bySrcType, nSrcID, message);\n    BroadcastEventToServer(eType, NF_ST_WORLD_SERVER, nEventID, bySrcType, nSrcID, message);\n    BroadcastEventToServer(eType, NF_ST_LOGIC_SERVER, nEventID, bySrcType, nSrcID, message);\n    BroadcastEventToServer(eType, NF_ST_GAME_SERVER, nEventID, bySrcType, nSrcID, message);\n    return 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/NFCommPlugin/NFKernelPlugin/NFCMessageModule.cpp b/src/NFCommPlugin/NFKernelPlugin/NFCMessageModule.cpp
--- a/src/NFCommPlugin/NFKernelPlugin/NFCMessageModule.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/src/NFCommPlugin/NFKernelPlugin/NFCMessageModule.cpp	(date 1688632074836)
@@ -756,7 +756,7 @@
                     {
                         NFLogError(NF_LOG_SYSTEMLOG, 0, "RpcServiec nMsgId:{} use time:{} ms, too long", svrPkg.msg_id(), useTime / 1000);
                     }
-                    NFLogTrace(NF_LOG_RECV_MSG, 0, "RpcServiec:{} nMsgId:{} packet:{} use time:{} us",
+                    NFLogTrace(NF_LOG_RECV_MSG, 0, "RpcServiec nMsgId:{} packet:{} use time:{} us",
                                svrPkg.msg_id(), packet.ToString(), useTime);
 
                     return 0;
@@ -927,6 +927,27 @@
             Send(pServerData->mUnlinkId, nModuleId, nMsgId, xData, param1, param2, sendLinkId, destServerLinkId);
         }
     }
+    else if (eSendType == NF_ST_PROXY_SERVER)
+    {
+        NF_SHARE_PTR<NFServerData> pServerData = GetServerByServerId(eSendType, dstBusId);
+        if (pServerData)
+        {
+            FindModule<NFIMessageModule>()->Send(pServerData->mUnlinkId, nModuleId, nMsgId, xData, param1, param2, pConfig->BusId, dstBusId);
+        }
+    }
+    else if (recvType == NF_ST_PROXY_SERVER)
+    {
+        auto pServerData = FindModule<NFIMessageModule>()->GetRandomServerByServerType(eSendType, NF_ST_PROXY_AGENT_SERVER);
+        if (pServerData)
+        {
+            FindModule<NFIMessageModule>()->Send(pServerData->mUnlinkId, nModuleId, nMsgId, xData, param1, param2, pConfig->BusId, dstBusId);
+            return 0;
+        }
+
+        pServerData = FindModule<NFIMessageModule>()->GetServerByServerId(eSendType, dstBusId);
+        CHECK_EXPR(pServerData, -1, "pServerData == NULL, busId:{}", dstBusId);
+        FindModule<NFIMessageModule>()->Send(pServerData->mUnlinkId, nModuleId, nMsgId, xData, param1, param2, pConfig->BusId, dstBusId);
+    }
     else
     {
         Send(linkData.m_routeData.mUnlinkId, nModuleId, nMsgId, xData, param1, param2, sendLinkId, destServerLinkId);
@@ -962,6 +983,14 @@
             Send(pServerData->mUnlinkId, nModuleId, nMsgId, xData, param1, param2, sendLinkId, destServerLinkId);
         }
     }
+    else if (eSendType == NF_ST_PROXY_SERVER)
+    {
+        NF_SHARE_PTR<NFServerData> pServerData = GetServerByServerId(eSendType, dstBusId);
+        if (pServerData)
+        {
+            FindModule<NFIMessageModule>()->Send(pServerData->mUnlinkId, nModuleId, nMsgId, xData, param1, param2, pConfig->BusId, dstBusId);
+        }
+    }
     else
     {
         Send(linkData.m_routeData.mUnlinkId, nModuleId, nMsgId, xData, param1, param2, sendLinkId, destServerLinkId);
Index: game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSession.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFWorldSession.h\n//    @Author           :    gaoyi\n//    @Date             :    22-10-28\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFWorldSession\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFLogicCommon/NFLogicCommonDefine.h\"\n#include \"NFWorldCommonDefine.h\"\n#include \"NFLogicCommon/NFAccountDefine.h\"\n\nclass NFWorldSession : public NFShmObj\n{\npublic:\n    NFWorldSession();\n\n    virtual ~NFWorldSession();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    uint64_t GetProxyId() const;\n\n    void SetProxyId(uint64_t proxyId);\n\n    uint64_t GetClientId() const;\n\n    void SetClientId(uint64_t clientId);\n\n    uint64_t GetUid() const;\n\n    void SetUid(uint64_t playerId);\n\n    uint64_t GetRoleId() const;\n\n    void SetRoleId(uint64_t roleId);\n\n    bool IsDisconnect() const;\n\n    void SetDisconnect(bool disconnect);\n\n    EAccountState GetState() const;\n\n    void SetState(EAccountState state);\n\n    uint32_t GetLogicId() const;\n\n    void SetLogicId(uint32_t logicId);\n\n    uint32_t GetGameId() const;\n\n    void SetGameId(uint32_t gameId);\n\n    uint64_t GetStateTick() const;\n\n    void SetStateTick(uint64_t stateTick);\n\npublic:\n    uint32_t GetLoginZid() const;\n\n    void SetLoginZid(uint32_t loginZid);\n\n    uint32_t GetChanId() const;\n\n    void SetChanId(uint32_t chanId);\nprivate:\n    uint64_t m_proxyId;\n    uint64_t m_clientId;\n    uint64_t m_uid;\n    uint64_t m_roleId;\n    uint32_t m_logicId;\n    uint32_t m_gameId;\n    bool m_disconnect;\n    EAccountState m_state;\n    uint64_t m_stateTick;\n    uint32_t m_loginZid;\n    uint32_t m_chanId;\nprivate:\nDECLARE_IDCREATE(NFWorldSession)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSession.h b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSession.h
--- a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSession.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSession.h	(date 1688616543098)
@@ -13,7 +13,7 @@
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFLogicCommon/NFLogicCommonDefine.h"
 #include "NFWorldCommonDefine.h"
 #include "NFLogicCommon/NFAccountDefine.h"
Index: game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSessionMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFWorldSessionMgr.h\n//    @Author           :    gaoyi\n//    @Date             :    22-10-28\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFWorldSessionMgr\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFLogicCommon/NFLogicCommonDefine.h\"\n#include \"NFWorldCommonDefine.h\"\n\nclass NFWorldSession;\nclass NFWorldSessionMgr : public NFShmObj\n{\npublic:\n    NFWorldSessionMgr();\n\n    virtual ~NFWorldSessionMgr();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    /**\n     * @brief 通过clientId获取Seesion数据\n     * @param clientId\n     * @return\n     */\n    NFWorldSession *GetSession(uint64_t clientId);\n\n    /**\n     * @brief 通过clientId创建Session数据, 如果玩家存在，返回NULL\n     * @param ClientId\n     * @return\n     */\n    NFWorldSession *CreateSession(uint64_t ClientId);\n\n    /**\n     * @brief 删除Session数据\n     * @param pSession\n     * @return\n     */\n    int DeleteSession(NFWorldSession *pSession);\n\n    int DeleteSession(uint64_t ClientId);\nprivate:\nDECLARE_IDCREATE(NFWorldSessionMgr)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSessionMgr.h b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSessionMgr.h
--- a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSessionMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldSessionMgr.h	(date 1688616543346)
@@ -12,7 +12,7 @@
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFLogicCommon/NFLogicCommonDefine.h"
 #include "NFWorldCommonDefine.h"
 
Index: game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayerMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFWorldPlayerIDHashTable.h\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFWorldPlayerIDHashTable.h\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmStl/NFShmHashMap.h\"\n#include \"NFWorldCommonDefine.h\"\n#include \"NFLoginQueue.h\"\n#include \"DBProto.pb.h\"\n#include <vector>\n\nenum\n{\n    /**\n     * @brief 通过roleId建立索引\n     */\n    NF_WORLD_PLAYER_ROLE_ID_INDEX = 0,\n    NF_WORLD_PLAYER_MAX_INDEX = 1,\n};\n\nclass NFWorldPlayer;\nclass NFWorldSession;\nclass NFWorldPlayerMgr : public NFShmObj {\npublic:\n    NFWorldPlayerMgr();\n    virtual ~NFWorldPlayerMgr();\n\n    int CreateInit();\n    int ResumeInit();\n\n    virtual int OnTimer(int timeId, int callcount) override;\npublic:\n    /**\n     * @brief\n     * @return\n     */\n    int PlayerTick();\n\n    int SessionTick();\npublic:\n\n    /**\n     * @brief 通过uid获取玩家数据\n     * @param uid\n     * @return\n     */\n    NFWorldPlayer *GetPlayerByUid(uint64_t uid);\n\n    /**\n     * @brief 通过uid创建玩家数据, 如果玩家存在，返回NULL\n     * @param uid\n     * @return\n     */\n    NFWorldPlayer *CreatePlayerByUid(uint64_t uid);\n\n    /**\n     * @brief 删除玩家数据\n     * @param pPlayer\n     * @return\n     */\n    int DeletePlayer(NFWorldPlayer *pPlayer);\n\npublic:\n    /**\n     * @brief 排队\n     */\n\n    uint32_t GetCurrentLoginNum() const;\n\n    void SetCurrentLoginNum(uint32_t currentLoginNum);\n\n    uint32_t GetMaxQueueNum() const;\n\n    void SetMaxQueueNum(uint32_t maxQueueNum);\n\n    uint32_t GetStartQueueNum() const;\n\n    void SetStartQueueNum(uint32_t startQueueNum);\n\n    /**\n     * @brief 是否需要排队\n     * @return\n     */\n    bool IsNeedLoginQueue() const;\n\n    /**\n     * @brief 是否排队队列已经满了\n     * @return\n     */\n    bool IsLoginQueueFull() const;\n\n    /**\n     * @brief 是否在排队队列中\n     * @param playerId\n     * @return\n     */\n    bool IsInLoginQueue(uint64_t playerId) const;\n\n     /**\n      * @brief 加入到登陆排队中\n      * @param playerId\n      * @return\n      */\n    bool InsertLoginQueue(uint64_t playerId);\n\n    /**\n     * @brief 通过玩家ID获得排队数据\n     * @param playerId\n     * @return\n     */\n    NFLoginQueue* GetLoginQueue(uint64_t playerId);\n\n    /**\n     * @brief 获得当前排队人数\n     * @return\n     */\n    uint32_t GetLoginQueueNum() const;\n\n    /**\n     * @brief 删除玩家的排队信息\n     * @param playerId\n     * @return\n     */\n    int DeleteLoginQueue(uint64_t playerId);\n\n    int HandleLoginQueue(NFWorldPlayer* pPlayer);\npublic:\n    /**\n     * @brief\n     * @param charDBBaseInfo\n     * @param charSimpleInfo\n     * @return\n     */\n    int CharDBToCharSimpleDB(const proto_ff::RoleDBData& charDBBaseInfo, proto_ff::LoginRoleProto& charSimpleInfo);\n\n    /**\n     * @brief 通知网关离开游戏\n     * @param pPlayer\n     * @param flag\n     * @return\n     */\n    int NotifyGateLeave(uint64_t proxyId, uint64_t clientId, proto_ff::LOGOUT_TYPE flag = proto_ff::LOGOUT_NONE);\n\n    /**\n     * @brief\n     * @param cid\n     * @param uid\n     * @param clientId\n     * @param logicId\n     * @param type\n     * @return\n     */\n    int NotifyLogicLeave(NFWorldPlayer* pPlayer, NFWorldSession* pSession, proto_ff::LOGOUT_TYPE type, int reqTransId = 0);\n\n    /**\n     * @brief 通知ProxyServer玩家服务器的busId改变\n     * @param pPlayer\n     * @param serverType\n     * @param busId\n     * @return\n     */\n    int NotifyGateChangeServerBusId(NFWorldPlayer* pPlayer, uint32_t serverType, uint32_t busId);\n\n    /**\n     * @brief 通知LogicServer玩家掉线\n     * @param pPlayer\n     * @param reason\n     * @return\n     */\n    int NotifyOtherServerPlayerDisconnect(NFWorldPlayer* pPlayer, uint32_t reason);\n    int NotifyOtherServerPlayerDisconnect(uint64_t uid, uint64_t roleId, uint32_t logicId, uint32_t reason);\n\n    int OnHandlePlayerDisconnect(NFWorldPlayer* pPlayer, uint32_t reason);\nprivate:\n    /**\n     * @brief 玩家ticker定时\n     */\n    int m_playerTickTimer;\nprivate:\n    /**\n     * @brief 排队\n     */\n\n    /**\n     * @brief 记录排队uid表列\n     */\n    NFShmHashMap<uint64_t, NFLoginQueue, WORLD_SERVER_MAX_ONLINE_COUNT> m_loginQueueMap;\n\n    /**\n     * @brief 计算已经进入的登陆的人数  包含在选角色界面和进入游戏的\n     */\n    uint32_t m_currentLoginNum;\n\n    /**\n     * @brief 最多排队的人数\n     */\n    uint32_t m_maxQueueNum;\n\n    /**\n     * @brief 开始排队人数\n     */\n    uint32_t m_startQueueNum;\nDECLARE_IDCREATE(NFWorldPlayerMgr)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayerMgr.h b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayerMgr.h
--- a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayerMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldPlayerMgr.h	(date 1688616543343)
@@ -12,7 +12,7 @@
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmStl/NFShmHashMap.h"
 #include "NFWorldCommonDefine.h"
 #include "NFLoginQueue.h"
Index: game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldConfig.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFWorldConfig.h\n//    @Author           :    gaoyi\n//    @Date             :    2022/10/12\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFWorldConfig\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include <common_logic_s.h>\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFLogicCommon/NFLogicCommonDefine.h\"\n\nclass NFWorldConfig : public NFShmObj\n{\npublic:\n    NFWorldConfig();\n\n    virtual ~NFWorldConfig();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    /**\n     * @brief 加载Server/WorldServer.lua中的WolrdServer配置，\n     *        通过common_logic.proto中的protobuf结构WorldServerConfig来解析，注意field要与lua的自动大小写完全一致\n     *        lua:                                   proto:\n     *        WorldServer = {                        message WorldExternalConfig {\n                    TokenTimeCheck = True;   ====>      optional bool TokenTimeCheck = 1[(yd_fieldoptions.field_use_stl)=true];\n              };                                    };\n     *\n     * @param luaMgr\n     * @return\n     */\n    int LoadConfig(NFILuaLoader luaMgr);\n\n    /**\n     * @brief 获取配置\n     * @return\n     */\n    const proto_ff_s::WorldExternalConfig_s *GetConfig() const;\n\n    bool IsWhiteAccount(uint64_t uid);\nprivate:\n    /**\n     * @brief 世界服务器额外配置\n     */\n    proto_ff_s::WorldExternalConfig_s m_config;\nDECLARE_IDCREATE(NFWorldConfig)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldConfig.h b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldConfig.h
--- a/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldConfig.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFWorldServer/NFWorldServerPlayerPlugin/NFWorldConfig.h	(date 1688616543423)
@@ -15,7 +15,7 @@
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFLogicCommon/NFLogicCommonDefine.h"
 
 class NFWorldConfig : public NFShmObj
Index: src/NFCommPlugin/NFNetPlugin/Evpp/NFEvppNetMessage.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFEvppServer.cpp\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFNetPlugin\n// -------------------------------------------------------------------------\n\n#include \"NFEvppNetMessage.h\"\n\n#include <stddef.h>\n#include <cstdint>\n#include <list>\n#include <string>\n#include <vector>\n#include \"NFComm/NFCore/NFCommon.h\"\n#include \"NFComm/NFPluginModule/NFCheck.h\"\n#include \"NFComm/NFPluginModule/NFIConfigModule.h\"\n\n#include \"NFComm/NFPluginModule/NFIMessageModule.h\"\n#include \"NFComm/NFPluginModule/NFLogMgr.h\"\n#include \"NFComm/NFPluginModule/NFCodeQueue.h\"\n#include \"NFEvppClient.h\"\n#include \"NFEvppServer.h\"\n#include \"NFCommPlugin/NFNetPlugin/NFIPacketParse.h\"\n#include \"NFComm/NFCore/NFStringUtility.h\"\n#include \"NFCommPlugin/NFNetPlugin/Encrypt.h\"\n\nNFEvppNetMessage::NFEvppNetMessage(NFIPluginManager* p, NF_SERVER_TYPES serverType) : NFINetMessage(p, serverType), m_netObjectPool(1000, false)\n{\n    auto pServerConfig = FindModule<NFIConfigModule>()->GetAppConfig(mServerType);\n    CHECK_EXPR_ASSERT_NOT_RET(pServerConfig, \"mServerType:{} Config Not Find\", mServerType);\n\n\tmxSendBuffer.AssureSpace(MAX_SEND_BUFFER_SIZE);\n    mxRecvBuffer.AssureSpace(MAX_RECV_BUFFER_SIZE);\n#ifdef NF_DEBUG_MODE\n    SetTimer(ENUM_SERVER_CLIENT_TIMER_HEART, ENUM_SERVER_CLIENT_TIMER_HEART_TIME_LONGTH*3);\n    SetTimer(ENUM_SERVER_TIMER_CHECK_HEART, ENUM_SERVER_TIMER_CHECK_HEART_TIME_LONGTH);\n#else\n    SetTimer(ENUM_SERVER_CLIENT_TIMER_HEART, ENUM_SERVER_CLIENT_TIMER_HEART_TIME_LONGTH*3);\n\tSetTimer(ENUM_SERVER_TIMER_CHECK_HEART, ENUM_SERVER_TIMER_CHECK_HEART_TIME_LONGTH);\n#endif\n    m_httpServer = NULL;\n#if defined(EVPP_HTTP_SERVER_SUPPORTS_SSL)\n    m_httpServerEnableSSL = false;\n#endif\n    m_httpClient = NULL;\n\n    if (m_pObjPluginManager->IsLoadAllServer())\n    {\n        m_coonectionThreadPool.reset(NF_NEW evpp::EventLoopThreadPool(NULL, 1));\n        m_coonectionThreadPool->Start(true);\n    }\n\n    /**\n     * @brief 0作废，作为一个错误处理，从1开始\n     */\n    mNetObjectArray.resize(MAX_CLIENT_INDEX);\n    for(int i = 1; i < (int)mNetObjectArray.size(); i++)\n    {\n        mNetObjectArray[i] = NULL;\n    }\n\n    mHandleMsgNumPerFrame= pServerConfig->HandleMsgNumPerFrame;\n\n    for(int i = 1; i < MAX_CLIENT_INDEX; i++)\n    {\n        uint64_t unlinkId = GetUnLinkId(NF_IS_NET, mServerType, pServerConfig->BusId, i);\n        while (!mFreeLinks.Enqueue(unlinkId)) {\n        }\n    }\n\n    mHandleMsgNumPerFrame = NF_NO_FIX_FAME_HANDLE_MAX_MSG_COUNT;\n\n    mCurHandleMsgNum = 0;\n    mLoopSendCount = 0;\n}\n\nNFEvppNetMessage::~NFEvppNetMessage()\n{\n\tfor (auto iter = mNetObjectMap.begin(); iter != mNetObjectMap.end(); ++iter)\n\t{\n\t\tauto pObject = iter->second;\n\t\tif (pObject)\n\t\t{\n            m_netObjectPool.FreeObj(pObject);\n\t\t}\n\t}\n    mNetObjectMap.clear();\n    for(int i = 1; i < (int)mNetObjectArray.size(); i++)\n    {\n        mNetObjectArray[i] = NULL;\n    }\n}\n\nvoid NFEvppNetMessage::ProcessMsgLogicThread()\n{\n    mCurHandleMsgNum = mHandleMsgNumPerFrame;\n\n    while(!mMsgQueue.IsQueueEmpty() && mCurHandleMsgNum >= 0)\n    {\n        std::vector<MsgFromNetInfo> vecMsg;\n        vecMsg.resize(200);\n\n        mMsgQueue.TryDequeueBulk(vecMsg);\n\n        for (size_t index = 0; index < vecMsg.size(); index++)\n        {\n            mCurHandleMsgNum--;\n            MsgFromNetInfo* pMsg = &vecMsg[index];\n            CHECK_EXPR_ASSERT_NOT_RET(pMsg->mTCPConPtr != NULL, \"\");\n\n            if (pMsg->nType == eMsgType_SENDBUFFER)\n            {\n                if (pMsg->pRecvBuffer)\n                {\n                    m_recvCodeQueueList.push_back(pMsg->pRecvBuffer);\n                    pMsg->mTCPConPtr->loop()->RunEvery(evpp::Duration(2500000), std::bind(&NFEvppNetMessage::LoopSend, this, pMsg->mTCPConPtr->loop()));\n                }\n            }\n            else if (pMsg->nType == eMsgType_CONNECTED)\n            {\n                for (size_t i = 0; i < m_connectionList.size(); i++)\n                {\n                    if (m_connectionList[i]->GetLinkId() == pMsg->nServerLinkId)\n                    {\n                        if (m_connectionList[i]->GetConnectionType() == NF_CONNECTION_TYPE_TCP_CLIENT)\n                        {\n                            CHECK_EXPR_ASSERT_NOT_RET(m_connectionList[i]->GetLinkId() == pMsg->nObjectLinkId, \"m_connectionList[i]->GetLinkId() != pMsg->nObjectLinkId, Error..........\");\n\n                            NetEvppObject* pObject = GetNetObject(pMsg->nObjectLinkId);\n                            if (pObject == NULL)\n                            {\n                                pObject = AddNetObject(pMsg->nObjectLinkId, pMsg->mTCPConPtr, m_connectionList[i]->GetPacketParseType(), m_connectionList[i]->IsSecurity());\n                                CHECK_EXPR_ASSERT_NOT_RET(pObject != NULL, \"AddNetObject Failed\");\n                            }\n                            CHECK_EXPR_ASSERT_NOT_RET(m_connectionList[i]->GetLinkId() == pObject->m_usLinkId, \"m_connectionList[i]->GetLinkId() != pObject->m_usLinkId, Error..........\");\n\n                            pObject->SetConnPtr(pMsg->mTCPConPtr);\n                            pObject->SetIsServer(false);\n                            NFDataPackage tmpPacket;\n                            OnHandleMsgPeer(eMsgType_CONNECTED, m_connectionList[i]->GetLinkId(), pObject->m_usLinkId, tmpPacket);\n                        }\n                        else\n                        {\n                            NetEvppObject* pObject = GetNetObject(pMsg->nObjectLinkId);\n                            CHECK_EXPR_ASSERT_NOT_RET(pObject == NULL, \"GetNetObject(pMsg->nObjectLinkId:{}) Exist\", pMsg->nObjectLinkId);\n                            pObject = AddNetObject(pMsg->nObjectLinkId, pMsg->mTCPConPtr, m_connectionList[i]->GetPacketParseType(), m_connectionList[i]->IsSecurity());\n                            CHECK_EXPR_ASSERT_NOT_RET(pObject != NULL, \"AddNetObject Failed\");\n\n                            NFDataPackage tmpPacket;\n                            OnHandleMsgPeer(eMsgType_CONNECTED, m_connectionList[i]->GetLinkId(), pObject->m_usLinkId, tmpPacket);\n                        }\n                        break;\n                    }\n                }\n            }\n            else if (pMsg->nType == eMsgType_DISCONNECTED)\n            {\n                if (pMsg->nObjectLinkId != 0)\n                {\n                    /**\n                     * @brief 不允许出现pMsg->nObjectLinkId找不到的情况，说明代码设置有考虑不周到的情况\n                     */\n                    NetEvppObject* pObject = GetNetObject(pMsg->nObjectLinkId);\n                    CHECK_EXPR_ASSERT_NOT_RET(pObject != NULL, \"net diconnect, tcp context error, can't find the net object:{}\", pMsg->nObjectLinkId);\n                    if (pObject->GetNeedRemove() == false)\n                    {\n                        if (pObject->IsServer())\n                        {\n                            pObject->SetNeedRemove(true);\n                        }\n                    }\n\n                    pObject->mConnPtr = NULL;\n                    NFDataPackage tmpPacket;\n                    OnHandleMsgPeer(eMsgType_DISCONNECTED, pMsg->nServerLinkId, pMsg->nObjectLinkId, tmpPacket);\n                }\n                else {\n                    /**\n                     * @brief   处理客户端连接服务器掉线, 这里相当于NFClient主动连接服务器，没有连接上\n                     *         这里的conn其实是一个临时的对象\n                     */\n                    NFLogError(NF_LOG_SYSTEMLOG, 0, \"net client:{} diconnect, can't connect the server\", pMsg->nServerLinkId);\n\n                    NFDataPackage tmpPacket;\n                    OnHandleMsgPeer(eMsgType_DISCONNECTED, pMsg->nServerLinkId, pMsg->nServerLinkId, tmpPacket);\n                }\n            }\n            else\n            {\n                NFLogError(NF_LOG_SYSTEMLOG, 0, \"net server  error\");\n            }\n        }\n    }\n}\n\nvoid NFEvppNetMessage::ProcessCodeQueue(NFCodeQueue* pRecvQueue)\n{\n    NF_ASSERT_MSG(pRecvQueue != NULL, \"pRecvQueue == NULL\");\n    while(pRecvQueue->HasCode() && mCurHandleMsgNum >= 0)\n    {\n        mxRecvBuffer.Clear();\n        int iCodeLen = 0;\n        int iRet = pRecvQueue->Get(mxRecvBuffer.WriteAddr(), mxRecvBuffer.WritableSize(), iCodeLen);\n        if (iRet || iCodeLen < (int)sizeof(NFDataPackage))\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"get code from pRecvQueue failed ret={}, codelen={}\", iRet, iCodeLen);\n            continue;\n        }\n        mxRecvBuffer.Produce(iCodeLen);\n\n        // 先获取NetHead\n        NFDataPackage* pCodePackage = (NFDataPackage*)mxRecvBuffer.ReadAddr();\n        if (iCodeLen != (int)sizeof(NFDataPackage) + (int)pCodePackage->nMsgLen) // 长度不一致\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"code length invalid. iCodeLen:{} != sizeof(NFDataPackage):{} + pCodePackage->nMsgLen:{}\", iCodeLen,\n                       sizeof(NFDataPackage), pCodePackage->nMsgLen);\n            continue;\n        }\n        pCodePackage->nBuffer = mxRecvBuffer.ReadAddr()+sizeof(NFDataPackage);\n\n        NetEvppObject* pObject = GetNetObject(pCodePackage->nObjectLinkId);\n        if (pObject)\n        {\n            OnHandleMsgPeer(eMsgType_RECIVEDATA, pCodePackage->nServerLinkId, pCodePackage->nObjectLinkId, *pCodePackage);\n        }\n        else\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"net server recv data, tcp context error\");\n        }\n        mCurHandleMsgNum--;\n    }\n}\n\n\nvoid NFEvppNetMessage::ProcessCodeQueue()\n{\n    mCurHandleMsgNum = mHandleMsgNumPerFrame;\n    for(int i = 0; i < (int)m_recvCodeQueueList.size(); i++)\n    {\n        NF_SHARE_PTR<NFBuffer> pRecvBuffer = m_recvCodeQueueList[i];\n        if (pRecvBuffer)\n        {\n            NFCodeQueue* pQueue = (NFCodeQueue*)pRecvBuffer->ReadAddr();\n            ProcessCodeQueue(pQueue);\n        }\n    }\n}\n\n/**\n* @brief 连接回调\n*\n* @return\n*/\nvoid NFEvppNetMessage::ConnectionCallback(const evpp::TCPConnPtr& conn, uint64_t ServerLinkId)\n{\n    if (conn->loop()->context(EVPP_LOOP_CONTEXT_0_MAIN_THREAD_RECV).IsEmpty())\n    {\n        NF_SHARE_PTR<NFBuffer> pRecvBuffer = NF_SHARE_PTR<NFBuffer>(NF_NEW NFBuffer());\n        pRecvBuffer->AssureSpace(MAX_CODE_QUEUE_SIZE);\n        pRecvBuffer->Produce(MAX_CODE_QUEUE_SIZE);\n        NFCodeQueue* pQueue = (NFCodeQueue*)pRecvBuffer->ReadAddr();\n        pQueue->Init(pRecvBuffer->ReadableSize());\n        conn->loop()->set_context(EVPP_LOOP_CONTEXT_0_MAIN_THREAD_RECV, evpp::Any(pRecvBuffer));\n\n        MsgFromNetInfo msg;\n        msg.nType = eMsgType_SENDBUFFER;\n        msg.mTCPConPtr = conn;\n        msg.nServerLinkId = ServerLinkId;\n        msg.pRecvBuffer = pRecvBuffer;\n        while(!mMsgQueue.Enqueue(msg)) {}\n    }\n\n    if (conn->loop()->context(EVPP_LOOP_CONTEXT_1_MAIN_THREAD_SEND).IsEmpty())\n    {\n        NF_SHARE_PTR<NFBuffer> pSendBuffer = NF_SHARE_PTR<NFBuffer>(NF_NEW NFBuffer());\n        pSendBuffer->AssureSpace(MAX_CODE_QUEUE_SIZE);\n        pSendBuffer->Produce(MAX_CODE_QUEUE_SIZE);\n        NFCodeQueue* pQueue = (NFCodeQueue*)pSendBuffer->ReadAddr();\n        pQueue->Init(pSendBuffer->ReadableSize());\n        conn->loop()->set_context(EVPP_LOOP_CONTEXT_1_MAIN_THREAD_SEND, evpp::Any(pSendBuffer));\n    }\n\n    if (conn->loop()->context(EVPP_LOOP_CONTEXT_2_COMPRESS_BUFFER).IsEmpty())\n    {\n        NF_SHARE_PTR<NFBuffer> pComBuffer = NF_SHARE_PTR<NFBuffer>(NF_NEW NFBuffer());\n        pComBuffer->AssureSpace(MAX_RECV_BUFFER_SIZE);\n        conn->loop()->set_context(EVPP_LOOP_CONTEXT_2_COMPRESS_BUFFER, evpp::Any(pComBuffer));\n    }\n\n    if (conn->loop()->context(EVPP_LOOP_CONTEXT_3_CONNPTR_MAP).IsEmpty())\n    {\n        NF_SHARE_PTR<std::unordered_map<uint64_t, evpp::TCPConnPtr>> pConnMap = NF_SHARE_PTR<std::unordered_map<uint64_t, evpp::TCPConnPtr>>(NF_NEW std::unordered_map<uint64_t, evpp::TCPConnPtr>());\n        conn->loop()->set_context(EVPP_LOOP_CONTEXT_3_CONNPTR_MAP, evpp::Any(pConnMap));\n    }\n\n    if (conn->loop()->context(EVPP_LOOP_CONTEXT_4_CODE_QUEUE_BUFFER).IsEmpty())\n    {\n        NF_SHARE_PTR<NFBuffer> pCodeQueueBuffer = NF_SHARE_PTR<NFBuffer>(NF_NEW NFBuffer());\n        pCodeQueueBuffer->AssureSpace(MAX_RECV_BUFFER_SIZE);\n        conn->loop()->set_context(EVPP_LOOP_CONTEXT_4_CODE_QUEUE_BUFFER, evpp::Any(pCodeQueueBuffer));\n    }\n\n\tif (conn->IsConnected())\n\t{\n\t\tconn->SetTCPNoDelay(true);\n\n        NF_SHARE_PTR<std::unordered_map<uint64_t, evpp::TCPConnPtr>> pConnMap = evpp::any_cast<NF_SHARE_PTR<std::unordered_map<uint64_t, evpp::TCPConnPtr>>>(conn->loop()->context(EVPP_LOOP_CONTEXT_3_CONNPTR_MAP));\n        NF_ASSERT_MSG(pConnMap != NULL,\n                           \"evpp::any_cast<NF_SHARE_PTR<std::unordered_map<uint64_t, evpp::TCPConnPtr>>>(conn->loop()->context(EVPP_LOOP_CONTEXT_3_CONNPTR_MAP)) Failed\");\n\n        MsgFromNetInfo msg;\n        msg.mTCPConPtr = conn;\n        msg.nServerLinkId = ServerLinkId;\n        msg.nType = eMsgType_CONNECTED;\n\n        //client connect\n        if (conn->type() == evpp::TCPConn::kOutgoing)\n        {\n            /**\n             * @brief 客户端掉线，一定会清理调conn->context(), 不如程序有问题\n             */\n            CHECK_EXPR_ASSERT_NOT_RET(conn->context().IsEmpty(), \"conn->context().IsEmpty() Error\");\n            msg.nObjectLinkId = ServerLinkId;\n            msg.mTCPConPtr->set_context(evpp::Any(msg.nObjectLinkId));\n            CHECK_EXPR_ASSERT_NOT_RET(pConnMap->find(ServerLinkId) == pConnMap->end(), \"pConnMap->find(connectLinkId) == pConnMap->end() Error\");\n            pConnMap->emplace(ServerLinkId, msg.mTCPConPtr);\n        }\n        else {\n            CHECK_EXPR_ASSERT_NOT_RET(conn->context().IsEmpty(), \"conn->context().IsEmpty() Error\");\n            msg.nObjectLinkId = GetFreeUnLinkId();\n            if (msg.nObjectLinkId == 0)\n            {\n                NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetFreeUnLinkId() Failed, No Free UnlinkId\");\n                msg.mTCPConPtr->Close();\n\n                /**\n                 * @brief 用来区分GetFreeUnLinkId Failed\n                 */\n                msg.mTCPConPtr->set_context(1, evpp::Any(msg.nObjectLinkId));\n\n                return;\n            }\n            msg.mTCPConPtr->set_context(evpp::Any(msg.nObjectLinkId));\n            CHECK_EXPR_ASSERT_NOT_RET(pConnMap->find(msg.nObjectLinkId) == pConnMap->end(), \"pConnMap->find(connectLinkId) == pConnMap->end() Error\");\n            pConnMap->emplace(msg.nObjectLinkId, msg.mTCPConPtr);\n        }\n\n\t\twhile(!mMsgQueue.Enqueue(msg)) {}\n\t}\n\telse\n\t{\n        NF_SHARE_PTR<std::unordered_map<uint64_t, evpp::TCPConnPtr>> pConnMap = evpp::any_cast<NF_SHARE_PTR<std::unordered_map<uint64_t, evpp::TCPConnPtr>>>(conn->loop()->context(EVPP_LOOP_CONTEXT_3_CONNPTR_MAP));\n        NF_ASSERT_MSG(pConnMap != NULL,\n                           \"evpp::any_cast<NF_SHARE_PTR<std::unordered_map<uint64_t, evpp::TCPConnPtr>>>(conn->loop()->context(EVPP_LOOP_CONTEXT_3_CONNPTR_MAP)) Failed\");\n\n        MsgFromNetInfo msg;\n        msg.Clear();\n        msg.mTCPConPtr = conn;\n        msg.nServerLinkId = ServerLinkId;\n        msg.nType = eMsgType_DISCONNECTED;\n        /**\n         * @brief 处理客户端连接服务器掉线\n         */\n        if (conn->type() == evpp::TCPConn::kOutgoing)\n        {\n            if (!conn->context().IsEmpty())\n            {\n                msg.nObjectLinkId  = evpp::any_cast<uint64_t>(conn->context());\n                msg.mTCPConPtr->set_context(evpp::Any());\n                pConnMap->erase(msg.nObjectLinkId);\n            }\n            else {\n                /**\n                 * @brief   处理NFClient客户端连接服务器掉线, 这里相当于NFClient主动连接服务器，没有连接上, 这里的conn其实是一个临时的对象.\n                 */\n                CHECK_EXPR_ASSERT_NOT_RET(pConnMap->find(msg.nServerLinkId) == pConnMap->end(), \"pConnMap->find(connectLinkId) == pConnMap->end() Error\");\n                msg.nObjectLinkId = 0;\n            }\n        }\n        else {\n            /**\n             * @brief 处理服务器的连接掉线\n             */\n            if (!conn->context().IsEmpty())\n            {\n                msg.nObjectLinkId  = evpp::any_cast<uint64_t>(conn->context());\n                msg.mTCPConPtr->set_context(evpp::Any());\n                pConnMap->erase(msg.nObjectLinkId);\n            }\n            else {\n                /**\n                 * @brief  GetFreeUnLinkId() Failed, NFServer的连接被主动关闭导致\n                 */\n                if (!conn->context(1).IsEmpty())\n                {\n                    NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetFreeUnLinkId() Failed, net client disconnect, can't find the net context!\");\n                    return;\n                }\n\n                NFLogError(NF_LOG_SYSTEMLOG, 0, \"Unknow Failed, net client disconnect, can't find the net context!\");\n                msg.nObjectLinkId = 0;\n            }\n        }\n\n        while(!mMsgQueue.Enqueue(msg)) {}\n\t}\n}\n\n/**\n* @brief 消息回调\n*\n* @return 消息回调\n*/\nvoid NFEvppNetMessage::MessageCallback(const evpp::TCPConnPtr& conn, evpp::Buffer* msg, uint64_t serverLinkId, uint32_t packetparse, bool bSecurity)\n{\n\tif (msg)\n\t{\n\t\twhile (true)\n\t\t{\n            char* outData = nullptr;\n            uint32_t outLen = 0;\n            uint32_t allLen = 0;\n            if (bSecurity)\n            {\n                Decryption((char*)msg->data(), msg->size());\n            }\n\n            NFDataPackage codePackage;\n            int ret = NFIPacketParse::DeCode(packetparse, msg->data(), msg->size(), outData, outLen, allLen, codePackage);\n\t\t\tif (ret < 0)\n\t\t\t{\n\t\t\t\tNFLogError(NF_LOG_SYSTEMLOG, 0, \"net server parse data failed!\");\n\t\t\t\tmsg->Reset();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (ret > 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n                if (!(codePackage.mModuleId == 0 && (codePackage.nMsgId == NF_CLIENT_TO_SERVER_HEART_BEAT\n                                                    || codePackage.nMsgId == NF_CLIENT_TO_SERVER_HEART_BEAT_RSP || codePackage.nMsgId == NF_SERVER_TO_SERVER_HEART_BEAT || codePackage.nMsgId == NF_SERVER_TO_SERVER_HEART_BEAT_RSP)))\n                {\n                    NFLogTrace(NF_LOG_RECV_MSG, 0, \"recv msg:{} \", codePackage.ToString());\n                }\n\n                if (codePackage.bCompress)\n                {\n                    CHECK_EXPR_ASSERT_NOT_RET(!conn->loop()->context(EVPP_LOOP_CONTEXT_2_COMPRESS_BUFFER).IsEmpty(), \"conn->loop()->context(EVPP_LOOP_CONTEXT_2_COMPRESS_BUFFER).IsEmpty()\");\n\n                    NF_SHARE_PTR<NFBuffer> pComBuffer = evpp::any_cast<NF_SHARE_PTR<NFBuffer>>(conn->loop()->context(EVPP_LOOP_CONTEXT_2_COMPRESS_BUFFER));\n                    pComBuffer->Clear();\n\n                    int decompressLen = NFIPacketParse::Decompress(packetparse, outData, outLen, (void *)pComBuffer->WriteAddr(), (int)pComBuffer->WritableSize());\n                    if (decompressLen < 0)\n                    {\n                        NFLogError(NF_LOG_RECV_MSG, 0, \"recv msg:{}, decompress failed!\", codePackage.ToString());\n                        msg->Skip(allLen);\n                        continue;\n                    }\n                    pComBuffer->Produce(decompressLen);\n\n                    CHECK_EXPR_ASSERT_NOT_RET(!conn->loop()->context(EVPP_LOOP_CONTEXT_0_MAIN_THREAD_RECV).IsEmpty(), \"conn->loop()->context(EVPP_LOOP_CONTEXT_0_MAIN_THREAD_RECV).IsEmpty(), Recv Code Queue Not Exist, Can't Parse Data\");\n                    NF_SHARE_PTR<NFBuffer> pRecvBuffer = evpp::any_cast<NF_SHARE_PTR<NFBuffer>>(conn->loop()->context(EVPP_LOOP_CONTEXT_0_MAIN_THREAD_RECV));\n                    NF_ASSERT(pRecvBuffer != NULL);\n                    NFCodeQueue* pRecvQueue = (NFCodeQueue*)pRecvBuffer->ReadAddr();\n                    NF_ASSERT(pRecvQueue != NULL);\n\n                    codePackage.nMsgLen = pComBuffer->ReadableSize();\n                    codePackage.nServerLinkId = serverLinkId;\n                    if (!conn->context().IsEmpty())\n                    {\n                        codePackage.nObjectLinkId  = evpp::any_cast<uint64_t>(conn->context());\n                    }\n                    else {\n                        NFLogError(NF_LOG_SYSTEMLOG, 0, \"net server diconnect, tcp context error\");\n                        codePackage.nObjectLinkId = 0;\n                    }\n                    int iRet = pRecvQueue->Put((const char*)&codePackage, sizeof(NFDataPackage), (const char*)pComBuffer->ReadAddr(), pComBuffer->ReadableSize());\n                    if (iRet != 0)\n                    {\n                        if (iRet == -1)\n                        {\n                            NFLogError(NF_LOG_SYSTEMLOG, 0, \"pRecvQueue->Put((const char*)&codePackage, sizeof(NFDataPackage), (const char*)outData, outLen) param error\");\n                        }\n                        else if (iRet == -2)\n                        {\n                            NFLogError(NF_LOG_SYSTEMLOG, 0, \"Recv Queue Full error, can't put the error\");\n                        }\n                    }\n                }\n                else {\n                    CHECK_EXPR_ASSERT_NOT_RET(!conn->loop()->context(EVPP_LOOP_CONTEXT_0_MAIN_THREAD_RECV).IsEmpty(), \"conn->loop()->context(EVPP_LOOP_CONTEXT_0_MAIN_THREAD_RECV).IsEmpty(), Recv Code Queue Not Exist, Can't Parse Data\");\n                    NF_SHARE_PTR<NFBuffer> pRecvBuffer = evpp::any_cast<NF_SHARE_PTR<NFBuffer>>(conn->loop()->context(EVPP_LOOP_CONTEXT_0_MAIN_THREAD_RECV));\n                    NF_ASSERT(pRecvBuffer != NULL);\n                    NFCodeQueue* pRecvQueue = (NFCodeQueue*)pRecvBuffer->ReadAddr();\n                    NF_ASSERT(pRecvQueue != NULL);\n\n                    codePackage.nMsgLen = outLen;\n                    codePackage.nServerLinkId = serverLinkId;\n                    if (!conn->context().IsEmpty())\n                    {\n                        codePackage.nObjectLinkId  = evpp::any_cast<uint64_t>(conn->context());\n                    }\n                    else {\n                        NFLogError(NF_LOG_SYSTEMLOG, 0, \"net server diconnect, tcp context error\");\n                        codePackage.nObjectLinkId = 0;\n                    }\n\n                    int iRet = pRecvQueue->Put((const char*)&codePackage, sizeof(NFDataPackage), (const char*)outData, outLen);\n                    if (iRet != 0)\n                    {\n                        if (iRet == -1)\n                        {\n                            NFLogError(NF_LOG_SYSTEMLOG, 0, \"pRecvQueue->Put((const char*)&codePackage, sizeof(NFDataPackage), (const char*)outData, outLen) param error\");\n                        }\n                        else if (iRet == -2)\n                        {\n                            NFLogError(NF_LOG_SYSTEMLOG, 0, \"Recv Queue Full error, Can't Parse Data\");\n                        }\n                    }\n                }\n\n\t\t\t\tmsg->Skip(allLen);\n\n                if (msg->length() <= 0)\n                {\n                    break;\n                }\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\n\nuint64_t NFEvppNetMessage::BindServer(const NFMessageFlag& flag)\n{\n    if (flag.bHttp)\n    {\n        int iRet = BindHttpServer(flag.nPort, flag.nNetThreadNum);\n        if (iRet == 0)\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"BindHttpServer Failed! port:{}\", flag.nPort);\n        }\n        return iRet;\n    }\n    else\n    {\n        NFEvppServer* pServer = NF_NEW NFEvppServer(m_pObjPluginManager, mServerType, flag);\n\n        uint64_t unLinkId = GetFreeUnLinkId();\n        pServer->SetLinkId(unLinkId);\n        pServer->SetConnCallback(\n                std::bind(&NFEvppNetMessage::ConnectionCallback, this, std::placeholders::_1, unLinkId));\n        pServer->SetMessageCallback(\n                std::bind(&NFEvppNetMessage::MessageCallback, this, std::placeholders::_1, std::placeholders::_2,\n                          unLinkId, flag.mPacketParseType, flag.mSecurity));\n        if (pServer->Init()) {\n            m_connectionList.push_back(pServer);\n            return unLinkId;\n        }\n    }\n\n    return 0;\n}\n\nuint64_t NFEvppNetMessage::BindHttpServer(uint32_t listen_port, uint32_t netThreadNum) {\n    NFCHttpServer *pServer = NF_NEW NFCHttpServer(mServerType, netThreadNum);\n    if (pServer) {\n        pServer->SetRecvCB(mHttpReceiveCB);\n        pServer->SetFilterCB(mHttpFilter);\n#if defined(EVPP_HTTP_SERVER_SUPPORTS_SSL)\n        pServer->SetPortSSLOption(listen_port, m_httpServerEnableSSL, m_httpServerCertificateChainFile.c_str(), m_httpServerPrivateKeyFile.c_str());\n#endif\n        if (pServer->InitServer(listen_port)) {\n            m_httpServer = pServer;\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/**\n* @brief\t初始化\n*\n* @return 是否成功\n*/\nuint64_t NFEvppNetMessage::ConnectServer(const NFMessageFlag &flag) {\n    NFEvppClient *pClient = NF_NEW NFEvppClient(m_pObjPluginManager, mServerType, flag);\n\n\tif (pClient)\n\t{\n\t\tuint64_t unLinkId = GetFreeUnLinkId();\n\t\tpClient->SetLinkId(unLinkId);\n\t\tpClient->SetConnCallback(std::bind(&NFEvppNetMessage::ConnectionCallback, this, std::placeholders::_1, unLinkId));\n\t\tpClient->SetMessageCallback(std::bind(&NFEvppNetMessage::MessageCallback, this, std::placeholders::_1, std::placeholders::_2, unLinkId, flag.mPacketParseType, flag.mSecurity));\n\n        if (m_pObjPluginManager->IsLoadAllServer() && m_coonectionThreadPool)\n        {\n            if (pClient->Init(m_coonectionThreadPool->GetNextLoop()))\n            {\n                m_connectionList.push_back(pClient);\n\n                return unLinkId;\n            }\n        }\n        else {\n            if (pClient->Init(NULL))\n            {\n                m_connectionList.push_back(pClient);\n\n                return unLinkId;\n            }\n        }\n\t}\n\treturn 0;\n}\n\nstd::string NFEvppNetMessage::GetLinkIp(uint64_t usLinkId)\n{\n\tNetEvppObject* pObject = GetNetObject(usLinkId);\n\tif (pObject)\n\t{\n\t\treturn pObject->GetStrIp();\n\t}\n\telse {\n\t    NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetNetObject Failed, usLinkId:{}\", usLinkId);\n\t}\n\n\treturn std::string(\"\");\n}\n\nuint32_t NFEvppNetMessage::GetPort(uint64_t usLinkId)\n{\n    NetEvppObject* pObject = GetNetObject(usLinkId);\n    if (pObject)\n    {\n        return pObject->GetPort();\n    }\n    else {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetNetObject Failed, usLinkId:{}\", usLinkId);\n    }\n    return 0;\n}\n\nNetEvppObject* NFEvppNetMessage::AddNetObject(const evpp::TCPConnPtr conn, uint32_t parseType, bool bSecurity)\n{\n\tuint64_t usLinkId = GetFreeUnLinkId();\n\tif (usLinkId == 0)\n\t{\n\t\tNFLogError(NF_LOG_SYSTEMLOG, 0, \"GetFreeUnLinkId Failed, connected count:{}  Can't add connect\", mNetObjectArray.size());\n\t\treturn nullptr;\n\t}\n\n\treturn AddNetObject(usLinkId, conn, parseType, bSecurity);\n}\n\nNetEvppObject* NFEvppNetMessage::AddNetObject(uint64_t unLinkId, const evpp::TCPConnPtr conn, uint32_t parseType, bool bSecurity)\n{\n    int index = GetServerIndexFromUnlinkId(unLinkId);\n    CHECK_EXPR_ASSERT(index > 0 && index < (int)mNetObjectArray.size(), NULL, \"unLinkId:{} index:{} > 0 && index < mNetObjectArray.size()\", unLinkId, index);\n    CHECK_EXPR_ASSERT(mNetObjectArray[index] == NULL, NULL, \"unLinkId:{} index:{} Exist\", unLinkId, index);\n    CHECK_EXPR_ASSERT(mNetObjectMap.find(unLinkId) == mNetObjectMap.end(), NULL, \"unLinkId:{} index:{} Exist\", unLinkId, index);\n\n\tauto pObject = m_netObjectPool.MallocObjWithArgs(conn);\n\tCHECK_EXPR_ASSERT(pObject, NULL, \"m_netObjectPool.Alloc() Failed\");\n\n    mNetObjectArray[index] = pObject;\n    mNetObjectMap.emplace(unLinkId, pObject);\n\n\tpObject->SetLinkId(unLinkId);\n\n\tif (conn)\n\t{\n\t\tstd::string remote_addr = conn->remote_addr();\n\t\tstd::vector<std::string> vec;\n        NFStringUtility::Split(remote_addr, \":\", &vec);\n        if (vec.size() >= 2)\n        {\n            pObject->SetStrIp(vec[0]);\n            pObject->SetPort(NFCommon::strto<uint32_t>(vec[1]));\n        }\n\t}\n\n\tpObject->SetPacketParseType(parseType);\n\tpObject->SetSecurity(bSecurity);\n\n\treturn pObject;\n}\n\nNetEvppObject* NFEvppNetMessage::GetNetObject(uint64_t usLinkId)\n{\n\tuint32_t serverType = GetServerTypeFromUnlinkId(usLinkId);\n\tCHECK_EXPR(serverType == mServerType, NULL, \"serverType != mServerType, this usLinkId:{} is not of the server:{}\", usLinkId, GetServerName(mServerType).c_str());\n\n    int index = GetServerIndexFromUnlinkId(usLinkId);\n    CHECK_EXPR_ASSERT(index > 0 && index < (int)mNetObjectArray.size(), NULL, \"unLinkId:{} index:{} > 0 && index < mNetObjectArray.size()\", usLinkId, index);\n\n    auto pObject = mNetObjectArray[index];\n\n\tif (pObject)\n\t{\n        return pObject;\n\t}\n\n\treturn nullptr;\n}\n\nvoid NFEvppNetMessage::CloseLinkId(uint64_t usLinkId)\n{\n    auto pObject = GetNetObject(usLinkId);\n    if (pObject)\n    {\n        if (pObject->mIsServer == false)\n        {\n            for (auto iter = m_connectionList.begin(); iter != m_connectionList.end(); iter++)\n            {\n                NFIConnection* pConnection = *iter;\n                if (pConnection->GetConnectionType() == NF_CONNECTION_TYPE_TCP_CLIENT)\n                {\n                    if (pConnection->GetLinkId() == usLinkId)\n                    {\n                        pConnection->Shut();\n                        pConnection->Finalize();\n                        NF_SAFE_DELETE(pConnection);\n                        m_connectionList.erase(iter);\n                        break;\n                    }\n                }\n            }\n        }\n\n        pObject->SetNeedRemove(true);\n        pObject->CloseObject();\n    }\n    else {\n        NFLogError(NF_LOG_SYSTEMLOG, 0, \"can't find the unLinkId:{}\", usLinkId);\n    }\n}\n\nuint64_t NFEvppNetMessage::GetFreeUnLinkId()\n{\n\tuint64_t unlinkId = 0;\n\tif (!mFreeLinks.IsQueueEmpty())\n\t{\n        if (mFreeLinks.TryDequeue(unlinkId)) {\n            return unlinkId;\n        }\n\t}\n\n    NFLogError(NF_LOG_SYSTEMLOG, 0, \"GetFreeUnLinkId failed!\");\n    return 0;\n}\n\nbool NFEvppNetMessage::Shut()\n{\n\tfor (size_t i = 0; i < m_connectionList.size(); i++)\n\t{\n\t\tNFIConnection* pConn = m_connectionList[i];\n\t\tif (pConn)\n\t\t{\n\t\t\tpConn->Shut();\n\t\t}\n\t}\n\n\n\treturn true;\n}\n\nbool NFEvppNetMessage::Finalize()\n{\n\tfor (size_t i = 0; i < m_connectionList.size(); i++)\n\t{\n\t\tNFIConnection* pConn = m_connectionList[i];\n\t\tif (pConn)\n\t\t{\n\t\t\tpConn->Finalize();\n\t\t}\n\t}\n\n    for (size_t i = 0; i < m_connectionList.size(); i++)\n    {\n        NFIConnection* pConn = m_connectionList[i];\n        if (pConn)\n        {\n            NF_SAFE_DELETE(pConn);\n        }\n    }\n\n    if (m_coonectionThreadPool)\n    {\n        m_coonectionThreadPool->Stop(true);\n        NF_ASSERT(m_coonectionThreadPool->IsStopped());\n        m_coonectionThreadPool->Join();\n        m_coonectionThreadPool.reset();\n    }\n\n    m_recvCodeQueueList.clear();\n\n\treturn true;\n}\n\nbool NFEvppNetMessage::Execute()\n{\n\tProcessMsgLogicThread();\n    ProcessCodeQueue();\n\tif (m_httpServer)\n    {\n\t    m_httpServer->Execute();\n    }\n    if (m_httpClient)\n    {\n        m_httpClient->Execute();\n    }\n\n\treturn true;\n}\n\nbool NFEvppNetMessage::Send(uint64_t usLinkId, NFDataPackage& packet, const char* msg, uint32_t nLen)\n{\n    NetEvppObject* pObject = GetNetObject(usLinkId);\n    if (pObject)\n    {\n        return Send(pObject, packet, msg, nLen);\n    }\n    else {\n        NFLogErrorIf(pObject == NULL, NF_LOG_SYSTEMLOG, 0, \"GetNetObject Failed, usLinkId:{}\", usLinkId);\n    }\n\n    return false;\n}\n\nbool NFEvppNetMessage::Send(uint64_t usLinkId, NFDataPackage& packet, const google::protobuf::Message& xData)\n{\n    NetEvppObject* pObject = GetNetObject(usLinkId);\n    if (pObject)\n    {\n        mxSendBuffer.Clear();\n        int byteSize = xData.ByteSize();\n        CHECK_EXPR((int)mxSendBuffer.WritableSize() >= byteSize, false, \"mxSendBuffer.WritableSize():{} < byteSize:{} msg:{}\", mxSendBuffer.WritableSize(), byteSize, xData.DebugString());\n\n        uint8_t* start = reinterpret_cast<uint8_t*>(mxSendBuffer.WriteAddr());\n        uint8_t* end = xData.SerializeWithCachedSizesToArray(start);\n        CHECK_EXPR(end - start == byteSize, false, \"xData.SerializeWithCachedSizesToArray Failed:{}\", xData.DebugString());\n        mxSendBuffer.Produce(byteSize);\n\n        return Send(pObject, packet, mxSendBuffer.ReadAddr(), mxSendBuffer.ReadableSize());\n    }\n    else {\n        NFLogErrorIf(pObject == NULL, NF_LOG_SYSTEMLOG, 0, \"GetNetObject Failed, usLinkId:{}\", usLinkId);\n    }\n\n    return false;\n}\n\nvoid NFEvppNetMessage::OnHandleMsgPeer(eMsgType type, uint64_t serverLinkId, uint64_t objectLinkId, NFDataPackage& packet)\n{\n\tswitch (type)\n\t{\n\tcase eMsgType_RECIVEDATA:\n\t{\n\t    if (packet.mModuleId == 0)\n        {\n            if (packet.nMsgId == NF_SERVER_TO_SERVER_HEART_BEAT)\n            {\n                NetEvppObject* pObject = GetNetObject(objectLinkId);\n                if (pObject && pObject->mIsServer)\n                {\n                    pObject->SetLastHeartBeatTime(NFGetTime());\n                    NFDataPackage packet;\n\n                    packet.mModuleId = 0;\n                    packet.nMsgId = NF_SERVER_TO_SERVER_HEART_BEAT_RSP;\n                    Send(pObject->GetLinkId(), packet, NULL, 0);\n                    return;\n                }\n                else {\n                    NFLogErrorIf(pObject == NULL, NF_LOG_SYSTEMLOG, 0, \"GetNetObject Failed, usLinkId:{}\", objectLinkId);\n                }\n            }\n\n            if (packet.nMsgId == NF_SERVER_TO_SERVER_HEART_BEAT_RSP)\n            {\n                NetEvppObject* pObject = GetNetObject(objectLinkId);\n                if (pObject && pObject->mIsServer == false)\n                {\n                    pObject->SetLastHeartBeatTime(NFGetTime());\n                    return;\n                }\n                else {\n                    NFLogErrorIf(pObject == NULL, NF_LOG_SYSTEMLOG, 0, \"GetNetObject Failed, usLinkId:{}\", objectLinkId);\n                }\n            }\n        }\n\n\t\tif (mRecvCB)\n\t\t{\n\t\t\tmRecvCB(serverLinkId, objectLinkId, packet);\n\t\t}\n\t}\n\tbreak;\n\tcase eMsgType_CONNECTED:\n\t{\n\t\tif (mEventCB)\n\t\t{\n\t\t\tmEventCB(type, serverLinkId, objectLinkId);\n\t\t}\n\t}\n\tbreak;\n\tcase eMsgType_DISCONNECTED:\n\t{\n\t\tif (mEventCB)\n\t\t{\n\t\t\tmEventCB(type, serverLinkId, objectLinkId);\n\t\t}\n\n\t\tif (objectLinkId > 0)\n        {\n            uint32_t serverType = GetServerTypeFromUnlinkId(objectLinkId);\n            NF_ASSERT_MSG(serverType == mServerType, \"the unlinkId is not of the server\");\n\n            uint32_t index = GetServerIndexFromUnlinkId(objectLinkId);\n            /**\n             * @brief 处理特殊情况，比如客户端主动连接服务器，连接不上\n             */\n            if (index == 0)\n            {\n                return;\n            }\n\n            auto pObject = GetNetObject(objectLinkId);\n            if (pObject && pObject->GetNeedRemove())\n            {\n                CHECK_EXPR_ASSERT_NOT_RET(index > 0 && index < mNetObjectArray.size(), \"unLinkId:{} index:{} Error\", objectLinkId, index);\n                CHECK_EXPR_ASSERT_NOT_RET(mNetObjectMap.find(objectLinkId) != mNetObjectMap.end(), \"unLinkId:{} index:{} Error\", objectLinkId, index);\n                mNetObjectArray[index] = NULL;\n                m_netObjectPool.FreeObj(pObject);\n                mNetObjectMap.erase(objectLinkId);\n                while (!mFreeLinks.Enqueue(objectLinkId)) {\n                }\n            }\n            else {\n                NFLogErrorIf(pObject == NULL, NF_LOG_SYSTEMLOG, 0, \"GetNetObject Failed, usLinkId:{}\", objectLinkId);\n            }\n        }\n\t}\n\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nbool NFEvppNetMessage::Send(NetEvppObject* pObject, NFDataPackage& codePackage, const char* msg, uint32_t nLen)\n{\n    if (pObject && !pObject->GetNeedRemove() && pObject->mConnPtr && pObject->mConnPtr->IsConnected())\n    {\n        codePackage.nPacketParseType = pObject->mPacketParseType;\n        codePackage.isSecurity = pObject->IsSecurity();\n        codePackage.nObjectLinkId = pObject->GetLinkId();\n        codePackage.nMsgLen = nLen;\n        CHECK_EXPR_ASSERT(!pObject->mConnPtr->loop()->context(EVPP_LOOP_CONTEXT_1_MAIN_THREAD_SEND).IsEmpty(), false, \"pConn->loop()->context(EVPP_LOOP_CONTEXT_1_MAIN_THREAD_SEND).IsEmpty() ERROR\");\n        NF_SHARE_PTR<NFBuffer> pSendBuffer = evpp::any_cast<NF_SHARE_PTR<NFBuffer>>(pObject->mConnPtr->loop()->context(EVPP_LOOP_CONTEXT_1_MAIN_THREAD_SEND));\n        CHECK_EXPR_ASSERT(pSendBuffer != NULL, false, \"evpp::any_cast<NF_SHARE_PTR<NFBuffer>>(pObject->mConnPtr->loop()->context(EVPP_LOOP_CONTEXT_1_MAIN_THREAD_SEND) NULL\");\n        NFCodeQueue* pSendQueue = (NFCodeQueue*)pSendBuffer->ReadAddr();\n        CHECK_EXPR_ASSERT(pSendQueue != NULL, false, \"(NFCodeQueue*)pSendBuffer->ReadAddr() NULL\");\n\n        int iRet = pSendQueue->Put((const char*)&codePackage, sizeof(NFDataPackage), msg, nLen);\n        if (iRet != 0)\n        {\n            if (iRet == -1)\n            {\n                NFLogError(NF_LOG_SYSTEMLOG, 0, \"pSendQueue->Put((const char*)&codePackage, sizeof(NFDataPackage), (const char*)msg, nLen) param error, package:({}) drop msg\", codePackage.ToString());\n            }\n            else if (iRet == -2)\n            {\n                NFLogError(NF_LOG_SYSTEMLOG, 0, \"Send Queue Full error, can't put the error, package:({}) drop msg\", codePackage.ToString());\n            }\n            pObject->mConnPtr->loop()->RunInLoop(std::bind(&NFEvppNetMessage::LoopSend, this, pObject->mConnPtr->loop()));\n        }\n\n        if (mLoopSendCount.load() <= 0)\n        {\n            mLoopSendCount++;\n            pObject->mConnPtr->loop()->RunInLoop(std::bind(&NFEvppNetMessage::LoopSend, this, pObject->mConnPtr->loop()));\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\nint NFEvppNetMessage::OnTimer(uint32_t nTimerID)\n{\n\tif (nTimerID == ENUM_SERVER_CLIENT_TIMER_HEART)\n\t{\n\t\tSendHeartMsg();\n\t}\n\telse if (nTimerID == ENUM_SERVER_TIMER_CHECK_HEART)\n\t{\n\t\tCheckServerHeartBeat();\n\t}\n    return 0;\n}\n\nvoid  NFEvppNetMessage::SendHeartMsg()\n{\n\tfor (size_t i = 0; i < m_connectionList.size(); i++)\n\t{\n\t\tif (m_connectionList[i] && m_connectionList[i]->GetConnectionType() == NF_CONNECTION_TYPE_TCP_CLIENT)\n\t\t{\n            NFDataPackage packet;\n            packet.mModuleId = 0;\n            packet.nMsgId = NF_SERVER_TO_SERVER_HEART_BEAT;\n\t\t\tSend(m_connectionList[i]->GetLinkId(), packet, NULL, 0);\n\t\t}\n\t}\n}\n\nvoid NFEvppNetMessage::CheckServerHeartBeat()\n{\n\tuint64_t nowTime = NFGetTime();\n\tfor (auto iter = mNetObjectMap.begin(); iter != mNetObjectMap.end(); iter++)\n\t{\n\t\tNetEvppObject* pObject = iter->second;\n\t\tif (pObject && pObject->mIsServer && pObject->mPacketParseType == PACKET_PARSE_TYPE_INTERNAL)//服务器与服务器之间有这个需求，协议必须是内网协议\n\t\t{\n\t\t    //debug 30min\n#ifdef NF_DEBUG_MODE\n\t\t\tif (pObject->mLastHeartBeatTime > 0 && nowTime - pObject->mLastHeartBeatTime > ENUM_SERVER_CLIENT_TIMER_HEART_TIME_LONGTH * 20 * 60)\n\t\t\t{\n\t\t\t\tpObject->CloseObject();\n\t\t\t}\n#else\n            if (pObject->mLastHeartBeatTime > 0 && nowTime - pObject->mLastHeartBeatTime > ENUM_EVPP_CLIENT_TIMER_HEART_TIME_LONGTH * 20)\n\t\t\t{\n\t\t\t\tpObject->CloseObject();\n\t\t\t}\n#endif\n\t\t}\n\t}\n}\n\nbool NFEvppNetMessage::ResponseHttpMsg(const NFIHttpHandle &req, const string &strMsg,\n                                       NFWebStatus code, const string &reason) {\n    if (m_httpServer)\n    {\n        return m_httpServer->ResponseMsg(req, strMsg, code, reason);\n    }\n    return false;\n}\n\nbool NFEvppNetMessage::ResponseHttpMsg(uint64_t requestId, const string &strMsg,\n                                       NFWebStatus code, const string &reason) {\n    if (m_httpServer)\n    {\n        return m_httpServer->ResponseMsg(requestId, strMsg, code, reason);\n    }\n    return false;\n}\n\nint NFEvppNetMessage::HttpGet(const string &strUri, const HTTP_CLIENT_RESPONE &respone,\n                              const map<std::string, std::string> &xHeaders, int timeout) {\n    if (!m_httpClient)\n    {\n        m_httpClient = NF_NEW NFCHttpClient();\n    }\n\n    return m_httpClient->HttpGet(strUri, respone, xHeaders, timeout);\n}\n\nint NFEvppNetMessage::HttpPost(const string &strUri, const string &strPostData, const HTTP_CLIENT_RESPONE &respone,\n                               const map<std::string, std::string> &xHeaders, int timeout) {\n    if (!m_httpClient)\n    {\n        m_httpClient = NF_NEW NFCHttpClient();\n    }\n\n    return m_httpClient->HttpPost(strUri, strPostData, respone, xHeaders, timeout);\n}\n\nvoid NFEvppNetMessage::LoopSend(evpp::EventLoop* loop)\n{\n    mLoopSendCount--;\n    CHECK_EXPR_ASSERT_NOT_RET(loop != NULL, \"loop == NULL ERROR\");\n    CHECK_EXPR_ASSERT_NOT_RET(!loop->context(EVPP_LOOP_CONTEXT_1_MAIN_THREAD_SEND).IsEmpty(), \"loop->context(EVPP_LOOP_CONTEXT_1_MAIN_THREAD_SEND).IsEmpty() ERROR\");\n    NF_SHARE_PTR<NFBuffer> pSendBuffer = evpp::any_cast<NF_SHARE_PTR<NFBuffer>>(loop->context(EVPP_LOOP_CONTEXT_1_MAIN_THREAD_SEND));\n    CHECK_EXPR_ASSERT_NOT_RET(pSendBuffer != NULL,  \"evpp::any_cast<NF_SHARE_PTR<NFBuffer>>(loop->context(EVPP_LOOP_CONTEXT_1_MAIN_THREAD_SEND) NULL\");\n    NFCodeQueue* pSendQueue = (NFCodeQueue*)pSendBuffer->ReadAddr();\n    CHECK_EXPR_ASSERT_NOT_RET(pSendQueue != NULL, \"(NFCodeQueue*)pSendBuffer->ReadAddr() NULL\");\n\n    CHECK_EXPR_ASSERT_NOT_RET(!loop->context(EVPP_LOOP_CONTEXT_2_COMPRESS_BUFFER).IsEmpty(), \"loop->context(EVPP_LOOP_CONTEXT_2_COMPRESS_BUFFER).IsEmpty() ERROR\");\n    NF_SHARE_PTR<NFBuffer> pComBuffer = evpp::any_cast<NF_SHARE_PTR<NFBuffer>>(loop->context(EVPP_LOOP_CONTEXT_2_COMPRESS_BUFFER));\n    CHECK_EXPR_ASSERT_NOT_RET(pComBuffer != NULL, \"pComBuffer NULL\");\n\n    CHECK_EXPR_ASSERT_NOT_RET(!loop->context(EVPP_LOOP_CONTEXT_4_CODE_QUEUE_BUFFER).IsEmpty(), \"loop->context(EVPP_LOOP_CONTEXT_4_CODE_QUEUE_BUFFER).IsEmpty() ERROR\");\n    NF_SHARE_PTR<NFBuffer> pCodeQueueBuffer = evpp::any_cast<NF_SHARE_PTR<NFBuffer>>(loop->context(EVPP_LOOP_CONTEXT_4_CODE_QUEUE_BUFFER));\n    CHECK_EXPR_ASSERT_NOT_RET(pCodeQueueBuffer != NULL, \"pCodeQueueBuffer NULL\");\n\n    while(pSendQueue->HasCode())\n    {\n        pCodeQueueBuffer->Clear();\n        int iCodeLen = 0;\n        int iRet = pSendQueue->Get(pCodeQueueBuffer->WriteAddr(), pCodeQueueBuffer->WritableSize(), iCodeLen);\n        if (iRet || iCodeLen < (int)sizeof(NFDataPackage))\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"get code from pRecvQueue failed ret={}, codelen={}\", iRet, iCodeLen);\n            continue;\n        }\n        pCodeQueueBuffer->Produce(iCodeLen);\n\n        // 先获取NetHead\n        NFDataPackage* pCodePackage = (NFDataPackage*)pCodeQueueBuffer->ReadAddr();\n        if (iCodeLen != (int)sizeof(NFDataPackage) + (int)pCodePackage->nMsgLen) // 长度不一致\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"code length invalid. iCodeLen:{} != sizeof(NFDataPackage):{} + pCodePackage->nMsgLen:{}\", iCodeLen,\n                       sizeof(NFDataPackage), pCodePackage->nMsgLen);\n            continue;\n        }\n\n        uint32_t parsePackageType = pCodePackage->nPacketParseType;\n        bool isSecurity = pCodePackage->isSecurity;\n\n        NF_SHARE_PTR<std::unordered_map<uint64_t, evpp::TCPConnPtr>> pConnMap = evpp::any_cast<NF_SHARE_PTR<std::unordered_map<uint64_t, evpp::TCPConnPtr>>>(loop->context(EVPP_LOOP_CONTEXT_3_CONNPTR_MAP));\n        CHECK_EXPR_ASSERT_NOT_RET(pConnMap != NULL, \"evpp::any_cast<NF_SHARE_PTR<std::unordered_map<uint64_t, evpp::TCPConnPtr>>>(loop->context(EVPP_LOOP_CONTEXT_3_CONNPTR_MAP)) Failed\");\n\n        auto iter = pConnMap->find(pCodePackage->nObjectLinkId);\n        if (iter == pConnMap->end())\n        {\n            NFLogError(NF_LOG_SYSTEMLOG, 0, \"pConnMap->find(pCodePackage->nObjectLinkId) Failed, objectLinkId:{} maybe disconnect\", pCodePackage->nObjectLinkId);\n            continue;\n        }\n\n        evpp::TCPConnPtr pConn = iter->second;\n\n        pComBuffer->Clear();\n        NFIPacketParse::EnCode(parsePackageType, *pCodePackage, pCodeQueueBuffer->ReadAddr() + sizeof(NFDataPackage), pCodePackage->nMsgLen, *pComBuffer);\n        pCodeQueueBuffer->Clear();\n\n        if (isSecurity)\n        {\n            Encryption(pComBuffer->ReadAddr(), pComBuffer->ReadableSize());\n        }\n\n        pConn->Send((const void*)pComBuffer->ReadAddr(), pComBuffer->ReadableSize());\n\n        pComBuffer->Clear();\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/NFCommPlugin/NFNetPlugin/Evpp/NFEvppNetMessage.cpp b/src/NFCommPlugin/NFNetPlugin/Evpp/NFEvppNetMessage.cpp
--- a/src/NFCommPlugin/NFNetPlugin/Evpp/NFEvppNetMessage.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/src/NFCommPlugin/NFNetPlugin/Evpp/NFEvppNetMessage.cpp	(date 1688611068953)
@@ -1010,7 +1010,7 @@
 {
 	for (size_t i = 0; i < m_connectionList.size(); i++)
 	{
-		if (m_connectionList[i] && m_connectionList[i]->GetConnectionType() == NF_CONNECTION_TYPE_TCP_CLIENT)
+		if (m_connectionList[i] && m_connectionList[i]->GetConnectionType() == NF_CONNECTION_TYPE_TCP_CLIENT && GetNetObject(m_connectionList[i]->GetLinkId()) != nullptr)
 		{
             NFDataPackage packet;
             packet.mModuleId = 0;
Index: game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by gaoyi on 2022/9/21.\n//\n\n#pragma once\n\nclass NFLogicCommon {\npublic:\n    NFLogicCommon();\n    virtual ~NFLogicCommon();\n};\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.h b/game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.h
--- a/game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/Fish/NFLogicComm/NFLogicCommon/NFLogicCommon.h	(date 1688630798370)
@@ -4,10 +4,22 @@
 
 #pragma once
 
+#include "NFComm/NFShmCore/NFShmString.h"
+
+#define NF_SERVER_COMMON_MAX_STRING_32 32
+#define NF_SERVER_COMMON_MAX_STRING_64 64
+#define NF_SERVER_COMMON_MAX_STRING_128 128
+#define NF_SERVER_COMMON_MAX_STRING_256 256
+#define NF_SERVER_COMMON_USE_STRING NF_SERVER_COMMON_MAX_STRING_128
+
+typedef NFShmString<NF_SERVER_COMMON_USE_STRING> NFCommonStr;
+
 class NFLogicCommon {
 public:
     NFLogicCommon();
     virtual ~NFLogicCommon();
+public:
+    static std::string GetLoginToken(const std::string& account, uint64_t userId, uint64_t time, const std::string& specialStr);
 };
 
 
Index: game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTestMgr.h\n//    @Author           :    gaoyi\n//    @Date             :    23-2-24\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTestMgr\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFServerComm/NFDescStorePlugin/NFIDescStore.h\"\n#include \"NFLogicCommon/NFDescStoreTypeDefines.h\"\n#include \"NFComm/NFShmStl/NFShmHashMap.h\"\n#include \"NFComm/NFShmStl/NFShmHashSet.h\"\n#include \"NFComm/NFShmStl/NFShmList.h\"\n\nclass NFTestMgr : public NFShmObj\n{\npublic:\n    NFTestMgr();\n\n    virtual ~NFTestMgr();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    virtual int OnTimer(int timeId, int callcount);\nprivate:\nDECLARE_IDCREATE(NFTestMgr)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestMgr.h b/game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestMgr.h
--- a/game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestMgr.h	(date 1688616542983)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFServerComm/NFDescStorePlugin/NFIDescStore.h"
 #include "NFLogicCommon/NFDescStoreTypeDefines.h"
Index: game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestObj.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTestObj.h\n//    @Author           :    gaoyi\n//    @Date             :    23-6-19\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTestObj\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n\nclass NFTestObj : public NFShmObj\n{\npublic:\n    NFTestObj();\n\n    virtual ~NFTestObj();\n\n    int CreateInit();\n\n    int ResumeInit();\n\nprivate:\nDECLARE_IDCREATE(NFTestObj)\npublic:\n    int id;\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestObj.h b/game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestObj.h
--- a/game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestObj.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFCommLogic/NFCommLogicPlugin/NFTestObj.h	(date 1688616543294)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 
 class NFTestObj : public NFShmObj
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/NFSnsServerPlayerPlugin.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFSnsServerPlayerPlugin.cpp\n//    @Author           :    Gao.Yi\n//    @Date             :   2022-09-18\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFSnsServerPlayerPlugin\n//\n// -------------------------------------------------------------------------\n\n#include \"NFSnsServerPlayerPlugin.h\"\n#include \"NFComm/NFPluginModule/NFIPluginManager.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFOnlineModule.h\"\n#include \"NFComm/NFPluginModule/NFIConfigModule.h\"\n#include \"Cache/NFRoleSimple.h\"\n#include \"Cache/NFCacheMgr.h\"\n#include \"Trans/NFTransCacheBase.h\"\n#include \"Trans/NFTransGetRoleSimple.h\"\n#include \"LoadCache/NFLoadCacheData.h\"\n#include \"NFLogicCommon/NFLogicCommonDefine.h\"\n#include \"LoadCache/NFLoadCacheMgr.h\"\n#include \"Trans/NFTransRoleLogin.h\"\n#include \"Trans/NFTransGetRoleDetail.h\"\n#include \"Part/NFSnsPart.h\"\n#include \"Part/NFSnsPartModule.h\"\n#include \"Relation/NFRelationPart.h\"\n\n#ifdef NF_DYNAMIC_PLUGIN\n\nNF_EXPORT void DllStartPlugin(NFIPluginManager* pm)\n{\n    CREATE_PLUGIN(pm, NFSnsServerPlayerPlugin)\n\n};\n\nNF_EXPORT void DllStopPlugin(NFIPluginManager* pm)\n{\n    DESTROY_PLUGIN(pm, NFSnsServerPlayerPlugin)\n};\n\n#endif\n\n\n//////////////////////////////////////////////////////////////////////////\n\nint NFSnsServerPlayerPlugin::GetPluginVersion()\n{\n\treturn 0;\n}\n\nstd::string NFSnsServerPlayerPlugin::GetPluginName()\n{\n\treturn GET_CLASS_NAME(NFSnsServerPlayerPlugin);\n}\n\nvoid NFSnsServerPlayerPlugin::Install()\n{\n\tREGISTER_MODULE(m_pObjPluginManager, NFCOnlineModule, NFCOnlineModule);\n    REGISTER_MODULE(m_pObjPluginManager, NFSnsPartModule, NFSnsPartModule);\n}\n\nvoid NFSnsServerPlayerPlugin::Uninstall()\n{\n\tUNREGISTER_MODULE(m_pObjPluginManager, NFCOnlineModule, NFCOnlineModule);\n    UNREGISTER_MODULE(m_pObjPluginManager, NFSnsPartModule, NFSnsPartModule);\n}\n\nbool NFSnsServerPlayerPlugin::InitShmObjectRegister()\n{\n    NFServerConfig* pConfig = FindModule<NFIConfigModule>()->GetAppConfig(NF_ST_SNS_SERVER);\n    NF_ASSERT(pConfig);\n\n    uint32_t maxOnlinePlayerNum = pConfig->MaxOnlinePlayerNum;\n\n    REGISTER_SHM_OBJ_WITH_HASH(NFRoleSimple, SNSSVR_MAX_ROLE_SIMPLE_NUM);\n    REGISTER_SHM_OBJ_WITH_HASH(NFRoleDetail, SNSSVR_MAX_ROLE_SIMPLE_NUM/3);\n    REGISTER_SINGLETON_SHM_OBJ(NFCacheMgr);\n    REGISTER_SHM_OBJ(NFTransCacheBase, 0);\n    REGISTER_SHM_OBJ(NFTransGetRoleSimple, SNS_GETTING_ROLE_SIZE*1.2);\n    REGISTER_SHM_OBJ(NFTransGetRoleDetail, SNS_GETTING_ROLE_SIZE*1.2);\n    REGISTER_SINGLETON_SHM_OBJ(NFLoadCacheMgr);\n    REGISTER_SHM_OBJ(NFTransRoleLogin, maxOnlinePlayerNum/10);\n\n    REGISTER_SHM_OBJ(NFSnsPart, 1);\n    REGISTER_SHM_OBJ(NFRelationPart, SNSSVR_MAX_ROLE_SIMPLE_NUM / 3);\n    return true;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/NFSnsServerPlayerPlugin.cpp b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/NFSnsServerPlayerPlugin.cpp
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/NFSnsServerPlayerPlugin.cpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/NFSnsServerPlayerPlugin.cpp	(date 1688616543182)
@@ -9,7 +9,7 @@
 
 #include "NFSnsServerPlayerPlugin.h"
 #include "NFComm/NFPluginModule/NFIPluginManager.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFOnlineModule.h"
 #include "NFComm/NFPluginModule/NFIConfigModule.h"
 #include "Cache/NFRoleSimple.h"
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Part/NFSnsPart.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFSnsPart.h\n//    @Author           :    gaoyi\n//    @Date             :    23-3-17\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFSnsPart\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFShmPtr.h\"\n#include \"DBProto2.pb.h\"\n#include \"NFComm/NFShmCore/NFSeqOP.h\"\n\nclass NFRoleDetail;\nclass NFRoleSimple;\nclass NFSnsPart : public NFShmObj, public NFSeqOP\n{\npublic:\n    NFSnsPart();\n\n    virtual ~NFSnsPart();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    int InitBase(NFRoleDetail *pMaster, uint32_t partType);\npublic:\n    virtual int Init(const proto_ff::RoleDBSnsDetail &data);\n\n    virtual int UnInit();\n\npublic:\n    /**\n     * @brief 处理客户端消息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleClientMessage(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 处理来自服务器的信息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleServerMessage(uint32_t msgId, NFDataPackage &packet);\npublic:\n    static int RegisterClientPartMsg(NFIPluginManager *pPluginManager, uint32_t nMsgID, uint32_t partType);\n\n    static int RegisterServerPartMsg(NFIPluginManager *pPluginManager, uint32_t nMsgID, uint32_t partType);\n\npublic:\n    /**\n     * @brief 登陆入口\n     * @return\n     */\n    virtual int OnLogin() { return 0; }\n\n    /**\n     * @brief 登出入口\n     * @return\n     */\n    virtual int OnLogout() { return 0; }\n\n    /**\n     * @brief 掉线入口\n     * @return\n     */\n    virtual int OnDisconnect() { return 0; }\n\n    /**\n     * @brief 重连入口\n     * @return\n     */\n    virtual int OnReconnect() { return 0; }\n\npublic:\n    ////////////////////////////////// 每日每周刷新接口 ///////////////////////////////////\n    /**\n     * @brief 每日刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int DailyUpdate(uint64_t unixSec) { return 0; }\n\n    /**\n     * @brief 每周刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int WeekUpdate(uint64_t unixSec) { return 0; }\n    ////////////////////////////////// 每日零点 每周一零点 刷新接口 ///////////////////////////////////\n    /**\n     * @brief 每日零点 刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int DailyZeroUpdate(uint64_t unixSec) { return 0; }\n\n    /**\n     * @brief 每日零点 刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int WeekZeroUpdate(uint64_t unixSec) { return 0; }\n\npublic:\n    /**\n     * @brief update\n     * @param tick\n     */\n    virtual int Update(uint64_t tick) { return 0; }\n\npublic:\n    virtual int SendMsgToClient(uint32_t nMsgId, const google::protobuf::Message &xData);\n\n    virtual int SendMsgToGameServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n\n    virtual int SendMsgToWorldServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n\n    virtual int SendMsgToLogicServer(uint32_t nMsgId, const google::protobuf::Message &xData);\npublic:\n    //部件类型\n    uint32_t PartType() { return m_partType; }\npublic:\n    virtual uint32_t GetCurRoleDetailSeq() const;\npublic:\n    NFRoleDetail* GetRoleDetail() const;\n    NFRoleSimple* GetRoleSimple() const;\nprotected:\n    uint64_t m_cid;\n    uint32_t m_partType;\nprivate:\nDECLARE_IDCREATE(NFSnsPart)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Part/NFSnsPart.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Part/NFSnsPart.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Part/NFSnsPart.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Part/NFSnsPart.h	(date 1688616543349)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFShmPtr.h"
 #include "DBProto2.pb.h"
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleSimple.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFRoleSimple.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-4\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFRoleSimple\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"DBProto_s.h\"\n#include \"DBProto2.pb.h\"\n\nclass NFRoleSimple : public NFShmObj\n{\npublic:\n    NFRoleSimple();\n\n    virtual ~NFRoleSimple();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    uint64_t GetRoleId() const;\n\n    void SetRoleId(uint64_t roleId);\n\n    uint64_t GetUid() const;\n\n    void SetUid(uint64_t uid);\n\n    uint32_t GetProxyId() const;\n\n    void SetProxyId(uint32_t proxyId);\n\n    uint64_t GetClientId() const;\n\n    void SetClientId(uint64_t clientId);\n\n    bool IsOnline() const;\n\n    void SetIsOnline(bool isOnline);\n\n    const proto_ff_s::RoleDBBaseData_s &GetBaseData() const;\n\n    void SetBaseData(const proto_ff_s::RoleDBBaseData_s &baseData);\n\n    void ReadFromPB(const proto_ff::RoleDBBaseData &dbData);\n\n    bool IsInited() const;\n\n    void SetIsInited(bool isInited);\n\n    uint32_t GetLogicId() const;\n\n    void SetLogicId(uint32_t logicId);\n\n    uint32_t GetGameId() const;\n\n    void SetGameId(uint32_t gameId);\n\npublic:\n    int Init(const proto_ff::RoleDBSimpleData &dbData);\n\npublic:\n    int OnLogin(bool isLoadDB);\n\n    int OnLogout();\n\n    int OnDisconnect(uint32_t reason);\n\n    int OnReconnect();\n\npublic:\n    bool CanDelete();\n\npublic:\n    int SendMsgToClient(uint32_t nMsgId, const google::protobuf::Message &xData);\n\n    int SendMsgToLogicServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n    int SendTransToLogicServer(uint32_t msgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0, uint32_t rsp_trans_id = 0);\n\n    int SendMsgToWorldServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n    int SendTransToWorldServer(uint32_t msgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0, uint32_t rsp_trans_id = 0);\n\n    int SendMsgToGameServer(uint32_t nMsgId, const google::protobuf::Message &xData);\n    int SendTransToGameServer(uint32_t msgId, const google::protobuf::Message &xData, uint32_t req_trans_id = 0, uint32_t rsp_trans_id = 0);\n\nprivate:\n    /**\n     * @brief\n     */\n    bool m_isInited;\n    /**\n     * @brief 角色ID\n     */\n    uint64_t m_roleId;\n\n    /**\n     * @brief 玩家ID\n     */\n    uint64_t m_uid;\npublic:\n    /**\n     * @brief 线上系统，更在线有关\n     */\n\n    /**\n     * @brief\n     */\n    uint32_t m_proxyId;\n\n    uint64_t m_clientId;\n\n    /**\n     * @brief\n     */\n    uint32_t m_logicId;\n\n    /**\n     * @brief\n     */\n    uint32_t m_gameId;\n\n    /**\n     * @brief\n     */\n    bool m_isOnline;\n\n    /**\n     * @brief\n     */\n    ::proto_ff_s::RoleDBBaseData_s m_baseData;\nDECLARE_IDCREATE(NFRoleSimple)\n\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleSimple.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleSimple.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleSimple.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleSimple.h	(date 1688616542954)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "DBProto_s.h"
 #include "DBProto2.pb.h"
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFCacheMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFCacheMgr.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-4\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFCacheMgr\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFRoleSimple.h\"\n#include \"NFRoleDetail.h\"\n\nclass NFCacheMgr : public NFShmObj\n{\npublic:\n    NFCacheMgr();\n\n    virtual ~NFCacheMgr();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    /**\n     * @brief\n     * @param num\n     * @return\n     */\n    int ReleaseSimpleCount(int num);\n\n    /**\n     * @brief\n     * @param roleId\n     * @return\n     */\n    NFRoleSimple *GetRoleSimple(uint64_t roleId);\n\n    /**\n     * @brief\n     * @param roleId\n     * @return\n     */\n    NFRoleSimple *CreateRoleSimple(uint64_t roleId);\n\n    /**\n     * @brief\n     * @param pRoleSimple\n     * @return\n     */\n    int DeleteRoleSimple(NFRoleSimple *pRoleSimple);\npublic:\n    /**\n     * @brief\n     * @param num\n     * @return\n     */\n    int ReleaseDetailCount(int num);\n\n    /**\n     * @brief\n     * @param roleId\n     * @return\n     */\n    NFRoleDetail *GetRoleDetail(uint64_t roleId);\n\n    /**\n     * @brief\n     * @param roleId\n     * @return\n     */\n    NFRoleDetail *CreateRoleDetail(uint64_t roleId);\n\n    /**\n     * @brief\n     * @param pRoleDetail\n     * @return\n     */\n    int DeleteRoleDetail(NFRoleDetail *pRoleDetail);\npublic:\n    /** 获取角色数据，如果找不到,query=true的情况下就去数据库拉取数据\n     * @brief\n     * @param role_id\n     * @param query 找不到是否查询数据库\n     * @return\n     */\n    NFRoleSimple* QueryRoleSimple(uint64_t role_id, bool query=true);\nprivate:\nDECLARE_IDCREATE(NFCacheMgr)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFCacheMgr.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFCacheMgr.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFCacheMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFCacheMgr.h	(date 1688616543297)
@@ -12,7 +12,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFRoleSimple.h"
 #include "NFRoleDetail.h"
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleDetail.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFRoleDetail.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-5\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFRoleDetail\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include <DBProto2.pb.h>\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLogicCommon/NFRoleDefine.h\"\n#include \"NFComm/NFShmStl/NFShmVector.h\"\n#include \"NFComm/NFShmCore/NFSeqOP.h\"\n\nclass NFSnsPart;\nclass NFRoleSimple;\nclass NFRoleDetail : public NFShmObj, public NFSeqOP\n{\npublic:\n    NFRoleDetail();\n\n    virtual ~NFRoleDetail();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    uint64_t GetRoleId() const;\n\n    void SetRoleId(uint64_t roleId);\n\npublic:\n    bool IsInited() const;\n\n    void SetIsInited(bool isInited);\n\npublic:\n    bool CanDelete();\n\npublic:\n    int Init(const proto_ff::RoleDBSnsDetail &data);\npublic:\n    NFSnsPart *CreatePart(uint32_t partType, const ::proto_ff::RoleDBSnsDetail &data);\n    int RecylePart(NFSnsPart *pPart);\n    //获取对应部件指针\n    virtual NFSnsPart *GetPart(uint32_t partType);\npublic:\n    NFRoleSimple* GetRoleSimple() const;\nprivate:\n    /**\n     * @brief\n     */\n    bool m_isInited;\n\n    /**\n     * @brief\n     */\n    uint64_t m_cid;\npublic:\n    NFShmVector<int, SNS_PART_MAX> m_pPart;\nDECLARE_IDCREATE(NFRoleDetail)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleDetail.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleDetail.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleDetail.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Cache/NFRoleDetail.h	(date 1688616543010)
@@ -14,7 +14,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFLogicCommon/NFRoleDefine.h"
 #include "NFComm/NFShmStl/NFShmVector.h"
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFQueryRole.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFQueryRole.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-4\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFQueryRole\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFArray.h\"\n\n#define MAX_QUERY_ROLE  120\n#define TRANS_SNS_BASE_TIMEOUT 60\n\nclass NFQueryRole\n{\npublic:\n    NFQueryRole();\n\n    virtual ~NFQueryRole();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    NFQueryRole& operator=(const NFQueryRole& query)\n    {\n        if (this != &query)\n        {\n            m_queryRoleList = query.m_queryRoleList;\n            m_queryedNum = query.m_queryedNum;\n            m_roleId = query.m_roleId;\n        }\n\n        return *this;\n    }\npublic:\n    /**\n     * @brief 添加一个要查询的roleId\n     * @param roleId\n     * @return\n     */\n    int Add(uint64_t roleId);\npublic:\n    /**\n     * @brief 被查询的角色队列\n     */\n    NFArray<uint64_t, MAX_QUERY_ROLE> m_queryRoleList;\n\n    /**\n     * @brief 已经查询到的数量\n     */\n    int m_queryedNum;\n\n    /**\n     * @brief\n     */\n    int m_queryedDetailNum;\n\n    /**\n     * @brief 查询的角色ID\n     */\n    uint64_t m_roleId;\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFQueryRole.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFQueryRole.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFQueryRole.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFQueryRole.h	(date 1688616543244)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFArray.h"
 
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleSimple.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransGetRoleRimple.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-4\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransGetRoleRimple\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFTransBase.h\"\n#include \"storesvr_sqldata.pb.h\"\n\nclass NFTransGetRoleSimple : public NFTransBase\n{\npublic:\n    NFTransGetRoleSimple();\n\n    virtual ~NFTransGetRoleSimple();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    virtual int HandleCSMsgReq(const google::protobuf::Message *pCSMsgReq);\n\n    virtual int HandleDBMsgRes(const google::protobuf::Message *pSSMsgRes, uint32_t cmd, uint32_t table_id,\n                               uint32_t seq, int32_t err_code);\n\n    int ProQueryRoleRes(const storesvr_sqldata::storesvr_selobj_res* pSelectRsp, int32_t err_code, int iTransID);\npublic:\n    int QueryRole(uint64_t roleId);\n\n    int OnTransFinished(int iRunLogicRetCode);\nprivate:\n    uint64_t m_roleId;\nDECLARE_IDCREATE(NFTransGetRoleSimple)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleSimple.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleSimple.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleSimple.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleSimple.h	(date 1688616543229)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFTransBase.h"
 #include "storesvr_sqldata.pb.h"
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransCacheBase.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransCacheBase.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-4\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransCacheBase\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFComm/NFShmCore/NFTransBase.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFQueryRole.h\"\n\nclass NFTransCacheBase : public NFTransBase\n{\npublic:\n    NFTransCacheBase();\n\n    virtual ~NFTransCacheBase();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    /**\n     * @brief\n     * @param reqTrans\n     * @return\n     */\n    virtual int Init(int reqTrans = 0);\n\n    /**\n     * @brief\n     * @param iRunLogicRetCode\n     * @return\n     */\n    int OnTransFinished(int iRunLogicRetCode) { return 0; }\n\n    /**\n     * @brief\n     * @param iRunLogicRetCode\n     * @return\n     */\n    int HandleTransFinished(int iRunLogicRetCode) { return 0; }\n\n    /**\n     * @brief\n     * @return\n     */\n    virtual int OnTimeOut() { return 0; }\n\n    /** 判断是否超时\n     * @brief\n     * @return\n     */\n    virtual bool IsTimeOut();\n\npublic:\n    /**\n     * @brief 查询详情数据\n     * @return\n     */\n    int QueryRoleDetail();\n\n    /**\n     * @brief\n     * @param iRunLogicRetCode\n     * @param roleId\n     * @return\n     */\n    virtual int HandleGetRoleDetailRes(int iRunLogicRetCode, uint64_t roleId);\n\npublic:\n    /**\n     * @brief 处理获取角色数据返回\n     * @param iRunLogicRetCode\n     * @param roleID\n     * @return\n     */\n    virtual int HandleGetRoleSimpleRes(int iRunLogicRetCode, uint64_t roleId);\n\n    /**\n     * @brief 查询角色\n     * @param query\n     * @return\n     */\n    virtual int QueryRoleSimple(NFQueryRole& query);\n\n    /**\n     * @brief 查询角色\n     * @param roleID\n     * @return\n     */\n    virtual int QueryRoleSimple(uint64_t roleID);\n\n    /**\n     * @brief 查询角色\n     * @return\n     */\n    virtual int QueryRoleSimple();\n\n    /**\n     * @brief 查询角色回调\n     * @param query\n     * @return\n     */\n    virtual int QueryRole_CallBack(NFQueryRole& query);\npublic:\n\n    void SetNotify() { m_bNotify = true; }\n\n    void AddQueryedSimpleNum() { m_query.m_queryedNum++; }\n\n    bool IsQuerySimpleFinished() { return m_query.m_queryedNum >= m_query.m_queryRoleList.GetSize(); }\n\n    void AddQueryedDetailNum() { m_query.m_queryedDetailNum++; }\n\n    bool IsQueryDetailFinished() { return m_query.m_queryedDetailNum >= m_query.m_queryRoleList.GetSize(); }\nprotected:\n    NFQueryRole m_query;\n    bool m_bNotify;\n    int m_reqTrans;\n    bool m_bGetDetail;\nDECLARE_IDCREATE(NFTransCacheBase)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransCacheBase.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransCacheBase.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransCacheBase.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransCacheBase.h	(date 1688616543286)
@@ -13,7 +13,7 @@
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
 #include "NFComm/NFShmCore/NFTransBase.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFQueryRole.h"
 
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransRoleLogin.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransRoleLOgin.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-5\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransRoleLOgin\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFTransCacheBase.h\"\n#include \"DBProto2_s.h\"\n#include \"ServerInternal2.pb.h\"\n#include \"storesvr_sqldata.pb.h\"\n\nclass NFTransRoleLogin : public NFTransCacheBase\n{\npublic:\n    NFTransRoleLogin();\n\n    virtual ~NFTransRoleLogin();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    virtual int OnTransFinished(int iRunLogicRetCode) override;\n\n    virtual int HandleTransFinished(int iRunLogicRetCode) override { return 0; }\n\n    virtual int OnTimeOut() override { return 0; }\n\n    virtual int HandleCSMsgReq(const google::protobuf::Message *pCSMsgReq) override;\n\n    virtual int HandleDBMsgRes(const google::protobuf::Message *pSSMsgRes, uint32_t cmd, uint32_t table_id,\n                               uint32_t seq, int32_t err_code) override;\n\npublic:\n    /**\n     * @brief 处理登录\n     * @param req\n     * @return\n     */\n    int OnRoleLogin(const proto_ff::WorldToSnsLoginReq &req);\n\n    /**\n     * @brief 处理登录返回\n     * @param iRunLogicRetCode\n     * @return\n     */\n    int OnRoleLoginRes(int iRunLogicRetCode);\n\n    /**\n     * @brief 处理数据库插入RoleDetail返回\n     * @param pRes\n     * @param err_code\n     * @return\n     */\n    int OnHandleInsertRoleDetailRes(const storesvr_sqldata::storesvr_insertobj_res* pRes, int err_code);\npublic:\n    /**\n     * @brief 处理获取角色数据返回\n     * @param iRunLogicRetCode\n     * @param roleID\n     * @return\n     */\n    virtual int HandleGetRoleSimpleRes(int iRunLogicRetCode, uint64_t roleId) override;\n\n    /**\n     * @brief\n     * @param iRunLogicRetCode\n     * @param roleId\n     * @return\n     */\n    virtual int HandleGetRoleDetailRes(int iRunLogicRetCode, uint64_t roleId) override;\n\n    /**\n     * @brief 查询角色回调\n     * @param query\n     * @return\n     */\n    virtual int QueryRole_CallBack(NFQueryRole &query) override;\n\nprivate:\n    uint64_t m_roleId;\n    uint32_t m_cmd;\n    uint32_t m_logicId;\n    uint32_t m_proxyId;\n    uint64_t m_clientId;\n    proto_ff_s::RoleDBSimpleData_s m_simpleInfo;\n    uint32_t m_lastLoginTime;\n    uint32_t m_lastLogoutTime;\nDECLARE_IDCREATE(NFTransRoleLogin)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransRoleLogin.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransRoleLogin.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransRoleLogin.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransRoleLogin.h	(date 1688616542985)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFTransCacheBase.h"
 #include "DBProto2_s.h"
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleDetail.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFTransGetRoleDetail.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-5\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFTransGetRoleDetail\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"storesvr_sqldata.pb.h\"\n#include \"NFComm/NFShmCore/NFTransBase.h\"\n\nclass NFTransGetRoleDetail : public NFTransBase\n{\npublic:\n    NFTransGetRoleDetail();\n\n    virtual ~NFTransGetRoleDetail();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    virtual int HandleCSMsgReq(const google::protobuf::Message *pCSMsgReq);\n\n    virtual int HandleDBMsgRes(const google::protobuf::Message *pSSMsgRes, uint32_t cmd, uint32_t table_id,\n                               uint32_t seq, int32_t err_code);\n\n    int ProQueryRoleRes(const storesvr_sqldata::storesvr_selobj_res* pSelectRsp, int32_t err_code, int iTransID);\npublic:\n    int QueryRole(uint64_t roleId);\n\n    int OnTransFinished(int iRunLogicRetCode);\nprivate:\n    uint64_t m_roleId;\nDECLARE_IDCREATE(NFTransGetRoleDetail)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleDetail.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleDetail.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleDetail.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Trans/NFTransGetRoleDetail.h	(date 1688616543142)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "storesvr_sqldata.pb.h"
 #include "NFComm/NFShmCore/NFTransBase.h"
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPlayer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFRelationPlayer.h\n//    @Author           :    gaoyi\n//    @Date             :    23-4-3\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFRelationPlayer\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmCore/NFShmString.h\"\n\n//基本关系数据\nstruct NFRelationCommonPlayer\n{\n    NFRelationCommonPlayer();\n\n    virtual ~NFRelationCommonPlayer();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    uint64_t m_cid;\n};\n\n//最近联系人玩家结构体\nstruct NFRelationRecentPlayer : public NFRelationCommonPlayer\n{\n    NFRelationRecentPlayer();\n\n    virtual ~NFRelationRecentPlayer();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    uint32_t m_recentType; //交互类型\n    uint64_t m_recentTime; //最后一次交互的时间\n};\n\n//好友玩家结构体\nstruct NFRelationFriendPlayer : public NFRelationCommonPlayer\n{\n    NFRelationFriendPlayer();\n\n    virtual ~NFRelationFriendPlayer();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    uint32_t closeness;            //亲密度\n    uint32_t closenessLevel;    //亲密度等级 （不存库，每次登陆时重新计算）\n    uint32_t todayCloseness;    //今天获得的亲密度值 （每天刷新，玩家身上保存刷新时间，每天定时重置亲密度值）\n    uint64_t updateTime;        //亲密度刷新时间\n};\n\n//仇人玩家结构体\nstruct NFRelationHatePlayer : public NFRelationCommonPlayer\n{\n    NFRelationHatePlayer();\n    virtual ~NFRelationHatePlayer();\n\n    int CreateInit();\n\n    int ResumeInit();\n    uint32_t m_killMeTimes; //杀我的次数\n};\n\n//好友申请结构体\nstruct NFRelationApplyPlayer : public NFRelationCommonPlayer\n{\n    NFRelationApplyPlayer();\n    virtual ~NFRelationApplyPlayer();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    NFShmString<32> m_sConnect;    //介绍\n};\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPlayer.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPlayer.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPlayer.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPlayer.h	(date 1688616543017)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmCore/NFShmString.h"
 
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationTeam.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFRelationTeam.h\n//    @Author           :    gaoyi\n//    @Date             :    23-4-3\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFRelationTeam\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFComm/NFShmStl/NFShmHashMap.h\"\n#include \"NFRelationPlayer.h\"\n#include \"NFComm/NFShmStl/NFShmHashMapWithList.h\"\n\nclass NFRelationBaseTeam\n{\npublic:\n    NFRelationBaseTeam()\n    {\n        if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode())\n        {\n            CreateInit();\n        }\n        else\n        {\n            ResumeInit();\n        }\n    }\n\n    virtual ~NFRelationBaseTeam()\n    {\n\n    }\n\n    int CreateInit()\n    {\n        return 0;\n    }\n\n    int ResumeInit()\n    {\n        return 0;\n    }\n\n    //获取大小\n    virtual uint32_t GetSize() = 0;\n\n    virtual uint32_t GetMaxSize() = 0;\n\n    //添加成员\n    virtual NFRelationCommonPlayer* AddPlayer(uint64_t cid, bool autoErase = true) = 0;\n\n    //判断是否已有某个成员\n    virtual bool HavePlayer(uint64_t cid) = 0;\n\n    virtual bool IsFull() = 0;\n\n    //获取好友数据\n    virtual NFRelationCommonPlayer *GetPlayer(uint64_t cid) = 0;\n\n    virtual void Clear() = 0;\n\n    virtual bool deleteRelation(uint64_t cid) = 0;\n};\n\ntemplate<typename RelationPlayer, size_t max_size>\nclass NFRelationTeam : public NFRelationBaseTeam\n{\n    static_assert((TIsDerived<RelationPlayer, NFRelationCommonPlayer>::Result), \"the class must inherit NFRelationCommonPlayer\");\npublic:\n    NFRelationTeam()\n    {\n        if (EN_OBJ_MODE_INIT == NFShmMgr::Instance()->GetCreateMode())\n        {\n            CreateInit();\n        }\n        else\n        {\n            ResumeInit();\n        }\n    }\n\n    virtual ~NFRelationTeam()\n    {\n\n    }\n\n    int CreateInit()\n    {\n        return 0;\n    }\n\n    int ResumeInit()\n    {\n        return 0;\n    }\n\n    //获取大小\n    uint32_t GetSize()\n    {\n        return m_playerMap.size();\n    }\n\n    virtual uint32_t GetMaxSize()\n    {\n        return m_playerMap.max_size();\n    }\n\n    //添加成员\n    virtual RelationPlayer* AddPlayer(uint64_t cid, bool autoErase = true)\n    {\n        if (!HavePlayer(cid))\n        {\n            if (IsFull())\n            {\n                if (!autoErase)\n                {\n                    NFLogError(NF_LOG_SYSTEMLOG, 0, \"m_playerMap Not Enough Space, max_size:{} class:{}\", GetMaxSize(), typeid(RelationPlayer).name());\n                    return NULL;\n                }\n\n                m_playerMap.auto_erase(1);\n                if (IsFull())\n                {\n                    NFLogError(NF_LOG_SYSTEMLOG, 0, \"m_playerMap auto_erase fail, max_size:{} class:{}\", GetMaxSize(), typeid(RelationPlayer).name());\n                    return NULL;\n                }\n            }\n\n            RelationPlayer& pPlayer = m_playerMap[cid];\n            pPlayer.m_cid = cid;\n            return &pPlayer;\n        }\n\n        return NULL;\n    }\n\n    //判断是否已有某个成员\n    virtual bool HavePlayer(uint64_t cid)\n    {\n        auto iter = m_playerMap.find(cid);\n        if (iter != m_playerMap.end())\n        {\n            return true;\n        }\n        return false;\n    }\n\n    virtual bool IsFull()\n    {\n        return m_playerMap.size() >= m_playerMap.max_size();\n    }\n\n    //获取好友列表数据\n    NFShmHashMapWithList<uint64_t, RelationPlayer, max_size> &GetPlayerData()\n    {\n        return m_playerMap;\n    }\n\n    //获取好友数据\n    virtual RelationPlayer *GetPlayer(uint64_t cid)\n    {\n        auto iter = m_playerMap.find(cid);\n        if (iter != m_playerMap.end())\n        {\n            return &iter->second;\n        }\n        return NULL;\n    }\n\n    virtual void Clear()\n    {\n        m_playerMap.clear();\n    }\n\n    virtual bool deleteRelation(uint64_t cid)\n    {\n        auto iter = m_playerMap.find(cid);\n        if (iter != m_playerMap.end())\n        {\n            m_playerMap.erase(iter);\n            return true;\n        }\n        return false;\n    }\nprotected:\n    NFShmHashMapWithList<uint64_t, RelationPlayer, max_size> m_playerMap;\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationTeam.hpp b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationTeam.hpp
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationTeam.hpp	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationTeam.hpp	(date 1688616543110)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFComm/NFShmStl/NFShmHashMap.h"
 #include "NFRelationPlayer.h"
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPart.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFFriendPart.h\n//    @Author           :    gaoyi\n//    @Date             :    23-3-17\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFFriendPart\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"Part/NFSnsPart.h\"\n#include \"NFRelationTeam.hpp\"\n#include \"NFLogicCommon/RelationDefine.h\"\n\nclass NFRelationPart : public NFSnsPart\n{\npublic:\n    NFRelationPart();\n\n    virtual ~NFRelationPart();\n\n    int CreateInit();\n\n    int ResumeInit();\n\npublic:\n    virtual int Init(const proto_ff::RoleDBSnsDetail &data);\n\n    virtual int UnInit();\n\npublic:\n    /**\n     * @brief 处理客户端消息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleClientMessage(uint32_t msgId, NFDataPackage &packet);\n\n    /**\n     * @brief 处理来自服务器的信息\n     * @param unLinkId\n     * @param packet\n     * @return\n     */\n    virtual int OnHandleServerMessage(uint32_t msgId, NFDataPackage &packet);\n\npublic:\n    static int RegisterClientMessage(NFIPluginManager *pPluginManager);\n\n    static int RetisterServerMessage(NFIPluginManager *pPluginManager);\n\npublic:\n    int OnHandleRelationDataReq(uint32_t msgId, NFDataPackage &packet);\n\npublic:\n    /**\n     * @brief 登陆入口\n     * @return\n     */\n    virtual int OnLogin() { return 0; }\n\n    /**\n     * @brief 登出入口\n     * @return\n     */\n    virtual int OnLogout() { return 0; }\n\n    /**\n     * @brief 掉线入口\n     * @return\n     */\n    virtual int OnDisconnect() { return 0; }\n\n    /**\n     * @brief 重连入口\n     * @return\n     */\n    virtual int OnReconnect() { return 0; }\n\npublic:\n    ////////////////////////////////// 每日每周刷新接口 ///////////////////////////////////\n    /**\n     * @brief 每日刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int DailyUpdate(uint64_t unixSec) { return 0; }\n\n    /**\n     * @brief 每周刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int WeekUpdate(uint64_t unixSec) { return 0; }\n    ////////////////////////////////// 每日零点 每周一零点 刷新接口 ///////////////////////////////////\n    /**\n     * @brief 每日零点 刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int DailyZeroUpdate(uint64_t unixSec) { return 0; }\n\n    /**\n     * @brief 每日零点 刷新接口\n     * @param unixSec\n     * @return\n     */\n    virtual int WeekZeroUpdate(uint64_t unixSec) { return 0; }\n\npublic:\n    /**\n     * @brief update\n     * @param tick\n     */\n    virtual int Update(uint64_t tick) { return 0; }\n\npublic:\n    //添加收礼记录\n    bool addGiftRecord(uint64_t targetId, uint64_t itemId, uint32_t sendType);\n\n    //添加好友\n    bool AddFriend(uint64_t cid);\n\n    //添加仇人\n    bool AddHate(uint64_t cid);\n\n    //添加黑名单\n    bool AddBlack(uint64_t cid);\n\n    //添加最近联系人\n    bool AddRecent(uint64_t cid, uint32_t recentType);\n\n    //添加好友申请\n    bool AddApply(uint64_t cid, string sConnect);\n\n    //添加屏蔽发言申请\n    bool AddShield(uint64_t cid);\n\n    //删除关系\n    bool deleteRelation(uint32_t groupIndex, uint64_t cid);\n\n    //删除某一类型的所有关系 （清除申请列表）\n    void deleteRelationByGroup(uint32_t groupIndex);\n\n    //某个关系是否存在\n    bool isRelationExit(uint32_t groupIndex, uint64_t cid);\n\n    //获取某组关系的剩余容量\n    uint32_t getLeftSize(uint32_t groupIndex);\n\n    //获取某组关系最大容量\n    uint32_t getMaxSize(uint32_t groupIndex);\n\n    //获取某组关系数量\n    uint32_t getCurSize(uint32_t groupIndex);\n\n    //获取某组关系数据\n\n    //获取某组关系的id列表\n    bool GetRelationIdList(uint32_t groupIndex, std::list<uint64_t> &ids, uint32_t limitCount = 0);\n\n    //增加亲密度\n    bool AddFriendCloseness(uint64_t cid, uint32_t type, uint64_t param = 0);\n\n    //获取亲密值\n    int32_t getFriendCloseness(uint64_t destId);\n\n    //获取亲密值等级\n    uint32_t getFriendClosenessLv(uint64_t destId);\n\n    //是否在冷却时间中\n    bool InCdTime();\n\n    //获取离线时好友增加数量\n    uint32_t GetFriendsAdd();\n\n    //增加离线时好友增加数量\n    void AddFriendsAdd();\n\n    //设置离线时好友增加数量\n    void SetFriendsAdd(uint32_t value);\n\n    //增加活跃值(对象操作次数)\n    void AddActive();\n\n    //获取活跃值(对象操作次数)\n    uint32_t GetActive();\n\n    //获取玩家\n    NFRelationCommonPlayer *GetPlayer(uint32_t groupIndex, uint64_t destId);\n\n    //获取最大机器人id\n    uint64_t GetStartRobotId();\n\n    //获取收礼记录\n    //GiftRecords &GetGiftRecords() { return _giftRecords; }\n\n    //设置感谢送礼\n    bool setThanksGift(uint32_t recordId);\n\n    NFRelationBaseTeam* GetRelationTeam(uint32_t groupIndex);\nprivate:\n    /**\n     * @brief 好友\n     */\n    NFRelationTeam<NFRelationFriendPlayer, MAX_FRIEND_SIZE> m_friendPlayerTeam;\n    /**\n     * @brief 黑名单\n     */\n    NFRelationTeam<NFRelationCommonPlayer, MAX_FRIEND_SIZE> m_blackPlayerTeam;\n    /**\n     * @brief 仇人\n     */\n    NFRelationTeam<NFRelationHatePlayer, MAX_FRIEND_SIZE> m_hatePlayerTeam;\n    /**\n     * @brief 最近联系人\n     */\n    NFRelationTeam<NFRelationRecentPlayer, MAX_FRIEND_SIZE> m_recentPlayerTeam;\n    /**\n     * @brief 申请好友列表\n     */\n    NFRelationTeam<NFRelationApplyPlayer, MAX_APPLY_SIZE> m_applyPlayerTeam;\n    /**\n     * @brief 屏蔽发言列表\n     */\n    NFRelationTeam<NFRelationCommonPlayer, MAX_SHIELD_SIZE> m_shieldPlayerTeam;\nprivate:\nDECLARE_IDCREATE(NFRelationPart)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPart.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPart.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPart.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/Relation/NFRelationPart.h	(date 1688616543410)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "Part/NFSnsPart.h"
 #include "NFRelationTeam.hpp"
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheData.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFLoadCacheData.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-4\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFLoadCacheData\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLoadCacheDataInfo.h\"\n#include \"NFComm/NFShmCore/NFShmStaticList.hpp\"\n\n#define SNS_GET_ROLE_SIMPLE_INFO_QUEUE 20000\n#define SNS_GETTING_ROLE_SIZE 300\n#define SNS_CALLBACK_TRANS_RUN_TIMES 20\n\nclass NFLoadCacheData\n{\npublic:\n    NFLoadCacheData();\n\n    virtual ~NFLoadCacheData();\n\n    int CreateInit();\n\n    int ResumeInit();\n\n    NFLoadCacheData& operator=(const NFLoadCacheData& data)\n    {\n        if (this == &data)\n            return *this;\n\n        m_roleId = data.m_roleId;\n        for(auto iter = data.m_roleInfo.Begin(); iter != data.m_roleInfo.End(); iter++)\n        {\n            m_roleInfo.PushBack(*iter);\n        }\n        return *this;\n    }\npublic:\n    /**\n     * @brief\n     * @param rid\n     * @param rtrans\n     * @param rtime\n     * @return\n     */\n    int Add(uint32_t transId, uint64_t time);\npublic:\n    uint64_t m_roleId;\n    NFShmStaticList<NFLoadCacheDataInfo, SNS_CALLBACK_TRANS_RUN_TIMES> m_roleInfo;\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheData.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheData.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheData.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheData.h	(date 1688616543014)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFLoadCacheDataInfo.h"
 #include "NFComm/NFShmCore/NFShmStaticList.hpp"
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheDataInfo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFLoadCacheDataInfo.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-4\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFLoadCacheDataInfo\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n\nclass NFLoadCacheDataInfo\n{\npublic:\n    NFLoadCacheDataInfo();\n\n    virtual ~NFLoadCacheDataInfo();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    uint32_t m_transId;\n    uint64_t m_loadTime;\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheDataInfo.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheDataInfo.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheDataInfo.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheDataInfo.h	(date 1688616543118)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 
 class NFLoadCacheDataInfo
Index: game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// -------------------------------------------------------------------------\n//    @FileName         :    NFLoadCacheMgr.h\n//    @Author           :    gaoyi\n//    @Date             :    22-11-4\n//    @Email\t\t\t:    445267987@qq.com\n//    @Module           :    NFLoadCacheMgr\n//\n// -------------------------------------------------------------------------\n\n#pragma once\n\n\n#include \"NFComm/NFCore/NFPlatform.h\"\n#include \"NFComm/NFShmCore/NFShmObj.h\"\n#include \"NFComm/NFShmCore/NFShmMgr.h\"\n#include \"NFLogicCommon/NFServerFrameTypeDefines.h\"\n#include \"NFComm/NFShmCore/NFISharedMemModule.h\"\n#include \"NFLoadCacheData.h\"\n#include \"NFComm/NFShmCore/NFShmOldHashMap.h\"\n#include \"NFComm/NFShmCore/NFShmStaticList.hpp\"\n#include \"Cache/NFRoleSimple.h\"\n\nclass NFLoadCacheMgr : public NFShmObj\n{\npublic:\n    NFLoadCacheMgr();\n\n    virtual ~NFLoadCacheMgr();\n\n    int CreateInit();\n\n    int ResumeInit();\npublic:\n    virtual int OnTimer(int timeId, int callcount) override;\n    int RefreshSimpleQueue();\n    int RefreshDetailQueue();\npublic:\n    // 接口没有做RoleSimple检测,需要自己提前检测（如TransSnsBase）\n    int GetRoleSimpleInfo(uint64_t roleId, int transId, uint64_t time);\n\n    // 接口会去check是否RoleSimple已经存在，存在会直接返回\n    int GetCheckedRoleSimpleInfo(uint64_t roleId);\n\n    int TransGetRoleSimpleInfo(NFLoadCacheData *data);\n\n    int HandleGetRoleSimpleTransFinished(int iRunLogicRetCode, uint64_t roleId);\npublic:\n    /**\n     * @brief\n     * @param roleId\n     * @param transId\n     * @param time\n     * @return\n     */\n    int GetRoleDetailInfo(uint64_t roleId, int transId, uint32_t time);\n\n    /**\n     * @brief\n     * @param data\n     * @return\n     */\n    int TransGetRoleDetailInfo(NFLoadCacheData *data);\n\n    /**\n     * @brief\n     * @param iRunLogicRetCode\n     * @param roleId\n     * @return\n     */\n    int HandleGetRoleDetailTransFinished(int iRunLogicRetCode, uint64_t roleId);\nprivate:\n    int m_refreshTimer;\n    bool flag;\nprivate:\n    NFShmOldHashMap<uint64_t, NFLoadCacheData, SNS_GET_ROLE_SIMPLE_INFO_QUEUE> m_roleSimpleWaitLoadMap;\n    NFShmOldHashMap<uint64_t, NFLoadCacheData, SNS_GETTING_ROLE_SIZE> m_roleSimpleLoadingMap;\nprivate:\n    NFShmOldHashMap<uint64_t, NFLoadCacheData, SNS_GET_ROLE_SIMPLE_INFO_QUEUE> m_roleDetailWaitLoadMap;\n    NFShmOldHashMap<uint64_t, NFLoadCacheData, SNS_GETTING_ROLE_SIZE> m_roleDetailLoadingMap;\nDECLARE_IDCREATE(NFLoadCacheMgr)\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheMgr.h b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheMgr.h
--- a/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheMgr.h	(revision 621eaf7a7c59359cc0c4403036a17e884a67b979)
+++ b/game/MMO/NFServerLogic/NFSnsServer/NFSnsServerPlayerPlugin/LoadCache/NFLoadCacheMgr.h	(date 1688616542965)
@@ -13,7 +13,7 @@
 #include "NFComm/NFCore/NFPlatform.h"
 #include "NFComm/NFShmCore/NFShmObj.h"
 #include "NFComm/NFShmCore/NFShmMgr.h"
-#include "NFLogicCommon/NFServerFrameTypeDefines.h"
+#include "NFLogicCommon/NFLogicShmTypeDefines.h"
 #include "NFComm/NFShmCore/NFISharedMemModule.h"
 #include "NFLoadCacheData.h"
 #include "NFComm/NFShmCore/NFShmOldHashMap.h"
